/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/8ball/index.js":
/*!*************************************!*\
  !*** ./node_modules/8ball/index.js ***!
  \*************************************/
/***/ ((module) => {

const responses = [
  'it is certain',
  'it is decidedly so',
  'without a doubt',
  'yes — definitely',
  'you may rely on it',
  'as I see it, yes',
  'most likely',
  'outlook good',
  'yes',
  'signs point to yes',
  'reply hazy, try again',
  'ask again later',
  'better not tell you now',
  'cannot predict now',
  'concentrate and ask again',
  'don’t count on it',
  'my reply is no',
  'my sources say no',
  'outlook not so good',
  'very doubtful'
]

module.exports = () => responses[Math.floor(responses.length * Math.random())]


/***/ }),

/***/ "./node_modules/@discordjs/collection/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@discordjs/collection/dist/index.js ***!
  \**********************************************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collection = void 0;
/**
 * A Map with additional utility methods. This is used throughout discord.js rather than Arrays for anything that has
 * an ID, for significantly improved performance and ease-of-use.
 * @extends {Map}
 * @property {number} size - The amount of elements in this collection.
 */
class Collection extends Map {
    constructor(entries) {
        super(entries);
        /**
         * Cached array for the `array()` method - will be reset to `null` whenever `set()` or `delete()` are called
         * @name Collection#_array
         * @type {?Array}
         * @private
         */
        Object.defineProperty(this, '_array', { value: null, writable: true, configurable: true });
        /**
         * Cached array for the `keyArray()` method - will be reset to `null` whenever `set()` or `delete()` are called
         * @name Collection#_keyArray
         * @type {?Array}
         * @private
         */
        Object.defineProperty(this, '_keyArray', { value: null, writable: true, configurable: true });
    }
    /**
     * Identical to [Map.get()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get).
     * Gets an element with the specified key, and returns its value, or `undefined` if the element does not exist.
     * @param {*} key - The key to get from this collection
     * @returns {* | undefined}
     */
    get(key) {
        return super.get(key);
    }
    /**
     * Identical to [Map.set()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set).
     * Sets a new element in the collection with the specified key and value.
     * @param {*} key - The key of the element to add
     * @param {*} value - The value of the element to add
     * @returns {Collection}
     */
    set(key, value) {
        this._array = null;
        this._keyArray = null;
        return super.set(key, value);
    }
    /**
     * Identical to [Map.has()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has).
     * Checks if an element exists in the collection.
     * @param {*} key - The key of the element to check for
     * @returns {boolean} `true` if the element exists, `false` if it does not exist.
     */
    has(key) {
        return super.has(key);
    }
    /**
     * Identical to [Map.delete()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete).
     * Deletes an element from the collection.
     * @param {*} key - The key to delete from the collection
     * @returns {boolean} `true` if the element was removed, `false` if the element does not exist.
     */
    delete(key) {
        this._array = null;
        this._keyArray = null;
        return super.delete(key);
    }
    /**
     * Identical to [Map.clear()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear).
     * Removes all elements from the collection.
     * @returns {undefined}
     */
    clear() {
        return super.clear();
    }
    /**
     * Creates an ordered array of the values of this collection, and caches it internally. The array will only be
     * reconstructed if an item is added to or removed from the collection, or if you change the length of the array
     * itself. If you don't want this caching behavior, use `[...collection.values()]` or
     * `Array.from(collection.values())` instead.
     * @returns {Array}
     */
    array() {
        if (!this._array || this._array.length !== this.size)
            this._array = [...this.values()];
        return this._array;
    }
    /**
     * Creates an ordered array of the keys of this collection, and caches it internally. The array will only be
     * reconstructed if an item is added to or removed from the collection, or if you change the length of the array
     * itself. If you don't want this caching behavior, use `[...collection.keys()]` or
     * `Array.from(collection.keys())` instead.
     * @returns {Array}
     */
    keyArray() {
        if (!this._keyArray || this._keyArray.length !== this.size)
            this._keyArray = [...this.keys()];
        return this._keyArray;
    }
    first(amount) {
        if (typeof amount === 'undefined')
            return this.values().next().value;
        if (amount < 0)
            return this.last(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.values();
        return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
        if (typeof amount === 'undefined')
            return this.keys().next().value;
        if (amount < 0)
            return this.lastKey(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.keys();
        return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
        const arr = this.array();
        if (typeof amount === 'undefined')
            return arr[arr.length - 1];
        if (amount < 0)
            return this.first(amount * -1);
        if (!amount)
            return [];
        return arr.slice(-amount);
    }
    lastKey(amount) {
        const arr = this.keyArray();
        if (typeof amount === 'undefined')
            return arr[arr.length - 1];
        if (amount < 0)
            return this.firstKey(amount * -1);
        if (!amount)
            return [];
        return arr.slice(-amount);
    }
    random(amount) {
        let arr = this.array();
        if (typeof amount === 'undefined')
            return arr[Math.floor(Math.random() * arr.length)];
        if (arr.length === 0 || !amount)
            return [];
        arr = arr.slice();
        return Array.from({ length: amount }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
        let arr = this.keyArray();
        if (typeof amount === 'undefined')
            return arr[Math.floor(Math.random() * arr.length)];
        if (arr.length === 0 || !amount)
            return [];
        arr = arr.slice();
        return Array.from({ length: amount }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    find(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this) {
            if (fn(val, key, this))
                return val;
        }
        return undefined;
    }
    findKey(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this) {
            if (fn(val, key, this))
                return key;
        }
        return undefined;
    }
    sweep(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this) {
            if (fn(val, key, this))
                this.delete(key);
        }
        return previousSize - this.size;
    }
    filter(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this) {
            if (fn(val, key, this))
                results.set(key, val);
        }
        return results;
    }
    partition(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        // TODO: consider removing the <K, V> from the constructors after TS 3.7.0 is released, as it infers it
        const results = [new this.constructor[Symbol.species](), new this.constructor[Symbol.species]()];
        for (const [key, val] of this) {
            if (fn(val, key, this)) {
                results[0].set(key, val);
            }
            else {
                results[1].set(key, val);
            }
        }
        return results;
    }
    flatMap(fn, thisArg) {
        const collections = this.map(fn, thisArg);
        return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        const iter = this.entries();
        return Array.from({ length: this.size }, () => {
            const [key, value] = iter.next().value;
            return fn(value, key, this);
        });
    }
    mapValues(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        const coll = new this.constructor[Symbol.species]();
        for (const [key, val] of this)
            coll.set(key, fn(val, key, this));
        return coll;
    }
    some(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this) {
            if (fn(val, key, this))
                return true;
        }
        return false;
    }
    every(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this) {
            if (!fn(val, key, this))
                return false;
        }
        return true;
    }
    /**
     * Applies a function to produce a single value. Identical in behavior to
     * [Array.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).
     * @param {Function} fn Function used to reduce, taking four arguments; `accumulator`, `currentValue`, `currentKey`,
     * and `collection`
     * @param {*} [initialValue] Starting value for the accumulator
     * @returns {*}
     * @example collection.reduce((acc, guild) => acc + guild.memberCount, 0);
     */
    reduce(fn, initialValue) {
        let accumulator;
        if (typeof initialValue !== 'undefined') {
            accumulator = initialValue;
            for (const [key, val] of this)
                accumulator = fn(accumulator, val, key, this);
            return accumulator;
        }
        let first = true;
        for (const [key, val] of this) {
            if (first) {
                accumulator = val;
                first = false;
                continue;
            }
            accumulator = fn(accumulator, val, key, this);
        }
        // No items iterated.
        if (first) {
            throw new TypeError('Reduce of empty collection with no initial value');
        }
        return accumulator;
    }
    each(fn, thisArg) {
        this.forEach(fn, thisArg);
        return this;
    }
    tap(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        fn(this);
        return this;
    }
    /**
     * Creates an identical shallow copy of this collection.
     * @returns {Collection}
     * @example const newColl = someColl.clone();
     */
    clone() {
        return new this.constructor[Symbol.species](this);
    }
    /**
     * Combines this collection with others into a new collection. None of the source collections are modified.
     * @param {...Collection} collections Collections to merge
     * @returns {Collection}
     * @example const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);
     */
    concat(...collections) {
        const newColl = this.clone();
        for (const coll of collections) {
            for (const [key, val] of coll)
                newColl.set(key, val);
        }
        return newColl;
    }
    /**
     * Checks if this collection shares identical items with another.
     * This is different to checking for equality using equal-signs, because
     * the collections may be different objects, but contain the same data.
     * @param {Collection} collection Collection to compare with
     * @returns {boolean} Whether the collections have identical contents
     */
    equals(collection) {
        if (!collection)
            return false;
        if (this === collection)
            return true;
        if (this.size !== collection.size)
            return false;
        for (const [key, value] of this) {
            if (!collection.has(key) || value !== collection.get(key)) {
                return false;
            }
        }
        return true;
    }
    /**
     * The sort method sorts the items of a collection in place and returns it.
     * The sort is not necessarily stable in Node 10 or older.
     * The default sort order is according to string Unicode code points.
     * @param {Function} [compareFunction] Specifies a function that defines the sort order.
     * If omitted, the collection is sorted according to each character's Unicode code point value,
     * according to the string conversion of each element.
     * @returns {Collection}
     * @example collection.sort((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
     */
    sort(compareFunction = (x, y) => Number(x > y) || Number(x === y) - 1) {
        const entries = [...this.entries()];
        entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
        // Perform clean-up
        super.clear();
        this._array = null;
        this._keyArray = null;
        // Set the new entries
        for (const [k, v] of entries) {
            super.set(k, v);
        }
        return this;
    }
    /**
     * The intersect method returns a new structure containing items where the keys are present in both original structures.
     * @param {Collection} other The other Collection to filter against
     * @returns {Collection}
     */
    intersect(other) {
        return other.filter((_, k) => this.has(k));
    }
    /**
     * The difference method returns a new structure containing items where the key is present in one of the original structures but not the other.
     * @param {Collection} other The other Collection to filter against
     * @returns {Collection}
     */
    difference(other) {
        return other.filter((_, k) => !this.has(k)).concat(this.filter((_, k) => !other.has(k)));
    }
    /**
     * The sorted method sorts the items of a collection and returns it.
     * The sort is not necessarily stable in Node 10 or older.
     * The default sort order is according to string Unicode code points.
     * @param {Function} [compareFunction] Specifies a function that defines the sort order.
     * If omitted, the collection is sorted according to each character's Unicode code point value,
     * according to the string conversion of each element.
     * @returns {Collection}
     * @example collection.sorted((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
     */
    sorted(compareFunction = (x, y) => Number(x > y) || Number(x === y) - 1) {
        return new this.constructor[Symbol.species]([...this.entries()])
            .sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
}
exports.Collection = Collection;
Collection.default = Collection;
module.exports = Collection;
exports.default = Collection;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXMiOlsiaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBUUE7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQWlCLFNBQVEsR0FBUztJQU12QyxZQUFtQixPQUErQztRQUNqRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFZjs7Ozs7V0FLRztRQUNILE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUUzRjs7Ozs7V0FLRztRQUNILE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUMvRixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxHQUFHLENBQUMsR0FBTTtRQUNoQixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEdBQUcsQ0FBQyxHQUFNLEVBQUUsS0FBUTtRQUMxQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNuQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztRQUN0QixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEdBQUcsQ0FBQyxHQUFNO1FBQ2hCLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsR0FBTTtRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FB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Y2UgQ29sbGVjdGlvbkNvbnN0cnVjdG9yIHtcblx0bmV3KCk6IENvbGxlY3Rpb248dW5rbm93biwgdW5rbm93bj47XG5cdG5ldzxLLCBWPihlbnRyaWVzPzogUmVhZG9ubHlBcnJheTxyZWFkb25seSBbSywgVl0+IHwgbnVsbCk6IENvbGxlY3Rpb248SywgVj47XG5cdG5ldzxLLCBWPihpdGVyYWJsZTogSXRlcmFibGU8cmVhZG9ubHkgW0ssIFZdPik6IENvbGxlY3Rpb248SywgVj47XG5cdHJlYWRvbmx5IHByb3RvdHlwZTogQ29sbGVjdGlvbjx1bmtub3duLCB1bmtub3duPjtcblx0cmVhZG9ubHkgW1N5bWJvbC5zcGVjaWVzXTogQ29sbGVjdGlvbkNvbnN0cnVjdG9yO1xufVxuXG4vKipcbiAqIEEgTWFwIHdpdGggYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMuIFRoaXMgaXMgdXNlZCB0aHJvdWdob3V0IGRpc2NvcmQuanMgcmF0aGVyIHRoYW4gQXJyYXlzIGZvciBhbnl0aGluZyB0aGF0IGhhc1xuICogYW4gSUQsIGZvciBzaWduaWZpY2FudGx5IGltcHJvdmVkIHBlcmZvcm1hbmNlIGFuZCBlYXNlLW9mLXVzZS5cbiAqIEBleHRlbmRzIHtNYXB9XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSAtIFRoZSBhbW91bnQgb2YgZWxlbWVudHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICovXG5jbGFzcyBDb2xsZWN0aW9uPEssIFY+IGV4dGVuZHMgTWFwPEssIFY+IHtcblx0cHJpdmF0ZSBfYXJyYXkhOiBWW10gfCBudWxsO1xuXHRwcml2YXRlIF9rZXlBcnJheSE6IEtbXSB8IG51bGw7XG5cdHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGVmYXVsdDogdHlwZW9mIENvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuXHRwdWJsaWMgWydjb25zdHJ1Y3RvciddOiB0eXBlb2YgQ29sbGVjdGlvbjtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IoZW50cmllcz86IFJlYWRvbmx5QXJyYXk8cmVhZG9ubHkgW0ssIFZdPiB8IG51bGwpIHtcblx0XHRzdXBlcihlbnRyaWVzKTtcblxuXHRcdC8qKlxuXHRcdCAqIENhY2hlZCBhcnJheSBmb3IgdGhlIGBhcnJheSgpYCBtZXRob2QgLSB3aWxsIGJlIHJlc2V0IHRvIGBudWxsYCB3aGVuZXZlciBgc2V0KClgIG9yIGBkZWxldGUoKWAgYXJlIGNhbGxlZFxuXHRcdCAqIEBuYW1lIENvbGxlY3Rpb24jX2FycmF5XG5cdFx0ICogQHR5cGUgez9BcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2FycmF5JywgeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblxuXHRcdC8qKlxuXHRcdCAqIENhY2hlZCBhcnJheSBmb3IgdGhlIGBrZXlBcnJheSgpYCBtZXRob2QgLSB3aWxsIGJlIHJlc2V0IHRvIGBudWxsYCB3aGVuZXZlciBgc2V0KClgIG9yIGBkZWxldGUoKWAgYXJlIGNhbGxlZFxuXHRcdCAqIEBuYW1lIENvbGxlY3Rpb24jX2tleUFycmF5XG5cdFx0ICogQHR5cGUgez9BcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2tleUFycmF5JywgeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJZGVudGljYWwgdG8gW01hcC5nZXQoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwL2dldCkuXG5cdCAqIEdldHMgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBhbmQgcmV0dXJucyBpdHMgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgdG8gZ2V0IGZyb20gdGhpcyBjb2xsZWN0aW9uXG5cdCAqIEByZXR1cm5zIHsqIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0cHVibGljIGdldChrZXk6IEspOiBWIHwgdW5kZWZpbmVkIHtcblx0XHRyZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogSWRlbnRpY2FsIHRvIFtNYXAuc2V0KCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcC9zZXQpLlxuXHQgKiBTZXRzIGEgbmV3IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGRcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGRcblx0ICogQHJldHVybnMge0NvbGxlY3Rpb259XG5cdCAqL1xuXHRwdWJsaWMgc2V0KGtleTogSywgdmFsdWU6IFYpOiB0aGlzIHtcblx0XHR0aGlzLl9hcnJheSA9IG51bGw7XG5cdFx0dGhpcy5fa2V5QXJyYXkgPSBudWxsO1xuXHRcdHJldHVybiBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogSWRlbnRpY2FsIHRvIFtNYXAuaGFzKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcC9oYXMpLlxuXHQgKiBDaGVja3MgaWYgYW4gZWxlbWVudCBleGlzdHMgaW4gdGhlIGNvbGxlY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBjaGVjayBmb3Jcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZWxlbWVudCBleGlzdHMsIGBmYWxzZWAgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG5cdCAqL1xuXHRwdWJsaWMgaGFzKGtleTogSyk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiBzdXBlci5oYXMoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJZGVudGljYWwgdG8gW01hcC5kZWxldGUoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwL2RlbGV0ZSkuXG5cdCAqIERlbGV0ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuXHQgKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgdG8gZGVsZXRlIGZyb20gdGhlIGNvbGxlY3Rpb25cblx0ICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZWxlbWVudCB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cblx0ICovXG5cdHB1YmxpYyBkZWxldGUoa2V5OiBLKTogYm9vbGVhbiB7XG5cdFx0dGhpcy5fYXJyYXkgPSBudWxsO1xuXHRcdHRoaXMuX2tleUFycmF5ID0gbnVsbDtcblx0XHRyZXR1cm4gc3VwZXIuZGVsZXRlKGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogSWRlbnRpY2FsIHRvIFtNYXAuY2xlYXIoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwL2NsZWFyKS5cblx0ICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cblx0ICogQHJldHVybnMge3VuZGVmaW5lZH1cblx0ICovXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcblx0XHRyZXR1cm4gc3VwZXIuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIG9yZGVyZWQgYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGlzIGNvbGxlY3Rpb24sIGFuZCBjYWNoZXMgaXQgaW50ZXJuYWxseS4gVGhlIGFycmF5IHdpbGwgb25seSBiZVxuXHQgKiByZWNvbnN0cnVjdGVkIGlmIGFuIGl0ZW0gaXMgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLCBvciBpZiB5b3UgY2hhbmdlIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG5cdCAqIGl0c2VsZi4gSWYgeW91IGRvbid0IHdhbnQgdGhpcyBjYWNoaW5nIGJlaGF2aW9yLCB1c2UgYFsuLi5jb2xsZWN0aW9uLnZhbHVlcygpXWAgb3Jcblx0ICogYEFycmF5LmZyb20oY29sbGVjdGlvbi52YWx1ZXMoKSlgIGluc3RlYWQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdHB1YmxpYyBhcnJheSgpOiBWW10ge1xuXHRcdGlmICghdGhpcy5fYXJyYXkgfHwgdGhpcy5fYXJyYXkubGVuZ3RoICE9PSB0aGlzLnNpemUpIHRoaXMuX2FycmF5ID0gWy4uLnRoaXMudmFsdWVzKCldO1xuXHRcdHJldHVybiB0aGlzLl9hcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIG9yZGVyZWQgYXJyYXkgb2YgdGhlIGtleXMgb2YgdGhpcyBjb2xsZWN0aW9uLCBhbmQgY2FjaGVzIGl0IGludGVybmFsbHkuIFRoZSBhcnJheSB3aWxsIG9ubHkgYmVcblx0ICogcmVjb25zdHJ1Y3RlZCBpZiBhbiBpdGVtIGlzIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbiwgb3IgaWYgeW91IGNoYW5nZSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxuXHQgKiBpdHNlbGYuIElmIHlvdSBkb24ndCB3YW50IHRoaXMgY2FjaGluZyBiZWhhdmlvciwgdXNlIGBbLi4uY29sbGVjdGlvbi5rZXlzKCldYCBvclxuXHQgKiBgQXJyYXkuZnJvbShjb2xsZWN0aW9uLmtleXMoKSlgIGluc3RlYWQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdHB1YmxpYyBrZXlBcnJheSgpOiBLW10ge1xuXHRcdGlmICghdGhpcy5fa2V5QXJyYXkgfHwgdGhpcy5fa2V5QXJyYXkubGVuZ3RoICE9PSB0aGlzLnNpemUpIHRoaXMuX2tleUFycmF5ID0gWy4uLnRoaXMua2V5cygpXTtcblx0XHRyZXR1cm4gdGhpcy5fa2V5QXJyYXk7XG5cdH1cblxuXHQvKipcblx0ICogT2J0YWlucyB0aGUgZmlyc3QgdmFsdWUocykgaW4gdGhpcyBjb2xsZWN0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Ftb3VudF0gQW1vdW50IG9mIHZhbHVlcyB0byBvYnRhaW4gZnJvbSB0aGUgYmVnaW5uaW5nXG5cdCAqIEByZXR1cm5zIHsqfEFycmF5PCo+fSBBIHNpbmdsZSB2YWx1ZSBpZiBubyBhbW91bnQgaXMgcHJvdmlkZWQgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLCBzdGFydGluZyBmcm9tIHRoZSBlbmQgaWZcblx0ICogYW1vdW50IGlzIG5lZ2F0aXZlXG5cdCAqL1xuXHRwdWJsaWMgZmlyc3QoKTogViB8IHVuZGVmaW5lZDtcblx0cHVibGljIGZpcnN0KGFtb3VudDogbnVtYmVyKTogVltdO1xuXHRwdWJsaWMgZmlyc3QoYW1vdW50PzogbnVtYmVyKTogViB8IFZbXSB8IHVuZGVmaW5lZCB7XG5cdFx0aWYgKHR5cGVvZiBhbW91bnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cdFx0aWYgKGFtb3VudCA8IDApIHJldHVybiB0aGlzLmxhc3QoYW1vdW50ICogLTEpO1xuXHRcdGFtb3VudCA9IE1hdGgubWluKHRoaXMuc2l6ZSwgYW1vdW50KTtcblx0XHRjb25zdCBpdGVyID0gdGhpcy52YWx1ZXMoKTtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogYW1vdW50IH0sICgpOiBWID0+IGl0ZXIubmV4dCgpLnZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPYnRhaW5zIHRoZSBmaXJzdCBrZXkocykgaW4gdGhpcyBjb2xsZWN0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Ftb3VudF0gQW1vdW50IG9mIGtleXMgdG8gb2J0YWluIGZyb20gdGhlIGJlZ2lubmluZ1xuXHQgKiBAcmV0dXJucyB7KnxBcnJheTwqPn0gQSBzaW5nbGUga2V5IGlmIG5vIGFtb3VudCBpcyBwcm92aWRlZCBvciBhbiBhcnJheSBvZiBrZXlzLCBzdGFydGluZyBmcm9tIHRoZSBlbmQgaWZcblx0ICogYW1vdW50IGlzIG5lZ2F0aXZlXG5cdCAqL1xuXHRwdWJsaWMgZmlyc3RLZXkoKTogSyB8IHVuZGVmaW5lZDtcblx0cHVibGljIGZpcnN0S2V5KGFtb3VudDogbnVtYmVyKTogS1tdO1xuXHRwdWJsaWMgZmlyc3RLZXkoYW1vdW50PzogbnVtYmVyKTogSyB8IEtbXSB8IHVuZGVmaW5lZCB7XG5cdFx0aWYgKHR5cGVvZiBhbW91bnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcy5rZXlzKCkubmV4dCgpLnZhbHVlO1xuXHRcdGlmIChhbW91bnQgPCAwKSByZXR1cm4gdGhpcy5sYXN0S2V5KGFtb3VudCAqIC0xKTtcblx0XHRhbW91bnQgPSBNYXRoLm1pbih0aGlzLnNpemUsIGFtb3VudCk7XG5cdFx0Y29uc3QgaXRlciA9IHRoaXMua2V5cygpO1xuXHRcdHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBhbW91bnQgfSwgKCk6IEsgPT4gaXRlci5uZXh0KCkudmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9idGFpbnMgdGhlIGxhc3QgdmFsdWUocykgaW4gdGhpcyBjb2xsZWN0aW9uLiBUaGlzIHJlbGllcyBvbiB7QGxpbmsgQ29sbGVjdGlvbiNhcnJheX0sIGFuZCB0aHVzIHRoZSBjYWNoaW5nXG5cdCAqIG1lY2hhbmlzbSBhcHBsaWVzIGhlcmUgYXMgd2VsbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRdIEFtb3VudCBvZiB2YWx1ZXMgdG8gb2J0YWluIGZyb20gdGhlIGVuZFxuXHQgKiBAcmV0dXJucyB7KnxBcnJheTwqPn0gQSBzaW5nbGUgdmFsdWUgaWYgbm8gYW1vdW50IGlzIHByb3ZpZGVkIG9yIGFuIGFycmF5IG9mIHZhbHVlcywgc3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaWZcblx0ICogYW1vdW50IGlzIG5lZ2F0aXZlXG5cdCAqL1xuXHRwdWJsaWMgbGFzdCgpOiBWIHwgdW5kZWZpbmVkO1xuXHRwdWJsaWMgbGFzdChhbW91bnQ6IG51bWJlcik6IFZbXTtcblx0cHVibGljIGxhc3QoYW1vdW50PzogbnVtYmVyKTogViB8IFZbXSB8IHVuZGVmaW5lZCB7XG5cdFx0Y29uc3QgYXJyID0gdGhpcy5hcnJheSgpO1xuXHRcdGlmICh0eXBlb2YgYW1vdW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG5cdFx0aWYgKGFtb3VudCA8IDApIHJldHVybiB0aGlzLmZpcnN0KGFtb3VudCAqIC0xKTtcblx0XHRpZiAoIWFtb3VudCkgcmV0dXJuIFtdO1xuXHRcdHJldHVybiBhcnIuc2xpY2UoLWFtb3VudCk7XG5cdH1cblxuXHQvKipcblx0ICogT2J0YWlucyB0aGUgbGFzdCBrZXkocykgaW4gdGhpcyBjb2xsZWN0aW9uLiBUaGlzIHJlbGllcyBvbiB7QGxpbmsgQ29sbGVjdGlvbiNrZXlBcnJheX0sIGFuZCB0aHVzIHRoZSBjYWNoaW5nXG5cdCAqIG1lY2hhbmlzbSBhcHBsaWVzIGhlcmUgYXMgd2VsbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRdIEFtb3VudCBvZiBrZXlzIHRvIG9idGFpbiBmcm9tIHRoZSBlbmRcblx0ICogQHJldHVybnMgeyp8QXJyYXk8Kj59IEEgc2luZ2xlIGtleSBpZiBubyBhbW91bnQgaXMgcHJvdmlkZWQgb3IgYW4gYXJyYXkgb2Yga2V5cywgc3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaWZcblx0ICogYW1vdW50IGlzIG5lZ2F0aXZlXG5cdCAqL1xuXHRwdWJsaWMgbGFzdEtleSgpOiBLIHwgdW5kZWZpbmVkO1xuXHRwdWJsaWMgbGFzdEtleShhbW91bnQ6IG51bWJlcik6IEtbXTtcblx0cHVibGljIGxhc3RLZXkoYW1vdW50PzogbnVtYmVyKTogSyB8IEtbXSB8IHVuZGVmaW5lZCB7XG5cdFx0Y29uc3QgYXJyID0gdGhpcy5rZXlBcnJheSgpO1xuXHRcdGlmICh0eXBlb2YgYW1vdW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG5cdFx0aWYgKGFtb3VudCA8IDApIHJldHVybiB0aGlzLmZpcnN0S2V5KGFtb3VudCAqIC0xKTtcblx0XHRpZiAoIWFtb3VudCkgcmV0dXJuIFtdO1xuXHRcdHJldHVybiBhcnIuc2xpY2UoLWFtb3VudCk7XG5cdH1cblxuXHQvKipcblx0ICogT2J0YWlucyB1bmlxdWUgcmFuZG9tIHZhbHVlKHMpIGZyb20gdGhpcyBjb2xsZWN0aW9uLiBUaGlzIHJlbGllcyBvbiB7QGxpbmsgQ29sbGVjdGlvbiNhcnJheX0sIGFuZCB0aHVzIHRoZSBjYWNoaW5nXG5cdCAqIG1lY2hhbmlzbSBhcHBsaWVzIGhlcmUgYXMgd2VsbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRdIEFtb3VudCBvZiB2YWx1ZXMgdG8gb2J0YWluIHJhbmRvbWx5XG5cdCAqIEByZXR1cm5zIHsqfEFycmF5PCo+fSBBIHNpbmdsZSB2YWx1ZSBpZiBubyBhbW91bnQgaXMgcHJvdmlkZWQgb3IgYW4gYXJyYXkgb2YgdmFsdWVzXG5cdCAqL1xuXHRwdWJsaWMgcmFuZG9tKCk6IFY7XG5cdHB1YmxpYyByYW5kb20oYW1vdW50OiBudW1iZXIpOiBWW107XG5cdHB1YmxpYyByYW5kb20oYW1vdW50PzogbnVtYmVyKTogViB8IFZbXSB7XG5cdFx0bGV0IGFyciA9IHRoaXMuYXJyYXkoKTtcblx0XHRpZiAodHlwZW9mIGFtb3VudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldO1xuXHRcdGlmIChhcnIubGVuZ3RoID09PSAwIHx8ICFhbW91bnQpIHJldHVybiBbXTtcblx0XHRhcnIgPSBhcnIuc2xpY2UoKTtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogYW1vdW50IH0sICgpOiBWID0+IGFyci5zcGxpY2UoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCksIDEpWzBdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPYnRhaW5zIHVuaXF1ZSByYW5kb20ga2V5KHMpIGZyb20gdGhpcyBjb2xsZWN0aW9uLiBUaGlzIHJlbGllcyBvbiB7QGxpbmsgQ29sbGVjdGlvbiNrZXlBcnJheX0sIGFuZCB0aHVzIHRoZSBjYWNoaW5nXG5cdCAqIG1lY2hhbmlzbSBhcHBsaWVzIGhlcmUgYXMgd2VsbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRdIEFtb3VudCBvZiBrZXlzIHRvIG9idGFpbiByYW5kb21seVxuXHQgKiBAcmV0dXJucyB7KnxBcnJheTwqPn0gQSBzaW5nbGUga2V5IGlmIG5vIGFtb3VudCBpcyBwcm92aWRlZCBvciBhbiBhcnJheVxuXHQgKi9cblx0cHVibGljIHJhbmRvbUtleSgpOiBLO1xuXHRwdWJsaWMgcmFuZG9tS2V5KGFtb3VudDogbnVtYmVyKTogS1tdO1xuXHRwdWJsaWMgcmFuZG9tS2V5KGFtb3VudD86IG51bWJlcik6IEsgfCBLW10ge1xuXHRcdGxldCBhcnIgPSB0aGlzLmtleUFycmF5KCk7XG5cdFx0aWYgKHR5cGVvZiBhbW91bnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gYXJyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpXTtcblx0XHRpZiAoYXJyLmxlbmd0aCA9PT0gMCB8fCAhYW1vdW50KSByZXR1cm4gW107XG5cdFx0YXJyID0gYXJyLnNsaWNlKCk7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGFtb3VudCB9LCAoKTogSyA9PiBhcnIuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpLCAxKVswXSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VhcmNoZXMgZm9yIGEgc2luZ2xlIGl0ZW0gd2hlcmUgdGhlIGdpdmVuIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUuIFRoaXMgYmVoYXZlcyBsaWtlXG5cdCAqIFtBcnJheS5maW5kKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmQpLlxuXHQgKiA8d2Fybj5BbGwgY29sbGVjdGlvbnMgdXNlZCBpbiBEaXNjb3JkLmpzIGFyZSBtYXBwZWQgdXNpbmcgdGhlaXIgYGlkYCBwcm9wZXJ0eSwgYW5kIGlmIHlvdSB3YW50IHRvIGZpbmQgYnkgaWQgeW91XG5cdCAqIHNob3VsZCB1c2UgdGhlIGBnZXRgIG1ldGhvZC4gU2VlXG5cdCAqIFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcC9nZXQpIGZvciBkZXRhaWxzLjwvd2Fybj5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHRlc3Qgd2l0aCAoc2hvdWxkIHJldHVybiBib29sZWFuKVxuXHQgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKiBAZXhhbXBsZSBjb2xsZWN0aW9uLmZpbmQodXNlciA9PiB1c2VyLnVzZXJuYW1lID09PSAnQm9iJyk7XG5cdCAqL1xuXHRwdWJsaWMgZmluZChmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4pOiBWIHwgdW5kZWZpbmVkO1xuXHRwdWJsaWMgZmluZDxUPihmbjogKHRoaXM6IFQsIHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4sIHRoaXNBcmc6IFQpOiBWIHwgdW5kZWZpbmVkO1xuXHRwdWJsaWMgZmluZChmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4sIHRoaXNBcmc/OiB1bmtub3duKTogViB8IHVuZGVmaW5lZCB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJykgZm4gPSBmbi5iaW5kKHRoaXNBcmcpO1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzKSB7XG5cdFx0XHRpZiAoZm4odmFsLCBrZXksIHRoaXMpKSByZXR1cm4gdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlYXJjaGVzIGZvciB0aGUga2V5IG9mIGEgc2luZ2xlIGl0ZW0gd2hlcmUgdGhlIGdpdmVuIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUuIFRoaXMgYmVoYXZlcyBsaWtlXG5cdCAqIFtBcnJheS5maW5kSW5kZXgoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZEluZGV4KSxcblx0ICogYnV0IHJldHVybnMgdGhlIGtleSByYXRoZXIgdGhhbiB0aGUgcG9zaXRpb25hbCBpbmRleC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHRlc3Qgd2l0aCAoc2hvdWxkIHJldHVybiBib29sZWFuKVxuXHQgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKiBAZXhhbXBsZSBjb2xsZWN0aW9uLmZpbmRLZXkodXNlciA9PiB1c2VyLnVzZXJuYW1lID09PSAnQm9iJyk7XG5cdCAqL1xuXHRwdWJsaWMgZmluZEtleShmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4pOiBLIHwgdW5kZWZpbmVkO1xuXHRwdWJsaWMgZmluZEtleTxUPihmbjogKHRoaXM6IFQsIHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4sIHRoaXNBcmc6IFQpOiBLIHwgdW5kZWZpbmVkO1xuXHRwdWJsaWMgZmluZEtleShmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4sIHRoaXNBcmc/OiB1bmtub3duKTogSyB8IHVuZGVmaW5lZCB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJykgZm4gPSBmbi5iaW5kKHRoaXNBcmcpO1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzKSB7XG5cdFx0XHRpZiAoZm4odmFsLCBrZXksIHRoaXMpKSByZXR1cm4ga2V5O1xuXHRcdH1cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgaXRlbXMgdGhhdCBzYXRpc2Z5IHRoZSBwcm92aWRlZCBmaWx0ZXIgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHVzZWQgdG8gdGVzdCAoc2hvdWxkIHJldHVybiBhIGJvb2xlYW4pXG5cdCAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgZnVuY3Rpb25cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiByZW1vdmVkIGVudHJpZXNcblx0ICovXG5cdHB1YmxpYyBzd2VlcChmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4pOiBudW1iZXI7XG5cdHB1YmxpYyBzd2VlcDxUPihmbjogKHRoaXM6IFQsIHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4sIHRoaXNBcmc6IFQpOiBudW1iZXI7XG5cdHB1YmxpYyBzd2VlcChmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4sIHRoaXNBcmc/OiB1bmtub3duKTogbnVtYmVyIHtcblx0XHRpZiAodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnKSBmbiA9IGZuLmJpbmQodGhpc0FyZyk7XG5cdFx0Y29uc3QgcHJldmlvdXNTaXplID0gdGhpcy5zaXplO1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzKSB7XG5cdFx0XHRpZiAoZm4odmFsLCBrZXksIHRoaXMpKSB0aGlzLmRlbGV0ZShrZXkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJldmlvdXNTaXplIC0gdGhpcy5zaXplO1xuXHR9XG5cblx0LyoqXG5cdCAqIElkZW50aWNhbCB0b1xuXHQgKiBbQXJyYXkuZmlsdGVyKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlciksXG5cdCAqIGJ1dCByZXR1cm5zIGEgQ29sbGVjdGlvbiBpbnN0ZWFkIG9mIGFuIEFycmF5LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gdGVzdCB3aXRoIChzaG91bGQgcmV0dXJuIGJvb2xlYW4pXG5cdCAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgZnVuY3Rpb25cblx0ICogQHJldHVybnMge0NvbGxlY3Rpb259XG5cdCAqIEBleGFtcGxlIGNvbGxlY3Rpb24uZmlsdGVyKHVzZXIgPT4gdXNlci51c2VybmFtZSA9PT0gJ0JvYicpO1xuXHQgKi9cblx0cHVibGljIGZpbHRlcihmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4pOiB0aGlzO1xuXHRwdWJsaWMgZmlsdGVyPFQ+KGZuOiAodGhpczogVCwgdmFsdWU6IFYsIGtleTogSywgY29sbGVjdGlvbjogdGhpcykgPT4gYm9vbGVhbiwgdGhpc0FyZzogVCk6IHRoaXM7XG5cdHB1YmxpYyBmaWx0ZXIoZm46ICh2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBib29sZWFuLCB0aGlzQXJnPzogdW5rbm93bik6IHRoaXMge1xuXHRcdGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcblx0XHRjb25zdCByZXN1bHRzID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdPEssIFY+KCkgYXMgdGhpcztcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcykge1xuXHRcdFx0aWYgKGZuKHZhbCwga2V5LCB0aGlzKSkgcmVzdWx0cy5zZXQoa2V5LCB2YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJ0aXRpb25zIHRoZSBjb2xsZWN0aW9uIGludG8gdHdvIGNvbGxlY3Rpb25zIHdoZXJlIHRoZSBmaXJzdCBjb2xsZWN0aW9uXG5cdCAqIGNvbnRhaW5zIHRoZSBpdGVtcyB0aGF0IHBhc3NlZCBhbmQgdGhlIHNlY29uZCBjb250YWlucyB0aGUgaXRlbXMgdGhhdCBmYWlsZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHVzZWQgdG8gdGVzdCAoc2hvdWxkIHJldHVybiBhIGJvb2xlYW4pXG5cdCAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgZnVuY3Rpb25cblx0ICogQHJldHVybnMge0NvbGxlY3Rpb25bXX1cblx0ICogQGV4YW1wbGUgY29uc3QgW2JpZywgc21hbGxdID0gY29sbGVjdGlvbi5wYXJ0aXRpb24oZ3VpbGQgPT4gZ3VpbGQubWVtYmVyQ291bnQgPiAyNTApO1xuXHQgKi9cblx0cHVibGljIHBhcnRpdGlvbihmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4pOiBbdGhpcywgdGhpc107XG5cdHB1YmxpYyBwYXJ0aXRpb248VD4oZm46ICh0aGlzOiBULCB2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBib29sZWFuLCB0aGlzQXJnOiBUKTogW3RoaXMsIHRoaXNdO1xuXHRwdWJsaWMgcGFydGl0aW9uKGZuOiAodmFsdWU6IFYsIGtleTogSywgY29sbGVjdGlvbjogdGhpcykgPT4gYm9vbGVhbiwgdGhpc0FyZz86IHVua25vd24pOiBbdGhpcywgdGhpc10ge1xuXHRcdGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcblx0XHQvLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyB0aGUgPEssIFY+IGZyb20gdGhlIGNvbnN0cnVjdG9ycyBhZnRlciBUUyAzLjcuMCBpcyByZWxlYXNlZCwgYXMgaXQgaW5mZXJzIGl0XG5cdFx0Y29uc3QgcmVzdWx0czogW3RoaXMsIHRoaXNdID0gW25ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXTxLLCBWPigpIGFzIHRoaXMsIG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXTxLLCBWPigpIGFzIHRoaXNdO1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzKSB7XG5cdFx0XHRpZiAoZm4odmFsLCBrZXksIHRoaXMpKSB7XG5cdFx0XHRcdHJlc3VsdHNbMF0uc2V0KGtleSwgdmFsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdHNbMV0uc2V0KGtleSwgdmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvKipcblx0ICogTWFwcyBlYWNoIGl0ZW0gaW50byBhIENvbGxlY3Rpb24sIHRoZW4gam9pbnMgdGhlIHJlc3VsdHMgaW50byBhIHNpbmdsZSBDb2xsZWN0aW9uLiBJZGVudGljYWwgaW4gYmVoYXZpb3IgdG9cblx0ICogW0FycmF5LmZsYXRNYXAoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmxhdE1hcCkuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYSBuZXcgQ29sbGVjdGlvblxuXHQgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuXHQgKiBAZXhhbXBsZSBjb2xsZWN0aW9uLmZsYXRNYXAoZ3VpbGQgPT4gZ3VpbGQubWVtYmVycy5jYWNoZSk7XG5cdCAqL1xuXHRwdWJsaWMgZmxhdE1hcDxUPihmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IENvbGxlY3Rpb248SywgVD4pOiBDb2xsZWN0aW9uPEssIFQ+O1xuXHRwdWJsaWMgZmxhdE1hcDxULCBUaGlzPihmbjogKHRoaXM6IFRoaXMsIHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IENvbGxlY3Rpb248SywgVD4sIHRoaXNBcmc6IFRoaXMpOiBDb2xsZWN0aW9uPEssIFQ+O1xuXHRwdWJsaWMgZmxhdE1hcDxUPihmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IENvbGxlY3Rpb248SywgVD4sIHRoaXNBcmc/OiB1bmtub3duKTogQ29sbGVjdGlvbjxLLCBUPiB7XG5cdFx0Y29uc3QgY29sbGVjdGlvbnMgPSB0aGlzLm1hcChmbiwgdGhpc0FyZyk7XG5cdFx0cmV0dXJuIChuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc108SywgVD4oKSBhcyBDb2xsZWN0aW9uPEssIFQ+KS5jb25jYXQoLi4uY29sbGVjdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hcHMgZWFjaCBpdGVtIHRvIGFub3RoZXIgdmFsdWUgaW50byBhbiBhcnJheS4gSWRlbnRpY2FsIGluIGJlaGF2aW9yIHRvXG5cdCAqIFtBcnJheS5tYXAoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBlbGVtZW50IG9mIHRoZSBuZXcgYXJyYXksIHRha2luZyB0aHJlZSBhcmd1bWVudHNcblx0ICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvblxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqIEBleGFtcGxlIGNvbGxlY3Rpb24ubWFwKHVzZXIgPT4gdXNlci50YWcpO1xuXHQgKi9cblx0cHVibGljIG1hcDxUPihmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IFQpOiBUW107XG5cdHB1YmxpYyBtYXA8VGhpcywgVD4oZm46ICh0aGlzOiBUaGlzLCB2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBULCB0aGlzQXJnOiBUaGlzKTogVFtdO1xuXHRwdWJsaWMgbWFwPFQ+KGZuOiAodmFsdWU6IFYsIGtleTogSywgY29sbGVjdGlvbjogdGhpcykgPT4gVCwgdGhpc0FyZz86IHVua25vd24pOiBUW10ge1xuXHRcdGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcblx0XHRjb25zdCBpdGVyID0gdGhpcy5lbnRyaWVzKCk7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMuc2l6ZSB9LCAoKTogVCA9PiB7XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVyLm5leHQoKS52YWx1ZTtcblx0XHRcdHJldHVybiBmbih2YWx1ZSwga2V5LCB0aGlzKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXBzIGVhY2ggaXRlbSB0byBhbm90aGVyIHZhbHVlIGludG8gYSBjb2xsZWN0aW9uLiBJZGVudGljYWwgaW4gYmVoYXZpb3IgdG9cblx0ICogW0FycmF5Lm1hcCgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGVsZW1lbnQgb2YgdGhlIG5ldyBjb2xsZWN0aW9uLCB0YWtpbmcgdGhyZWUgYXJndW1lbnRzXG5cdCAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgZnVuY3Rpb25cblx0ICogQHJldHVybnMge0NvbGxlY3Rpb259XG5cdCAqIEBleGFtcGxlIGNvbGxlY3Rpb24ubWFwVmFsdWVzKHVzZXIgPT4gdXNlci50YWcpO1xuXHQgKi9cblx0cHVibGljIG1hcFZhbHVlczxUPihmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IFQpOiBDb2xsZWN0aW9uPEssIFQ+O1xuXHRwdWJsaWMgbWFwVmFsdWVzPFRoaXMsIFQ+KGZuOiAodGhpczogVGhpcywgdmFsdWU6IFYsIGtleTogSywgY29sbGVjdGlvbjogdGhpcykgPT4gVCwgdGhpc0FyZzogVGhpcyk6IENvbGxlY3Rpb248SywgVD47XG5cdHB1YmxpYyBtYXBWYWx1ZXM8VD4oZm46ICh2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBULCB0aGlzQXJnPzogdW5rbm93bik6IENvbGxlY3Rpb248SywgVD4ge1xuXHRcdGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcblx0XHRjb25zdCBjb2xsID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdPEssIFQ+KCkgYXMgQ29sbGVjdGlvbjxLLCBUPjtcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcykgY29sbC5zZXQoa2V5LCBmbih2YWwsIGtleSwgdGhpcykpO1xuXHRcdHJldHVybiBjb2xsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGVyZSBleGlzdHMgYW4gaXRlbSB0aGF0IHBhc3NlcyBhIHRlc3QuIElkZW50aWNhbCBpbiBiZWhhdmlvciB0b1xuXHQgKiBbQXJyYXkuc29tZSgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lKS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdXNlZCB0byB0ZXN0IChzaG91bGQgcmV0dXJuIGEgYm9vbGVhbilcblx0ICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvblxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQGV4YW1wbGUgY29sbGVjdGlvbi5zb21lKHVzZXIgPT4gdXNlci5kaXNjcmltaW5hdG9yID09PSAnMDAwMCcpO1xuXHQgKi9cblx0cHVibGljIHNvbWUoZm46ICh2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBib29sZWFuKTogYm9vbGVhbjtcblx0cHVibGljIHNvbWU8VD4oZm46ICh0aGlzOiBULCB2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBib29sZWFuLCB0aGlzQXJnOiBUKTogYm9vbGVhbjtcblx0cHVibGljIHNvbWUoZm46ICh2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBib29sZWFuLCB0aGlzQXJnPzogdW5rbm93bik6IGJvb2xlYW4ge1xuXHRcdGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcykge1xuXHRcdFx0aWYgKGZuKHZhbCwga2V5LCB0aGlzKSkgcmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYWxsIGl0ZW1zIHBhc3NlcyBhIHRlc3QuIElkZW50aWNhbCBpbiBiZWhhdmlvciB0b1xuXHQgKiBbQXJyYXkuZXZlcnkoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnkpLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB1c2VkIHRvIHRlc3QgKHNob3VsZCByZXR1cm4gYSBib29sZWFuKVxuXHQgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAZXhhbXBsZSBjb2xsZWN0aW9uLmV2ZXJ5KHVzZXIgPT4gIXVzZXIuYm90KTtcblx0ICovXG5cdHB1YmxpYyBldmVyeShmbjogKHZhbHVlOiBWLCBrZXk6IEssIGNvbGxlY3Rpb246IHRoaXMpID0+IGJvb2xlYW4pOiBib29sZWFuO1xuXHRwdWJsaWMgZXZlcnk8VD4oZm46ICh0aGlzOiBULCB2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiBib29sZWFuLCB0aGlzQXJnOiBUKTogYm9vbGVhbjtcblx0cHVibGljIGV2ZXJ5KGZuOiAodmFsdWU6IFYsIGtleTogSywgY29sbGVjdGlvbjogdGhpcykgPT4gYm9vbGVhbiwgdGhpc0FyZz86IHVua25vd24pOiBib29sZWFuIHtcblx0XHRpZiAodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnKSBmbiA9IGZuLmJpbmQodGhpc0FyZyk7XG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMpIHtcblx0XHRcdGlmICghZm4odmFsLCBrZXksIHRoaXMpKSByZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBwcm9kdWNlIGEgc2luZ2xlIHZhbHVlLiBJZGVudGljYWwgaW4gYmVoYXZpb3IgdG9cblx0ICogW0FycmF5LnJlZHVjZSgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UpLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB1c2VkIHRvIHJlZHVjZSwgdGFraW5nIGZvdXIgYXJndW1lbnRzOyBgYWNjdW11bGF0b3JgLCBgY3VycmVudFZhbHVlYCwgYGN1cnJlbnRLZXlgLFxuXHQgKiBhbmQgYGNvbGxlY3Rpb25gXG5cdCAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gU3RhcnRpbmcgdmFsdWUgZm9yIHRoZSBhY2N1bXVsYXRvclxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICogQGV4YW1wbGUgY29sbGVjdGlvbi5yZWR1Y2UoKGFjYywgZ3VpbGQpID0+IGFjYyArIGd1aWxkLm1lbWJlckNvdW50LCAwKTtcblx0ICovXG5cdHB1YmxpYyByZWR1Y2U8VD4oZm46IChhY2N1bXVsYXRvcjogVCwgdmFsdWU6IFYsIGtleTogSywgY29sbGVjdGlvbjogdGhpcykgPT4gVCwgaW5pdGlhbFZhbHVlPzogVCk6IFQge1xuXHRcdGxldCBhY2N1bXVsYXRvciE6IFQ7XG5cblx0XHRpZiAodHlwZW9mIGluaXRpYWxWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGFjY3VtdWxhdG9yID0gaW5pdGlhbFZhbHVlO1xuXHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMpIGFjY3VtdWxhdG9yID0gZm4oYWNjdW11bGF0b3IsIHZhbCwga2V5LCB0aGlzKTtcblx0XHRcdHJldHVybiBhY2N1bXVsYXRvcjtcblx0XHR9XG5cdFx0bGV0IGZpcnN0ID0gdHJ1ZTtcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcykge1xuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdGFjY3VtdWxhdG9yID0gdmFsIGFzIHVua25vd24gYXMgVDtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRhY2N1bXVsYXRvciA9IGZuKGFjY3VtdWxhdG9yLCB2YWwsIGtleSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gTm8gaXRlbXMgaXRlcmF0ZWQuXG5cdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgY29sbGVjdGlvbiB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjdW11bGF0b3I7XG5cdH1cblxuXHQvKipcblx0ICogSWRlbnRpY2FsIHRvXG5cdCAqIFtNYXAuZm9yRWFjaCgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAvZm9yRWFjaCksXG5cdCAqIGJ1dCByZXR1cm5zIHRoZSBjb2xsZWN0aW9uIGluc3RlYWQgb2YgdW5kZWZpbmVkLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnRcblx0ICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvblxuXHQgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cblx0ICogQGV4YW1wbGVcblx0ICogY29sbGVjdGlvblxuXHQgKiAgLmVhY2godXNlciA9PiBjb25zb2xlLmxvZyh1c2VyLnVzZXJuYW1lKSlcblx0ICogIC5maWx0ZXIodXNlciA9PiB1c2VyLmJvdClcblx0ICogIC5lYWNoKHVzZXIgPT4gY29uc29sZS5sb2codXNlci51c2VybmFtZSkpO1xuXHQgKi9cblx0cHVibGljIGVhY2goZm46ICh2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiB2b2lkKTogdGhpcztcblx0cHVibGljIGVhY2g8VD4oZm46ICh0aGlzOiBULCB2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiB2b2lkLCB0aGlzQXJnOiBUKTogdGhpcztcblx0cHVibGljIGVhY2goZm46ICh2YWx1ZTogViwga2V5OiBLLCBjb2xsZWN0aW9uOiB0aGlzKSA9PiB2b2lkLCB0aGlzQXJnPzogdW5rbm93bik6IHRoaXMge1xuXHRcdHRoaXMuZm9yRWFjaChmbiBhcyAodmFsdWU6IFYsIGtleTogSywgbWFwOiBNYXA8SywgVj4pID0+IHZvaWQsIHRoaXNBcmcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJ1bnMgYSBmdW5jdGlvbiBvbiB0aGUgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB0aGUgY29sbGVjdGlvbi5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZVxuXHQgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb2xsZWN0aW9uXG5cdCAqICAudGFwKGNvbGwgPT4gY29uc29sZS5sb2coY29sbC5zaXplKSlcblx0ICogIC5maWx0ZXIodXNlciA9PiB1c2VyLmJvdClcblx0ICogIC50YXAoY29sbCA9PiBjb25zb2xlLmxvZyhjb2xsLnNpemUpKVxuXHQgKi9cblx0cHVibGljIHRhcChmbjogKGNvbGxlY3Rpb246IHRoaXMpID0+IHZvaWQpOiB0aGlzO1xuXHRwdWJsaWMgdGFwPFQ+KGZuOiAodGhpczogVCwgY29sbGVjdGlvbjogdGhpcykgPT4gdm9pZCwgdGhpc0FyZzogVCk6IHRoaXM7XG5cdHB1YmxpYyB0YXAoZm46IChjb2xsZWN0aW9uOiB0aGlzKSA9PiB2b2lkLCB0aGlzQXJnPzogdW5rbm93bik6IHRoaXMge1xuXHRcdGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcblx0XHRmbih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGlkZW50aWNhbCBzaGFsbG93IGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uLlxuXHQgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cblx0ICogQGV4YW1wbGUgY29uc3QgbmV3Q29sbCA9IHNvbWVDb2xsLmNsb25lKCk7XG5cdCAqL1xuXHRwdWJsaWMgY2xvbmUoKTogdGhpcyB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXSh0aGlzKSBhcyB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbWJpbmVzIHRoaXMgY29sbGVjdGlvbiB3aXRoIG90aGVycyBpbnRvIGEgbmV3IGNvbGxlY3Rpb24uIE5vbmUgb2YgdGhlIHNvdXJjZSBjb2xsZWN0aW9ucyBhcmUgbW9kaWZpZWQuXG5cdCAqIEBwYXJhbSB7Li4uQ29sbGVjdGlvbn0gY29sbGVjdGlvbnMgQ29sbGVjdGlvbnMgdG8gbWVyZ2Vcblx0ICogQHJldHVybnMge0NvbGxlY3Rpb259XG5cdCAqIEBleGFtcGxlIGNvbnN0IG5ld0NvbGwgPSBzb21lQ29sbC5jb25jYXQoc29tZU90aGVyQ29sbCwgYW5vdGhlckNvbGwsIG9oQm95QUNvbGwpO1xuXHQgKi9cblx0cHVibGljIGNvbmNhdCguLi5jb2xsZWN0aW9uczogQ29sbGVjdGlvbjxLLCBWPltdKTogdGhpcyB7XG5cdFx0Y29uc3QgbmV3Q29sbCA9IHRoaXMuY2xvbmUoKTtcblx0XHRmb3IgKGNvbnN0IGNvbGwgb2YgY29sbGVjdGlvbnMpIHtcblx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBjb2xsKSBuZXdDb2xsLnNldChrZXksIHZhbCk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXdDb2xsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGlzIGNvbGxlY3Rpb24gc2hhcmVzIGlkZW50aWNhbCBpdGVtcyB3aXRoIGFub3RoZXIuXG5cdCAqIFRoaXMgaXMgZGlmZmVyZW50IHRvIGNoZWNraW5nIGZvciBlcXVhbGl0eSB1c2luZyBlcXVhbC1zaWducywgYmVjYXVzZVxuXHQgKiB0aGUgY29sbGVjdGlvbnMgbWF5IGJlIGRpZmZlcmVudCBvYmplY3RzLCBidXQgY29udGFpbiB0aGUgc2FtZSBkYXRhLlxuXHQgKiBAcGFyYW0ge0NvbGxlY3Rpb259IGNvbGxlY3Rpb24gQ29sbGVjdGlvbiB0byBjb21wYXJlIHdpdGhcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNvbGxlY3Rpb25zIGhhdmUgaWRlbnRpY2FsIGNvbnRlbnRzXG5cdCAqL1xuXHRwdWJsaWMgZXF1YWxzKGNvbGxlY3Rpb246IENvbGxlY3Rpb248SywgVj4pOiBib29sZWFuIHtcblx0XHRpZiAoIWNvbGxlY3Rpb24pIHJldHVybiBmYWxzZTtcblx0XHRpZiAodGhpcyA9PT0gY29sbGVjdGlvbikgcmV0dXJuIHRydWU7XG5cdFx0aWYgKHRoaXMuc2l6ZSAhPT0gY29sbGVjdGlvbi5zaXplKSByZXR1cm4gZmFsc2U7XG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuXHRcdFx0aWYgKCFjb2xsZWN0aW9uLmhhcyhrZXkpIHx8IHZhbHVlICE9PSBjb2xsZWN0aW9uLmdldChrZXkpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHNvcnQgbWV0aG9kIHNvcnRzIHRoZSBpdGVtcyBvZiBhIGNvbGxlY3Rpb24gaW4gcGxhY2UgYW5kIHJldHVybnMgaXQuXG5cdCAqIFRoZSBzb3J0IGlzIG5vdCBuZWNlc3NhcmlseSBzdGFibGUgaW4gTm9kZSAxMCBvciBvbGRlci5cblx0ICogVGhlIGRlZmF1bHQgc29ydCBvcmRlciBpcyBhY2NvcmRpbmcgdG8gc3RyaW5nIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlRnVuY3Rpb25dIFNwZWNpZmllcyBhIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyB0aGUgc29ydCBvcmRlci5cblx0ICogSWYgb21pdHRlZCwgdGhlIGNvbGxlY3Rpb24gaXMgc29ydGVkIGFjY29yZGluZyB0byBlYWNoIGNoYXJhY3RlcidzIFVuaWNvZGUgY29kZSBwb2ludCB2YWx1ZSxcblx0ICogYWNjb3JkaW5nIHRvIHRoZSBzdHJpbmcgY29udmVyc2lvbiBvZiBlYWNoIGVsZW1lbnQuXG5cdCAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuXHQgKiBAZXhhbXBsZSBjb2xsZWN0aW9uLnNvcnQoKHVzZXJBLCB1c2VyQikgPT4gdXNlckEuY3JlYXRlZFRpbWVzdGFtcCAtIHVzZXJCLmNyZWF0ZWRUaW1lc3RhbXApO1xuXHQgKi9cblx0cHVibGljIHNvcnQoY29tcGFyZUZ1bmN0aW9uOiAoZmlyc3RWYWx1ZTogViwgc2Vjb25kVmFsdWU6IFYsIGZpcnN0S2V5OiBLLCBzZWNvbmRLZXk6IEspID0+IG51bWJlciA9ICh4LCB5KTogbnVtYmVyID0+IE51bWJlcih4ID4geSkgfHwgTnVtYmVyKHggPT09IHkpIC0gMSk6IHRoaXMge1xuXHRcdGNvbnN0IGVudHJpZXMgPSBbLi4udGhpcy5lbnRyaWVzKCldO1xuXHRcdGVudHJpZXMuc29ydCgoYSwgYik6IG51bWJlciA9PiBjb21wYXJlRnVuY3Rpb24oYVsxXSwgYlsxXSwgYVswXSwgYlswXSkpO1xuXG5cdFx0Ly8gUGVyZm9ybSBjbGVhbi11cFxuXHRcdHN1cGVyLmNsZWFyKCk7XG5cdFx0dGhpcy5fYXJyYXkgPSBudWxsO1xuXHRcdHRoaXMuX2tleUFycmF5ID0gbnVsbDtcblxuXHRcdC8vIFNldCB0aGUgbmV3IGVudHJpZXNcblx0XHRmb3IgKGNvbnN0IFtrLCB2XSBvZiBlbnRyaWVzKSB7XG5cdFx0XHRzdXBlci5zZXQoaywgdik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBpbnRlcnNlY3QgbWV0aG9kIHJldHVybnMgYSBuZXcgc3RydWN0dXJlIGNvbnRhaW5pbmcgaXRlbXMgd2hlcmUgdGhlIGtleXMgYXJlIHByZXNlbnQgaW4gYm90aCBvcmlnaW5hbCBzdHJ1Y3R1cmVzLlxuXHQgKiBAcGFyYW0ge0NvbGxlY3Rpb259IG90aGVyIFRoZSBvdGhlciBDb2xsZWN0aW9uIHRvIGZpbHRlciBhZ2FpbnN0XG5cdCAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuXHQgKi9cblx0cHVibGljIGludGVyc2VjdChvdGhlcjogQ29sbGVjdGlvbjxLLCBWPik6IENvbGxlY3Rpb248SywgVj4ge1xuXHRcdHJldHVybiBvdGhlci5maWx0ZXIoKF8sIGspID0+IHRoaXMuaGFzKGspKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZGlmZmVyZW5jZSBtZXRob2QgcmV0dXJucyBhIG5ldyBzdHJ1Y3R1cmUgY29udGFpbmluZyBpdGVtcyB3aGVyZSB0aGUga2V5IGlzIHByZXNlbnQgaW4gb25lIG9mIHRoZSBvcmlnaW5hbCBzdHJ1Y3R1cmVzIGJ1dCBub3QgdGhlIG90aGVyLlxuXHQgKiBAcGFyYW0ge0NvbGxlY3Rpb259IG90aGVyIFRoZSBvdGhlciBDb2xsZWN0aW9uIHRvIGZpbHRlciBhZ2FpbnN0XG5cdCAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuXHQgKi9cblx0cHVibGljIGRpZmZlcmVuY2Uob3RoZXI6IENvbGxlY3Rpb248SywgVj4pOiBDb2xsZWN0aW9uPEssIFY+IHtcblx0XHRyZXR1cm4gb3RoZXIuZmlsdGVyKChfLCBrKSA9PiAhdGhpcy5oYXMoaykpLmNvbmNhdCh0aGlzLmZpbHRlcigoXywgaykgPT4gIW90aGVyLmhhcyhrKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBzb3J0ZWQgbWV0aG9kIHNvcnRzIHRoZSBpdGVtcyBvZiBhIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgaXQuXG5cdCAqIFRoZSBzb3J0IGlzIG5vdCBuZWNlc3NhcmlseSBzdGFibGUgaW4gTm9kZSAxMCBvciBvbGRlci5cblx0ICogVGhlIGRlZmF1bHQgc29ydCBvcmRlciBpcyBhY2NvcmRpbmcgdG8gc3RyaW5nIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlRnVuY3Rpb25dIFNwZWNpZmllcyBhIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyB0aGUgc29ydCBvcmRlci5cblx0ICogSWYgb21pdHRlZCwgdGhlIGNvbGxlY3Rpb24gaXMgc29ydGVkIGFjY29yZGluZyB0byBlYWNoIGNoYXJhY3RlcidzIFVuaWNvZGUgY29kZSBwb2ludCB2YWx1ZSxcblx0ICogYWNjb3JkaW5nIHRvIHRoZSBzdHJpbmcgY29udmVyc2lvbiBvZiBlYWNoIGVsZW1lbnQuXG5cdCAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuXHQgKiBAZXhhbXBsZSBjb2xsZWN0aW9uLnNvcnRlZCgodXNlckEsIHVzZXJCKSA9PiB1c2VyQS5jcmVhdGVkVGltZXN0YW1wIC0gdXNlckIuY3JlYXRlZFRpbWVzdGFtcCk7XG5cdCAqL1xuXHRwdWJsaWMgc29ydGVkKGNvbXBhcmVGdW5jdGlvbjogKGZpcnN0VmFsdWU6IFYsIHNlY29uZFZhbHVlOiBWLCBmaXJzdEtleTogSywgc2Vjb25kS2V5OiBLKSA9PiBudW1iZXIgPSAoeCwgeSk6IG51bWJlciA9PiBOdW1iZXIoeCA+IHkpIHx8IE51bWJlcih4ID09PSB5KSAtIDEpOiB0aGlzIHtcblx0XHRyZXR1cm4gKG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShbLi4udGhpcy5lbnRyaWVzKCldKSBhcyB0aGlzKVxuXHRcdFx0LnNvcnQoKGF2LCBidiwgYWssIGJrKSA9PiBjb21wYXJlRnVuY3Rpb24oYXYsIGJ2LCBhaywgYmspKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG5leHBvcnQgeyBDb2xsZWN0aW9uIH07XG5leHBvcnQgZGVmYXVsdCBDb2xsZWN0aW9uO1xuIl19

/***/ }),

/***/ "./node_modules/@discordjs/form-data/lib/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@discordjs/form-data/lib/browser.js ***!
  \**********************************************************/
/***/ ((module) => {

/* eslint-env browser */
module.exports = typeof self == 'object' ? self.FormData : window.FormData;


/***/ }),

/***/ "./node_modules/abort-controller/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/abort-controller/browser.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
/*globals self, window */


/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports.default = AbortController


/***/ }),

/***/ "./node_modules/discord.js/package.json":
/*!**********************************************!*\
  !*** ./node_modules/discord.js/package.json ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"_from\":\"discord.js\",\"_id\":\"discord.js@12.5.1\",\"_inBundle\":false,\"_integrity\":\"sha512-VwZkVaUAIOB9mKdca0I5MefPMTQJTNg0qdgi1huF3iwsFwJ0L5s/Y69AQe+iPmjuV6j9rtKoG0Ta0n9vgEIL6w==\",\"_location\":\"/discord.js\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"tag\",\"registry\":true,\"raw\":\"discord.js\",\"name\":\"discord.js\",\"escapedName\":\"discord.js\",\"rawSpec\":\"\",\"saveSpec\":null,\"fetchSpec\":\"latest\"},\"_requiredBy\":[\"#USER\",\"/\"],\"_resolved\":\"https://registry.npmjs.org/discord.js/-/discord.js-12.5.1.tgz\",\"_shasum\":\"992b45753e3815526a279914ccc281d3496f5990\",\"_spec\":\"discord.js\",\"_where\":\"C:\\\\Users\\\\nicho\\\\source\\\\bots\\\\select_star\",\"author\":{\"name\":\"Amish Shah\",\"email\":\"amishshah.2k@gmail.com\"},\"browser\":{\"@discordjs/opus\":false,\"https\":false,\"ws\":false,\"erlpack\":false,\"prism-media\":false,\"opusscript\":false,\"node-opus\":false,\"tweetnacl\":false,\"sodium\":false,\"worker_threads\":false,\"zlib-sync\":false,\"src/sharding/Shard.js\":false,\"src/sharding/ShardClientUtil.js\":false,\"src/sharding/ShardingManager.js\":false,\"src/client/voice/ClientVoiceManager.js\":false,\"src/client/voice/VoiceBroadcast.js\":false,\"src/client/voice/VoiceConnection.js\":false,\"src/client/voice/dispatcher/BroadcastDispatcher.js\":false,\"src/client/voice/dispatcher/StreamDispatcher.js\":false,\"src/client/voice/networking/VoiceUDPClient.js\":false,\"src/client/voice/networking/VoiceWebSocket.js\":false,\"src/client/voice/player/AudioPlayer.js\":false,\"src/client/voice/player/BasePlayer.js\":false,\"src/client/voice/player/BroadcastAudioPlayer.js\":false,\"src/client/voice/receiver/PacketHandler.js\":false,\"src/client/voice/receiver/Receiver.js\":false,\"src/client/voice/util/PlayInterface.js\":false,\"src/client/voice/util/Secretbox.js\":false,\"src/client/voice/util/Silence.js\":false,\"src/client/voice/util/VolumeInterface.js\":false},\"bugs\":{\"url\":\"https://github.com/discordjs/discord.js/issues\"},\"bundleDependencies\":false,\"commitlint\":{\"extends\":[\"@commitlint/config-angular\"],\"rules\":{\"scope-case\":[2,\"always\",\"pascal-case\"],\"type-enum\":[2,\"always\",[\"chore\",\"build\",\"ci\",\"docs\",\"feat\",\"fix\",\"perf\",\"refactor\",\"revert\",\"style\",\"test\"]]}},\"dependencies\":{\"@discordjs/collection\":\"^0.1.6\",\"@discordjs/form-data\":\"^3.0.1\",\"abort-controller\":\"^3.0.0\",\"node-fetch\":\"^2.6.1\",\"prism-media\":\"^1.2.2\",\"setimmediate\":\"^1.0.5\",\"tweetnacl\":\"^1.0.3\",\"ws\":\"^7.3.1\"},\"deprecated\":false,\"description\":\"A powerful library for interacting with the Discord API\",\"devDependencies\":{\"@commitlint/cli\":\"^11.0.0\",\"@commitlint/config-angular\":\"^11.0.0\",\"@types/node\":\"^12.12.6\",\"@types/ws\":\"^7.2.7\",\"cross-env\":\"^7.0.2\",\"discord.js-docgen\":\"git+https://github.com/discordjs/docgen.git\",\"dtslint\":\"^4.0.4\",\"eslint\":\"^7.11.0\",\"eslint-config-prettier\":\"^6.13.0\",\"eslint-plugin-import\":\"^2.22.1\",\"eslint-plugin-prettier\":\"^3.1.4\",\"husky\":\"^4.3.0\",\"jest\":\"^26.6.0\",\"json-filter-loader\":\"^1.0.0\",\"lint-staged\":\"^10.4.2\",\"prettier\":\"^2.1.2\",\"terser-webpack-plugin\":\"^4.2.3\",\"tslint\":\"^6.1.3\",\"typescript\":\"^4.0.3\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^3.3.12\"},\"engines\":{\"node\":\">=12.0.0\"},\"exports\":{\".\":[{\"require\":\"./src/index.js\",\"import\":\"./esm/discord.mjs\"},\"./src/index.js\"],\"./esm\":\"./esm/discord.mjs\"},\"homepage\":\"https://github.com/discordjs/discord.js#readme\",\"husky\":{\"hooks\":{\"pre-commit\":\"lint-staged\",\"commit-msg\":\"commitlint -E HUSKY_GIT_PARAMS\"}},\"keywords\":[\"discord\",\"api\",\"bot\",\"client\",\"node\",\"discordapp\"],\"license\":\"Apache-2.0\",\"lint-staged\":{\"*.js\":\"eslint --fix\",\"*.ts\":\"prettier --write\"},\"main\":\"./src/index\",\"name\":\"discord.js\",\"prettier\":{\"singleQuote\":true,\"printWidth\":120,\"trailingComma\":\"all\",\"endOfLine\":\"lf\",\"arrowParens\":\"avoid\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/discordjs/discord.js.git\"},\"runkitExampleFilename\":\"./docs/examples/ping.js\",\"scripts\":{\"build:browser\":\"webpack\",\"docs\":\"docgen --source src --custom docs/index.yml --output docs/docs.json\",\"docs:test\":\"docgen --source src --custom docs/index.yml\",\"lint\":\"eslint src\",\"lint:fix\":\"eslint src --fix\",\"lint:typings\":\"tslint typings/index.d.ts\",\"prepublishOnly\":\"npm run test && cross-env NODE_ENV=production npm run build:browser\",\"prettier\":\"prettier --write src/**/*.js typings/**/*.ts\",\"test\":\"npm run lint && npm run docs:test && npm run lint:typings\",\"test:typescript\":\"tsc\"},\"types\":\"./typings/index.d.ts\",\"unpkg\":\"./webpack/discord.min.js\",\"version\":\"12.5.1\"}");

/***/ }),

/***/ "./node_modules/discord.js/src/WebSocket.js":
/*!**************************************************!*\
  !*** ./node_modules/discord.js/src/WebSocket.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const { browser } = __webpack_require__(/*! ./util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

let erlpack;

try {
  erlpack = __webpack_require__(/*! erlpack */ "?a56a");
  if (!erlpack.pack) erlpack = null;
} catch {} // eslint-disable-line no-empty

let TextDecoder;

if (browser) {
  TextDecoder = window.TextDecoder; // eslint-disable-line no-undef
  exports.WebSocket = window.WebSocket; // eslint-disable-line no-undef
} else {
  TextDecoder = __webpack_require__(/*! util */ "?0bed").TextDecoder;
  exports.WebSocket = __webpack_require__(/*! ws */ "?98fa");
}

const ab = new TextDecoder();

exports.encoding = erlpack ? 'etf' : 'json';

exports.pack = erlpack ? erlpack.pack : JSON.stringify;

exports.unpack = (data, type) => {
  if (exports.encoding === 'json' || type === 'json') {
    if (typeof data !== 'string') {
      data = ab.decode(data);
    }
    return JSON.parse(data);
  }
  if (!Buffer.isBuffer(data)) data = Buffer.from(new Uint8Array(data));
  return erlpack.unpack(data);
};

exports.create = (gateway, query = {}, ...args) => {
  const [g, q] = gateway.split('?');
  query.encoding = exports.encoding;
  query = new URLSearchParams(query);
  if (q) new URLSearchParams(q).forEach((v, k) => query.set(k, v));
  const ws = new exports.WebSocket(`${g}?${query}`, ...args);
  if (browser) ws.binaryType = 'arraybuffer';
  return ws;
};

for (const state of ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED']) exports[state] = exports.WebSocket[state];


/***/ }),

/***/ "./node_modules/discord.js/src/client/BaseClient.js":
/*!**********************************************************!*\
  !*** ./node_modules/discord.js/src/client/BaseClient.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const RESTManager = __webpack_require__(/*! ../rest/RESTManager */ "./node_modules/discord.js/src/rest/RESTManager.js");
const { DefaultOptions } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * The base class for all clients.
 * @extends {EventEmitter}
 */
class BaseClient extends EventEmitter {
  constructor(options = {}) {
    super();

    /**
     * Timeouts set by {@link BaseClient#setTimeout} that are still active
     * @type {Set<Timeout>}
     * @private
     */
    this._timeouts = new Set();

    /**
     * Intervals set by {@link BaseClient#setInterval} that are still active
     * @type {Set<Timeout>}
     * @private
     */
    this._intervals = new Set();

    /**
     * Intervals set by {@link BaseClient#setImmediate} that are still active
     * @type {Set<Immediate>}
     * @private
     */
    this._immediates = new Set();

    /**
     * The options the client was instantiated with
     * @type {ClientOptions}
     */
    this.options = Util.mergeDefault(DefaultOptions, options);

    /**
     * The REST manager of the client
     * @type {RESTManager}
     * @private
     */
    this.rest = new RESTManager(this, options._tokenType);
  }

  /**
   * API shortcut
   * @type {Object}
   * @readonly
   * @private
   */
  get api() {
    return this.rest.api;
  }

  /**
   * Destroys all assets used by the base client.
   */
  destroy() {
    for (const t of this._timeouts) this.clearTimeout(t);
    for (const i of this._intervals) this.clearInterval(i);
    for (const i of this._immediates) this.clearImmediate(i);
    this._timeouts.clear();
    this._intervals.clear();
    this._immediates.clear();
  }

  /**
   * Sets a timeout that will be automatically cancelled if the client is destroyed.
   * @param {Function} fn Function to execute
   * @param {number} delay Time to wait before executing (in milliseconds)
   * @param {...*} args Arguments for the function
   * @returns {Timeout}
   */
  setTimeout(fn, delay, ...args) {
    const timeout = setTimeout(() => {
      fn(...args);
      this._timeouts.delete(timeout);
    }, delay);
    this._timeouts.add(timeout);
    return timeout;
  }

  /**
   * Clears a timeout.
   * @param {Timeout} timeout Timeout to cancel
   */
  clearTimeout(timeout) {
    clearTimeout(timeout);
    this._timeouts.delete(timeout);
  }

  /**
   * Sets an interval that will be automatically cancelled if the client is destroyed.
   * @param {Function} fn Function to execute
   * @param {number} delay Time to wait between executions (in milliseconds)
   * @param {...*} args Arguments for the function
   * @returns {Timeout}
   */
  setInterval(fn, delay, ...args) {
    const interval = setInterval(fn, delay, ...args);
    this._intervals.add(interval);
    return interval;
  }

  /**
   * Clears an interval.
   * @param {Timeout} interval Interval to cancel
   */
  clearInterval(interval) {
    clearInterval(interval);
    this._intervals.delete(interval);
  }

  /**
   * Sets an immediate that will be automatically cancelled if the client is destroyed.
   * @param {Function} fn Function to execute
   * @param {...*} args Arguments for the function
   * @returns {Immediate}
   */
  setImmediate(fn, ...args) {
    const immediate = setImmediate(fn, ...args);
    this._immediates.add(immediate);
    return immediate;
  }

  /**
   * Clears an immediate.
   * @param {Immediate} immediate Immediate to cancel
   */
  clearImmediate(immediate) {
    clearImmediate(immediate);
    this._immediates.delete(immediate);
  }

  /**
   * Increments max listeners by one, if they are not zero.
   * @private
   */
  incrementMaxListeners() {
    const maxListeners = this.getMaxListeners();
    if (maxListeners !== 0) {
      this.setMaxListeners(maxListeners + 1);
    }
  }

  /**
   * Decrements max listeners by one, if they are not zero.
   * @private
   */
  decrementMaxListeners() {
    const maxListeners = this.getMaxListeners();
    if (maxListeners !== 0) {
      this.setMaxListeners(maxListeners - 1);
    }
  }

  toJSON(...props) {
    return Util.flatten(this, { domain: false }, ...props);
  }
}

module.exports = BaseClient;


/***/ }),

/***/ "./node_modules/discord.js/src/client/Client.js":
/*!******************************************************!*\
  !*** ./node_modules/discord.js/src/client/Client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseClient = __webpack_require__(/*! ./BaseClient */ "./node_modules/discord.js/src/client/BaseClient.js");
const ActionsManager = __webpack_require__(/*! ./actions/ActionsManager */ "./node_modules/discord.js/src/client/actions/ActionsManager.js");
const ClientVoiceManager = __webpack_require__(/*! ./voice/ClientVoiceManager */ "?5b33");
const WebSocketManager = __webpack_require__(/*! ./websocket/WebSocketManager */ "./node_modules/discord.js/src/client/websocket/WebSocketManager.js");
const { Error, TypeError, RangeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const ChannelManager = __webpack_require__(/*! ../managers/ChannelManager */ "./node_modules/discord.js/src/managers/ChannelManager.js");
const GuildEmojiManager = __webpack_require__(/*! ../managers/GuildEmojiManager */ "./node_modules/discord.js/src/managers/GuildEmojiManager.js");
const GuildManager = __webpack_require__(/*! ../managers/GuildManager */ "./node_modules/discord.js/src/managers/GuildManager.js");
const UserManager = __webpack_require__(/*! ../managers/UserManager */ "./node_modules/discord.js/src/managers/UserManager.js");
const ShardClientUtil = __webpack_require__(/*! ../sharding/ShardClientUtil */ "?e41f");
const ClientApplication = __webpack_require__(/*! ../structures/ClientApplication */ "./node_modules/discord.js/src/structures/ClientApplication.js");
const GuildPreview = __webpack_require__(/*! ../structures/GuildPreview */ "./node_modules/discord.js/src/structures/GuildPreview.js");
const GuildTemplate = __webpack_require__(/*! ../structures/GuildTemplate */ "./node_modules/discord.js/src/structures/GuildTemplate.js");
const Invite = __webpack_require__(/*! ../structures/Invite */ "./node_modules/discord.js/src/structures/Invite.js");
const VoiceRegion = __webpack_require__(/*! ../structures/VoiceRegion */ "./node_modules/discord.js/src/structures/VoiceRegion.js");
const Webhook = __webpack_require__(/*! ../structures/Webhook */ "./node_modules/discord.js/src/structures/Webhook.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { Events, browser, DefaultOptions } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");
const Intents = __webpack_require__(/*! ../util/Intents */ "./node_modules/discord.js/src/util/Intents.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
const Structures = __webpack_require__(/*! ../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");

/**
 * The main hub for interacting with the Discord API, and the starting point for any bot.
 * @extends {BaseClient}
 */
class Client extends BaseClient {
  /**
   * @param {ClientOptions} [options] Options for the client
   */
  constructor(options = {}) {
    super(Object.assign({ _tokenType: 'Bot' }, options));

    // Obtain shard details from environment or if present, worker threads
    let data = process.env;
    try {
      // Test if worker threads module is present and used
      data = __webpack_require__(/*! worker_threads */ "?1797").workerData || data;
    } catch {
      // Do nothing
    }

    if (this.options.shards === DefaultOptions.shards) {
      if ('SHARDS' in data) {
        this.options.shards = JSON.parse(data.SHARDS);
      }
    }

    if (this.options.shardCount === DefaultOptions.shardCount) {
      if ('SHARD_COUNT' in data) {
        this.options.shardCount = Number(data.SHARD_COUNT);
      } else if (Array.isArray(this.options.shards)) {
        this.options.shardCount = this.options.shards.length;
      }
    }

    const typeofShards = typeof this.options.shards;

    if (typeofShards === 'undefined' && typeof this.options.shardCount === 'number') {
      this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
    }

    if (typeofShards === 'number') this.options.shards = [this.options.shards];

    if (Array.isArray(this.options.shards)) {
      this.options.shards = [
        ...new Set(
          this.options.shards.filter(item => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)),
        ),
      ];
    }

    this._validateOptions();

    /**
     * The WebSocket manager of the client
     * @type {WebSocketManager}
     */
    this.ws = new WebSocketManager(this);

    /**
     * The action manager of the client
     * @type {ActionsManager}
     * @private
     */
    this.actions = new ActionsManager(this);

    /**
     * The voice manager of the client (`null` in browsers)
     * @type {?ClientVoiceManager}
     */
    this.voice = !browser ? new ClientVoiceManager(this) : null;

    /**
     * Shard helpers for the client (only if the process was spawned from a {@link ShardingManager})
     * @type {?ShardClientUtil}
     */
    this.shard =
      !browser && process.env.SHARDING_MANAGER
        ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE)
        : null;

    /**
     * All of the {@link User} objects that have been cached at any point, mapped by their IDs
     * @type {UserManager}
     */
    this.users = new UserManager(this);

    /**
     * All of the guilds the client is currently handling, mapped by their IDs -
     * as long as sharding isn't being used, this will be *every* guild the bot is a member of
     * @type {GuildManager}
     */
    this.guilds = new GuildManager(this);

    /**
     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -
     * as long as sharding isn't being used, this will be *every* channel in *every* guild the bot
     * is a member of. Note that DM channels will not be initially cached, and thus not be present
     * in the Manager without their explicit fetching or use.
     * @type {ChannelManager}
     */
    this.channels = new ChannelManager(this);

    const ClientPresence = Structures.get('ClientPresence');
    /**
     * The presence of the Client
     * @private
     * @type {ClientPresence}
     */
    this.presence = new ClientPresence(this);

    Object.defineProperty(this, 'token', { writable: true });
    if (!browser && !this.token && 'DISCORD_TOKEN' in process.env) {
      /**
       * Authorization token for the logged in bot.
       * If present, this defaults to `process.env.DISCORD_TOKEN` when instantiating the client
       * <warn>This should be kept private at all times.</warn>
       * @type {?string}
       */
      this.token = process.env.DISCORD_TOKEN;
    } else {
      this.token = null;
    }

    /**
     * User that the client is logged in as
     * @type {?ClientUser}
     */
    this.user = null;

    /**
     * Time at which the client was last regarded as being in the `READY` state
     * (each time the client disconnects and successfully reconnects, this will be overwritten)
     * @type {?Date}
     */
    this.readyAt = null;

    if (this.options.messageSweepInterval > 0) {
      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);
    }
  }

  /**
   * All custom emojis that the client has access to, mapped by their IDs
   * @type {GuildEmojiManager}
   * @readonly
   */
  get emojis() {
    const emojis = new GuildEmojiManager({ client: this });
    for (const guild of this.guilds.cache.values()) {
      if (guild.available) for (const emoji of guild.emojis.cache.values()) emojis.cache.set(emoji.id, emoji);
    }
    return emojis;
  }

  /**
   * Timestamp of the time the client was last `READY` at
   * @type {?number}
   * @readonly
   */
  get readyTimestamp() {
    return this.readyAt ? this.readyAt.getTime() : null;
  }

  /**
   * How long it has been since the client last entered the `READY` state in milliseconds
   * @type {?number}
   * @readonly
   */
  get uptime() {
    return this.readyAt ? Date.now() - this.readyAt : null;
  }

  /**
   * Logs the client in, establishing a websocket connection to Discord.
   * @param {string} [token=this.token] Token of the account to log in with
   * @returns {Promise<string>} Token of the account used
   * @example
   * client.login('my token');
   */
  async login(token = this.token) {
    if (!token || typeof token !== 'string') throw new Error('TOKEN_INVALID');
    this.token = token = token.replace(/^(Bot|Bearer)\s*/i, '');
    this.emit(
      Events.DEBUG,
      `Provided token: ${token
        .split('.')
        .map((val, i) => (i > 1 ? val.replace(/./g, '*') : val))
        .join('.')}`,
    );

    if (this.options.presence) {
      this.options.ws.presence = await this.presence._parse(this.options.presence);
    }

    this.emit(Events.DEBUG, 'Preparing to connect to the gateway...');

    try {
      await this.ws.connect();
      return this.token;
    } catch (error) {
      this.destroy();
      throw error;
    }
  }

  /**
   * Logs out, terminates the connection to Discord, and destroys the client.
   * @returns {void}
   */
  destroy() {
    super.destroy();
    this.ws.destroy();
    this.token = null;
  }

  /**
   * Obtains an invite from Discord.
   * @param {InviteResolvable} invite Invite code or URL
   * @returns {Promise<Invite>}
   * @example
   * client.fetchInvite('https://discord.gg/bRCvFy9')
   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))
   *   .catch(console.error);
   */
  fetchInvite(invite) {
    const code = DataResolver.resolveInviteCode(invite);
    return this.api
      .invites(code)
      .get({ query: { with_counts: true } })
      .then(data => new Invite(this, data));
  }

  /**
   * Obtains a template from Discord.
   * @param {GuildTemplateResolvable} template Template code or URL
   * @returns {Promise<GuildTemplate>}
   * @example
   * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')
   *   .then(template => console.log(`Obtained template with code: ${template.code}`))
   *   .catch(console.error);
   */
  fetchGuildTemplate(template) {
    const code = DataResolver.resolveGuildTemplateCode(template);
    return this.api.guilds
      .templates(code)
      .get()
      .then(data => new GuildTemplate(this, data));
  }

  /**
   * Obtains a webhook from Discord.
   * @param {Snowflake} id ID of the webhook
   * @param {string} [token] Token for the webhook
   * @returns {Promise<Webhook>}
   * @example
   * client.fetchWebhook('id', 'token')
   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))
   *   .catch(console.error);
   */
  fetchWebhook(id, token) {
    return this.api
      .webhooks(id, token)
      .get()
      .then(data => new Webhook(this, data));
  }

  /**
   * Obtains the available voice regions from Discord.
   * @returns {Promise<Collection<string, VoiceRegion>>}
   * @example
   * client.fetchVoiceRegions()
   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))
   *   .catch(console.error);
   */
  fetchVoiceRegions() {
    return this.api.voice.regions.get().then(res => {
      const regions = new Collection();
      for (const region of res) regions.set(region.id, new VoiceRegion(region));
      return regions;
    });
  }

  /**
   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.
   * If the message has been edited, the time of the edit is used rather than the time of the original message.
   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)
   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}
   * @returns {number} Amount of messages that were removed from the caches,
   * or -1 if the message cache lifetime is unlimited
   * @example
   * // Remove all messages older than 1800 seconds from the messages cache
   * const amount = client.sweepMessages(1800);
   * console.log(`Successfully removed ${amount} messages from the cache.`);
   */
  sweepMessages(lifetime = this.options.messageCacheLifetime) {
    if (typeof lifetime !== 'number' || isNaN(lifetime)) {
      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');
    }
    if (lifetime <= 0) {
      this.emit(Events.DEBUG, "Didn't sweep messages - lifetime is unlimited");
      return -1;
    }

    const lifetimeMs = lifetime * 1000;
    const now = Date.now();
    let channels = 0;
    let messages = 0;

    for (const channel of this.channels.cache.values()) {
      if (!channel.messages) continue;
      channels++;

      messages += channel.messages.cache.sweep(
        message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs,
      );
    }

    this.emit(
      Events.DEBUG,
      `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`,
    );
    return messages;
  }

  /**
   * Obtains the OAuth Application of this bot from Discord.
   * @returns {Promise<ClientApplication>}
   */
  fetchApplication() {
    return this.api.oauth2
      .applications('@me')
      .get()
      .then(app => new ClientApplication(this, app));
  }

  /**
   * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.
   * @param {GuildResolvable} guild The guild to fetch the preview for
   * @returns {Promise<GuildPreview>}
   */
  fetchGuildPreview(guild) {
    const id = this.guilds.resolveID(guild);
    if (!id) throw new TypeError('INVALID_TYPE', 'guild', 'GuildResolvable');
    return this.api
      .guilds(id)
      .preview.get()
      .then(data => new GuildPreview(this, data));
  }

  /**
   * Generates a link that can be used to invite the bot to a guild.
   * @param {InviteGenerationOptions|PermissionResolvable} [options] Permissions to request
   * @returns {Promise<string>}
   * @example
   * client.generateInvite({
   *   permissions: ['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'],
   * })
   *   .then(link => console.log(`Generated bot invite link: ${link}`))
   *   .catch(console.error);
   */
  async generateInvite(options = {}) {
    if (Array.isArray(options) || ['string', 'number'].includes(typeof options) || options instanceof Permissions) {
      process.emitWarning(
        'Client#generateInvite: Generate invite with an options object instead of a PermissionResolvable',
        'DeprecationWarning',
      );
      options = { permissions: options };
    }
    const application = await this.fetchApplication();
    const query = new URLSearchParams({
      client_id: application.id,
      permissions: Permissions.resolve(options.permissions),
      scope: 'bot',
    });
    if (typeof options.disableGuildSelect === 'boolean') {
      query.set('disable_guild_select', options.disableGuildSelect.toString());
    }
    if (typeof options.guild !== 'undefined') {
      const guildID = this.guilds.resolveID(options.guild);
      if (!guildID) throw new TypeError('INVALID_TYPE', 'options.guild', 'GuildResolvable');
      query.set('guild_id', guildID);
    }
    return `${this.options.http.api}${this.api.oauth2.authorize}?${query}`;
  }

  toJSON() {
    return super.toJSON({
      readyAt: false,
    });
  }

  /**
   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script
   * with the client as `this`.
   * @param {string} script Script to eval
   * @returns {*}
   * @private
   */
  _eval(script) {
    return eval(script);
  }

  /**
   * Validates the client options.
   * @param {ClientOptions} [options=this.options] Options to validate
   * @private
   */
  _validateOptions(options = this.options) {
    if (typeof options.ws.intents !== 'undefined') {
      options.ws.intents = Intents.resolve(options.ws.intents);
    }
    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount) || options.shardCount < 1) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'shardCount', 'a number greater than or equal to 1');
    }
    if (options.shards && !(options.shards === 'auto' || Array.isArray(options.shards))) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'shards', "'auto', a number or array of numbers");
    }
    if (options.shards && !options.shards.length) throw new RangeError('CLIENT_INVALID_PROVIDED_SHARDS');
    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'messageCacheMaxSize', 'a number');
    }
    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'The messageCacheLifetime', 'a number');
    }
    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'messageSweepInterval', 'a number');
    }
    if (
      typeof options.messageEditHistoryMaxSize !== 'number' ||
      isNaN(options.messageEditHistoryMaxSize) ||
      options.messageEditHistoryMaxSize < -1
    ) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'messageEditHistoryMaxSize', 'a number greater than or equal to -1');
    }
    if (typeof options.fetchAllMembers !== 'boolean') {
      throw new TypeError('CLIENT_INVALID_OPTION', 'fetchAllMembers', 'a boolean');
    }
    if (typeof options.disableMentions !== 'string') {
      throw new TypeError('CLIENT_INVALID_OPTION', 'disableMentions', 'a string');
    }
    if (!Array.isArray(options.partials)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'partials', 'an Array');
    }
    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'restWsBridgeTimeout', 'a number');
    }
    if (typeof options.restRequestTimeout !== 'number' || isNaN(options.restRequestTimeout)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'restRequestTimeout', 'a number');
    }
    if (typeof options.restSweepInterval !== 'number' || isNaN(options.restSweepInterval)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'restSweepInterval', 'a number');
    }
    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {
      throw new TypeError('CLIENT_INVALID_OPTION', 'retryLimit', 'a number');
    }
  }
}

module.exports = Client;

/**
 * Options for {@link Client#generateInvite}.
 * @typedef {Object} InviteGenerationOptions
 * @property {PermissionResolvable} [permissions] Permissions to request
 * @property {GuildResolvable} [guild] Guild to preselect
 * @property {boolean} [disableGuildSelect] Whether to disable the guild selection
 */

/**
 * Emitted for general warnings.
 * @event Client#warn
 * @param {string} info The warning
 */

/**
 * Emitted for general debugging information.
 * @event Client#debug
 * @param {string} info The debug information
 */


/***/ }),

/***/ "./node_modules/discord.js/src/client/WebhookClient.js":
/*!*************************************************************!*\
  !*** ./node_modules/discord.js/src/client/WebhookClient.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseClient = __webpack_require__(/*! ./BaseClient */ "./node_modules/discord.js/src/client/BaseClient.js");
const Webhook = __webpack_require__(/*! ../structures/Webhook */ "./node_modules/discord.js/src/structures/Webhook.js");

/**
 * The webhook client.
 * @implements {Webhook}
 * @extends {BaseClient}
 */
class WebhookClient extends BaseClient {
  /**
   * @param {Snowflake} id ID of the webhook
   * @param {string} token Token of the webhook
   * @param {ClientOptions} [options] Options for the client
   * @example
   * // Create a new webhook and send a message
   * const hook = new Discord.WebhookClient('1234', 'abcdef');
   * hook.send('This will send a message').catch(console.error);
   */
  constructor(id, token, options) {
    super(options);
    Object.defineProperty(this, 'client', { value: this });
    this.id = id;
    Object.defineProperty(this, 'token', { value: token, writable: true, configurable: true });
  }
}

Webhook.applyToClass(WebhookClient);

module.exports = WebhookClient;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/Action.js":
/*!**************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/Action.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { PartialTypes } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/*

ABOUT ACTIONS

Actions are similar to WebSocket Packet Handlers, but since introducing
the REST API methods, in order to prevent rewriting code to handle data,
"actions" have been introduced. They're basically what Packet Handlers
used to be but they're strictly for manipulating data and making sure
that WebSocket events don't clash with REST methods.

*/

class GenericAction {
  constructor(client) {
    this.client = client;
  }

  handle(data) {
    return data;
  }

  getPayload(data, manager, id, partialType, cache) {
    const existing = manager.cache.get(id);
    if (!existing && this.client.options.partials.includes(partialType)) {
      return manager.add(data, cache);
    }
    return existing;
  }

  getChannel(data) {
    const id = data.channel_id || data.id;
    return (
      data.channel ||
      this.getPayload(
        {
          id,
          guild_id: data.guild_id,
          recipients: [data.author || { id: data.user_id }],
        },
        this.client.channels,
        id,
        PartialTypes.CHANNEL,
      )
    );
  }

  getMessage(data, channel, cache) {
    const id = data.message_id || data.id;
    return (
      data.message ||
      this.getPayload(
        {
          id,
          channel_id: channel.id,
          guild_id: data.guild_id || (channel.guild ? channel.guild.id : null),
        },
        channel.messages,
        id,
        PartialTypes.MESSAGE,
        cache,
      )
    );
  }

  getReaction(data, message, user) {
    const id = data.emoji.id || decodeURIComponent(data.emoji.name);
    return this.getPayload(
      {
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user ? user.id === this.client.user.id : false,
      },
      message.reactions,
      id,
      PartialTypes.REACTION,
    );
  }

  getMember(data, guild) {
    return this.getPayload(data, guild.members, data.user.id, PartialTypes.GUILD_MEMBER);
  }

  getUser(data) {
    const id = data.user_id;
    return data.user || this.getPayload({ id }, this.client.users, id, PartialTypes.USER);
  }

  getUserFromMember(data) {
    if (data.guild_id && data.member && data.member.user) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (guild) {
        return guild.members.add(data.member).user;
      } else {
        return this.client.users.add(data.member.user);
      }
    }
    return this.getUser(data);
  }
}

module.exports = GenericAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/ActionsManager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/ActionsManager.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


class ActionsManager {
  constructor(client) {
    this.client = client;

    this.register(__webpack_require__(/*! ./MessageCreate */ "./node_modules/discord.js/src/client/actions/MessageCreate.js"));
    this.register(__webpack_require__(/*! ./MessageDelete */ "./node_modules/discord.js/src/client/actions/MessageDelete.js"));
    this.register(__webpack_require__(/*! ./MessageDeleteBulk */ "./node_modules/discord.js/src/client/actions/MessageDeleteBulk.js"));
    this.register(__webpack_require__(/*! ./MessageUpdate */ "./node_modules/discord.js/src/client/actions/MessageUpdate.js"));
    this.register(__webpack_require__(/*! ./MessageReactionAdd */ "./node_modules/discord.js/src/client/actions/MessageReactionAdd.js"));
    this.register(__webpack_require__(/*! ./MessageReactionRemove */ "./node_modules/discord.js/src/client/actions/MessageReactionRemove.js"));
    this.register(__webpack_require__(/*! ./MessageReactionRemoveAll */ "./node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js"));
    this.register(__webpack_require__(/*! ./MessageReactionRemoveEmoji */ "./node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js"));
    this.register(__webpack_require__(/*! ./ChannelCreate */ "./node_modules/discord.js/src/client/actions/ChannelCreate.js"));
    this.register(__webpack_require__(/*! ./ChannelDelete */ "./node_modules/discord.js/src/client/actions/ChannelDelete.js"));
    this.register(__webpack_require__(/*! ./ChannelUpdate */ "./node_modules/discord.js/src/client/actions/ChannelUpdate.js"));
    this.register(__webpack_require__(/*! ./GuildDelete */ "./node_modules/discord.js/src/client/actions/GuildDelete.js"));
    this.register(__webpack_require__(/*! ./GuildUpdate */ "./node_modules/discord.js/src/client/actions/GuildUpdate.js"));
    this.register(__webpack_require__(/*! ./InviteCreate */ "./node_modules/discord.js/src/client/actions/InviteCreate.js"));
    this.register(__webpack_require__(/*! ./InviteDelete */ "./node_modules/discord.js/src/client/actions/InviteDelete.js"));
    this.register(__webpack_require__(/*! ./GuildMemberRemove */ "./node_modules/discord.js/src/client/actions/GuildMemberRemove.js"));
    this.register(__webpack_require__(/*! ./GuildMemberUpdate */ "./node_modules/discord.js/src/client/actions/GuildMemberUpdate.js"));
    this.register(__webpack_require__(/*! ./GuildBanRemove */ "./node_modules/discord.js/src/client/actions/GuildBanRemove.js"));
    this.register(__webpack_require__(/*! ./GuildRoleCreate */ "./node_modules/discord.js/src/client/actions/GuildRoleCreate.js"));
    this.register(__webpack_require__(/*! ./GuildRoleDelete */ "./node_modules/discord.js/src/client/actions/GuildRoleDelete.js"));
    this.register(__webpack_require__(/*! ./GuildRoleUpdate */ "./node_modules/discord.js/src/client/actions/GuildRoleUpdate.js"));
    this.register(__webpack_require__(/*! ./PresenceUpdate */ "./node_modules/discord.js/src/client/actions/PresenceUpdate.js"));
    this.register(__webpack_require__(/*! ./UserUpdate */ "./node_modules/discord.js/src/client/actions/UserUpdate.js"));
    this.register(__webpack_require__(/*! ./VoiceStateUpdate */ "./node_modules/discord.js/src/client/actions/VoiceStateUpdate.js"));
    this.register(__webpack_require__(/*! ./GuildEmojiCreate */ "./node_modules/discord.js/src/client/actions/GuildEmojiCreate.js"));
    this.register(__webpack_require__(/*! ./GuildEmojiDelete */ "./node_modules/discord.js/src/client/actions/GuildEmojiDelete.js"));
    this.register(__webpack_require__(/*! ./GuildEmojiUpdate */ "./node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js"));
    this.register(__webpack_require__(/*! ./GuildEmojisUpdate */ "./node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js"));
    this.register(__webpack_require__(/*! ./GuildRolesPositionUpdate */ "./node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js"));
    this.register(__webpack_require__(/*! ./GuildChannelsPositionUpdate */ "./node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js"));
    this.register(__webpack_require__(/*! ./GuildIntegrationsUpdate */ "./node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js"));
    this.register(__webpack_require__(/*! ./WebhooksUpdate */ "./node_modules/discord.js/src/client/actions/WebhooksUpdate.js"));
    this.register(__webpack_require__(/*! ./TypingStart */ "./node_modules/discord.js/src/client/actions/TypingStart.js"));
  }

  register(Action) {
    this[Action.name.replace(/Action$/, '')] = new Action(this.client);
  }
}

module.exports = ActionsManager;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/ChannelCreate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/ChannelCreate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class ChannelCreateAction extends Action {
  handle(data) {
    const client = this.client;
    const existing = client.channels.cache.has(data.id);
    const channel = client.channels.add(data);
    if (!existing && channel) {
      /**
       * Emitted whenever a channel is created.
       * @event Client#channelCreate
       * @param {DMChannel|GuildChannel} channel The channel that was created
       */
      client.emit(Events.CHANNEL_CREATE, channel);
    }
    return { channel };
  }
}

module.exports = ChannelCreateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/ChannelDelete.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/ChannelDelete.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const DMChannel = __webpack_require__(/*! ../../structures/DMChannel */ "./node_modules/discord.js/src/structures/DMChannel.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class ChannelDeleteAction extends Action {
  constructor(client) {
    super(client);
    this.deleted = new Map();
  }

  handle(data) {
    const client = this.client;
    let channel = client.channels.cache.get(data.id);

    if (channel) {
      client.channels.remove(channel.id);
      channel.deleted = true;
      if (channel.messages && !(channel instanceof DMChannel)) {
        for (const message of channel.messages.cache.values()) {
          message.deleted = true;
        }
      }
      /**
       * Emitted whenever a channel is deleted.
       * @event Client#channelDelete
       * @param {DMChannel|GuildChannel} channel The channel that was deleted
       */
      client.emit(Events.CHANNEL_DELETE, channel);
    }

    return { channel };
  }
}

module.exports = ChannelDeleteAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/ChannelUpdate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/ChannelUpdate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const Channel = __webpack_require__(/*! ../../structures/Channel */ "./node_modules/discord.js/src/structures/Channel.js");
const { ChannelTypes } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class ChannelUpdateAction extends Action {
  handle(data) {
    const client = this.client;

    let channel = client.channels.cache.get(data.id);
    if (channel) {
      const old = channel._update(data);

      if (ChannelTypes[channel.type.toUpperCase()] !== data.type) {
        const newChannel = Channel.create(this.client, data, channel.guild);
        for (const [id, message] of channel.messages.cache) newChannel.messages.cache.set(id, message);
        newChannel._typing = new Map(channel._typing);
        channel = newChannel;
        this.client.channels.cache.set(channel.id, channel);
      }

      return {
        old,
        updated: channel,
      };
    }

    return {};
  }
}

module.exports = ChannelUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildBanRemove.js":
/*!**********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildBanRemove.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildBanRemove extends Action {
  handle(data) {
    const client = this.client;
    const guild = client.guilds.cache.get(data.guild_id);
    const user = client.users.add(data.user);
    /**
     * Emitted whenever a member is unbanned from a guild.
     * @event Client#guildBanRemove
     * @param {Guild} guild The guild that the unban occurred in
     * @param {User} user The user that was unbanned
     */
    if (guild && user) client.emit(Events.GUILD_BAN_REMOVE, guild, user);
  }
}

module.exports = GuildBanRemove;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");

class GuildChannelsPositionUpdate extends Action {
  handle(data) {
    const client = this.client;

    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      for (const partialChannel of data.channels) {
        const channel = guild.channels.cache.get(partialChannel.id);
        if (channel) channel.rawPosition = partialChannel.position;
      }
    }

    return { guild };
  }
}

module.exports = GuildChannelsPositionUpdate;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildDelete.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildDelete.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildDeleteAction extends Action {
  constructor(client) {
    super(client);
    this.deleted = new Map();
  }

  handle(data) {
    const client = this.client;

    let guild = client.guilds.cache.get(data.id);
    if (guild) {
      for (const channel of guild.channels.cache.values()) {
        if (channel.type === 'text') channel.stopTyping(true);
      }

      if (data.unavailable) {
        // Guild is unavailable
        guild.available = false;

        /**
         * Emitted whenever a guild becomes unavailable, likely due to a server outage.
         * @event Client#guildUnavailable
         * @param {Guild} guild The guild that has become unavailable
         */
        client.emit(Events.GUILD_UNAVAILABLE, guild);

        // Stops the GuildDelete packet thinking a guild was actually deleted,
        // handles emitting of event itself
        return {
          guild: null,
        };
      }

      for (const channel of guild.channels.cache.values()) this.client.channels.remove(channel.id);
      if (guild.voice && guild.voice.connection) guild.voice.connection.disconnect();

      // Delete guild
      client.guilds.cache.delete(guild.id);
      guild.deleted = true;

      /**
       * Emitted whenever a guild kicks the client or the guild is deleted/left.
       * @event Client#guildDelete
       * @param {Guild} guild The guild that was deleted
       */
      client.emit(Events.GUILD_DELETE, guild);

      this.deleted.set(guild.id, guild);
      this.scheduleForDeletion(guild.id);
    } else {
      guild = this.deleted.get(data.id) || null;
    }

    return { guild };
  }

  scheduleForDeletion(id) {
    this.client.setTimeout(() => this.deleted.delete(id), this.client.options.restWsBridgeTimeout);
  }
}

module.exports = GuildDeleteAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildEmojiCreate.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildEmojiCreate.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildEmojiCreateAction extends Action {
  handle(guild, createdEmoji) {
    const already = guild.emojis.cache.has(createdEmoji.id);
    const emoji = guild.emojis.add(createdEmoji);
    /**
     * Emitted whenever a custom emoji is created in a guild.
     * @event Client#emojiCreate
     * @param {GuildEmoji} emoji The emoji that was created
     */
    if (!already) this.client.emit(Events.GUILD_EMOJI_CREATE, emoji);
    return { emoji };
  }
}

module.exports = GuildEmojiCreateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildEmojiDelete.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildEmojiDelete.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildEmojiDeleteAction extends Action {
  handle(emoji) {
    emoji.guild.emojis.cache.delete(emoji.id);
    emoji.deleted = true;
    /**
     * Emitted whenever a custom emoji is deleted in a guild.
     * @event Client#emojiDelete
     * @param {GuildEmoji} emoji The emoji that was deleted
     */
    this.client.emit(Events.GUILD_EMOJI_DELETE, emoji);
    return { emoji };
  }
}

module.exports = GuildEmojiDeleteAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildEmojiUpdateAction extends Action {
  handle(current, data) {
    const old = current._update(data);
    /**
     * Emitted whenever a custom emoji is updated in a guild.
     * @event Client#emojiUpdate
     * @param {GuildEmoji} oldEmoji The old emoji
     * @param {GuildEmoji} newEmoji The new emoji
     */
    this.client.emit(Events.GUILD_EMOJI_UPDATE, old, current);
    return { emoji: current };
  }
}

module.exports = GuildEmojiUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js":
/*!*************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");

class GuildEmojisUpdateAction extends Action {
  handle(data) {
    const guild = this.client.guilds.cache.get(data.guild_id);
    if (!guild || !guild.emojis) return;

    const deletions = new Map(guild.emojis.cache);

    for (const emoji of data.emojis) {
      // Determine type of emoji event
      const cachedEmoji = guild.emojis.cache.get(emoji.id);
      if (cachedEmoji) {
        deletions.delete(emoji.id);
        if (!cachedEmoji.equals(emoji)) {
          // Emoji updated
          this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
        }
      } else {
        // Emoji added
        this.client.actions.GuildEmojiCreate.handle(guild, emoji);
      }
    }

    for (const emoji of deletions.values()) {
      // Emoji deleted
      this.client.actions.GuildEmojiDelete.handle(emoji);
    }
  }
}

module.exports = GuildEmojisUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildIntegrationsUpdate extends Action {
  handle(data) {
    const client = this.client;
    const guild = client.guilds.cache.get(data.guild_id);
    /**
     * Emitted whenever a guild integration is updated
     * @event Client#guildIntegrationsUpdate
     * @param {Guild} guild The guild whose integrations were updated
     */
    if (guild) client.emit(Events.GUILD_INTEGRATIONS_UPDATE, guild);
  }
}

module.exports = GuildIntegrationsUpdate;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildMemberRemove.js":
/*!*************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildMemberRemove.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events, Status } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildMemberRemoveAction extends Action {
  handle(data, shard) {
    const client = this.client;
    const guild = client.guilds.cache.get(data.guild_id);
    let member = null;
    if (guild) {
      member = this.getMember({ user: data.user }, guild);
      guild.memberCount--;
      if (member) {
        member.deleted = true;
        guild.members.cache.delete(member.id);
        /**
         * Emitted whenever a member leaves a guild, or is kicked.
         * @event Client#guildMemberRemove
         * @param {GuildMember} member The member that has left/been kicked from the guild
         */
        if (shard.status === Status.READY) client.emit(Events.GUILD_MEMBER_REMOVE, member);
      }
      guild.voiceStates.cache.delete(data.user.id);
    }
    return { guild, member };
  }
}

module.exports = GuildMemberRemoveAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildMemberUpdate.js":
/*!*************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildMemberUpdate.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Status, Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildMemberUpdateAction extends Action {
  handle(data, shard) {
    const { client } = this;
    if (data.user.username) {
      const user = client.users.cache.get(data.user.id);
      if (!user) {
        client.users.add(data.user);
      } else if (!user.equals(data.user)) {
        client.actions.UserUpdate.handle(data.user);
      }
    }

    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      const member = this.getMember({ user: data.user }, guild);
      if (member) {
        const old = member._update(data);
        /**
         * Emitted whenever a guild member changes - i.e. new role, removed role, nickname.
         * Also emitted when the user's details (e.g. username) change.
         * @event Client#guildMemberUpdate
         * @param {GuildMember} oldMember The member before the update
         * @param {GuildMember} newMember The member after the update
         */
        if (shard.status === Status.READY) client.emit(Events.GUILD_MEMBER_UPDATE, old, member);
      } else {
        const newMember = guild.members.add(data);
        /**
         * Emitted whenever a member becomes available in a large guild.
         * @event Client#guildMemberAvailable
         * @param {GuildMember} member The member that became available
         */
        this.client.emit(Events.GUILD_MEMBER_AVAILABLE, newMember);
      }
    }
  }
}

module.exports = GuildMemberUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildRoleCreate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildRoleCreate.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildRoleCreate extends Action {
  handle(data) {
    const client = this.client;
    const guild = client.guilds.cache.get(data.guild_id);
    let role;
    if (guild) {
      const already = guild.roles.cache.has(data.role.id);
      role = guild.roles.add(data.role);
      /**
       * Emitted whenever a role is created.
       * @event Client#roleCreate
       * @param {Role} role The role that was created
       */
      if (!already) client.emit(Events.GUILD_ROLE_CREATE, role);
    }
    return { role };
  }
}

module.exports = GuildRoleCreate;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildRoleDelete.js":
/*!***********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildRoleDelete.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildRoleDeleteAction extends Action {
  handle(data) {
    const client = this.client;
    const guild = client.guilds.cache.get(data.guild_id);
    let role;

    if (guild) {
      role = guild.roles.cache.get(data.role_id);
      if (role) {
        guild.roles.cache.delete(data.role_id);
        role.deleted = true;
        /**
         * Emitted whenever a guild role is deleted.
         * @event Client#roleDelete
         * @param {Role} role The role that was deleted
         */
        client.emit(Events.GUILD_ROLE_DELETE, role);
      }
    }

    return { role };
  }
}

module.exports = GuildRoleDeleteAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildRoleUpdate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildRoleUpdate.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildRoleUpdateAction extends Action {
  handle(data) {
    const client = this.client;
    const guild = client.guilds.cache.get(data.guild_id);

    if (guild) {
      let old = null;

      const role = guild.roles.cache.get(data.role.id);
      if (role) {
        old = role._update(data.role);
        /**
         * Emitted whenever a guild role is updated.
         * @event Client#roleUpdate
         * @param {Role} oldRole The role before the update
         * @param {Role} newRole The role after the update
         */
        client.emit(Events.GUILD_ROLE_UPDATE, old, role);
      }

      return {
        old,
        updated: role,
      };
    }

    return {
      old: null,
      updated: null,
    };
  }
}

module.exports = GuildRoleUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");

class GuildRolesPositionUpdate extends Action {
  handle(data) {
    const client = this.client;

    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      for (const partialRole of data.roles) {
        const role = guild.roles.cache.get(partialRole.id);
        if (role) role.rawPosition = partialRole.position;
      }
    }

    return { guild };
  }
}

module.exports = GuildRolesPositionUpdate;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/GuildUpdate.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/GuildUpdate.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class GuildUpdateAction extends Action {
  handle(data) {
    const client = this.client;

    const guild = client.guilds.cache.get(data.id);
    if (guild) {
      const old = guild._update(data);
      /**
       * Emitted whenever a guild is updated - e.g. name change.
       * @event Client#guildUpdate
       * @param {Guild} oldGuild The guild before the update
       * @param {Guild} newGuild The guild after the update
       */
      client.emit(Events.GUILD_UPDATE, old, guild);
      return {
        old,
        updated: guild,
      };
    }

    return {
      old: null,
      updated: null,
    };
  }
}

module.exports = GuildUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/InviteCreate.js":
/*!********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/InviteCreate.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const Invite = __webpack_require__(/*! ../../structures/Invite */ "./node_modules/discord.js/src/structures/Invite.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class InviteCreateAction extends Action {
  handle(data) {
    const client = this.client;
    const channel = client.channels.cache.get(data.channel_id);
    const guild = client.guilds.cache.get(data.guild_id);
    if (!channel) return false;

    const inviteData = Object.assign(data, { channel, guild });
    const invite = new Invite(client, inviteData);
    /**
     * Emitted when an invite is created.
     * <info> This event only triggers if the client has `MANAGE_GUILD` permissions for the guild,
     * or `MANAGE_CHANNEL` permissions for the channel.</info>
     * @event Client#inviteCreate
     * @param {Invite} invite The invite that was created
     */
    client.emit(Events.INVITE_CREATE, invite);
    return { invite };
  }
}

module.exports = InviteCreateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/InviteDelete.js":
/*!********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/InviteDelete.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const Invite = __webpack_require__(/*! ../../structures/Invite */ "./node_modules/discord.js/src/structures/Invite.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class InviteDeleteAction extends Action {
  handle(data) {
    const client = this.client;
    const channel = client.channels.cache.get(data.channel_id);
    const guild = client.guilds.cache.get(data.guild_id);
    if (!channel && !guild) return false;

    const inviteData = Object.assign(data, { channel, guild });
    const invite = new Invite(client, inviteData);

    /**
     * Emitted when an invite is deleted.
     * <info> This event only triggers if the client has `MANAGE_GUILD` permissions for the guild,
     * or `MANAGE_CHANNEL` permissions for the channel.</info>
     * @event Client#inviteDelete
     * @param {Invite} invite The invite that was deleted
     */
    client.emit(Events.INVITE_DELETE, invite);
    return { invite };
  }
}

module.exports = InviteDeleteAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageCreate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageCreate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class MessageCreateAction extends Action {
  handle(data) {
    const client = this.client;
    const channel = client.channels.cache.get(data.channel_id);
    if (channel) {
      const existing = channel.messages.cache.get(data.id);
      if (existing) return { message: existing };
      const message = channel.messages.add(data);
      const user = message.author;
      let member = message.member;
      channel.lastMessageID = data.id;
      if (user) {
        user.lastMessageID = data.id;
        user.lastMessageChannelID = channel.id;
      }
      if (member) {
        member.lastMessageID = data.id;
        member.lastMessageChannelID = channel.id;
      }

      /**
       * Emitted whenever a message is created.
       * @event Client#message
       * @param {Message} message The created message
       */
      client.emit(Events.MESSAGE_CREATE, message);
      return { message };
    }

    return {};
  }
}

module.exports = MessageCreateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageDelete.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageDelete.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class MessageDeleteAction extends Action {
  handle(data) {
    const client = this.client;
    const channel = this.getChannel(data);
    let message;
    if (channel) {
      message = this.getMessage(data, channel);
      if (message) {
        channel.messages.cache.delete(message.id);
        message.deleted = true;
        /**
         * Emitted whenever a message is deleted.
         * @event Client#messageDelete
         * @param {Message} message The deleted message
         */
        client.emit(Events.MESSAGE_DELETE, message);
      }
    }

    return { message };
  }
}

module.exports = MessageDeleteAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageDeleteBulk.js":
/*!*************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageDeleteBulk.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const Collection = __webpack_require__(/*! ../../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class MessageDeleteBulkAction extends Action {
  handle(data) {
    const client = this.client;
    const channel = client.channels.cache.get(data.channel_id);

    if (channel) {
      const ids = data.ids;
      const messages = new Collection();
      for (const id of ids) {
        const message = this.getMessage(
          {
            id,
            guild_id: data.guild_id,
          },
          channel,
          false,
        );
        if (message) {
          message.deleted = true;
          messages.set(message.id, message);
          channel.messages.cache.delete(id);
        }
      }

      /**
       * Emitted whenever messages are deleted in bulk.
       * @event Client#messageDeleteBulk
       * @param {Collection<Snowflake, Message>} messages The deleted messages, mapped by their ID
       */
      if (messages.size > 0) client.emit(Events.MESSAGE_BULK_DELETE, messages);
      return { messages };
    }
    return {};
  }
}

module.exports = MessageDeleteBulkAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageReactionAdd.js":
/*!**************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageReactionAdd.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const { PartialTypes } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/*
{ user_id: 'id',
     message_id: 'id',
     emoji: { name: '�', id: null },
     channel_id: 'id',
     // If originating from a guild
     guild_id: 'id',
     member: { ..., user: { ... } } }
*/

class MessageReactionAdd extends Action {
  handle(data) {
    if (!data.emoji) return false;

    const user = this.getUserFromMember(data);
    if (!user) return false;

    // Verify channel
    const channel = this.getChannel(data);
    if (!channel || channel.type === 'voice') return false;

    // Verify message
    const message = this.getMessage(data, channel);
    if (!message) return false;

    // Verify reaction
    if (message.partial && !this.client.options.partials.includes(PartialTypes.REACTION)) return false;
    const existing = message.reactions.cache.get(data.emoji.id || data.emoji.name);
    if (existing && existing.users.cache.has(user.id)) return { message, reaction: existing, user };
    const reaction = message.reactions.add({
      emoji: data.emoji,
      count: message.partial ? null : 0,
      me: user.id === this.client.user.id,
    });
    if (!reaction) return false;
    reaction._add(user);
    /**
     * Emitted whenever a reaction is added to a cached message.
     * @event Client#messageReactionAdd
     * @param {MessageReaction} messageReaction The reaction object
     * @param {User} user The user that applied the guild or reaction emoji
     */
    this.client.emit(Events.MESSAGE_REACTION_ADD, reaction, user);

    return { message, reaction, user };
  }
}

module.exports = MessageReactionAdd;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageReactionRemove.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageReactionRemove.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/*
{ user_id: 'id',
     message_id: 'id',
     emoji: { name: '�', id: null },
     channel_id: 'id',
     guild_id: 'id' }
*/

class MessageReactionRemove extends Action {
  handle(data) {
    if (!data.emoji) return false;

    const user = this.getUser(data);
    if (!user) return false;

    // Verify channel
    const channel = this.getChannel(data);
    if (!channel || channel.type === 'voice') return false;

    // Verify message
    const message = this.getMessage(data, channel);
    if (!message) return false;

    // Verify reaction
    const reaction = this.getReaction(data, message, user);
    if (!reaction) return false;
    reaction._remove(user);
    /**
     * Emitted whenever a reaction is removed from a cached message.
     * @event Client#messageReactionRemove
     * @param {MessageReaction} messageReaction The reaction object
     * @param {User} user The user whose emoji or reaction emoji was removed
     */
    this.client.emit(Events.MESSAGE_REACTION_REMOVE, reaction, user);

    return { message, reaction, user };
  }
}

module.exports = MessageReactionRemove;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class MessageReactionRemoveAll extends Action {
  handle(data) {
    // Verify channel
    const channel = this.getChannel(data);
    if (!channel || channel.type === 'voice') return false;

    // Verify message
    const message = this.getMessage(data, channel);
    if (!message) return false;

    message.reactions.cache.clear();
    this.client.emit(Events.MESSAGE_REACTION_REMOVE_ALL, message);

    return { message };
  }
}

/**
 * Emitted whenever all reactions are removed from a cached message.
 * @event Client#messageReactionRemoveAll
 * @param {Message} message The message the reactions were removed from
 */

module.exports = MessageReactionRemoveAll;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class MessageReactionRemoveEmoji extends Action {
  handle(data) {
    const channel = this.getChannel(data);
    if (!channel || channel.type === 'voice') return false;

    const message = this.getMessage(data, channel);
    if (!message) return false;

    const reaction = this.getReaction(data, message);
    if (!reaction) return false;
    if (!message.partial) message.reactions.cache.delete(reaction.emoji.id || reaction.emoji.name);

    /**
     * Emitted when a bot removes an emoji reaction from a cached message.
     * @event Client#messageReactionRemoveEmoji
     * @param {MessageReaction} reaction The reaction that was removed
     */
    this.client.emit(Events.MESSAGE_REACTION_REMOVE_EMOJI, reaction);
    return { reaction };
  }
}

module.exports = MessageReactionRemoveEmoji;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/MessageUpdate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/MessageUpdate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");

class MessageUpdateAction extends Action {
  handle(data) {
    const channel = this.getChannel(data);
    if (channel) {
      const { id, channel_id, guild_id, author, timestamp, type } = data;
      const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
      if (message) {
        const old = message.patch(data);
        return {
          old,
          updated: message,
        };
      }
    }

    return {};
  }
}

module.exports = MessageUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/PresenceUpdate.js":
/*!**********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/PresenceUpdate.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class PresenceUpdateAction extends Action {
  handle(data) {
    let user = this.client.users.cache.get(data.user.id);
    if (!user && data.user.username) user = this.client.users.add(data.user);
    if (!user) return;

    if (data.user && data.user.username) {
      if (!user.equals(data.user)) this.client.actions.UserUpdate.handle(data.user);
    }

    const guild = this.client.guilds.cache.get(data.guild_id);
    if (!guild) return;

    let oldPresence = guild.presences.cache.get(user.id);
    if (oldPresence) oldPresence = oldPresence._clone();
    let member = guild.members.cache.get(user.id);
    if (!member && data.status !== 'offline') {
      member = guild.members.add({
        user,
        roles: data.roles,
        deaf: false,
        mute: false,
      });
      this.client.emit(Events.GUILD_MEMBER_AVAILABLE, member);
    }
    guild.presences.add(Object.assign(data, { guild }));
    if (member && this.client.listenerCount(Events.PRESENCE_UPDATE)) {
      /**
       * Emitted whenever a guild member's presence (e.g. status, activity) is changed.
       * @event Client#presenceUpdate
       * @param {?Presence} oldPresence The presence before the update, if one at all
       * @param {Presence} newPresence The presence after the update
       */
      this.client.emit(Events.PRESENCE_UPDATE, oldPresence, member.presence);
    }
  }
}

module.exports = PresenceUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/TypingStart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/TypingStart.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const textBasedChannelTypes = ['dm', 'text', 'news'];

class TypingStart extends Action {
  handle(data) {
    const channel = this.getChannel(data);
    if (!channel) {
      return;
    }
    if (!textBasedChannelTypes.includes(channel.type)) {
      this.client.emit(Events.WARN, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
      return;
    }

    const user = this.getUserFromMember(data);
    const timestamp = new Date(data.timestamp * 1000);

    if (channel && user) {
      if (channel._typing.has(user.id)) {
        const typing = channel._typing.get(user.id);

        typing.lastTimestamp = timestamp;
        typing.elapsedTime = Date.now() - typing.since;
        this.client.clearTimeout(typing.timeout);
        typing.timeout = this.tooLate(channel, user);
      } else {
        const since = new Date();
        const lastTimestamp = new Date();
        channel._typing.set(user.id, {
          user,
          since,
          lastTimestamp,
          elapsedTime: Date.now() - since,
          timeout: this.tooLate(channel, user),
        });

        /**
         * Emitted whenever a user starts typing in a channel.
         * @event Client#typingStart
         * @param {Channel} channel The channel the user started typing in
         * @param {User} user The user that started typing
         */
        this.client.emit(Events.TYPING_START, channel, user);
      }
    }
  }

  tooLate(channel, user) {
    return channel.client.setTimeout(() => {
      channel._typing.delete(user.id);
    }, 10000);
  }
}

module.exports = TypingStart;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/UserUpdate.js":
/*!******************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/UserUpdate.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class UserUpdateAction extends Action {
  handle(data) {
    const client = this.client;

    const newUser = client.users.cache.get(data.id);
    const oldUser = newUser._update(data);

    if (!oldUser.equals(newUser)) {
      /**
       * Emitted whenever a user's details (e.g. username) are changed.
       * Triggered by the Discord gateway events USER_UPDATE, GUILD_MEMBER_UPDATE, and PRESENCE_UPDATE.
       * @event Client#userUpdate
       * @param {User} oldUser The user before the update
       * @param {User} newUser The user after the update
       */
      client.emit(Events.USER_UPDATE, oldUser, newUser);
      return {
        old: oldUser,
        updated: newUser,
      };
    }

    return {
      old: null,
      updated: null,
    };
  }
}

module.exports = UserUpdateAction;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/VoiceStateUpdate.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/VoiceStateUpdate.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Structures = __webpack_require__(/*! ../../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");

class VoiceStateUpdate extends Action {
  handle(data) {
    const client = this.client;
    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      const VoiceState = Structures.get('VoiceState');
      // Update the state
      const oldState = guild.voiceStates.cache.has(data.user_id)
        ? guild.voiceStates.cache.get(data.user_id)._clone()
        : new VoiceState(guild, { user_id: data.user_id });

      const newState = guild.voiceStates.add(data);

      // Get the member
      let member = guild.members.cache.get(data.user_id);
      if (member && data.member) {
        member._patch(data.member);
      } else if (data.member && data.member.user && data.member.joined_at) {
        member = guild.members.add(data.member);
      }

      // Emit event
      if (member && member.user.id === client.user.id) {
        client.emit('debug', `[VOICE] received voice state update: ${JSON.stringify(data)}`);
        client.voice.onVoiceStateUpdate(data);
      }

      /**
       * Emitted whenever a member changes voice state - e.g. joins/leaves a channel, mutes/unmutes.
       * @event Client#voiceStateUpdate
       * @param {VoiceState} oldState The voice state before the update
       * @param {VoiceState} newState The voice state after the update
       */
      client.emit(Events.VOICE_STATE_UPDATE, oldState, newState);
    }
  }
}

module.exports = VoiceStateUpdate;


/***/ }),

/***/ "./node_modules/discord.js/src/client/actions/WebhooksUpdate.js":
/*!**********************************************************************!*\
  !*** ./node_modules/discord.js/src/client/actions/WebhooksUpdate.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Action = __webpack_require__(/*! ./Action */ "./node_modules/discord.js/src/client/actions/Action.js");
const { Events } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class WebhooksUpdate extends Action {
  handle(data) {
    const client = this.client;
    const channel = client.channels.cache.get(data.channel_id);
    /**
     * Emitted whenever a guild text channel has its webhooks changed.
     * @event Client#webhookUpdate
     * @param {TextChannel} channel The channel that had a webhook update
     */
    if (channel) client.emit(Events.WEBHOOKS_UPDATE, channel);
  }
}

module.exports = WebhooksUpdate;


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/WebSocketManager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/WebSocketManager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const WebSocketShard = __webpack_require__(/*! ./WebSocketShard */ "./node_modules/discord.js/src/client/websocket/WebSocketShard.js");
const PacketHandlers = __webpack_require__(/*! ./handlers */ "./node_modules/discord.js/src/client/websocket/handlers/index.js");
const { Error: DJSError } = __webpack_require__(/*! ../../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { Events, ShardEvents, Status, WSCodes, WSEvents } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Util = __webpack_require__(/*! ../../util/Util */ "./node_modules/discord.js/src/util/Util.js");

const BeforeReadyWhitelist = [
  WSEvents.READY,
  WSEvents.RESUMED,
  WSEvents.GUILD_CREATE,
  WSEvents.GUILD_DELETE,
  WSEvents.GUILD_MEMBERS_CHUNK,
  WSEvents.GUILD_MEMBER_ADD,
  WSEvents.GUILD_MEMBER_REMOVE,
];

const UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);
const UNRESUMABLE_CLOSE_CODES = [1000, 4006, 4007];

/**
 * The WebSocket manager for this client.
 * <info>This class forwards raw dispatch events,
 * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>
 * @extends EventEmitter
 */
class WebSocketManager extends EventEmitter {
  constructor(client) {
    super();

    /**
     * The client that instantiated this WebSocketManager
     * @type {Client}
     * @readonly
     * @name WebSocketManager#client
     */
    Object.defineProperty(this, 'client', { value: client });

    /**
     * The gateway this manager uses
     * @type {?string}
     */
    this.gateway = null;

    /**
     * The amount of shards this manager handles
     * @private
     * @type {number}
     */
    this.totalShards = this.client.options.shards.length;

    /**
     * A collection of all shards this manager handles
     * @type {Collection<number, WebSocketShard>}
     */
    this.shards = new Collection();

    /**
     * An array of shards to be connected or that need to reconnect
     * @type {Set<WebSocketShard>}
     * @private
     * @name WebSocketManager#shardQueue
     */
    Object.defineProperty(this, 'shardQueue', { value: new Set(), writable: true });

    /**
     * An array of queued events before this WebSocketManager became ready
     * @type {object[]}
     * @private
     * @name WebSocketManager#packetQueue
     */
    Object.defineProperty(this, 'packetQueue', { value: [] });

    /**
     * The current status of this WebSocketManager
     * @type {number}
     */
    this.status = Status.IDLE;

    /**
     * If this manager was destroyed. It will prevent shards from reconnecting
     * @type {boolean}
     * @private
     */
    this.destroyed = false;

    /**
     * If this manager is currently reconnecting one or multiple shards
     * @type {boolean}
     * @private
     */
    this.reconnecting = false;

    /**
     * The current session limit of the client
     * @private
     * @type {?Object}
     * @property {number} total Total number of identifies available
     * @property {number} remaining Number of identifies remaining
     * @property {number} reset_after Number of milliseconds after which the limit resets
     */
    this.sessionStartLimit = null;
  }

  /**
   * The average ping of all WebSocketShards
   * @type {number}
   * @readonly
   */
  get ping() {
    const sum = this.shards.reduce((a, b) => a + b.ping, 0);
    return sum / this.shards.size;
  }

  /**
   * Emits a debug message.
   * @param {string} message The debug message
   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any
   * @private
   */
  debug(message, shard) {
    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);
  }

  /**
   * Connects this manager to the gateway.
   * @private
   */
  async connect() {
    const invalidToken = new DJSError(WSCodes[4004]);
    const {
      url: gatewayURL,
      shards: recommendedShards,
      session_start_limit: sessionStartLimit,
    } = await this.client.api.gateway.bot.get().catch(error => {
      throw error.httpStatus === 401 ? invalidToken : error;
    });

    this.sessionStartLimit = sessionStartLimit;

    const { total, remaining, reset_after } = sessionStartLimit;

    this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);

    this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);

    this.gateway = `${gatewayURL}/`;

    let { shards } = this.client.options;

    if (shards === 'auto') {
      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);
      this.totalShards = this.client.options.shardCount = recommendedShards;
      shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);
    }

    this.totalShards = shards.length;
    this.debug(`Spawning shards: ${shards.join(', ')}`);
    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));

    await this._handleSessionLimit(remaining, reset_after);

    return this.createShards();
  }

  /**
   * Handles the creation of a shard.
   * @returns {Promise<boolean>}
   * @private
   */
  async createShards() {
    // If we don't have any shards to handle, return
    if (!this.shardQueue.size) return false;

    const [shard] = this.shardQueue;

    this.shardQueue.delete(shard);

    if (!shard.eventsAttached) {
      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {
        /**
         * Emitted when a shard turns ready.
         * @event Client#shardReady
         * @param {number} id The shard ID that turned ready
         * @param {?Set<string>} unavailableGuilds Set of unavailable guild IDs, if any
         */
        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);

        if (!this.shardQueue.size) this.reconnecting = false;
        this.checkShardsReady();
      });

      shard.on(ShardEvents.CLOSE, event => {
        if (event.code === 1000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {
          /**
           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.
           * @event Client#shardDisconnect
           * @param {CloseEvent} event The WebSocket close event
           * @param {number} id The shard ID that disconnected
           */
          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);
          this.debug(WSCodes[event.code], shard);
          return;
        }

        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {
          // These event codes cannot be resumed
          shard.sessionID = null;
        }

        /**
         * Emitted when a shard is attempting to reconnect or re-identify.
         * @event Client#shardReconnecting
         * @param {number} id The shard ID that is attempting to reconnect
         */
        this.client.emit(Events.SHARD_RECONNECTING, shard.id);

        this.shardQueue.add(shard);

        if (shard.sessionID) {
          this.debug(`Session ID is present, attempting an immediate reconnect...`, shard);
          this.reconnect(true);
        } else {
          shard.destroy({ reset: true, emit: false, log: false });
          this.reconnect();
        }
      });

      shard.on(ShardEvents.INVALID_SESSION, () => {
        this.client.emit(Events.SHARD_RECONNECTING, shard.id);
      });

      shard.on(ShardEvents.DESTROYED, () => {
        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);

        this.client.emit(Events.SHARD_RECONNECTING, shard.id);

        this.shardQueue.add(shard);
        this.reconnect();
      });

      shard.eventsAttached = true;
    }

    this.shards.set(shard.id, shard);

    try {
      await shard.connect();
    } catch (error) {
      if (error && error.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {
        throw new DJSError(WSCodes[error.code]);
        // Undefined if session is invalid, error event for regular closes
      } else if (!error || error.code) {
        this.debug('Failed to connect to the gateway, requeueing...', shard);
        this.shardQueue.add(shard);
      } else {
        throw error;
      }
    }
    // If we have more shards, add a 5s delay
    if (this.shardQueue.size) {
      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);
      await Util.delayFor(5000);
      await this._handleSessionLimit();
      return this.createShards();
    }

    return true;
  }

  /**
   * Handles reconnects for this manager.
   * @param {boolean} [skipLimit=false] IF this reconnect should skip checking the session limit
   * @private
   * @returns {Promise<boolean>}
   */
  async reconnect(skipLimit = false) {
    if (this.reconnecting || this.status !== Status.READY) return false;
    this.reconnecting = true;
    try {
      if (!skipLimit) await this._handleSessionLimit();
      await this.createShards();
    } catch (error) {
      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);
      if (error.httpStatus !== 401) {
        this.debug(`Possible network error occurred. Retrying in 5s...`);
        await Util.delayFor(5000);
        this.reconnecting = false;
        return this.reconnect();
      }
      // If we get an error at this point, it means we cannot reconnect anymore
      if (this.client.listenerCount(Events.INVALIDATED)) {
        /**
         * Emitted when the client's session becomes invalidated.
         * You are expected to handle closing the process gracefully and preventing a boot loop
         * if you are listening to this event.
         * @event Client#invalidated
         */
        this.client.emit(Events.INVALIDATED);
        // Destroy just the shards. This means you have to handle the cleanup yourself
        this.destroy();
      } else {
        this.client.destroy();
      }
    } finally {
      this.reconnecting = false;
    }
    return true;
  }

  /**
   * Broadcasts a packet to every shard this manager handles.
   * @param {Object} packet The packet to send
   * @private
   */
  broadcast(packet) {
    for (const shard of this.shards.values()) shard.send(packet);
  }

  /**
   * Destroys this manager and all its shards.
   * @private
   */
  destroy() {
    if (this.destroyed) return;
    this.debug(`Manager was destroyed. Called by:\n${new Error('MANAGER_DESTROYED').stack}`);
    this.destroyed = true;
    this.shardQueue.clear();
    for (const shard of this.shards.values()) shard.destroy({ closeCode: 1000, reset: true, emit: false, log: false });
  }

  /**
   * Handles the timeout required if we cannot identify anymore.
   * @param {number} [remaining] The amount of remaining identify sessions that can be done today
   * @param {number} [resetAfter] The amount of time in which the identify counter resets
   * @private
   */
  async _handleSessionLimit(remaining, resetAfter) {
    if (typeof remaining === 'undefined' && typeof resetAfter === 'undefined') {
      const { session_start_limit } = await this.client.api.gateway.bot.get();
      this.sessionStartLimit = session_start_limit;
      remaining = session_start_limit.remaining;
      resetAfter = session_start_limit.reset_after;
      this.debug(`Session Limit Information
    Total: ${session_start_limit.total}
    Remaining: ${remaining}`);
    }
    if (!remaining) {
      this.debug(`Exceeded identify threshold. Will attempt a connection in ${resetAfter}ms`);
      await Util.delayFor(resetAfter);
    }
  }

  /**
   * Processes a packet and queues it if this WebSocketManager is not ready.
   * @param {Object} [packet] The packet to be handled
   * @param {WebSocketShard} [shard] The shard that will handle this packet
   * @returns {boolean}
   * @private
   */
  handlePacket(packet, shard) {
    if (packet && this.status !== Status.READY) {
      if (!BeforeReadyWhitelist.includes(packet.t)) {
        this.packetQueue.push({ packet, shard });
        return false;
      }
    }

    if (this.packetQueue.length) {
      const item = this.packetQueue.shift();
      this.client.setImmediate(() => {
        this.handlePacket(item.packet, item.shard);
      });
    }

    if (packet && PacketHandlers[packet.t]) {
      PacketHandlers[packet.t](this.client, packet, shard);
    }

    return true;
  }

  /**
   * Checks whether the client is ready to be marked as ready.
   * @private
   */
  async checkShardsReady() {
    if (this.status === Status.READY) return;
    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {
      return;
    }

    this.status = Status.NEARLY;

    if (this.client.options.fetchAllMembers) {
      try {
        const promises = this.client.guilds.cache.map(guild => {
          if (guild.available) return guild.members.fetch();
          // Return empty promise if guild is unavailable
          return Promise.resolve();
        });
        await Promise.all(promises);
      } catch (err) {
        this.debug(`Failed to fetch all members before ready! ${err}\n${err.stack}`);
      }
    }

    this.triggerClientReady();
  }

  /**
   * Causes the client to be marked as ready and emits the ready event.
   * @private
   */
  triggerClientReady() {
    this.status = Status.READY;

    this.client.readyAt = new Date();

    /**
     * Emitted when the client becomes ready to start working.
     * @event Client#ready
     */
    this.client.emit(Events.CLIENT_READY);

    this.handlePacket();
  }
}

module.exports = WebSocketManager;


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/WebSocketShard.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/WebSocketShard.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const WebSocket = __webpack_require__(/*! ../../WebSocket */ "./node_modules/discord.js/src/WebSocket.js");
const { browser, Status, Events, ShardEvents, OPCodes, WSEvents } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

const STATUS_KEYS = Object.keys(Status);
const CONNECTION_STATE = Object.keys(WebSocket.WebSocket);

let zlib;

if (!browser) {
  try {
    zlib = __webpack_require__(/*! zlib-sync */ "?ca8b");
  } catch {} // eslint-disable-line no-empty
}

/**
 * Represents a Shard's WebSocket connection
 */
class WebSocketShard extends EventEmitter {
  constructor(manager, id) {
    super();

    /**
     * The WebSocketManager of the shard
     * @type {WebSocketManager}
     */
    this.manager = manager;

    /**
     * The ID of the shard
     * @type {number}
     */
    this.id = id;

    /**
     * The current status of the shard
     * @type {Status}
     */
    this.status = Status.IDLE;

    /**
     * The current sequence of the shard
     * @type {number}
     * @private
     */
    this.sequence = -1;

    /**
     * The sequence of the shard after close
     * @type {number}
     * @private
     */
    this.closeSequence = 0;

    /**
     * The current session ID of the shard
     * @type {?string}
     * @private
     */
    this.sessionID = null;

    /**
     * The previous heartbeat ping of the shard
     * @type {number}
     */
    this.ping = -1;

    /**
     * The last time a ping was sent (a timestamp)
     * @type {number}
     * @private
     */
    this.lastPingTimestamp = -1;

    /**
     * If we received a heartbeat ack back. Used to identify zombie connections
     * @type {boolean}
     * @private
     */
    this.lastHeartbeatAcked = true;

    /**
     * Contains the rate limit queue and metadata
     * @name WebSocketShard#ratelimit
     * @type {Object}
     * @private
     */
    Object.defineProperty(this, 'ratelimit', {
      value: {
        queue: [],
        total: 120,
        remaining: 120,
        time: 60e3,
        timer: null,
      },
    });

    /**
     * The WebSocket connection for the current shard
     * @name WebSocketShard#connection
     * @type {?WebSocket}
     * @private
     */
    Object.defineProperty(this, 'connection', { value: null, writable: true });

    /**
     * @external Inflate
     * @see {@link https://www.npmjs.com/package/zlib-sync}
     */

    /**
     * The compression to use
     * @name WebSocketShard#inflate
     * @type {?Inflate}
     * @private
     */
    Object.defineProperty(this, 'inflate', { value: null, writable: true });

    /**
     * The HELLO timeout
     * @name WebSocketShard#helloTimeout
     * @type {?NodeJS.Timeout}
     * @private
     */
    Object.defineProperty(this, 'helloTimeout', { value: null, writable: true });

    /**
     * If the manager attached its event handlers on the shard
     * @name WebSocketShard#eventsAttached
     * @type {boolean}
     * @private
     */
    Object.defineProperty(this, 'eventsAttached', { value: false, writable: true });

    /**
     * A set of guild IDs this shard expects to receive
     * @name WebSocketShard#expectedGuilds
     * @type {?Set<string>}
     * @private
     */
    Object.defineProperty(this, 'expectedGuilds', { value: null, writable: true });

    /**
     * The ready timeout
     * @name WebSocketShard#readyTimeout
     * @type {?NodeJS.Timeout}
     * @private
     */
    Object.defineProperty(this, 'readyTimeout', { value: null, writable: true });

    /**
     * Time when the WebSocket connection was opened
     * @name WebSocketShard#connectedAt
     * @type {number}
     * @private
     */
    Object.defineProperty(this, 'connectedAt', { value: 0, writable: true });
  }

  /**
   * Emits a debug event.
   * @param {string} message The debug message
   * @private
   */
  debug(message) {
    this.manager.debug(message, this);
  }

  /**
   * Connects the shard to the gateway.
   * @private
   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,
   * or reject if we couldn't connect
   */
  connect() {
    const { gateway, client } = this.manager;

    if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status.READY) {
      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      const cleanup = () => {
        this.removeListener(ShardEvents.CLOSE, onClose);
        this.removeListener(ShardEvents.READY, onReady);
        this.removeListener(ShardEvents.RESUMED, onResumed);
        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);
        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);
      };

      const onReady = () => {
        cleanup();
        resolve();
      };

      const onResumed = () => {
        cleanup();
        resolve();
      };

      const onClose = event => {
        cleanup();
        reject(event);
      };

      const onInvalidOrDestroyed = () => {
        cleanup();
        // eslint-disable-next-line prefer-promise-reject-errors
        reject();
      };

      this.once(ShardEvents.READY, onReady);
      this.once(ShardEvents.RESUMED, onResumed);
      this.once(ShardEvents.CLOSE, onClose);
      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);
      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);

      if (this.connection && this.connection.readyState === WebSocket.OPEN) {
        this.debug('An open connection was found, attempting an immediate identify.');
        this.identify();
        return;
      }

      if (this.connection) {
        this.debug(`A connection object was found. Cleaning up before continuing.
    State: ${CONNECTION_STATE[this.connection.readyState]}`);
        this.destroy({ emit: false });
      }

      const wsQuery = { v: client.options.ws.version };

      if (zlib) {
        this.inflate = new zlib.Inflate({
          chunkSize: 65535,
          flush: zlib.Z_SYNC_FLUSH,
          to: WebSocket.encoding === 'json' ? 'string' : '',
        });
        wsQuery.compress = 'zlib-stream';
      }

      this.debug(
        `[CONNECT]
    Gateway    : ${gateway}
    Version    : ${client.options.ws.version}
    Encoding   : ${WebSocket.encoding}
    Compression: ${zlib ? 'zlib-stream' : 'none'}`,
      );

      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;
      this.setHelloTimeout();

      this.connectedAt = Date.now();

      const ws = (this.connection = WebSocket.create(gateway, wsQuery));
      ws.onopen = this.onOpen.bind(this);
      ws.onmessage = this.onMessage.bind(this);
      ws.onerror = this.onError.bind(this);
      ws.onclose = this.onClose.bind(this);
    });
  }

  /**
   * Called whenever a connection is opened to the gateway.
   * @private
   */
  onOpen() {
    this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now() - this.connectedAt}ms`);
    this.status = Status.NEARLY;
  }

  /**
   * Called whenever a message is received.
   * @param {MessageEvent} event Event received
   * @private
   */
  onMessage({ data }) {
    let raw;
    if (data instanceof ArrayBuffer) data = new Uint8Array(data);
    if (zlib) {
      const l = data.length;
      const flush =
        l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;

      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);
      if (!flush) return;
      raw = this.inflate.result;
    } else {
      raw = data;
    }
    let packet;
    try {
      packet = WebSocket.unpack(raw);
      this.manager.client.emit(Events.RAW, packet, this.id);
      if (packet.op === OPCodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);
    } catch (err) {
      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);
      return;
    }
    this.onPacket(packet);
  }

  /**
   * Called whenever an error occurs with the WebSocket.
   * @param {ErrorEvent} event The error that occurred
   * @private
   */
  onError(event) {
    const error = event && event.error ? event.error : event;
    if (!error) return;

    /**
     * Emitted whenever a shard's WebSocket encounters a connection error.
     * @event Client#shardError
     * @param {Error} error The encountered error
     * @param {number} shardID The shard that encountered this error
     */
    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);
  }

  /**
   * @external CloseEvent
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}
   */

  /**
   * @external ErrorEvent
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}
   */

  /**
   * @external MessageEvent
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}
   */

  /**
   * Called whenever a connection to the gateway is closed.
   * @param {CloseEvent} event Close event that was received
   * @private
   */
  onClose(event) {
    if (this.sequence !== -1) this.closeSequence = this.sequence;
    this.sequence = -1;

    this.debug(`[CLOSE]
    Event Code: ${event.code}
    Clean     : ${event.wasClean}
    Reason    : ${event.reason || 'No reason received'}`);

    this.setHeartbeatTimer(-1);
    this.setHelloTimeout(-1);
    // If we still have a connection object, clean up its listeners
    if (this.connection) this._cleanupConnection();

    this.status = Status.DISCONNECTED;

    /**
     * Emitted when a shard's WebSocket closes.
     * @private
     * @event WebSocketShard#close
     * @param {CloseEvent} event The received event
     */
    this.emit(ShardEvents.CLOSE, event);
  }

  /**
   * Called whenever a packet is received.
   * @param {Object} packet The received packet
   * @private
   */
  onPacket(packet) {
    if (!packet) {
      this.debug(`Received broken packet: '${packet}'.`);
      return;
    }

    switch (packet.t) {
      case WSEvents.READY:
        /**
         * Emitted when the shard receives the READY payload and is now waiting for guilds
         * @event WebSocketShard#ready
         */
        this.emit(ShardEvents.READY);

        this.sessionID = packet.d.session_id;
        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));
        this.status = Status.WAITING_FOR_GUILDS;
        this.debug(`[READY] Session ${this.sessionID}.`);
        this.lastHeartbeatAcked = true;
        this.sendHeartbeat('ReadyHeartbeat');
        break;
      case WSEvents.RESUMED: {
        /**
         * Emitted when the shard resumes successfully
         * @event WebSocketShard#resumed
         */
        this.emit(ShardEvents.RESUMED);

        this.status = Status.READY;
        const replayed = packet.s - this.closeSequence;
        this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${replayed} events.`);
        this.lastHeartbeatAcked = true;
        this.sendHeartbeat('ResumeHeartbeat');
        break;
      }
    }

    if (packet.s > this.sequence) this.sequence = packet.s;

    switch (packet.op) {
      case OPCodes.HELLO:
        this.setHelloTimeout(-1);
        this.setHeartbeatTimer(packet.d.heartbeat_interval);
        this.identify();
        break;
      case OPCodes.RECONNECT:
        this.debug('[RECONNECT] Discord asked us to reconnect');
        this.destroy({ closeCode: 4000 });
        break;
      case OPCodes.INVALID_SESSION:
        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);
        // If we can resume the session, do so immediately
        if (packet.d) {
          this.identifyResume();
          return;
        }
        // Reset the sequence
        this.sequence = -1;
        // Reset the session ID as it's invalid
        this.sessionID = null;
        // Set the status to reconnecting
        this.status = Status.RECONNECTING;
        // Finally, emit the INVALID_SESSION event
        this.emit(ShardEvents.INVALID_SESSION);
        break;
      case OPCodes.HEARTBEAT_ACK:
        this.ackHeartbeat();
        break;
      case OPCodes.HEARTBEAT:
        this.sendHeartbeat('HeartbeatRequest', true);
        break;
      default:
        this.manager.handlePacket(packet, this);
        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {
          this.expectedGuilds.delete(packet.d.id);
          this.checkReady();
        }
    }
  }

  /**
   * Checks if the shard can be marked as ready
   * @private
   */
  checkReady() {
    // Step 0. Clear the ready timeout, if it exists
    if (this.readyTimeout) {
      this.manager.client.clearTimeout(this.readyTimeout);
      this.readyTimeout = null;
    }
    // Step 1. If we don't have any other guilds pending, we are ready
    if (!this.expectedGuilds.size) {
      this.debug('Shard received all its guilds. Marking as fully ready.');
      this.status = Status.READY;

      /**
       * Emitted when the shard is fully ready.
       * This event is emitted if:
       * * all guilds were received by this shard
       * * the ready timeout expired, and some guilds are unavailable
       * @event WebSocketShard#allReady
       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any
       */
      this.emit(ShardEvents.ALL_READY);
      return;
    }
    // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds
    this.readyTimeout = this.manager.client.setTimeout(() => {
      this.debug(`Shard did not receive any more guild packets in 15 seconds.
  Unavailable guild count: ${this.expectedGuilds.size}`);

      this.readyTimeout = null;

      this.status = Status.READY;

      this.emit(ShardEvents.ALL_READY, this.expectedGuilds);
    }, 15000);
  }

  /**
   * Sets the HELLO packet timeout.
   * @param {number} [time] If set to -1, it will clear the hello timeout timeout
   * @private
   */
  setHelloTimeout(time) {
    if (time === -1) {
      if (this.helloTimeout) {
        this.debug('Clearing the HELLO timeout.');
        this.manager.client.clearTimeout(this.helloTimeout);
        this.helloTimeout = null;
      }
      return;
    }
    this.debug('Setting a HELLO timeout for 20s.');
    this.helloTimeout = this.manager.client.setTimeout(() => {
      this.debug('Did not receive HELLO in time. Destroying and connecting again.');
      this.destroy({ reset: true, closeCode: 4009 });
    }, 20000);
  }

  /**
   * Sets the heartbeat timer for this shard.
   * @param {number} time If -1, clears the interval, any other number sets an interval
   * @private
   */
  setHeartbeatTimer(time) {
    if (time === -1) {
      if (this.heartbeatInterval) {
        this.debug('Clearing the heartbeat interval.');
        this.manager.client.clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
      }
      return;
    }
    this.debug(`Setting a heartbeat interval for ${time}ms.`);
    // Sanity checks
    if (this.heartbeatInterval) this.manager.client.clearInterval(this.heartbeatInterval);
    this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), time);
  }

  /**
   * Sends a heartbeat to the WebSocket.
   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect
   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent
   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.
   * @private
   */
  sendHeartbeat(
    tag = 'HeartbeatTimer',
    ignoreHeartbeatAck = [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status),
  ) {
    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {
      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);
    } else if (!this.lastHeartbeatAcked) {
      this.debug(
        `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.
    Status          : ${STATUS_KEYS[this.status]}
    Sequence        : ${this.sequence}
    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`,
      );

      this.destroy({ closeCode: 4009, reset: true });
      return;
    }

    this.debug(`[${tag}] Sending a heartbeat.`);
    this.lastHeartbeatAcked = false;
    this.lastPingTimestamp = Date.now();
    this.send({ op: OPCodes.HEARTBEAT, d: this.sequence }, true);
  }

  /**
   * Acknowledges a heartbeat.
   * @private
   */
  ackHeartbeat() {
    this.lastHeartbeatAcked = true;
    const latency = Date.now() - this.lastPingTimestamp;
    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);
    this.ping = latency;
  }

  /**
   * Identifies the client on the connection.
   * @private
   * @returns {void}
   */
  identify() {
    return this.sessionID ? this.identifyResume() : this.identifyNew();
  }

  /**
   * Identifies as a new connection on the gateway.
   * @private
   */
  identifyNew() {
    const { client } = this.manager;
    if (!client.token) {
      this.debug('[IDENTIFY] No token available to identify a new session.');
      return;
    }

    this.status = Status.IDENTIFYING;

    // Clone the identify payload and assign the token and shard info
    const d = {
      ...client.options.ws,
      token: client.token,
      shard: [this.id, Number(client.options.shardCount)],
    };

    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount}`);
    this.send({ op: OPCodes.IDENTIFY, d }, true);
  }

  /**
   * Resumes a session on the gateway.
   * @private
   */
  identifyResume() {
    if (!this.sessionID) {
      this.debug('[RESUME] No session ID was present; identifying as a new session.');
      this.identifyNew();
      return;
    }

    this.status = Status.RESUMING;

    this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);

    const d = {
      token: this.manager.client.token,
      session_id: this.sessionID,
      seq: this.closeSequence,
    };

    this.send({ op: OPCodes.RESUME, d }, true);
  }

  /**
   * Adds a packet to the queue to be sent to the gateway.
   * <warn>If you use this method, make sure you understand that you need to provide
   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).
   * Do not use this method if you don't know what you're doing.</warn>
   * @param {Object} data The full packet to send
   * @param {boolean} [important=false] If this packet should be added first in queue
   */
  send(data, important = false) {
    this.ratelimit.queue[important ? 'unshift' : 'push'](data);
    this.processQueue();
  }

  /**
   * Sends data, bypassing the queue.
   * @param {Object} data Packet to send
   * @returns {void}
   * @private
   */
  _send(data) {
    if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {
      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);
      this.destroy({ close: 4000 });
      return;
    }

    this.connection.send(WebSocket.pack(data), err => {
      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);
    });
  }

  /**
   * Processes the current WebSocket queue.
   * @returns {void}
   * @private
   */
  processQueue() {
    if (this.ratelimit.remaining === 0) return;
    if (this.ratelimit.queue.length === 0) return;
    if (this.ratelimit.remaining === this.ratelimit.total) {
      this.ratelimit.timer = this.manager.client.setTimeout(() => {
        this.ratelimit.remaining = this.ratelimit.total;
        this.processQueue();
      }, this.ratelimit.time);
    }
    while (this.ratelimit.remaining > 0) {
      const item = this.ratelimit.queue.shift();
      if (!item) return;
      this._send(item);
      this.ratelimit.remaining--;
    }
  }

  /**
   * Destroys this shard and closes its WebSocket connection.
   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard
   * @private
   */
  destroy({ closeCode = 1000, reset = false, emit = true, log = true } = {}) {
    if (log) {
      this.debug(`[DESTROY]
    Close Code    : ${closeCode}
    Reset         : ${reset}
    Emit DESTROYED: ${emit}`);
    }

    // Step 0: Remove all timers
    this.setHeartbeatTimer(-1);
    this.setHelloTimeout(-1);

    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED
    if (this.connection) {
      // If the connection is currently opened, we will (hopefully) receive close
      if (this.connection.readyState === WebSocket.OPEN) {
        this.connection.close(closeCode);
      } else {
        // Connection is not OPEN
        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
        // Remove listeners from the connection
        this._cleanupConnection();
        // Attempt to close the connection just in case
        try {
          this.connection.close(closeCode);
        } catch {
          // No-op
        }
        // Emit the destroyed event if needed
        if (emit) this._emitDestroyed();
      }
    } else if (emit) {
      // We requested a destroy, but we had no connection. Emit destroyed
      this._emitDestroyed();
    }

    // Step 2: Null the connection object
    this.connection = null;

    // Step 3: Set the shard status to DISCONNECTED
    this.status = Status.DISCONNECTED;

    // Step 4: Cache the old sequence (use to attempt a resume)
    if (this.sequence !== -1) this.closeSequence = this.sequence;

    // Step 5: Reset the sequence and session ID if requested
    if (reset) {
      this.sequence = -1;
      this.sessionID = null;
    }

    // Step 6: reset the ratelimit data
    this.ratelimit.remaining = this.ratelimit.total;
    this.ratelimit.queue.length = 0;
    if (this.ratelimit.timer) {
      this.manager.client.clearTimeout(this.ratelimit.timer);
      this.ratelimit.timer = null;
    }
  }

  /**
   * Cleans up the WebSocket connection listeners.
   * @private
   */
  _cleanupConnection() {
    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;
  }

  /**
   * Emits the DESTROYED event on the shard
   * @private
   */
  _emitDestroyed() {
    /**
     * Emitted when a shard is destroyed, but no WebSocket connection was present.
     * @private
     * @event WebSocketShard#destroyed
     */
    this.emit(ShardEvents.DESTROYED);
  }
}

module.exports = WebSocketShard;


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.ChannelCreate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.ChannelDelete.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Events } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = (client, { d: data }) => {
  const channel = client.channels.cache.get(data.channel_id);
  const time = new Date(data.last_pin_timestamp);

  if (channel && !Number.isNaN(time.getTime())) {
    // Discord sends null for last_pin_timestamp if the last pinned message was removed
    channel.lastPinTimestamp = time.getTime() || null;

    /**
     * Emitted whenever the pins of a channel are updated. Due to the nature of the WebSocket event,
     * not much information can be provided easily here - you need to manually check the pins yourself.
     * @event Client#channelPinsUpdate
     * @param {DMChannel|TextChannel} channel The channel that the pins update occurred in
     * @param {Date} time The time of the pins update
     */
    client.emit(Events.CHANNEL_PINS_UPDATE, channel, time);
  }
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Events } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = (client, packet) => {
  const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
  if (old && updated) {
    /**
     * Emitted whenever a channel is updated - e.g. name change, topic change, channel type change.
     * @event Client#channelUpdate
     * @param {DMChannel|GuildChannel} oldChannel The channel before the update
     * @param {DMChannel|GuildChannel} newChannel The channel after the update
     */
    client.emit(Events.CHANNEL_UPDATE, old, updated);
  }
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js":
/*!********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Events } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = (client, { d: data }) => {
  const guild = client.guilds.cache.get(data.guild_id);
  const user = client.users.add(data.user);

  /**
   * Emitted whenever a member is banned from a guild.
   * @event Client#guildBanAdd
   * @param {Guild} guild The guild that the ban occurred in
   * @param {User} user The user that was banned
   */
  if (guild && user) client.emit(Events.GUILD_BAN_ADD, guild, user);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildBanRemove.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Events, Status } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = async (client, { d: data }, shard) => {
  let guild = client.guilds.cache.get(data.id);
  if (guild) {
    if (!guild.available && !data.unavailable) {
      // A newly available guild
      guild._patch(data);
      // If the client was ready before and we had unavailable guilds, fetch them
      if (client.ws.status === Status.READY && client.options.fetchAllMembers) {
        await guild.members
          .fetch()
          .catch(err => client.emit(Events.DEBUG, `Failed to fetch all members: ${err}\n${err.stack}`));
      }
    }
  } else {
    // A new guild
    data.shardID = shard.id;
    guild = client.guilds.add(data);
    if (client.ws.status === Status.READY) {
      /**
       * Emitted whenever the client joins a guild.
       * @event Client#guildCreate
       * @param {Guild} guild The created guild
       */
      if (client.options.fetchAllMembers) {
        await guild.members
          .fetch()
          .catch(err => client.emit(Events.DEBUG, `Failed to fetch all members: ${err}\n${err.stack}`));
      }
      client.emit(Events.GUILD_CREATE, guild);
    }
  }
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildDelete.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildEmojisUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildIntegrationsUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Collection = __webpack_require__(/*! ../../../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { Events } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = (client, { d: data }) => {
  const guild = client.guilds.cache.get(data.guild_id);
  if (!guild) return;
  const members = new Collection();

  for (const member of data.members) members.set(member.user.id, guild.members.add(member));
  if (data.presences) {
    for (const presence of data.presences) guild.presences.add(Object.assign(presence, { guild }));
  }
  /**
   * Emitted whenever a chunk of guild members is received (all members come from the same guild).
   * @event Client#guildMembersChunk
   * @param {Collection<Snowflake, GuildMember>} members The members in the chunk
   * @param {Guild} guild The guild related to the member chunk
   * @param {Object} chunk Properties of the received chunk
   * @param {number} chunk.index Index of the received chunk
   * @param {number} chunk.count Number of chunks the client should receive
   * @param {?string} chunk.nonce Nonce for this chunk
   */
  client.emit(Events.GUILD_MEMBERS_CHUNK, members, guild, {
    count: data.chunk_count,
    index: data.chunk_index,
    nonce: data.nonce,
  });
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Events, Status } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = (client, { d: data }, shard) => {
  const guild = client.guilds.cache.get(data.guild_id);
  if (guild) {
    guild.memberCount++;
    const member = guild.members.add(data);
    if (shard.status === Status.READY) {
      /**
       * Emitted whenever a user joins a guild.
       * @event Client#guildMemberAdd
       * @param {GuildMember} member The member that has joined a guild
       */
      client.emit(Events.GUILD_MEMBER_ADD, member);
    }
  }
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet, shard) => {
  client.actions.GuildMemberRemove.handle(packet.d, shard);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet, shard) => {
  client.actions.GuildMemberUpdate.handle(packet.d, shard);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js":
/*!************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildRoleCreate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js":
/*!************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildRoleDelete.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js":
/*!************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildRoleUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.GuildUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js":
/*!********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.InviteCreate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js":
/*!********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.InviteDelete.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.MessageCreate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.MessageDelete.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.MessageDeleteBulk.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.MessageReactionAdd.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js ***!
  \******************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.MessageReactionRemove.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js ***!
  \**********************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.MessageReactionRemoveAll.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.MessageReactionRemoveEmoji.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Events } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = (client, packet) => {
  const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
  if (old && updated) {
    /**
     * Emitted whenever a message is updated - e.g. embed or content change.
     * @event Client#messageUpdate
     * @param {Message} oldMessage The message before the update
     * @param {Message} newMessage The message after the update
     */
    client.emit(Events.MESSAGE_UPDATE, old, updated);
  }
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.PresenceUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/READY.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/READY.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let ClientUser;

module.exports = (client, { d: data }, shard) => {
  if (client.user) {
    client.user._patch(data.user);
  } else {
    if (!ClientUser) ClientUser = __webpack_require__(/*! ../../../structures/ClientUser */ "./node_modules/discord.js/src/structures/ClientUser.js");
    const clientUser = new ClientUser(client, data.user);
    client.user = clientUser;
    client.users.cache.set(clientUser.id, clientUser);
  }

  for (const guild of data.guilds) {
    guild.shardID = shard.id;
    client.guilds.add(guild);
  }

  shard.checkReady();
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/RESUMED.js":
/*!**************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/RESUMED.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Events } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

module.exports = (client, packet, shard) => {
  const replayed = shard.sequence - shard.closeSequence;
  /**
   * Emitted when a shard resumes successfully.
   * @event Client#shardResume
   * @param {number} id The shard ID that resumed
   * @param {number} replayedEvents The amount of replayed events
   */
  client.emit(Events.SHARD_RESUME, shard.id, replayed);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.TypingStart.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js":
/*!******************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.UserUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.emit('debug', `[VOICE] received voice server: ${JSON.stringify(packet)}`);
  client.voice.onVoiceServer(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.VoiceStateUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (client, packet) => {
  client.actions.WebhooksUpdate.handle(packet.d);
};


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { WSEvents } = __webpack_require__(/*! ../../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

const handlers = {};

for (const name of Object.keys(WSEvents)) {
  try {
    handlers[name] = __webpack_require__("./node_modules/discord.js/src/client/websocket/handlers sync recursive ^\\.\\/.*\\.js$")(`./${name}.js`);
  } catch {} // eslint-disable-line no-empty
}

module.exports = handlers;


/***/ }),

/***/ "./node_modules/discord.js/src/client/websocket/handlers sync recursive ^\\.\\/.*\\.js$":
/*!**********************************************************************************!*\
  !*** ./node_modules/discord.js/src/client/websocket/handlers/ sync ^\.\/.*\.js$ ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./CHANNEL_CREATE.js": "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js",
	"./CHANNEL_DELETE.js": "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js",
	"./CHANNEL_PINS_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js",
	"./CHANNEL_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js",
	"./GUILD_BAN_ADD.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js",
	"./GUILD_BAN_REMOVE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js",
	"./GUILD_CREATE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js",
	"./GUILD_DELETE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js",
	"./GUILD_EMOJIS_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js",
	"./GUILD_INTEGRATIONS_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js",
	"./GUILD_MEMBERS_CHUNK.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js",
	"./GUILD_MEMBER_ADD.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js",
	"./GUILD_MEMBER_REMOVE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js",
	"./GUILD_MEMBER_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js",
	"./GUILD_ROLE_CREATE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js",
	"./GUILD_ROLE_DELETE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js",
	"./GUILD_ROLE_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js",
	"./GUILD_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js",
	"./INVITE_CREATE.js": "./node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js",
	"./INVITE_DELETE.js": "./node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js",
	"./MESSAGE_CREATE.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js",
	"./MESSAGE_DELETE.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js",
	"./MESSAGE_DELETE_BULK.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js",
	"./MESSAGE_REACTION_ADD.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js",
	"./MESSAGE_REACTION_REMOVE.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js",
	"./MESSAGE_REACTION_REMOVE_ALL.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js",
	"./MESSAGE_REACTION_REMOVE_EMOJI.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js",
	"./MESSAGE_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js",
	"./PRESENCE_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js",
	"./READY.js": "./node_modules/discord.js/src/client/websocket/handlers/READY.js",
	"./RESUMED.js": "./node_modules/discord.js/src/client/websocket/handlers/RESUMED.js",
	"./TYPING_START.js": "./node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js",
	"./USER_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js",
	"./VOICE_SERVER_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js",
	"./VOICE_STATE_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js",
	"./WEBHOOKS_UPDATE.js": "./node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js",
	"./index.js": "./node_modules/discord.js/src/client/websocket/handlers/index.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/discord.js/src/client/websocket/handlers sync recursive ^\\.\\/.*\\.js$";

/***/ }),

/***/ "./node_modules/discord.js/src/errors/DJSError.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/errors/DJSError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


// Heavily inspired by node's `internal/errors` module

const kCode = Symbol('code');
const messages = new Map();

/**
 * Extend an error of some sort into a DiscordjsError.
 * @param {Error} Base Base error to extend
 * @returns {DiscordjsError}
 */
function makeDiscordjsError(Base) {
  return class DiscordjsError extends Base {
    constructor(key, ...args) {
      super(message(key, args));
      this[kCode] = key;
      if (Error.captureStackTrace) Error.captureStackTrace(this, DiscordjsError);
    }

    get name() {
      return `${super.name} [${this[kCode]}]`;
    }

    get code() {
      return this[kCode];
    }
  };
}

/**
 * Format the message for an error.
 * @param {string} key Error key
 * @param {Array<*>} args Arguments to pass for util format or as function args
 * @returns {string} Formatted string
 */
function message(key, args) {
  if (typeof key !== 'string') throw new Error('Error message key must be a string');
  const msg = messages.get(key);
  if (!msg) throw new Error(`An invalid error message key was used: ${key}.`);
  if (typeof msg === 'function') return msg(...args);
  if (args === undefined || args.length === 0) return msg;
  args.unshift(msg);
  return String(...args);
}

/**
 * Register an error code and message.
 * @param {string} sym Unique name for the error
 * @param {*} val Value of the error
 */
function register(sym, val) {
  messages.set(sym, typeof val === 'function' ? val : String(val));
}

module.exports = {
  register,
  Error: makeDiscordjsError(Error),
  TypeError: makeDiscordjsError(TypeError),
  RangeError: makeDiscordjsError(RangeError),
};


/***/ }),

/***/ "./node_modules/discord.js/src/errors/Messages.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/errors/Messages.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { register } = __webpack_require__(/*! ./DJSError */ "./node_modules/discord.js/src/errors/DJSError.js");

const Messages = {
  CLIENT_INVALID_OPTION: (prop, must) => `The ${prop} option must be ${must}`,
  CLIENT_INVALID_PROVIDED_SHARDS: 'None of the provided shards were valid.',

  TOKEN_INVALID: 'An invalid token was provided.',
  TOKEN_MISSING: 'Request to use token, but token was unavailable to the client.',

  WS_CLOSE_REQUESTED: 'WebSocket closed due to user request.',
  WS_CONNECTION_EXISTS: 'There is already an existing WebSocket connection.',
  WS_NOT_OPEN: (data = 'data') => `Websocket not open to send ${data}`,

  BITFIELD_INVALID: 'Invalid bitfield flag or number.',

  SHARDING_INVALID: 'Invalid shard settings were provided.',
  SHARDING_REQUIRED: 'This session would have handled too many guilds - Sharding is required.',
  INVALID_INTENTS: 'Invalid intent provided for WebSocket intents.',
  DISALLOWED_INTENTS: 'Privileged intent provided is not enabled or whitelisted.',
  SHARDING_NO_SHARDS: 'No shards have been spawned.',
  SHARDING_IN_PROCESS: 'Shards are still being spawned.',
  SHARDING_SHARD_NOT_FOUND: id => `Shard ${id} could not be found.`,
  SHARDING_ALREADY_SPAWNED: count => `Already spawned ${count} shards.`,
  SHARDING_PROCESS_EXISTS: id => `Shard ${id} already has an active process.`,
  SHARDING_WORKER_EXISTS: id => `Shard ${id} already has an active worker.`,
  SHARDING_READY_TIMEOUT: id => `Shard ${id}'s Client took too long to become ready.`,
  SHARDING_READY_DISCONNECTED: id => `Shard ${id}'s Client disconnected before becoming ready.`,
  SHARDING_READY_DIED: id => `Shard ${id}'s process exited before its Client became ready.`,
  SHARDING_NO_CHILD_EXISTS: id => `Shard ${id} has no active process or worker.`,
  SHARDING_SHARD_MISCALCULATION: (shard, guild, count) =>
    `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,

  COLOR_RANGE: 'Color must be within the range 0 - 16777215 (0xFFFFFF).',
  COLOR_CONVERT: 'Unable to convert color to a number.',

  EMBED_FIELD_NAME: 'MessageEmbed field names may not be empty.',
  EMBED_FIELD_VALUE: 'MessageEmbed field values may not be empty.',

  FILE_NOT_FOUND: file => `File could not be found: ${file}`,

  USER_NO_DMCHANNEL: 'No DM Channel exists!',

  VOICE_INVALID_HEARTBEAT: 'Tried to set voice heartbeat but no valid interval was specified.',
  VOICE_USER_MISSING: "Couldn't resolve the user to create stream.",
  VOICE_JOIN_CHANNEL: (full = false) =>
    `You do not have permission to join this voice channel${full ? '; it is full.' : '.'}`,
  VOICE_CONNECTION_TIMEOUT: 'Connection not established within 15 seconds.',
  VOICE_TOKEN_ABSENT: 'Token not provided from voice server packet.',
  VOICE_SESSION_ABSENT: 'Session ID not supplied.',
  VOICE_INVALID_ENDPOINT: 'Invalid endpoint received.',
  VOICE_NO_BROWSER: 'Voice connections are not available in browsers.',
  VOICE_CONNECTION_ATTEMPTS_EXCEEDED: attempts => `Too many connection attempts (${attempts}).`,
  VOICE_JOIN_SOCKET_CLOSED: 'Tried to send join packet, but the WebSocket is not open.',
  VOICE_PLAY_INTERFACE_NO_BROADCAST: 'A broadcast cannot be played in this context.',
  VOICE_PLAY_INTERFACE_BAD_TYPE: 'Unknown stream type',
  VOICE_PRISM_DEMUXERS_NEED_STREAM: 'To play a webm/ogg stream, you need to pass a ReadableStream.',

  VOICE_STATE_UNCACHED_MEMBER: 'The member of this voice state is uncached.',
  VOICE_STATE_NOT_OWN: 'You cannot self-deafen/mute on VoiceStates that do not belong to the ClientUser.',
  VOICE_STATE_INVALID_TYPE: name => `${name} must be a boolean.`,

  UDP_SEND_FAIL: 'Tried to send a UDP packet, but there is no socket available.',
  UDP_ADDRESS_MALFORMED: 'Malformed UDP address or port.',
  UDP_CONNECTION_EXISTS: 'There is already an existing UDP connection.',

  REQ_RESOURCE_TYPE: 'The resource must be a string, Buffer or a valid file stream.',

  IMAGE_FORMAT: format => `Invalid image format: ${format}`,
  IMAGE_SIZE: size => `Invalid image size: ${size}`,

  MESSAGE_BULK_DELETE_TYPE: 'The messages must be an Array, Collection, or number.',
  MESSAGE_NONCE_TYPE: 'Message nonce must fit in an unsigned 64-bit integer.',

  TYPING_COUNT: 'Count must be at least 1',

  SPLIT_MAX_LEN: 'Chunk exceeds the max length and contains no split characters.',

  BAN_RESOLVE_ID: (ban = false) => `Couldn't resolve the user ID to ${ban ? 'ban' : 'unban'}.`,
  FETCH_BAN_RESOLVE_ID: "Couldn't resolve the user ID to fetch the ban.",

  PRUNE_DAYS_TYPE: 'Days must be a number',

  GUILD_CHANNEL_RESOLVE: 'Could not resolve channel to a guild channel.',
  GUILD_VOICE_CHANNEL_RESOLVE: 'Could not resolve channel to a guild voice channel.',
  GUILD_CHANNEL_ORPHAN: 'Could not find a parent to this guild channel.',
  GUILD_OWNED: 'Guild is owned by the client.',
  GUILD_MEMBERS_TIMEOUT: "Members didn't arrive in time.",
  GUILD_UNCACHED_ME: 'The client user as a member of this guild is uncached.',

  INVALID_TYPE: (name, expected, an = false) => `Supplied ${name} is not a${an ? 'n' : ''} ${expected}.`,

  WEBHOOK_MESSAGE: 'The message was not sent by a webhook.',

  EMOJI_TYPE: 'Emoji must be a string or GuildEmoji/ReactionEmoji',
  EMOJI_MANAGED: 'Emoji is managed and has no Author.',
  MISSING_MANAGE_EMOJIS_PERMISSION: guild =>
    `Client must have Manage Emoji permission in guild ${guild} to see emoji authors.`,

  REACTION_RESOLVE_USER: "Couldn't resolve the user ID to remove from the reaction.",

  VANITY_URL: 'This guild does not have the VANITY_URL feature enabled.',

  DELETE_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot delete them",
  FETCH_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot fetch them",

  MEMBER_FETCH_NONCE_LENGTH: 'Nonce length must not exceed 32 characters.',
};

for (const [name, message] of Object.entries(Messages)) register(name, message);


/***/ }),

/***/ "./node_modules/discord.js/src/errors/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/discord.js/src/errors/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./DJSError */ "./node_modules/discord.js/src/errors/DJSError.js");
module.exports.Messages = __webpack_require__(/*! ./Messages */ "./node_modules/discord.js/src/errors/Messages.js");


/***/ }),

/***/ "./node_modules/discord.js/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/discord.js/src/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Util = __webpack_require__(/*! ./util/Util */ "./node_modules/discord.js/src/util/Util.js");

module.exports = {
  // "Root" classes (starting points)
  BaseClient: __webpack_require__(/*! ./client/BaseClient */ "./node_modules/discord.js/src/client/BaseClient.js"),
  Client: __webpack_require__(/*! ./client/Client */ "./node_modules/discord.js/src/client/Client.js"),
  Shard: __webpack_require__(/*! ./sharding/Shard */ "?9d4d"),
  ShardClientUtil: __webpack_require__(/*! ./sharding/ShardClientUtil */ "?7ce5"),
  ShardingManager: __webpack_require__(/*! ./sharding/ShardingManager */ "?271f"),
  WebhookClient: __webpack_require__(/*! ./client/WebhookClient */ "./node_modules/discord.js/src/client/WebhookClient.js"),

  // Utilities
  ActivityFlags: __webpack_require__(/*! ./util/ActivityFlags */ "./node_modules/discord.js/src/util/ActivityFlags.js"),
  BitField: __webpack_require__(/*! ./util/BitField */ "./node_modules/discord.js/src/util/BitField.js"),
  Collection: __webpack_require__(/*! ./util/Collection */ "./node_modules/discord.js/src/util/Collection.js"),
  Constants: __webpack_require__(/*! ./util/Constants */ "./node_modules/discord.js/src/util/Constants.js"),
  DataResolver: __webpack_require__(/*! ./util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js"),
  BaseManager: __webpack_require__(/*! ./managers/BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js"),
  DiscordAPIError: __webpack_require__(/*! ./rest/DiscordAPIError */ "./node_modules/discord.js/src/rest/DiscordAPIError.js"),
  HTTPError: __webpack_require__(/*! ./rest/HTTPError */ "./node_modules/discord.js/src/rest/HTTPError.js"),
  MessageFlags: __webpack_require__(/*! ./util/MessageFlags */ "./node_modules/discord.js/src/util/MessageFlags.js"),
  Intents: __webpack_require__(/*! ./util/Intents */ "./node_modules/discord.js/src/util/Intents.js"),
  Permissions: __webpack_require__(/*! ./util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js"),
  Speaking: __webpack_require__(/*! ./util/Speaking */ "./node_modules/discord.js/src/util/Speaking.js"),
  Snowflake: __webpack_require__(/*! ./util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js"),
  SnowflakeUtil: __webpack_require__(/*! ./util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js"),
  Structures: __webpack_require__(/*! ./util/Structures */ "./node_modules/discord.js/src/util/Structures.js"),
  SystemChannelFlags: __webpack_require__(/*! ./util/SystemChannelFlags */ "./node_modules/discord.js/src/util/SystemChannelFlags.js"),
  UserFlags: __webpack_require__(/*! ./util/UserFlags */ "./node_modules/discord.js/src/util/UserFlags.js"),
  Util: Util,
  version: __webpack_require__(/*! ../package.json */ "./node_modules/discord.js/package.json").version,

  // Managers
  ChannelManager: __webpack_require__(/*! ./managers/ChannelManager */ "./node_modules/discord.js/src/managers/ChannelManager.js"),
  GuildChannelManager: __webpack_require__(/*! ./managers/GuildChannelManager */ "./node_modules/discord.js/src/managers/GuildChannelManager.js"),
  GuildEmojiManager: __webpack_require__(/*! ./managers/GuildEmojiManager */ "./node_modules/discord.js/src/managers/GuildEmojiManager.js"),
  GuildEmojiRoleManager: __webpack_require__(/*! ./managers/GuildEmojiRoleManager */ "./node_modules/discord.js/src/managers/GuildEmojiRoleManager.js"),
  GuildMemberManager: __webpack_require__(/*! ./managers/GuildMemberManager */ "./node_modules/discord.js/src/managers/GuildMemberManager.js"),
  GuildMemberRoleManager: __webpack_require__(/*! ./managers/GuildMemberRoleManager */ "./node_modules/discord.js/src/managers/GuildMemberRoleManager.js"),
  GuildManager: __webpack_require__(/*! ./managers/GuildManager */ "./node_modules/discord.js/src/managers/GuildManager.js"),
  ReactionManager: __webpack_require__(/*! ./managers/ReactionManager */ "./node_modules/discord.js/src/managers/ReactionManager.js"),
  ReactionUserManager: __webpack_require__(/*! ./managers/ReactionUserManager */ "./node_modules/discord.js/src/managers/ReactionUserManager.js"),
  MessageManager: __webpack_require__(/*! ./managers/MessageManager */ "./node_modules/discord.js/src/managers/MessageManager.js"),
  PresenceManager: __webpack_require__(/*! ./managers/PresenceManager */ "./node_modules/discord.js/src/managers/PresenceManager.js"),
  RoleManager: __webpack_require__(/*! ./managers/RoleManager */ "./node_modules/discord.js/src/managers/RoleManager.js"),
  UserManager: __webpack_require__(/*! ./managers/UserManager */ "./node_modules/discord.js/src/managers/UserManager.js"),

  // Shortcuts to Util methods
  discordSort: Util.discordSort,
  escapeMarkdown: Util.escapeMarkdown,
  fetchRecommendedShards: Util.fetchRecommendedShards,
  resolveColor: Util.resolveColor,
  resolveString: Util.resolveString,
  splitMessage: Util.splitMessage,

  // Structures
  Application: __webpack_require__(/*! ./structures/interfaces/Application */ "./node_modules/discord.js/src/structures/interfaces/Application.js"),
  Base: __webpack_require__(/*! ./structures/Base */ "./node_modules/discord.js/src/structures/Base.js"),
  Activity: __webpack_require__(/*! ./structures/Presence */ "./node_modules/discord.js/src/structures/Presence.js").Activity,
  APIMessage: __webpack_require__(/*! ./structures/APIMessage */ "./node_modules/discord.js/src/structures/APIMessage.js"),
  BaseGuildEmoji: __webpack_require__(/*! ./structures/BaseGuildEmoji */ "./node_modules/discord.js/src/structures/BaseGuildEmoji.js"),
  CategoryChannel: __webpack_require__(/*! ./structures/CategoryChannel */ "./node_modules/discord.js/src/structures/CategoryChannel.js"),
  Channel: __webpack_require__(/*! ./structures/Channel */ "./node_modules/discord.js/src/structures/Channel.js"),
  ClientApplication: __webpack_require__(/*! ./structures/ClientApplication */ "./node_modules/discord.js/src/structures/ClientApplication.js"),
  get ClientUser() {
    // This is a getter so that it properly extends any custom User class
    return __webpack_require__(/*! ./structures/ClientUser */ "./node_modules/discord.js/src/structures/ClientUser.js");
  },
  Collector: __webpack_require__(/*! ./structures/interfaces/Collector */ "./node_modules/discord.js/src/structures/interfaces/Collector.js"),
  DMChannel: __webpack_require__(/*! ./structures/DMChannel */ "./node_modules/discord.js/src/structures/DMChannel.js"),
  Emoji: __webpack_require__(/*! ./structures/Emoji */ "./node_modules/discord.js/src/structures/Emoji.js"),
  Guild: __webpack_require__(/*! ./structures/Guild */ "./node_modules/discord.js/src/structures/Guild.js"),
  GuildAuditLogs: __webpack_require__(/*! ./structures/GuildAuditLogs */ "./node_modules/discord.js/src/structures/GuildAuditLogs.js"),
  GuildChannel: __webpack_require__(/*! ./structures/GuildChannel */ "./node_modules/discord.js/src/structures/GuildChannel.js"),
  GuildEmoji: __webpack_require__(/*! ./structures/GuildEmoji */ "./node_modules/discord.js/src/structures/GuildEmoji.js"),
  GuildMember: __webpack_require__(/*! ./structures/GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js"),
  GuildPreview: __webpack_require__(/*! ./structures/GuildPreview */ "./node_modules/discord.js/src/structures/GuildPreview.js"),
  GuildTemplate: __webpack_require__(/*! ./structures/GuildTemplate */ "./node_modules/discord.js/src/structures/GuildTemplate.js"),
  Integration: __webpack_require__(/*! ./structures/Integration */ "./node_modules/discord.js/src/structures/Integration.js"),
  Invite: __webpack_require__(/*! ./structures/Invite */ "./node_modules/discord.js/src/structures/Invite.js"),
  Message: __webpack_require__(/*! ./structures/Message */ "./node_modules/discord.js/src/structures/Message.js"),
  MessageAttachment: __webpack_require__(/*! ./structures/MessageAttachment */ "./node_modules/discord.js/src/structures/MessageAttachment.js"),
  MessageCollector: __webpack_require__(/*! ./structures/MessageCollector */ "./node_modules/discord.js/src/structures/MessageCollector.js"),
  MessageEmbed: __webpack_require__(/*! ./structures/MessageEmbed */ "./node_modules/discord.js/src/structures/MessageEmbed.js"),
  MessageMentions: __webpack_require__(/*! ./structures/MessageMentions */ "./node_modules/discord.js/src/structures/MessageMentions.js"),
  MessageReaction: __webpack_require__(/*! ./structures/MessageReaction */ "./node_modules/discord.js/src/structures/MessageReaction.js"),
  NewsChannel: __webpack_require__(/*! ./structures/NewsChannel */ "./node_modules/discord.js/src/structures/NewsChannel.js"),
  PermissionOverwrites: __webpack_require__(/*! ./structures/PermissionOverwrites */ "./node_modules/discord.js/src/structures/PermissionOverwrites.js"),
  Presence: __webpack_require__(/*! ./structures/Presence */ "./node_modules/discord.js/src/structures/Presence.js").Presence,
  ClientPresence: __webpack_require__(/*! ./structures/ClientPresence */ "./node_modules/discord.js/src/structures/ClientPresence.js"),
  ReactionCollector: __webpack_require__(/*! ./structures/ReactionCollector */ "./node_modules/discord.js/src/structures/ReactionCollector.js"),
  ReactionEmoji: __webpack_require__(/*! ./structures/ReactionEmoji */ "./node_modules/discord.js/src/structures/ReactionEmoji.js"),
  RichPresenceAssets: __webpack_require__(/*! ./structures/Presence */ "./node_modules/discord.js/src/structures/Presence.js").RichPresenceAssets,
  Role: __webpack_require__(/*! ./structures/Role */ "./node_modules/discord.js/src/structures/Role.js"),
  StoreChannel: __webpack_require__(/*! ./structures/StoreChannel */ "./node_modules/discord.js/src/structures/StoreChannel.js"),
  Team: __webpack_require__(/*! ./structures/Team */ "./node_modules/discord.js/src/structures/Team.js"),
  TeamMember: __webpack_require__(/*! ./structures/TeamMember */ "./node_modules/discord.js/src/structures/TeamMember.js"),
  TextChannel: __webpack_require__(/*! ./structures/TextChannel */ "./node_modules/discord.js/src/structures/TextChannel.js"),
  User: __webpack_require__(/*! ./structures/User */ "./node_modules/discord.js/src/structures/User.js"),
  VoiceChannel: __webpack_require__(/*! ./structures/VoiceChannel */ "./node_modules/discord.js/src/structures/VoiceChannel.js"),
  VoiceRegion: __webpack_require__(/*! ./structures/VoiceRegion */ "./node_modules/discord.js/src/structures/VoiceRegion.js"),
  VoiceState: __webpack_require__(/*! ./structures/VoiceState */ "./node_modules/discord.js/src/structures/VoiceState.js"),
  Webhook: __webpack_require__(/*! ./structures/Webhook */ "./node_modules/discord.js/src/structures/Webhook.js"),

  WebSocket: __webpack_require__(/*! ./WebSocket */ "./node_modules/discord.js/src/WebSocket.js"),
};


/***/ }),

/***/ "./node_modules/discord.js/src/managers/BaseManager.js":
/*!*************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/BaseManager.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
let Structures;

/**
 * Manages the API methods of a data model and holds its cache.
 * @abstract
 */
class BaseManager {
  constructor(client, iterable, holds, cacheType = Collection, ...cacheOptions) {
    if (!Structures) Structures = __webpack_require__(/*! ../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");
    /**
     * The data structure belonging to this manager
     * @name BaseManager#holds
     * @type {Function}
     * @private
     * @readonly
     */
    Object.defineProperty(this, 'holds', { value: Structures.get(holds.name) || holds });

    /**
     * The client that instantiated this Manager
     * @name BaseManager#client
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: client });

    /**
     * The type of Collection of the Manager
     * @type {Collection}
     */
    this.cacheType = cacheType;

    /**
     * Holds the cache for the data model
     * @type {Collection}
     */
    this.cache = new cacheType(...cacheOptions);
    if (iterable) for (const i of iterable) this.add(i);
  }

  add(data, cache = true, { id, extras = [] } = {}) {
    const existing = this.cache.get(id || data.id);
    if (existing && existing._patch && cache) existing._patch(data);
    if (existing) return existing;

    const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
    if (cache) this.cache.set(id || entry.id, entry);
    return entry;
  }

  /**
   * Resolves a data entry to a data Object.
   * @param {string|Object} idOrInstance The id or instance of something in this Manager
   * @returns {?Object} An instance from this Manager
   */
  resolve(idOrInstance) {
    if (idOrInstance instanceof this.holds) return idOrInstance;
    if (typeof idOrInstance === 'string') return this.cache.get(idOrInstance) || null;
    return null;
  }

  /**
   * Resolves a data entry to a instance ID.
   * @param {string|Object} idOrInstance The id or instance of something in this Manager
   * @returns {?Snowflake}
   */
  resolveID(idOrInstance) {
    if (idOrInstance instanceof this.holds) return idOrInstance.id;
    if (typeof idOrInstance === 'string') return idOrInstance;
    return null;
  }

  valueOf() {
    return this.cache;
  }
}

module.exports = BaseManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/ChannelManager.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/ChannelManager.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const Channel = __webpack_require__(/*! ../structures/Channel */ "./node_modules/discord.js/src/structures/Channel.js");
const { Events } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/**
 * A manager of channels belonging to a client
 * @extends {BaseManager}
 */
class ChannelManager extends BaseManager {
  constructor(client, iterable) {
    super(client, iterable, Channel);
  }

  /**
   * The cache of Channels
   * @type {Collection<Snowflake, Channel>}
   * @name ChannelManager#cache
   */

  add(data, guild, cache = true) {
    const existing = this.cache.get(data.id);
    if (existing) {
      if (existing._patch && cache) existing._patch(data);
      if (guild) guild.channels.add(existing);
      return existing;
    }

    const channel = Channel.create(this.client, data, guild);

    if (!channel) {
      this.client.emit(Events.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
      return null;
    }

    if (cache) this.cache.set(channel.id, channel);

    return channel;
  }

  remove(id) {
    const channel = this.cache.get(id);
    if (channel.guild) channel.guild.channels.cache.delete(id);
    this.cache.delete(id);
  }

  /**
   * Data that can be resolved to give a Channel object. This can be:
   * * A Channel object
   * * A Snowflake
   * @typedef {Channel|Snowflake} ChannelResolvable
   */

  /**
   * Resolves a ChannelResolvable to a Channel object.
   * @method resolve
   * @memberof ChannelManager
   * @instance
   * @param {ChannelResolvable} channel The channel resolvable to resolve
   * @returns {?Channel}
   */

  /**
   * Resolves a ChannelResolvable to a channel ID string.
   * @method resolveID
   * @memberof ChannelManager
   * @instance
   * @param {ChannelResolvable} channel The channel resolvable to resolve
   * @returns {?Snowflake}
   */

  /**
   * Obtains a channel from Discord, or the channel cache if it's already available.
   * @param {Snowflake} id ID of the channel
   * @param {boolean} [cache=true] Whether to cache the new channel object if it isn't already
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<Channel>}
   * @example
   * // Fetch a channel by its id
   * client.channels.fetch('222109930545610754')
   *   .then(channel => console.log(channel.name))
   *   .catch(console.error);
   */
  async fetch(id, cache = true, force = false) {
    if (!force) {
      const existing = this.cache.get(id);
      if (existing && !existing.partial) return existing;
    }

    const data = await this.client.api.channels(id).get();
    return this.add(data, null, cache);
  }
}

module.exports = ChannelManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/GuildChannelManager.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/GuildChannelManager.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const GuildChannel = __webpack_require__(/*! ../structures/GuildChannel */ "./node_modules/discord.js/src/structures/GuildChannel.js");
const PermissionOverwrites = __webpack_require__(/*! ../structures/PermissionOverwrites */ "./node_modules/discord.js/src/structures/PermissionOverwrites.js");
const { ChannelTypes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/**
 * Manages API methods for GuildChannels and stores their cache.
 * @extends {BaseManager}
 */
class GuildChannelManager extends BaseManager {
  constructor(guild, iterable) {
    super(guild.client, iterable, GuildChannel);

    /**
     * The guild this Manager belongs to
     * @type {Guild}
     */
    this.guild = guild;
  }

  /**
   * The cache of this Manager
   * @type {Collection<Snowflake, GuildChannel>}
   * @name GuildChannelManager#cache
   */

  add(channel) {
    const existing = this.cache.get(channel.id);
    if (existing) return existing;
    this.cache.set(channel.id, channel);
    return channel;
  }

  /**
   * Data that can be resolved to give a Guild Channel object. This can be:
   * * A GuildChannel object
   * * A Snowflake
   * @typedef {GuildChannel|Snowflake} GuildChannelResolvable
   */

  /**
   * Resolves a GuildChannelResolvable to a Channel object.
   * @method resolve
   * @memberof GuildChannelManager
   * @instance
   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
   * @returns {?GuildChannel}
   */

  /**
   * Resolves a GuildChannelResolvable to a channel ID string.
   * @method resolveID
   * @memberof GuildChannelManager
   * @instance
   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
   * @returns {?Snowflake}
   */

  /**
   * Creates a new channel in the guild.
   * @param {string} name The name of the new channel
   * @param {Object} [options] Options
   * @param {string} [options.type='text'] The type of the new channel, either `text`, `voice`, or `category`
   * @param {string} [options.topic] The topic for the new channel
   * @param {boolean} [options.nsfw] Whether the new channel is nsfw
   * @param {number} [options.bitrate] Bitrate of the new channel in bits (only voice)
   * @param {number} [options.userLimit] Maximum amount of users allowed in the new channel (only voice)
   * @param {ChannelResolvable} [options.parent] Parent of the new channel
   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites]
   * Permission overwrites of the new channel
   * @param {number} [options.position] Position of the new channel
   * @param {number} [options.rateLimitPerUser] The ratelimit per user for the channel
   * @param {string} [options.reason] Reason for creating the channel
   * @returns {Promise<GuildChannel>}
   * @example
   * // Create a new text channel
   * guild.channels.create('new-general', { reason: 'Needed a cool new channel' })
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Create a new channel with permission overwrites
   * guild.channels.create('new-voice', {
   *   type: 'voice',
   *   permissionOverwrites: [
   *      {
   *        id: message.author.id,
   *        deny: ['VIEW_CHANNEL'],
   *     },
   *   ],
   * })
   */
  async create(name, options = {}) {
    let {
      type,
      topic,
      nsfw,
      bitrate,
      userLimit,
      parent,
      permissionOverwrites,
      position,
      rateLimitPerUser,
      reason,
    } = options;
    if (parent) parent = this.client.channels.resolveID(parent);
    if (permissionOverwrites) {
      permissionOverwrites = permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));
    }

    const data = await this.client.api.guilds(this.guild.id).channels.post({
      data: {
        name,
        topic,
        type: type ? ChannelTypes[type.toUpperCase()] : ChannelTypes.TEXT,
        nsfw,
        bitrate,
        user_limit: userLimit,
        parent_id: parent,
        position,
        permission_overwrites: permissionOverwrites,
        rate_limit_per_user: rateLimitPerUser,
      },
      reason,
    });
    return this.client.actions.ChannelCreate.handle(data).channel;
  }
}

module.exports = GuildChannelManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/GuildEmojiManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/GuildEmojiManager.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const { TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const GuildEmoji = __webpack_require__(/*! ../structures/GuildEmoji */ "./node_modules/discord.js/src/structures/GuildEmoji.js");
const ReactionEmoji = __webpack_require__(/*! ../structures/ReactionEmoji */ "./node_modules/discord.js/src/structures/ReactionEmoji.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");
const { parseEmoji } = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Manages API methods for GuildEmojis and stores their cache.
 * @extends {BaseManager}
 */
class GuildEmojiManager extends BaseManager {
  constructor(guild, iterable) {
    super(guild.client, iterable, GuildEmoji);
    /**
     * The guild this manager belongs to
     * @type {Guild}
     */
    this.guild = guild;
  }

  /**
   * The cache of GuildEmojis
   * @type {Collection<Snowflake, GuildEmoji>}
   * @name GuildEmojiManager#cache
   */

  add(data, cache) {
    return super.add(data, cache, { extras: [this.guild] });
  }

  /**
   * Creates a new custom emoji in the guild.
   * @param {BufferResolvable|Base64Resolvable} attachment The image for the emoji
   * @param {string} name The name for the emoji
   * @param {Object} [options] Options
   * @param {Collection<Snowflake, Role>|RoleResolvable[]} [options.roles] Roles to limit the emoji to
   * @param {string} [options.reason] Reason for creating the emoji
   * @returns {Promise<Emoji>} The created emoji
   * @example
   * // Create a new emoji from a url
   * guild.emojis.create('https://i.imgur.com/w3duR07.png', 'rip')
   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
   *   .catch(console.error);
   * @example
   * // Create a new emoji from a file on your computer
   * guild.emojis.create('./memes/banana.png', 'banana')
   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
   *   .catch(console.error);
   */
  async create(attachment, name, { roles, reason } = {}) {
    attachment = await DataResolver.resolveImage(attachment);
    if (!attachment) throw new TypeError('REQ_RESOURCE_TYPE');

    const data = { image: attachment, name };
    if (roles) {
      data.roles = [];
      for (let role of roles instanceof Collection ? roles.values() : roles) {
        role = this.guild.roles.resolve(role);
        if (!role) {
          return Promise.reject(
            new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true),
          );
        }
        data.roles.push(role.id);
      }
    }

    return this.client.api
      .guilds(this.guild.id)
      .emojis.post({ data, reason })
      .then(emoji => this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji);
  }

  /**
   * Data that can be resolved into an GuildEmoji object. This can be:
   * * A custom emoji ID
   * * A GuildEmoji object
   * * A ReactionEmoji object
   * @typedef {Snowflake|GuildEmoji|ReactionEmoji} EmojiResolvable
   */

  /**
   * Resolves an EmojiResolvable to an Emoji object.
   * @param {EmojiResolvable} emoji The Emoji resolvable to identify
   * @returns {?GuildEmoji}
   */
  resolve(emoji) {
    if (emoji instanceof ReactionEmoji) return super.resolve(emoji.id);
    return super.resolve(emoji);
  }

  /**
   * Resolves an EmojiResolvable to an Emoji ID string.
   * @param {EmojiResolvable} emoji The Emoji resolvable to identify
   * @returns {?Snowflake}
   */
  resolveID(emoji) {
    if (emoji instanceof ReactionEmoji) return emoji.id;
    return super.resolveID(emoji);
  }

  /**
   * Data that can be resolved to give an emoji identifier. This can be:
   * * The unicode representation of an emoji
   * * The `<a:name:id>`, `<:name:id>`, `:name:id` or `a:name:id` emoji identifier string of an emoji
   * * An EmojiResolvable
   * @typedef {string|EmojiResolvable} EmojiIdentifierResolvable
   */

  /**
   * Resolves an EmojiResolvable to an emoji identifier.
   * @param {EmojiIdentifierResolvable} emoji The emoji resolvable to resolve
   * @returns {?string}
   */
  resolveIdentifier(emoji) {
    const emojiResolvable = this.resolve(emoji);
    if (emojiResolvable) return emojiResolvable.identifier;
    if (emoji instanceof ReactionEmoji) return emoji.identifier;
    if (typeof emoji === 'string') {
      const res = parseEmoji(emoji);
      if (res && res.name.length) {
        emoji = `${res.animated ? 'a:' : ''}${res.name}${res.id ? `:${res.id}` : ''}`;
      }
      if (!emoji.includes('%')) return encodeURIComponent(emoji);
      else return emoji;
    }
    return null;
  }
}

module.exports = GuildEmojiManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/GuildEmojiRoleManager.js":
/*!***********************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/GuildEmojiRoleManager.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");

/**
 * Manages API methods for roles belonging to emojis and stores their cache.
 */
class GuildEmojiRoleManager {
  constructor(emoji) {
    /**
     * The emoji belonging to this manager
     * @type {GuildEmoji}
     */
    this.emoji = emoji;
    /**
     * The guild belonging to this manager
     * @type {Guild}
     */
    this.guild = emoji.guild;
    /**
     * The client belonging to this manager
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: emoji.client });
  }

  /**
   * The filtered collection of roles of the guild emoji
   * @type {Collection<Snowflake, Role>}
   * @private
   * @readonly
   */
  get _roles() {
    return this.guild.roles.cache.filter(role => this.emoji._roles.includes(role.id));
  }

  /**
   * The cache of roles belonging to this emoji
   * @type {Collection<Snowflake, Role>}
   * @readonly
   */
  get cache() {
    return this._roles;
  }

  /**
   * Adds a role (or multiple roles) to the list of roles that can use this emoji.
   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
   * @returns {Promise<GuildEmoji>}
   */
  add(roleOrRoles) {
    if (roleOrRoles instanceof Collection) return this.add(roleOrRoles.keyArray());
    if (!Array.isArray(roleOrRoles)) return this.add([roleOrRoles]);
    roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));

    if (roleOrRoles.includes(null)) {
      return Promise.reject(new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true));
    }

    const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];
    return this.set(newRoles);
  }

  /**
   * Removes a role (or multiple roles) from the list of roles that can use this emoji.
   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
   * @returns {Promise<GuildEmoji>}
   */
  remove(roleOrRoles) {
    if (roleOrRoles instanceof Collection) return this.remove(roleOrRoles.keyArray());
    if (!Array.isArray(roleOrRoles)) return this.remove([roleOrRoles]);
    roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolveID(r));

    if (roleOrRoles.includes(null)) {
      return Promise.reject(new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true));
    }

    const newRoles = this._roles.keyArray().filter(role => !roleOrRoles.includes(role));
    return this.set(newRoles);
  }

  /**
   * Sets the role(s) that can use this emoji.
   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply
   * @returns {Promise<GuildEmoji>}
   * @example
   * // Set the emoji's roles to a single role
   * guildEmoji.roles.set(['391156570408615936'])
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Remove all roles from an emoji
   * guildEmoji.roles.set([])
   *    .then(console.log)
   *    .catch(console.error);
   */
  set(roles) {
    return this.emoji.edit({ roles });
  }

  clone() {
    const clone = new this.constructor(this.emoji);
    clone._patch(this._roles.keyArray().slice());
    return clone;
  }

  /**
   * Patches the roles for this manager's cache
   * @param {Snowflake[]} roles The new roles
   * @private
   */
  _patch(roles) {
    this.emoji._roles = roles;
  }
}

module.exports = GuildEmojiRoleManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/GuildManager.js":
/*!**************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/GuildManager.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const Guild = __webpack_require__(/*! ../structures/Guild */ "./node_modules/discord.js/src/structures/Guild.js");
const GuildChannel = __webpack_require__(/*! ../structures/GuildChannel */ "./node_modules/discord.js/src/structures/GuildChannel.js");
const GuildEmoji = __webpack_require__(/*! ../structures/GuildEmoji */ "./node_modules/discord.js/src/structures/GuildEmoji.js");
const GuildMember = __webpack_require__(/*! ../structures/GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js");
const Invite = __webpack_require__(/*! ../structures/Invite */ "./node_modules/discord.js/src/structures/Invite.js");
const Role = __webpack_require__(/*! ../structures/Role */ "./node_modules/discord.js/src/structures/Role.js");
const {
  ChannelTypes,
  Events,
  VerificationLevels,
  DefaultMessageNotifications,
  ExplicitContentFilterLevels,
} = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
const { resolveColor } = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Manages API methods for Guilds and stores their cache.
 * @extends {BaseManager}
 */
class GuildManager extends BaseManager {
  constructor(client, iterable) {
    super(client, iterable, Guild);
  }

  /**
   * The cache of this Manager
   * @type {Collection<Snowflake, Guild>}
   * @name GuildManager#cache
   */

  /**
   * Data that resolves to give a Guild object. This can be:
   * * A Guild object
   * * A GuildChannel object
   * * A GuildEmoji object
   * * A Role object
   * * A Snowflake
   * * An Invite object
   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable
   */

  /**
   * Partial data for a Role.
   * @typedef {Object} PartialRoleData
   * @property {number} [id] The ID for this role, used to set channel overrides,
   * this is a placeholder and will be replaced by the API after consumption
   * @property {string} [name] The name of the role
   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
   * @property {boolean} [hoist] Whether or not the role should be hoisted
   * @property {number} [position] The position of the role
   * @property {PermissionResolvable|number} [permissions] The permissions of the role
   * @property {boolean} [mentionable] Whether or not the role should be mentionable
   */

  /**
   * Partial overwrite data.
   * @typedef {Object} PartialOverwriteData
   * @property {number|Snowflake} id The Role or User ID for this overwrite
   * @property {string} [type] The type of this overwrite
   * @property {PermissionResolvable} [allow] The permissions to allow
   * @property {PermissionResolvable} [deny] The permissions to deny
   */

  /**
   * Partial data for a Channel.
   * @typedef {Object} PartialChannelData
   * @property {number} [id] The ID for this channel, used to set its parent,
   * this is a placeholder and will be replaced by the API after consumption
   * @property {number} [parentID] The parent ID for this channel
   * @property {string} [type] The type of the channel
   * @property {string} name The name of the channel
   * @property {string} [topic] The topic of the text channel
   * @property {boolean} [nsfw] Whether the channel is NSFW
   * @property {number} [bitrate] The bitrate of the voice channel
   * @property {number} [userLimit] The user limit of the channel
   * @property {PartialOverwriteData} [permissionOverwrites]
   * Overwrites of the channel
   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds
   */

  /**
   * Resolves a GuildResolvable to a Guild object.
   * @method resolve
   * @memberof GuildManager
   * @instance
   * @param {GuildResolvable} guild The guild resolvable to identify
   * @returns {?Guild}
   */
  resolve(guild) {
    if (
      guild instanceof GuildChannel ||
      guild instanceof GuildMember ||
      guild instanceof GuildEmoji ||
      guild instanceof Role ||
      (guild instanceof Invite && guild.guild)
    ) {
      return super.resolve(guild.guild);
    }
    return super.resolve(guild);
  }

  /**
   * Resolves a GuildResolvable to a Guild ID string.
   * @method resolveID
   * @memberof GuildManager
   * @instance
   * @param {GuildResolvable} guild The guild resolvable to identify
   * @returns {?Snowflake}
   */
  resolveID(guild) {
    if (
      guild instanceof GuildChannel ||
      guild instanceof GuildMember ||
      guild instanceof GuildEmoji ||
      guild instanceof Role ||
      (guild instanceof Invite && guild.guild)
    ) {
      return super.resolveID(guild.guild.id);
    }
    return super.resolveID(guild);
  }

  /**
   * Creates a guild.
   * <warn>This is only available to bots in fewer than 10 guilds.</warn>
   * @param {string} name The name of the guild
   * @param {Object} [options] Options for the creating
   * @param {number} [options.afkChannelID] The ID of the AFK channel
   * @param {number} [options.afkTimeout] The AFK timeout in seconds
   * @param {PartialChannelData[]} [options.channels] The channels for this guild
   * @param {DefaultMessageNotifications} [options.defaultMessageNotifications] The default message notifications
   * for the guild
   * @param {ExplicitContentFilterLevel} [options.explicitContentFilter] The explicit content filter level for the guild
   * @param {BufferResolvable|Base64Resolvable} [options.icon=null] The icon for the guild
   * @param {string} [options.region] The region for the server, defaults to the closest one available
   * @param {PartialRoleData[]} [options.roles] The roles for this guild,
   * the first element of this array is used to change properties of the guild's everyone role.
   * @param {number} [options.systemChannelID] The ID of the system channel
   * @param {VerificationLevel} [options.verificationLevel] The verification level for the guild
   * @returns {Promise<Guild>} The guild that was created
   */
  async create(
    name,
    {
      afkChannelID,
      afkTimeout,
      channels = [],
      defaultMessageNotifications,
      explicitContentFilter,
      icon = null,
      region,
      roles = [],
      systemChannelID,
      verificationLevel,
    } = {},
  ) {
    icon = await DataResolver.resolveImage(icon);
    if (typeof verificationLevel !== 'undefined' && typeof verificationLevel !== 'number') {
      verificationLevel = VerificationLevels.indexOf(verificationLevel);
    }
    if (typeof defaultMessageNotifications !== 'undefined' && typeof defaultMessageNotifications !== 'number') {
      defaultMessageNotifications = DefaultMessageNotifications.indexOf(defaultMessageNotifications);
    }
    if (typeof explicitContentFilter !== 'undefined' && typeof explicitContentFilter !== 'number') {
      explicitContentFilter = ExplicitContentFilterLevels.indexOf(explicitContentFilter);
    }
    for (const channel of channels) {
      if (channel.type) channel.type = ChannelTypes[channel.type.toUpperCase()];
      channel.parent_id = channel.parentID;
      delete channel.parentID;
      if (!channel.permissionOverwrites) continue;
      for (const overwrite of channel.permissionOverwrites) {
        if (overwrite.allow) overwrite.allow = Permissions.resolve(overwrite.allow);
        if (overwrite.deny) overwrite.deny = Permissions.resolve(overwrite.deny);
      }
      channel.permission_overwrites = channel.permissionOverwrites;
      delete channel.permissionOverwrites;
    }
    for (const role of roles) {
      if (role.color) role.color = resolveColor(role.color);
      if (role.permissions) role.permissions = Permissions.resolve(role.permissions);
    }
    return new Promise((resolve, reject) =>
      this.client.api.guilds
        .post({
          data: {
            name,
            region,
            icon,
            verification_level: verificationLevel,
            default_message_notifications: defaultMessageNotifications,
            explicit_content_filter: explicitContentFilter,
            roles,
            channels,
            afk_channel_id: afkChannelID,
            afk_timeout: afkTimeout,
            system_channel_id: systemChannelID,
          },
        })
        .then(data => {
          if (this.client.guilds.cache.has(data.id)) return resolve(this.client.guilds.cache.get(data.id));

          const handleGuild = guild => {
            if (guild.id === data.id) {
              this.client.clearTimeout(timeout);
              this.client.removeListener(Events.GUILD_CREATE, handleGuild);
              this.client.decrementMaxListeners();
              resolve(guild);
            }
          };
          this.client.incrementMaxListeners();
          this.client.on(Events.GUILD_CREATE, handleGuild);

          const timeout = this.client.setTimeout(() => {
            this.client.removeListener(Events.GUILD_CREATE, handleGuild);
            this.client.decrementMaxListeners();
            resolve(this.client.guilds.add(data));
          }, 10000);
          return undefined;
        }, reject),
    );
  }

  /**
   * Obtains a guild from Discord, or the guild cache if it's already available.
   * @param {Snowflake} id ID of the guild
   * @param {boolean} [cache=true] Whether to cache the new guild object if it isn't already
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<Guild>}
   * @example
   * // Fetch a guild by its id
   * client.guilds.fetch('222078108977594368')
   *   .then(guild => console.log(guild.name))
   *   .catch(console.error);
   */
  async fetch(id, cache = true, force = false) {
    if (!force) {
      const existing = this.cache.get(id);
      if (existing) return existing;
    }

    const data = await this.client.api.guilds(id).get({ query: { with_counts: true } });
    return this.add(data, cache);
  }
}

module.exports = GuildManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/GuildMemberManager.js":
/*!********************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/GuildMemberManager.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const { Error, TypeError, RangeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const GuildMember = __webpack_require__(/*! ../structures/GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { Events, OPCodes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const SnowflakeUtil = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");

/**
 * Manages API methods for GuildMembers and stores their cache.
 * @extends {BaseManager}
 */
class GuildMemberManager extends BaseManager {
  constructor(guild, iterable) {
    super(guild.client, iterable, GuildMember);
    /**
     * The guild this manager belongs to
     * @type {Guild}
     */
    this.guild = guild;
  }

  /**
   * The cache of this Manager
   * @type {Collection<Snowflake, GuildMember>}
   * @name GuildMemberManager#cache
   */

  add(data, cache = true) {
    return super.add(data, cache, { id: data.user.id, extras: [this.guild] });
  }

  /**
   * Data that resolves to give a GuildMember object. This can be:
   * * A GuildMember object
   * * A User resolvable
   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable
   */

  /**
   * Resolves a GuildMemberResolvable to a GuildMember object.
   * @param {GuildMemberResolvable} member The user that is part of the guild
   * @returns {?GuildMember}
   */
  resolve(member) {
    const memberResolvable = super.resolve(member);
    if (memberResolvable) return memberResolvable;
    const userResolvable = this.client.users.resolveID(member);
    if (userResolvable) return super.resolve(userResolvable);
    return null;
  }

  /**
   * Resolves a GuildMemberResolvable to a member ID string.
   * @param {GuildMemberResolvable} member The user that is part of the guild
   * @returns {?Snowflake}
   */
  resolveID(member) {
    const memberResolvable = super.resolveID(member);
    if (memberResolvable) return memberResolvable;
    const userResolvable = this.client.users.resolveID(member);
    return this.cache.has(userResolvable) ? userResolvable : null;
  }

  /**
   * Options used to fetch a single member from a guild.
   * @typedef {Object} FetchMemberOptions
   * @property {UserResolvable} user The user to fetch
   * @property {boolean} [cache=true] Whether or not to cache the fetched member
   * @property {boolean} [force=false] Whether to skip the cache check and request the API
   */

  /**
   * Options used to fetch multiple members from a guild.
   * @typedef {Object} FetchMembersOptions
   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch
   * @property {?string} query Limit fetch to members with similar usernames
   * @property {number} [limit=0] Maximum number of members to request
   * @property {boolean} [withPresences=false] Whether or not to include the presences
   * @property {number} [time=120e3] Timeout for receipt of members
   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)
   * @property {boolean} [force=false] Whether to skip the cache check and request the API
   */

  /**
   * Fetches member(s) from Discord, even if they're offline.
   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.
   * If undefined, fetches all members.
   * If a query, it limits the results to users with similar usernames.
   * @returns {Promise<GuildMember>|Promise<Collection<Snowflake, GuildMember>>}
   * @example
   * // Fetch all members from a guild
   * guild.members.fetch()
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Fetch a single member
   * guild.members.fetch('66564597481480192')
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Fetch a single member without checking cache
   * guild.members.fetch({ user, force: true })
   *   .then(console.log)
   *   .catch(console.error)
   * @example
   * // Fetch a single member without caching
   * guild.members.fetch({ user, cache: false })
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Fetch by an array of users including their presences
   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Fetch by query
   * guild.members.fetch({ query: 'hydra', limit: 1 })
   *   .then(console.log)
   *   .catch(console.error);
   */
  fetch(options) {
    if (!options) return this._fetchMany();
    const user = this.client.users.resolveID(options);
    if (user) return this._fetchSingle({ user, cache: true });
    if (options.user) {
      if (Array.isArray(options.user)) {
        options.user = options.user.map(u => this.client.users.resolveID(u));
        return this._fetchMany(options);
      } else {
        options.user = this.client.users.resolveID(options.user);
      }
      if (!options.limit && !options.withPresences) return this._fetchSingle(options);
    }
    return this._fetchMany(options);
  }

  /**
   * Prunes members from the guild based on how long they have been inactive.
   * <info>It's recommended to set options.count to `false` for large guilds.</info>
   * @param {Object} [options] Prune options
   * @param {number} [options.days=7] Number of days of inactivity required to kick
   * @param {boolean} [options.dry=false] Get number of users that will be kicked, without actually kicking them
   * @param {boolean} [options.count=true] Whether or not to return the number of users that have been kicked.
   * @param {RoleResolvable[]} [options.roles=[]] Array of roles to bypass the "...and no roles" constraint when pruning
   * @param {string} [options.reason] Reason for this prune
   * @returns {Promise<number|null>} The number of members that were/will be kicked
   * @example
   * // See how many members will be pruned
   * guild.members.prune({ dry: true })
   *   .then(pruned => console.log(`This will prune ${pruned} people!`))
   *   .catch(console.error);
   * @example
   * // Actually prune the members
   * guild.members.prune({ days: 1, reason: 'too many people!' })
   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))
   *   .catch(console.error);
   * @example
   * // Include members with a specified role
   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })
   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))
   *    .catch(console.error);
   */
  prune({ days = 7, dry = false, count: compute_prune_count = true, roles = [], reason } = {}) {
    if (typeof days !== 'number') throw new TypeError('PRUNE_DAYS_TYPE');

    const query = { days };
    const resolvedRoles = [];

    for (const role of roles) {
      const resolvedRole = this.guild.roles.resolveID(role);
      if (!resolvedRole) {
        return Promise.reject(new TypeError('INVALID_TYPE', 'roles', 'Array of Roles or Snowflakes', true));
      }
      resolvedRoles.push(resolvedRole);
    }

    if (resolvedRoles.length) {
      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;
    }

    const endpoint = this.client.api.guilds(this.guild.id).prune;

    if (dry) {
      return endpoint.get({ query, reason }).then(data => data.pruned);
    }

    return endpoint
      .post({
        data: { ...query, compute_prune_count },
        reason,
      })
      .then(data => data.pruned);
  }

  /**
   * Bans a user from the guild.
   * @param {UserResolvable} user The user to ban
   * @param {Object} [options] Options for the ban
   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7
   * @param {string} [options.reason] Reason for banning
   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
   * be resolved, the user ID will be the result.
   * @example
   * // Ban a user by ID (or with a user/guild member object)
   * guild.members.ban('84484653687267328')
   *   .then(user => console.log(`Banned ${user.username || user.id || user} from ${guild.name}`))
   *   .catch(console.error);
   */
  ban(user, options = { days: 0 }) {
    if (options.days) options.delete_message_days = options.days;
    const id = this.client.users.resolveID(user);
    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID', true));
    return this.client.api
      .guilds(this.guild.id)
      .bans[id].put({ data: options })
      .then(() => {
        if (user instanceof GuildMember) return user;
        const _user = this.client.users.resolve(id);
        if (_user) {
          const member = this.resolve(_user);
          return member || _user;
        }
        return id;
      });
  }

  /**
   * Unbans a user from the guild.
   * @param {UserResolvable} user The user to unban
   * @param {string} [reason] Reason for unbanning user
   * @returns {Promise<User>}
   * @example
   * // Unban a user by ID (or with a user/guild member object)
   * guild.members.unban('84484653687267328')
   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))
   *   .catch(console.error);
   */
  unban(user, reason) {
    const id = this.client.users.resolveID(user);
    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID'));
    return this.client.api
      .guilds(this.guild.id)
      .bans[id].delete({ reason })
      .then(() => this.client.users.resolve(user));
  }

  _fetchSingle({ user, cache, force = false }) {
    if (!force) {
      const existing = this.cache.get(user);
      if (existing && !existing.partial) return Promise.resolve(existing);
    }

    return this.client.api
      .guilds(this.guild.id)
      .members(user)
      .get()
      .then(data => this.add(data, cache));
  }

  _fetchMany({
    limit = 0,
    withPresences: presences = false,
    user: user_ids,
    query,
    time = 120e3,
    nonce = SnowflakeUtil.generate(),
    force = false,
  } = {}) {
    return new Promise((resolve, reject) => {
      if (this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids && !force) {
        resolve(this.cache);
        return;
      }
      if (!query && !user_ids) query = '';
      if (nonce.length > 32) throw new RangeError('MEMBER_FETCH_NONCE_LENGTH');
      this.guild.shard.send({
        op: OPCodes.REQUEST_GUILD_MEMBERS,
        d: {
          guild_id: this.guild.id,
          presences,
          user_ids,
          query,
          nonce,
          limit,
        },
      });
      const fetchedMembers = new Collection();
      const option = query || limit || presences || user_ids;
      let i = 0;
      const handler = (members, _, chunk) => {
        timeout.refresh();
        if (chunk.nonce !== nonce) return;
        i++;
        for (const member of members.values()) {
          if (option) fetchedMembers.set(member.id, member);
        }
        if (
          this.guild.memberCount <= this.cache.size ||
          (option && members.size < 1000) ||
          (limit && fetchedMembers.size >= limit) ||
          i === chunk.count
        ) {
          this.client.clearTimeout(timeout);
          this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);
          this.client.decrementMaxListeners();
          let fetched = option ? fetchedMembers : this.cache;
          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();
          resolve(fetched);
        }
      };
      const timeout = this.client.setTimeout(() => {
        this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);
        this.client.decrementMaxListeners();
        reject(new Error('GUILD_MEMBERS_TIMEOUT'));
      }, time);
      this.client.incrementMaxListeners();
      this.client.on(Events.GUILD_MEMBERS_CHUNK, handler);
    });
  }
}

module.exports = GuildMemberManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/GuildMemberRoleManager.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/GuildMemberRoleManager.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");

/**
 * Manages API methods for roles of a GuildMember and stores their cache.
 */
class GuildMemberRoleManager {
  constructor(member) {
    /**
     * The GuildMember this manager belongs to
     * @type {GuildMember}
     */
    this.member = member;
    /**
     * The Guild this manager belongs to
     * @type {Guild}
     */
    this.guild = member.guild;
    Object.defineProperty(this, 'client', { value: member.client });
  }

  /**
   * The filtered collection of roles of the member
   * @type {Collection<Snowflake, Role>}
   * @private
   * @readonly
   */
  get _roles() {
    const everyone = this.guild.roles.everyone;
    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);
  }

  /**
   * The roles of this member
   * @type {Collection<Snowflake, Role>}
   * @readonly
   */
  get cache() {
    return this._roles;
  }

  /**
   * The role of the member used to hoist them in a separate category in the users list
   * @type {?Role}
   * @readonly
   */
  get hoist() {
    const hoistedRoles = this._roles.filter(role => role.hoist);
    if (!hoistedRoles.size) return null;
    return hoistedRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));
  }

  /**
   * The role of the member used to set their color
   * @type {?Role}
   * @readonly
   */
  get color() {
    const coloredRoles = this._roles.filter(role => role.color);
    if (!coloredRoles.size) return null;
    return coloredRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));
  }

  /**
   * The role of the member with the highest position
   * @type {Role}
   * @readonly
   */
  get highest() {
    return this._roles.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this._roles.first());
  }

  /**
   * Adds a role (or multiple roles) to the member.
   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
   * @param {string} [reason] Reason for adding the role(s)
   * @returns {Promise<GuildMember>}
   */
  async add(roleOrRoles, reason) {
    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));
      if (roleOrRoles.includes(null)) {
        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);
      }

      const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];
      return this.set(newRoles, reason);
    } else {
      roleOrRoles = this.guild.roles.resolve(roleOrRoles);
      if (roleOrRoles === null) {
        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');
      }

      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].put({ reason });

      const clone = this.member._clone();
      clone._roles = [...this._roles.keys(), roleOrRoles.id];
      return clone;
    }
  }

  /**
   * Removes a role (or multiple roles) from the member.
   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
   * @param {string} [reason] Reason for removing the role(s)
   * @returns {Promise<GuildMember>}
   */
  async remove(roleOrRoles, reason) {
    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));
      if (roleOrRoles.includes(null)) {
        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);
      }

      const newRoles = this._roles.filter(role => !roleOrRoles.includes(role));
      return this.set(newRoles, reason);
    } else {
      roleOrRoles = this.guild.roles.resolve(roleOrRoles);
      if (roleOrRoles === null) {
        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);
      }

      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].delete({ reason });

      const clone = this.member._clone();
      const newRoles = this._roles.filter(role => role.id !== roleOrRoles.id);
      clone._roles = [...newRoles.keys()];
      return clone;
    }
  }

  /**
   * Sets the roles applied to the member.
   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply
   * @param {string} [reason] Reason for applying the roles
   * @returns {Promise<GuildMember>}
   * @example
   * // Set the member's roles to a single role
   * guildMember.roles.set(['391156570408615936'])
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Remove all the roles from a member
   * guildMember.roles.set([])
   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))
   *   .catch(console.error);
   */
  set(roles, reason) {
    return this.member.edit({ roles }, reason);
  }

  clone() {
    const clone = new this.constructor(this.member);
    clone.member._roles = [...this._roles.keyArray()];
    return clone;
  }
}

module.exports = GuildMemberRoleManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/MessageManager.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/MessageManager.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const { TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Message = __webpack_require__(/*! ../structures/Message */ "./node_modules/discord.js/src/structures/Message.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const LimitedCollection = __webpack_require__(/*! ../util/LimitedCollection */ "./node_modules/discord.js/src/util/LimitedCollection.js");

/**
 * Manages API methods for Messages and holds their cache.
 * @extends {BaseManager}
 */
class MessageManager extends BaseManager {
  constructor(channel, iterable) {
    super(channel.client, iterable, Message, LimitedCollection, channel.client.options.messageCacheMaxSize);
    /**
     * The channel that the messages belong to
     * @type {TextBasedChannel}
     */
    this.channel = channel;
  }

  /**
   * The cache of Messages
   * @type {Collection<Snowflake, Message>}
   * @name MessageManager#cache
   */

  add(data, cache) {
    return super.add(data, cache, { extras: [this.channel] });
  }

  /**
   * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and
   * `after` are mutually exclusive. All the parameters are optional.
   * @typedef {Object} ChannelLogsQueryOptions
   * @property {number} [limit=50] Number of messages to acquire
   * @property {Snowflake} [before] ID of a message to get the messages that were posted before it
   * @property {Snowflake} [after] ID of a message to get the messages that were posted after it
   * @property {Snowflake} [around] ID of a message to get the messages that were posted around it
   */

  /**
   * Gets a message, or messages, from this channel.
   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.
   * Those need to be fetched separately in such a case.</info>
   * @param {Snowflake|ChannelLogsQueryOptions} [message] The ID of the message to fetch, or query parameters.
   * @param {boolean} [cache=true] Whether to cache the message(s)
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<Message>|Promise<Collection<Snowflake, Message>>}
   * @example
   * // Get message
   * channel.messages.fetch('99539446449315840')
   *   .then(message => console.log(message.content))
   *   .catch(console.error);
   * @example
   * // Get messages
   * channel.messages.fetch({ limit: 10 })
   *   .then(messages => console.log(`Received ${messages.size} messages`))
   *   .catch(console.error);
   * @example
   * // Get messages and filter by user ID
   * channel.messages.fetch()
   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))
   *   .catch(console.error);
   */
  fetch(message, cache = true, force = false) {
    return typeof message === 'string' ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);
  }

  /**
   * Fetches the pinned messages of this channel and returns a collection of them.
   * <info>The returned Collection does not contain any reaction data of the messages.
   * Those need to be fetched separately.</info>
   * @param {boolean} [cache=true] Whether to cache the message(s)
   * @returns {Promise<Collection<Snowflake, Message>>}
   * @example
   * // Get pinned messages
   * channel.messages.fetchPinned()
   *   .then(messages => console.log(`Received ${messages.size} messages`))
   *   .catch(console.error);
   */
  fetchPinned(cache = true) {
    return this.client.api.channels[this.channel.id].pins.get().then(data => {
      const messages = new Collection();
      for (const message of data) messages.set(message.id, this.add(message, cache));
      return messages;
    });
  }

  /**
   * Data that can be resolved to a Message object. This can be:
   * * A Message
   * * A Snowflake
   * @typedef {Message|Snowflake} MessageResolvable
   */

  /**
   * Resolves a MessageResolvable to a Message object.
   * @method resolve
   * @memberof MessageManager
   * @instance
   * @param {MessageResolvable} message The message resolvable to resolve
   * @returns {?Message}
   */

  /**
   * Resolves a MessageResolvable to a Message ID string.
   * @method resolveID
   * @memberof MessageManager
   * @instance
   * @param {MessageResolvable} message The message resolvable to resolve
   * @returns {?Snowflake}
   */

  /**
   * Deletes a message, even if it's not cached.
   * @param {MessageResolvable} message The message to delete
   * @param {string} [reason] Reason for deleting this message, if it does not belong to the client user
   * @returns {Promise<void>}
   */
  async delete(message, reason) {
    message = this.resolveID(message);
    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');

    await this.client.api.channels(this.channel.id).messages(message).delete({ reason });
  }

  async _fetchId(messageID, cache, force) {
    if (!force) {
      const existing = this.cache.get(messageID);
      if (existing && !existing.partial) return existing;
    }

    const data = await this.client.api.channels[this.channel.id].messages[messageID].get();
    return this.add(data, cache);
  }

  async _fetchMany(options = {}, cache) {
    const data = await this.client.api.channels[this.channel.id].messages.get({ query: options });
    const messages = new Collection();
    for (const message of data) messages.set(message.id, this.add(message, cache));
    return messages;
  }
}

module.exports = MessageManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/PresenceManager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/PresenceManager.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const { Presence } = __webpack_require__(/*! ../structures/Presence */ "./node_modules/discord.js/src/structures/Presence.js");

/**
 * Manages API methods for Presences and holds their cache.
 * @extends {BaseManager}
 */
class PresenceManager extends BaseManager {
  constructor(client, iterable) {
    super(client, iterable, Presence);
  }

  /**
   * The cache of Presences
   * @type {Collection<Snowflake, Presence>}
   * @name PresenceManager#cache
   */

  add(data, cache) {
    const existing = this.cache.get(data.user.id);
    return existing ? existing.patch(data) : super.add(data, cache, { id: data.user.id });
  }

  /**
   * Data that can be resolved to a Presence object. This can be:
   * * A Presence
   * * A UserResolvable
   * * A Snowflake
   * @typedef {Presence|UserResolvable|Snowflake} PresenceResolvable
   */

  /**
   * Resolves a PresenceResolvable to a Presence object.
   * @param {PresenceResolvable} presence The presence resolvable to resolve
   * @returns {?Presence}
   */
  resolve(presence) {
    const presenceResolvable = super.resolve(presence);
    if (presenceResolvable) return presenceResolvable;
    const UserResolvable = this.client.users.resolveID(presence);
    return super.resolve(UserResolvable) || null;
  }

  /**
   * Resolves a PresenceResolvable to a Presence ID string.
   * @param {PresenceResolvable} presence The presence resolvable to resolve
   * @returns {?Snowflake}
   */
  resolveID(presence) {
    const presenceResolvable = super.resolveID(presence);
    if (presenceResolvable) return presenceResolvable;
    const userResolvable = this.client.users.resolveID(presence);
    return this.cache.has(userResolvable) ? userResolvable : null;
  }
}

module.exports = PresenceManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/ReactionManager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/ReactionManager.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const MessageReaction = __webpack_require__(/*! ../structures/MessageReaction */ "./node_modules/discord.js/src/structures/MessageReaction.js");

/**
 * Manages API methods for reactions and holds their cache.
 * @extends {BaseManager}
 */
class ReactionManager extends BaseManager {
  constructor(message, iterable) {
    super(message.client, iterable, MessageReaction);

    /**
     * The message that this manager belongs to
     * @type {Message}
     */
    this.message = message;
  }

  add(data, cache) {
    return super.add(data, cache, { id: data.emoji.id || data.emoji.name, extras: [this.message] });
  }

  /**
   * The reaction cache of this manager
   * @type {Collection<string|Snowflake, MessageReaction>}
   * @name ReactionManager#cache
   */

  /**
   * Data that can be resolved to a MessageReaction object. This can be:
   * * A MessageReaction
   * * A Snowflake
   * @typedef {MessageReaction|Snowflake} MessageReactionResolvable
   */

  /**
   * Resolves a MessageReactionResolvable to a MessageReaction object.
   * @method resolve
   * @memberof ReactionManager
   * @instance
   * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
   * @returns {?MessageReaction}
   */

  /**
   * Resolves a MessageReactionResolvable to a MessageReaction ID string.
   * @method resolveID
   * @memberof ReactionManager
   * @instance
   * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
   * @returns {?Snowflake}
   */

  /**
   * Removes all reactions from a message.
   * @returns {Promise<Message>}
   */
  removeAll() {
    return this.client.api
      .channels(this.message.channel.id)
      .messages(this.message.id)
      .reactions.delete()
      .then(() => this.message);
  }
}

module.exports = ReactionManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/ReactionUserManager.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/ReactionUserManager.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");

/**
 * Manages API methods for users who reacted to a reaction and stores their cache.
 * @extends {BaseManager}
 */
class ReactionUserManager extends BaseManager {
  constructor(client, iterable, reaction) {
    super(client, iterable, { name: 'User' });
    /**
     * The reaction that this manager belongs to
     * @type {MessageReaction}
     */
    this.reaction = reaction;
  }

  /**
   * The cache of this manager
   * @type {Collection<Snowflake, User>}
   * @name ReactionUserManager#cache
   */

  /**
   * Fetches all the users that gave this reaction. Resolves with a collection of users, mapped by their IDs.
   * @param {Object} [options] Options for fetching the users
   * @param {number} [options.limit=100] The maximum amount of users to fetch, defaults to 100
   * @param {Snowflake} [options.before] Limit fetching users to those with an id lower than the supplied id
   * @param {Snowflake} [options.after] Limit fetching users to those with an id greater than the supplied id
   * @returns {Promise<Collection<Snowflake, User>>}
   */
  async fetch({ limit = 100, after, before } = {}) {
    const message = this.reaction.message;
    const data = await this.client.api.channels[message.channel.id].messages[message.id].reactions[
      this.reaction.emoji.identifier
    ].get({ query: { limit, before, after } });
    const users = new Collection();
    for (const rawUser of data) {
      const user = this.client.users.add(rawUser);
      this.cache.set(user.id, user);
      users.set(user.id, user);
    }
    return users;
  }

  /**
   * Removes a user from this reaction.
   * @param {UserResolvable} [user=this.client.user] The user to remove the reaction of
   * @returns {Promise<MessageReaction>}
   */
  remove(user = this.client.user) {
    const userID = this.client.users.resolveID(user);
    if (!userID) return Promise.reject(new Error('REACTION_RESOLVE_USER'));
    const message = this.reaction.message;
    return this.client.api.channels[message.channel.id].messages[message.id].reactions[this.reaction.emoji.identifier][
      userID === this.client.user.id ? '@me' : userID
    ]
      .delete()
      .then(() => this.reaction);
  }
}

module.exports = ReactionUserManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/RoleManager.js":
/*!*************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/RoleManager.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const Role = __webpack_require__(/*! ../structures/Role */ "./node_modules/discord.js/src/structures/Role.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
const { resolveColor } = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Manages API methods for roles and stores their cache.
 * @extends {BaseManager}
 */
class RoleManager extends BaseManager {
  constructor(guild, iterable) {
    super(guild.client, iterable, Role);
    /**
     * The guild belonging to this manager
     * @type {Guild}
     */
    this.guild = guild;
  }

  /**
   * The role cache of this manager
   * @type {Collection<Snowflake, Role>}
   * @name RoleManager#cache
   */

  add(data, cache) {
    return super.add(data, cache, { extras: [this.guild] });
  }

  /**
   * Obtains one or more roles from Discord, or the role cache if they're already available.
   * @param {Snowflake} [id] ID or IDs of the role(s)
   * @param {boolean} [cache=true] Whether to cache the new roles objects if it weren't already
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<Role|RoleManager>}
   * @example
   * // Fetch all roles from the guild
   * message.guild.roles.fetch()
   *   .then(roles => console.log(`There are ${roles.cache.size} roles.`))
   *   .catch(console.error);
   * @example
   * // Fetch a single role
   * message.guild.roles.fetch('222078108977594368')
   *   .then(role => console.log(`The role color is: ${role.color}`))
   *   .catch(console.error);
   */
  async fetch(id, cache = true, force = false) {
    if (id && !force) {
      const existing = this.cache.get(id);
      if (existing) return existing;
    }

    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405
    const roles = await this.client.api.guilds(this.guild.id).roles.get();
    for (const role of roles) this.add(role, cache);
    return id ? this.cache.get(id) || null : this;
  }

  /**
   * Data that can be resolved to a Role object. This can be:
   * * A Role
   * * A Snowflake
   * @typedef {Role|Snowflake} RoleResolvable
   */

  /**
   * Resolves a RoleResolvable to a Role object.
   * @method resolve
   * @memberof RoleManager
   * @instance
   * @param {RoleResolvable} role The role resolvable to resolve
   * @returns {?Role}
   */

  /**
   * Resolves a RoleResolvable to a role ID string.
   * @method resolveID
   * @memberof RoleManager
   * @instance
   * @param {RoleResolvable} role The role resolvable to resolve
   * @returns {?Snowflake}
   */

  /**
   * Creates a new role in the guild with given information.
   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>
   * @param {Object} [options] Options
   * @param {RoleData} [options.data] The data to create the role with
   * @param {string} [options.reason] Reason for creating this role
   * @returns {Promise<Role>}
   * @example
   * // Create a new role
   * guild.roles.create()
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Create a new role with data and a reason
   * guild.roles.create({
   *   data: {
   *     name: 'Super Cool People',
   *     color: 'BLUE',
   *   },
   *   reason: 'we needed a role for Super Cool People',
   * })
   *   .then(console.log)
   *   .catch(console.error);
   */
  create({ data = {}, reason } = {}) {
    if (data.color) data.color = resolveColor(data.color);
    if (data.permissions) data.permissions = Permissions.resolve(data.permissions);

    return this.guild.client.api
      .guilds(this.guild.id)
      .roles.post({ data, reason })
      .then(r => {
        const { role } = this.client.actions.GuildRoleCreate.handle({
          guild_id: this.guild.id,
          role: r,
        });
        if (data.position) return role.setPosition(data.position, reason);
        return role;
      });
  }

  /**
   * The `@everyone` role of the guild
   * @type {Role}
   * @readonly
   */
  get everyone() {
    return this.cache.get(this.guild.id);
  }

  /**
   * The role with the highest position in the cache
   * @type {Role}
   * @readonly
   */
  get highest() {
    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());
  }
}

module.exports = RoleManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/UserManager.js":
/*!*************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/UserManager.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");
const GuildMember = __webpack_require__(/*! ../structures/GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js");
const Message = __webpack_require__(/*! ../structures/Message */ "./node_modules/discord.js/src/structures/Message.js");
const User = __webpack_require__(/*! ../structures/User */ "./node_modules/discord.js/src/structures/User.js");

/**
 * Manages API methods for users and stores their cache.
 * @extends {BaseManager}
 */
class UserManager extends BaseManager {
  constructor(client, iterable) {
    super(client, iterable, User);
  }

  /**
   * The cache of this manager
   * @type {Collection<Snowflake, User>}
   * @name UserManager#cache
   */

  /**
   * Data that resolves to give a User object. This can be:
   * * A User object
   * * A Snowflake
   * * A Message object (resolves to the message author)
   * * A GuildMember object
   * @typedef {User|Snowflake|Message|GuildMember} UserResolvable
   */

  /**
   * Resolves a UserResolvable to a User object.
   * @param {UserResolvable} user The UserResolvable to identify
   * @returns {?User}
   */
  resolve(user) {
    if (user instanceof GuildMember) return user.user;
    if (user instanceof Message) return user.author;
    return super.resolve(user);
  }

  /**
   * Resolves a UserResolvable to a user ID string.
   * @param {UserResolvable} user The UserResolvable to identify
   * @returns {?Snowflake}
   */
  resolveID(user) {
    if (user instanceof GuildMember) return user.user.id;
    if (user instanceof Message) return user.author.id;
    return super.resolveID(user);
  }

  /**
   * Obtains a user from Discord, or the user cache if it's already available.
   * @param {Snowflake} id ID of the user
   * @param {boolean} [cache=true] Whether to cache the new user object if it isn't already
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<User>}
   */
  async fetch(id, cache = true, force = false) {
    if (!force) {
      const existing = this.cache.get(id);
      if (existing && !existing.partial) return existing;
    }

    const data = await this.client.api.users(id).get();
    return this.add(data, cache);
  }
}

module.exports = UserManager;


/***/ }),

/***/ "./node_modules/discord.js/src/managers/VoiceStateManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/managers/VoiceStateManager.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseManager = __webpack_require__(/*! ./BaseManager */ "./node_modules/discord.js/src/managers/BaseManager.js");

/**
 * Manages API methods for VoiceStates and stores their cache.
 * @extends {BaseManager}
 */
class VoiceStateManager extends BaseManager {
  constructor(guild, iterable) {
    super(guild.client, iterable, { name: 'VoiceState' });
    /**
     * The guild this manager belongs to
     * @type {Guild}
     */
    this.guild = guild;
  }

  /**
   * The cache of this manager
   * @type {Collection<Snowflake, VoiceState>}
   * @name VoiceStateManager#cache
   */

  add(data, cache = true) {
    const existing = this.cache.get(data.user_id);
    if (existing) return existing._patch(data);

    const entry = new this.holds(this.guild, data);
    if (cache) this.cache.set(data.user_id, entry);
    return entry;
  }
}

module.exports = VoiceStateManager;


/***/ }),

/***/ "./node_modules/discord.js/src/rest/APIRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/rest/APIRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const https = __webpack_require__(/*! https */ "?8ff5");
const FormData = __webpack_require__(/*! @discordjs/form-data */ "./node_modules/@discordjs/form-data/lib/browser.js");
const AbortController = __webpack_require__(/*! abort-controller */ "./node_modules/abort-controller/browser.js");
const fetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
const { browser, UserAgent } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

if (https.Agent) var agent = new https.Agent({ keepAlive: true });

class APIRequest {
  constructor(rest, method, path, options) {
    this.rest = rest;
    this.client = rest.client;
    this.method = method;
    this.route = options.route;
    this.options = options;
    this.retries = 0;

    let queryString = '';
    if (options.query) {
      const query = Object.entries(options.query)
        .filter(([, value]) => ![null, 'null', 'undefined'].includes(value) && typeof value !== 'undefined')
        .flatMap(([key, value]) => (Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]));
      queryString = new URLSearchParams(query).toString();
    }
    this.path = `${path}${queryString && `?${queryString}`}`;
  }

  make() {
    const API =
      this.options.versioned === false
        ? this.client.options.http.api
        : `${this.client.options.http.api}/v${this.client.options.http.version}`;
    const url = API + this.path;
    let headers = {};

    if (this.options.auth !== false) headers.Authorization = this.rest.getAuth();
    if (this.options.reason) headers['X-Audit-Log-Reason'] = encodeURIComponent(this.options.reason);
    if (!browser) headers['User-Agent'] = UserAgent;
    if (this.options.headers) headers = Object.assign(headers, this.options.headers);

    let body;
    if (this.options.files && this.options.files.length) {
      body = new FormData();
      for (const file of this.options.files) if (file && file.file) body.append(file.name, file.file, file.name);
      if (typeof this.options.data !== 'undefined') body.append('payload_json', JSON.stringify(this.options.data));
      if (!browser) headers = Object.assign(headers, body.getHeaders());
      // eslint-disable-next-line eqeqeq
    } else if (this.options.data != null) {
      body = JSON.stringify(this.options.data);
      headers['Content-Type'] = 'application/json';
    }

    const controller = new AbortController();
    const timeout = this.client.setTimeout(() => controller.abort(), this.client.options.restRequestTimeout);
    return fetch(url, {
      method: this.method,
      headers,
      agent,
      body,
      signal: controller.signal,
    }).finally(() => this.client.clearTimeout(timeout));
  }
}

module.exports = APIRequest;


/***/ }),

/***/ "./node_modules/discord.js/src/rest/APIRouter.js":
/*!*******************************************************!*\
  !*** ./node_modules/discord.js/src/rest/APIRouter.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


const noop = () => {}; // eslint-disable-line no-empty-function
const methods = ['get', 'post', 'delete', 'patch', 'put'];
const reflectors = [
  'toString',
  'valueOf',
  'inspect',
  'constructor',
  Symbol.toPrimitive,
  Symbol.for('nodejs.util.inspect.custom'),
];

function buildRoute(manager) {
  const route = [''];
  const handler = {
    get(target, name) {
      if (reflectors.includes(name)) return () => route.join('/');
      if (methods.includes(name)) {
        const routeBucket = [];
        for (let i = 0; i < route.length; i++) {
          // Reactions routes and sub-routes all share the same bucket
          if (route[i - 1] === 'reactions') break;
          // Literal IDs should only be taken account if they are the Major ID (the Channel/Guild ID)
          if (/\d{16,19}/g.test(route[i]) && !/channels|guilds/.test(route[i - 1])) routeBucket.push(':id');
          // All other parts of the route should be considered as part of the bucket identifier
          else routeBucket.push(route[i]);
        }
        return options =>
          manager.request(
            name,
            route.join('/'),
            Object.assign(
              {
                versioned: manager.versioned,
                route: routeBucket.join('/'),
              },
              options,
            ),
          );
      }
      route.push(name);
      return new Proxy(noop, handler);
    },
    apply(target, _, args) {
      route.push(...args.filter(x => x != null)); // eslint-disable-line eqeqeq
      return new Proxy(noop, handler);
    },
  };
  return new Proxy(noop, handler);
}

module.exports = buildRoute;


/***/ }),

/***/ "./node_modules/discord.js/src/rest/AsyncQueue.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/rest/AsyncQueue.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
/**
 * MIT License
 *
 * Copyright (c) 2020 kyranet, discord.js
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



// TODO(kyranet, vladfrangu): replace this with discord.js v13's core AsyncQueue.

/**
 * An async queue that preserves the stack and prevents lock-ups.
 * @private
 */
class AsyncQueue {
  constructor() {
    /**
     * The promises array.
     * @type {Array<{promise: Promise<void>, resolve: Function}>}
     * @private
     */
    this.promises = [];
  }

  /**
   * The remaining amount of queued promises
   * @type {number}
   */
  get remaining() {
    return this.promises.length;
  }

  /**
   * Waits for last promise and queues a new one.
   * @returns {Promise<void>}
   * @example
   * const queue = new AsyncQueue();
   * async function request(url, options) {
   *     await queue.wait();
   *     try {
   *         const result = await fetch(url, options);
   *         // Do some operations with 'result'
   *     } finally {
   *         // Remove first entry from the queue and resolve for the next entry
   *         queue.shift();
   *     }
   * }
   *
   * request(someUrl1, someOptions1); // Will call fetch() immediately
   * request(someUrl2, someOptions2); // Will call fetch() after the first finished
   * request(someUrl3, someOptions3); // Will call fetch() after the second finished
   */
  wait() {
    const next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();
    let resolve;
    const promise = new Promise(res => {
      resolve = res;
    });

    this.promises.push({
      resolve,
      promise,
    });

    return next;
  }

  /**
   * Frees the queue's lock for the next item to process.
   */
  shift() {
    const deferred = this.promises.shift();
    if (typeof deferred !== 'undefined') deferred.resolve();
  }
}

module.exports = AsyncQueue;


/***/ }),

/***/ "./node_modules/discord.js/src/rest/DiscordAPIError.js":
/*!*************************************************************!*\
  !*** ./node_modules/discord.js/src/rest/DiscordAPIError.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Represents an error from the Discord API.
 * @extends Error
 */
class DiscordAPIError extends Error {
  constructor(path, error, method, status) {
    super();
    const flattened = this.constructor.flattenErrors(error.errors || error).join('\n');
    this.name = 'DiscordAPIError';
    this.message = error.message && flattened ? `${error.message}\n${flattened}` : error.message || flattened;

    /**
     * The HTTP method used for the request
     * @type {string}
     */
    this.method = method;

    /**
     * The path of the request relative to the HTTP endpoint
     * @type {string}
     */
    this.path = path;

    /**
     * HTTP error code returned by Discord
     * @type {number}
     */
    this.code = error.code;

    /**
     * The HTTP status code
     * @type {number}
     */
    this.httpStatus = status;
  }

  /**
   * Flattens an errors object returned from the API into an array.
   * @param {Object} obj Discord errors object
   * @param {string} [key] Used internally to determine key names of nested fields
   * @returns {string[]}
   * @private
   */
  static flattenErrors(obj, key = '') {
    let messages = [];

    for (const [k, v] of Object.entries(obj)) {
      if (k === 'message') continue;
      const newKey = key ? (isNaN(k) ? `${key}.${k}` : `${key}[${k}]`) : k;

      if (v._errors) {
        messages.push(`${newKey}: ${v._errors.map(e => e.message).join(' ')}`);
      } else if (v.code || v.message) {
        messages.push(`${v.code ? `${v.code}: ` : ''}${v.message}`.trim());
      } else if (typeof v === 'string') {
        messages.push(v);
      } else {
        messages = messages.concat(this.flattenErrors(v, newKey));
      }
    }

    return messages;
  }
}

module.exports = DiscordAPIError;


/***/ }),

/***/ "./node_modules/discord.js/src/rest/HTTPError.js":
/*!*******************************************************!*\
  !*** ./node_modules/discord.js/src/rest/HTTPError.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Represents a HTTP error from a request.
 * @extends Error
 */
class HTTPError extends Error {
  constructor(message, name, code, method, path) {
    super(message);

    /**
     * The name of the error
     * @type {string}
     */
    this.name = name;

    /**
     * HTTP error code returned from the request
     * @type {number}
     */
    this.code = code || 500;

    /**
     * The HTTP method used for the request
     * @type {string}
     */
    this.method = method;

    /**
     * The path of the request relative to the HTTP endpoint
     * @type {string}
     */
    this.path = path;
  }
}

module.exports = HTTPError;


/***/ }),

/***/ "./node_modules/discord.js/src/rest/RESTManager.js":
/*!*********************************************************!*\
  !*** ./node_modules/discord.js/src/rest/RESTManager.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const APIRequest = __webpack_require__(/*! ./APIRequest */ "./node_modules/discord.js/src/rest/APIRequest.js");
const routeBuilder = __webpack_require__(/*! ./APIRouter */ "./node_modules/discord.js/src/rest/APIRouter.js");
const RequestHandler = __webpack_require__(/*! ./RequestHandler */ "./node_modules/discord.js/src/rest/RequestHandler.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { Endpoints } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class RESTManager {
  constructor(client, tokenPrefix = 'Bot') {
    this.client = client;
    this.handlers = new Collection();
    this.tokenPrefix = tokenPrefix;
    this.versioned = true;
    this.globalTimeout = null;
    if (client.options.restSweepInterval > 0) {
      client.setInterval(() => {
        this.handlers.sweep(handler => handler._inactive);
      }, client.options.restSweepInterval * 1000);
    }
  }

  get api() {
    return routeBuilder(this);
  }

  getAuth() {
    const token = this.client.token || this.client.accessToken;
    if (token) return `${this.tokenPrefix} ${token}`;
    throw new Error('TOKEN_MISSING');
  }

  get cdn() {
    return Endpoints.CDN(this.client.options.http.cdn);
  }

  request(method, url, options = {}) {
    const apiRequest = new APIRequest(this, method, url, options);
    let handler = this.handlers.get(apiRequest.route);

    if (!handler) {
      handler = new RequestHandler(this);
      this.handlers.set(apiRequest.route, handler);
    }

    return handler.push(apiRequest);
  }

  get endpoint() {
    return this.client.options.http.api;
  }

  set endpoint(endpoint) {
    this.client.options.http.api = endpoint;
  }
}

module.exports = RESTManager;


/***/ }),

/***/ "./node_modules/discord.js/src/rest/RequestHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/discord.js/src/rest/RequestHandler.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AsyncQueue = __webpack_require__(/*! ./AsyncQueue */ "./node_modules/discord.js/src/rest/AsyncQueue.js");
const DiscordAPIError = __webpack_require__(/*! ./DiscordAPIError */ "./node_modules/discord.js/src/rest/DiscordAPIError.js");
const HTTPError = __webpack_require__(/*! ./HTTPError */ "./node_modules/discord.js/src/rest/HTTPError.js");
const {
  Events: { RATE_LIMIT },
  browser,
} = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

function parseResponse(res) {
  if (res.headers.get('content-type').startsWith('application/json')) return res.json();
  if (browser) return res.blob();
  return res.buffer();
}

function getAPIOffset(serverDate) {
  return new Date(serverDate).getTime() - Date.now();
}

function calculateReset(reset, serverDate) {
  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);
}

class RequestHandler {
  constructor(manager) {
    this.manager = manager;
    this.queue = new AsyncQueue();
    this.reset = -1;
    this.remaining = -1;
    this.limit = -1;
    this.retryAfter = -1;
  }

  async push(request) {
    await this.queue.wait();
    try {
      return await this.execute(request);
    } finally {
      this.queue.shift();
    }
  }

  get limited() {
    return Boolean(this.manager.globalTimeout) || (this.remaining <= 0 && Date.now() < this.reset);
  }

  get _inactive() {
    return this.queue.remaining === 0 && !this.limited;
  }

  async execute(request) {
    // After calculations and requests have been done, pre-emptively stop further requests
    if (this.limited) {
      const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();

      if (this.manager.client.listenerCount(RATE_LIMIT)) {
        /**
         * Emitted when the client hits a rate limit while making a request
         * @event Client#rateLimit
         * @param {Object} rateLimitInfo Object containing the rate limit info
         * @param {number} rateLimitInfo.timeout Timeout in ms
         * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint
         * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event
         * @param {string} rateLimitInfo.path Path used for request that triggered this event
         * @param {string} rateLimitInfo.route Route used for request that triggered this event
         */
        this.manager.client.emit(RATE_LIMIT, {
          timeout,
          limit: this.limit,
          method: request.method,
          path: request.path,
          route: request.route,
        });
      }

      if (this.manager.globalTimeout) {
        await this.manager.globalTimeout;
      } else {
        // Wait for the timeout to expire in order to avoid an actual 429
        await Util.delayFor(timeout);
      }
    }

    // Perform the request
    let res;
    try {
      res = await request.make();
    } catch (error) {
      // Retry the specified number of times for request abortions
      if (request.retries === this.manager.client.options.retryLimit) {
        throw new HTTPError(error.message, error.constructor.name, error.status, request.method, request.path);
      }

      request.retries++;
      return this.execute(request);
    }

    if (res && res.headers) {
      const serverDate = res.headers.get('date');
      const limit = res.headers.get('x-ratelimit-limit');
      const remaining = res.headers.get('x-ratelimit-remaining');
      const reset = res.headers.get('x-ratelimit-reset');
      const retryAfter = res.headers.get('retry-after');

      this.limit = limit ? Number(limit) : Infinity;
      this.remaining = remaining ? Number(remaining) : 1;
      this.reset = reset ? calculateReset(reset, serverDate) : Date.now();
      this.retryAfter = retryAfter ? Number(retryAfter) : -1;

      // https://github.com/discordapp/discord-api-docs/issues/182
      if (request.route.includes('reactions')) {
        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;
      }

      // Handle global ratelimit
      if (res.headers.get('x-ratelimit-global')) {
        // Set the manager's global timeout as the promise for other requests to "wait"
        this.manager.globalTimeout = Util.delayFor(this.retryAfter);

        // Wait for the global timeout to resolve before continuing
        await this.manager.globalTimeout;

        // Clean up global timeout
        this.manager.globalTimeout = null;
      }
    }

    // Handle 2xx and 3xx responses
    if (res.ok) {
      // Nothing wrong with the request, proceed with the next one
      return parseResponse(res);
    }

    // Handle 4xx responses
    if (res.status >= 400 && res.status < 500) {
      // Handle ratelimited requests
      if (res.status === 429) {
        // A ratelimit was hit - this should never happen
        this.manager.client.emit('debug', `429 hit on route ${request.route}`);
        await Util.delayFor(this.retryAfter);
        return this.execute(request);
      }

      // Handle possible malformed requests
      let data;
      try {
        data = await parseResponse(res);
      } catch (err) {
        throw new HTTPError(err.message, err.constructor.name, err.status, request.method, request.path);
      }

      throw new DiscordAPIError(request.path, data, request.method, res.status);
    }

    // Handle 5xx responses
    if (res.status >= 500 && res.status < 600) {
      // Retry the specified number of times for possible serverside issues
      if (request.retries === this.manager.client.options.retryLimit) {
        throw new HTTPError(res.statusText, res.constructor.name, res.status, request.method, request.path);
      }

      request.retries++;
      return this.execute(request);
    }

    // Fallback in the rare case a status code outside the range 200..=599 is returned
    return null;
  }
}

module.exports = RequestHandler;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/APIMessage.js":
/*!**************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/APIMessage.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const MessageAttachment = __webpack_require__(/*! ./MessageAttachment */ "./node_modules/discord.js/src/structures/MessageAttachment.js");
const MessageEmbed = __webpack_require__(/*! ./MessageEmbed */ "./node_modules/discord.js/src/structures/MessageEmbed.js");
const { RangeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const { browser } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");
const MessageFlags = __webpack_require__(/*! ../util/MessageFlags */ "./node_modules/discord.js/src/util/MessageFlags.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a message to be sent to the API.
 */
class APIMessage {
  /**
   * @param {MessageTarget} target - The target for this message to be sent to
   * @param {MessageOptions|WebhookMessageOptions} options - Options passed in from send
   */
  constructor(target, options) {
    /**
     * The target for this message to be sent to
     * @type {MessageTarget}
     */
    this.target = target;

    /**
     * Options passed in from send
     * @type {MessageOptions|WebhookMessageOptions}
     */
    this.options = options;

    /**
     * Data sendable to the API
     * @type {?Object}
     */
    this.data = null;

    /**
     * Files sendable to the API
     * @type {?Object[]}
     */
    this.files = null;
  }

  /**
   * Whether or not the target is a webhook
   * @type {boolean}
   * @readonly
   */
  get isWebhook() {
    const Webhook = __webpack_require__(/*! ./Webhook */ "./node_modules/discord.js/src/structures/Webhook.js");
    const WebhookClient = __webpack_require__(/*! ../client/WebhookClient */ "./node_modules/discord.js/src/client/WebhookClient.js");
    return this.target instanceof Webhook || this.target instanceof WebhookClient;
  }

  /**
   * Whether or not the target is a user
   * @type {boolean}
   * @readonly
   */
  get isUser() {
    const User = __webpack_require__(/*! ./User */ "./node_modules/discord.js/src/structures/User.js");
    const GuildMember = __webpack_require__(/*! ./GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js");
    return this.target instanceof User || this.target instanceof GuildMember;
  }

  /**
   * Whether or not the target is a message
   * @type {boolean}
   * @readonly
   */
  get isMessage() {
    const Message = __webpack_require__(/*! ./Message */ "./node_modules/discord.js/src/structures/Message.js");
    return this.target instanceof Message;
  }

  /**
   * Makes the content of this message.
   * @returns {?(string|string[])}
   */
  makeContent() {
    const GuildMember = __webpack_require__(/*! ./GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js");

    let content;
    if (this.options.content === null) {
      content = '';
    } else if (typeof this.options.content !== 'undefined') {
      content = Util.resolveString(this.options.content);
    }

    if (typeof content !== 'string') return content;

    const disableMentions =
      typeof this.options.disableMentions === 'undefined'
        ? this.target.client.options.disableMentions
        : this.options.disableMentions;
    if (disableMentions === 'all') {
      content = Util.removeMentions(content);
    } else if (disableMentions === 'everyone') {
      content = content.replace(/@([^<>@ ]*)/gmsu, (match, target) => {
        if (target.match(/^[&!]?\d+$/)) {
          return `@${target}`;
        } else {
          return `@\u200b${target}`;
        }
      });
    }

    const isSplit = typeof this.options.split !== 'undefined' && this.options.split !== false;
    const isCode = typeof this.options.code !== 'undefined' && this.options.code !== false;
    const splitOptions = isSplit ? { ...this.options.split } : undefined;

    let mentionPart = '';
    if (this.options.reply && !this.isUser && this.target.type !== 'dm') {
      const id = this.target.client.users.resolveID(this.options.reply);
      mentionPart = `<@${this.options.reply instanceof GuildMember && this.options.reply.nickname ? '!' : ''}${id}>, `;
      if (isSplit) {
        splitOptions.prepend = `${mentionPart}${splitOptions.prepend || ''}`;
      }
    }

    if (content || mentionPart) {
      if (isCode) {
        const codeName = typeof this.options.code === 'string' ? this.options.code : '';
        content = `${mentionPart}\`\`\`${codeName}\n${Util.cleanCodeBlockContent(content)}\n\`\`\``;
        if (isSplit) {
          splitOptions.prepend = `${splitOptions.prepend || ''}\`\`\`${codeName}\n`;
          splitOptions.append = `\n\`\`\`${splitOptions.append || ''}`;
        }
      } else if (mentionPart) {
        content = `${mentionPart}${content}`;
      }

      if (isSplit) {
        content = Util.splitMessage(content, splitOptions);
      }
    }

    return content;
  }

  /**
   * Resolves data.
   * @returns {APIMessage}
   */
  resolveData() {
    if (this.data) return this;

    const content = this.makeContent();
    const tts = Boolean(this.options.tts);

    let nonce;
    if (typeof this.options.nonce !== 'undefined') {
      nonce = parseInt(this.options.nonce);
      if (isNaN(nonce) || nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');
    }

    const embedLikes = [];
    if (this.isWebhook) {
      if (this.options.embeds) {
        embedLikes.push(...this.options.embeds);
      }
    } else if (this.options.embed) {
      embedLikes.push(this.options.embed);
    }
    const embeds = embedLikes.map(e => new MessageEmbed(e).toJSON());

    let username;
    let avatarURL;
    if (this.isWebhook) {
      username = this.options.username || this.target.name;
      if (this.options.avatarURL) avatarURL = this.options.avatarURL;
    }

    let flags;
    if (this.isMessage) {
      // eslint-disable-next-line eqeqeq
      flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : this.target.flags.bitfield;
    }

    let allowedMentions =
      typeof this.options.allowedMentions === 'undefined'
        ? this.target.client.options.allowedMentions
        : this.options.allowedMentions;
    if (this.options.reply) {
      const id = this.target.client.users.resolveID(this.options.reply);
      if (allowedMentions) {
        // Clone the object as not to alter the ClientOptions object
        allowedMentions = Util.cloneObject(allowedMentions);
        const parsed = allowedMentions.parse && allowedMentions.parse.includes('users');
        // Check if the mention won't be parsed, and isn't supplied in `users`
        if (!parsed && !(allowedMentions.users && allowedMentions.users.includes(id))) {
          if (!allowedMentions.users) allowedMentions.users = [];
          allowedMentions.users.push(id);
        }
      } else {
        allowedMentions = { users: [id] };
      }
    }

    this.data = {
      content,
      tts,
      nonce,
      embed: this.options.embed === null ? null : embeds[0],
      embeds,
      username,
      avatar_url: avatarURL,
      allowed_mentions: typeof content === 'undefined' ? undefined : allowedMentions,
      flags,
    };
    return this;
  }

  /**
   * Resolves files.
   * @returns {Promise<APIMessage>}
   */
  async resolveFiles() {
    if (this.files) return this;

    const embedLikes = [];
    if (this.isWebhook) {
      if (this.options.embeds) {
        embedLikes.push(...this.options.embeds);
      }
    } else if (this.options.embed) {
      embedLikes.push(this.options.embed);
    }

    const fileLikes = [];
    if (this.options.files) {
      fileLikes.push(...this.options.files);
    }
    for (const embed of embedLikes) {
      if (embed.files) {
        fileLikes.push(...embed.files);
      }
    }

    this.files = await Promise.all(fileLikes.map(f => this.constructor.resolveFile(f)));
    return this;
  }

  /**
   * Converts this APIMessage into an array of APIMessages for each split content
   * @returns {APIMessage[]}
   */
  split() {
    if (!this.data) this.resolveData();

    if (!Array.isArray(this.data.content)) return [this];

    const apiMessages = [];

    for (let i = 0; i < this.data.content.length; i++) {
      let data;
      let opt;

      if (i === this.data.content.length - 1) {
        data = { ...this.data, content: this.data.content[i] };
        opt = { ...this.options, content: this.data.content[i] };
      } else {
        data = { content: this.data.content[i], tts: this.data.tts, allowed_mentions: this.options.allowedMentions };
        opt = { content: this.data.content[i], tts: this.data.tts, allowedMentions: this.options.allowedMentions };
      }

      const apiMessage = new APIMessage(this.target, opt);
      apiMessage.data = data;
      apiMessages.push(apiMessage);
    }

    return apiMessages;
  }

  /**
   * Resolves a single file into an object sendable to the API.
   * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} fileLike Something that could be resolved to a file
   * @returns {Object}
   */
  static async resolveFile(fileLike) {
    let attachment;
    let name;

    const findName = thing => {
      if (typeof thing === 'string') {
        return Util.basename(thing);
      }

      if (thing.path) {
        return Util.basename(thing.path);
      }

      return 'file.jpg';
    };

    const ownAttachment =
      typeof fileLike === 'string' ||
      fileLike instanceof (browser ? ArrayBuffer : Buffer) ||
      typeof fileLike.pipe === 'function';
    if (ownAttachment) {
      attachment = fileLike;
      name = findName(attachment);
    } else {
      attachment = fileLike.attachment;
      name = fileLike.name || findName(attachment);
    }

    const resource = await DataResolver.resolveFile(attachment);
    return { attachment, name, file: resource };
  }

  /**
   * Partitions embeds and attachments.
   * @param {Array<MessageEmbed|MessageAttachment>} items Items to partition
   * @returns {Array<MessageEmbed[], MessageAttachment[]>}
   */
  static partitionMessageAdditions(items) {
    const embeds = [];
    const files = [];
    for (const item of items) {
      if (item instanceof MessageEmbed) {
        embeds.push(item);
      } else if (item instanceof MessageAttachment) {
        files.push(item);
      }
    }

    return [embeds, files];
  }

  /**
   * Transforms the user-level arguments into a final options object. Passing a transformed options object alone into
   * this method will keep it the same, allowing for the reuse of the final options object.
   * @param {StringResolvable} [content] Content to send
   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use
   * @param {MessageOptions|WebhookMessageOptions} [extra={}] Extra options to add onto transformed options
   * @param {boolean} [isWebhook=false] Whether or not to use WebhookMessageOptions as the result
   * @returns {MessageOptions|WebhookMessageOptions}
   */
  static transformOptions(content, options, extra = {}, isWebhook = false) {
    if (!options && typeof content === 'object' && !Array.isArray(content)) {
      options = content;
      content = undefined;
    }

    if (!options) {
      options = {};
    } else if (options instanceof MessageEmbed) {
      return isWebhook ? { content, embeds: [options], ...extra } : { content, embed: options, ...extra };
    } else if (options instanceof MessageAttachment) {
      return { content, files: [options], ...extra };
    }

    if (Array.isArray(options)) {
      const [embeds, files] = this.partitionMessageAdditions(options);
      return isWebhook ? { content, embeds, files, ...extra } : { content, embed: embeds[0], files, ...extra };
    } else if (Array.isArray(content)) {
      const [embeds, files] = this.partitionMessageAdditions(content);
      if (embeds.length || files.length) {
        return isWebhook ? { embeds, files, ...extra } : { embed: embeds[0], files, ...extra };
      }
    }

    return { content, ...options, ...extra };
  }

  /**
   * Creates an `APIMessage` from user-level arguments.
   * @param {MessageTarget} target Target to send to
   * @param {StringResolvable} [content] Content to send
   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use
   * @param {MessageOptions|WebhookMessageOptions} [extra={}] - Extra options to add onto transformed options
   * @returns {MessageOptions|WebhookMessageOptions}
   */
  static create(target, content, options, extra = {}) {
    const Webhook = __webpack_require__(/*! ./Webhook */ "./node_modules/discord.js/src/structures/Webhook.js");
    const WebhookClient = __webpack_require__(/*! ../client/WebhookClient */ "./node_modules/discord.js/src/client/WebhookClient.js");

    const isWebhook = target instanceof Webhook || target instanceof WebhookClient;
    const transformed = this.transformOptions(content, options, extra, isWebhook);
    return new this(target, transformed);
  }
}

module.exports = APIMessage;

/**
 * A target for a message.
 * @typedef {TextChannel|DMChannel|User|GuildMember|Webhook|WebhookClient} MessageTarget
 */

/**
 * Additional items that can be sent with a message.
 * @typedef {MessageEmbed|MessageAttachment|Array<MessageEmbed|MessageAttachment>} MessageAdditions
 */


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Base.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Base.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a data model that is identifiable by a Snowflake (i.e. Discord API data models).
 * @abstract
 */
class Base {
  constructor(client) {
    /**
     * The client that instantiated this
     * @name Base#client
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: client });
  }

  _clone() {
    return Object.assign(Object.create(this), this);
  }

  _patch(data) {
    return data;
  }

  _update(data) {
    const clone = this._clone();
    this._patch(data);
    return clone;
  }

  toJSON(...props) {
    return Util.flatten(this, ...props);
  }

  valueOf() {
    return this.id;
  }
}

module.exports = Base;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/BaseGuildEmoji.js":
/*!******************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/BaseGuildEmoji.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Emoji = __webpack_require__(/*! ./Emoji */ "./node_modules/discord.js/src/structures/Emoji.js");

/**
 * Parent class for {@link GuildEmoji} and {@link GuildPreviewEmoji}.
 * @extends {Emoji}
 * @abstract
 */
class BaseGuildEmoji extends Emoji {
  constructor(client, data, guild) {
    super(client, data);

    /**
     * The guild this emoji is a part of
     * @type {Guild|GuildPreview}
     */
    this.guild = guild;

    this.requireColons = null;
    this.managed = null;
    this.available = null;

    /**
     * Array of role ids this emoji is active for
     * @name BaseGuildEmoji#_roles
     * @type {Snowflake[]}
     * @private
     */
    Object.defineProperty(this, '_roles', { value: [], writable: true });

    this._patch(data);
  }

  _patch(data) {
    if (data.name) this.name = data.name;

    if (typeof data.require_colons !== 'undefined') {
      /**
       * Whether or not this emoji requires colons surrounding it
       * @type {?boolean}
       */
      this.requiresColons = data.require_colons;
    }

    if (typeof data.managed !== 'undefined') {
      /**
       * Whether this emoji is managed by an external service
       * @type {?boolean}
       */
      this.managed = data.managed;
    }

    if (typeof data.available !== 'undefined') {
      /**
       * Whether this emoji is available
       * @type {?boolean}
       */
      this.available = data.available;
    }

    if (data.roles) this._roles = data.roles;
  }
}

module.exports = BaseGuildEmoji;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/CategoryChannel.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/CategoryChannel.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const GuildChannel = __webpack_require__(/*! ./GuildChannel */ "./node_modules/discord.js/src/structures/GuildChannel.js");

/**
 * Represents a guild category channel on Discord.
 * @extends {GuildChannel}
 */
class CategoryChannel extends GuildChannel {
  /**
   * Channels that are a part of this category
   * @type {Collection<Snowflake, GuildChannel>}
   * @readonly
   */
  get children() {
    return this.guild.channels.cache.filter(c => c.parentID === this.id);
  }

  /**
   * Sets the category parent of this channel.
   * <warn>It is not currently possible to set the parent of a CategoryChannel.</warn>
   * @method setParent
   * @memberof CategoryChannel
   * @instance
   * @param {?GuildChannel|Snowflake} channel Parent channel
   * @param {Object} [options={}] Options to pass
   * @param {boolean} [options.lockPermissions=true] Lock the permissions to what the parent's permissions are
   * @param {string} [options.reason] Reason for modifying the parent of this channel
   * @returns {Promise<GuildChannel>}
   */
}

module.exports = CategoryChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Channel.js":
/*!***********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Channel.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const { ChannelTypes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");

/**
 * Represents any channel on Discord.
 * @extends {Base}
 * @abstract
 */
class Channel extends Base {
  constructor(client, data) {
    super(client);

    const type = Object.keys(ChannelTypes)[data.type];
    /**
     * The type of the channel, either:
     * * `dm` - a DM channel
     * * `text` - a guild text channel
     * * `voice` - a guild voice channel
     * * `category` - a guild category channel
     * * `news` - a guild news channel
     * * `store` - a guild store channel
     * * `unknown` - a generic channel of unknown type, could be Channel or GuildChannel
     * @type {string}
     */
    this.type = type ? type.toLowerCase() : 'unknown';

    /**
     * Whether the channel has been deleted
     * @type {boolean}
     */
    this.deleted = false;

    if (data) this._patch(data);
  }

  _patch(data) {
    /**
     * The unique ID of the channel
     * @type {Snowflake}
     */
    this.id = data.id;
  }

  /**
   * The timestamp the channel was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the channel was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.
   * @returns {string}
   * @example
   * // Logs: Hello from <#123456789012345678>!
   * console.log(`Hello from ${channel}!`);
   */
  toString() {
    return `<#${this.id}>`;
  }

  /**
   * Deletes this channel.
   * @returns {Promise<Channel>}
   * @example
   * // Delete the channel
   * channel.delete()
   *   .then(console.log)
   *   .catch(console.error);
   */
  delete() {
    return this.client.api
      .channels(this.id)
      .delete()
      .then(() => this);
  }

  /**
   * Fetches this channel.
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<Channel>}
   */
  fetch(force = false) {
    return this.client.channels.fetch(this.id, true, force);
  }

  /**
   * Indicates whether this channel is text-based.
   * @returns {boolean}
   */
  isText() {
    return 'messages' in this;
  }

  static create(client, data, guild) {
    const Structures = __webpack_require__(/*! ../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");
    let channel;
    if (!data.guild_id && !guild) {
      if ((data.recipients && data.type !== ChannelTypes.GROUP) || data.type === ChannelTypes.DM) {
        const DMChannel = Structures.get('DMChannel');
        channel = new DMChannel(client, data);
      } else if (data.type === ChannelTypes.GROUP) {
        const PartialGroupDMChannel = __webpack_require__(/*! ./PartialGroupDMChannel */ "./node_modules/discord.js/src/structures/PartialGroupDMChannel.js");
        channel = new PartialGroupDMChannel(client, data);
      }
    } else {
      guild = guild || client.guilds.cache.get(data.guild_id);
      if (guild) {
        switch (data.type) {
          case ChannelTypes.TEXT: {
            const TextChannel = Structures.get('TextChannel');
            channel = new TextChannel(guild, data);
            break;
          }
          case ChannelTypes.VOICE: {
            const VoiceChannel = Structures.get('VoiceChannel');
            channel = new VoiceChannel(guild, data);
            break;
          }
          case ChannelTypes.CATEGORY: {
            const CategoryChannel = Structures.get('CategoryChannel');
            channel = new CategoryChannel(guild, data);
            break;
          }
          case ChannelTypes.NEWS: {
            const NewsChannel = Structures.get('NewsChannel');
            channel = new NewsChannel(guild, data);
            break;
          }
          case ChannelTypes.STORE: {
            const StoreChannel = Structures.get('StoreChannel');
            channel = new StoreChannel(guild, data);
            break;
          }
        }
        if (channel) guild.channels.cache.set(channel.id, channel);
      }
    }
    return channel;
  }

  toJSON(...props) {
    return super.toJSON({ createdTimestamp: true }, ...props);
  }
}

module.exports = Channel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/ClientApplication.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/ClientApplication.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Team = __webpack_require__(/*! ./Team */ "./node_modules/discord.js/src/structures/Team.js");
const Application = __webpack_require__(/*! ./interfaces/Application */ "./node_modules/discord.js/src/structures/interfaces/Application.js");

/**
 * Represents a Client OAuth2 Application.
 * @extends {Application}
 */
class ClientApplication extends Application {
  _patch(data) {
    super._patch(data);

    /**
     * The app's cover image
     * @type {?string}
     */
    this.cover = data.cover_image || null;

    /**
     * The app's RPC origins, if enabled
     * @type {string[]}
     */
    this.rpcOrigins = data.rpc_origins || [];

    /**
     * If this app's bot requires a code grant when using the OAuth2 flow
     * @type {?boolean}
     */
    this.botRequireCodeGrant = typeof data.bot_require_code_grant !== 'undefined' ? data.bot_require_code_grant : null;

    /**
     * If this app's bot is public
     * @type {?boolean}
     */
    this.botPublic = typeof data.bot_public !== 'undefined' ? data.bot_public : null;

    /**
     * The owner of this OAuth application
     * @type {?User|Team}
     */
    this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users.add(data.owner) : null;
  }
}

module.exports = ClientApplication;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/ClientPresence.js":
/*!******************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/ClientPresence.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Presence } = __webpack_require__(/*! ./Presence */ "./node_modules/discord.js/src/structures/Presence.js");
const { TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { ActivityTypes, OPCodes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

class ClientPresence extends Presence {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} [data={}] The data for the client presence
   */
  constructor(client, data = {}) {
    super(client, Object.assign(data, { status: 'online', user: { id: null } }));
  }

  async set(presence) {
    const packet = await this._parse(presence);
    this.patch(packet);
    if (typeof presence.shardID === 'undefined') {
      this.client.ws.broadcast({ op: OPCodes.STATUS_UPDATE, d: packet });
    } else if (Array.isArray(presence.shardID)) {
      for (const shardID of presence.shardID) {
        this.client.ws.shards.get(shardID).send({ op: OPCodes.STATUS_UPDATE, d: packet });
      }
    } else {
      this.client.ws.shards.get(presence.shardID).send({ op: OPCodes.STATUS_UPDATE, d: packet });
    }
    return this;
  }

  async _parse({ status, since, afk, activity }) {
    const applicationID = activity && (activity.application ? activity.application.id || activity.application : null);
    let assets = new Collection();
    if (activity) {
      if (typeof activity.name !== 'string') throw new TypeError('INVALID_TYPE', 'name', 'string');
      if (!activity.type) activity.type = 0;
      if (activity.assets && applicationID) {
        try {
          const a = await this.client.api.oauth2.applications(applicationID).assets.get();
          for (const asset of a) assets.set(asset.name, asset.id);
        } catch {} // eslint-disable-line no-empty
      }
    }

    const packet = {
      afk: afk != null ? afk : false, // eslint-disable-line eqeqeq
      since: since != null ? since : null, // eslint-disable-line eqeqeq
      status: status || this.status,
      game: activity
        ? {
            type: activity.type,
            name: activity.name,
            url: activity.url,
            details: activity.details || undefined,
            state: activity.state || undefined,
            assets: activity.assets
              ? {
                  large_text: activity.assets.largeText || undefined,
                  small_text: activity.assets.smallText || undefined,
                  large_image: assets.get(activity.assets.largeImage) || activity.assets.largeImage,
                  small_image: assets.get(activity.assets.smallImage) || activity.assets.smallImage,
                }
              : undefined,
            timestamps: activity.timestamps || undefined,
            party: activity.party || undefined,
            application_id: applicationID || undefined,
            secrets: activity.secrets || undefined,
            instance: activity.instance || undefined,
          }
        : null,
    };

    if ((status || afk || since) && !activity) {
      packet.game = this.activities[0] || null;
    }

    if (packet.game) {
      packet.game.type =
        typeof packet.game.type === 'number' ? packet.game.type : ActivityTypes.indexOf(packet.game.type);
    }

    return packet;
  }
}

module.exports = ClientPresence;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/ClientUser.js":
/*!**************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/ClientUser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");
const Structures = __webpack_require__(/*! ../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");

/**
 * Represents the logged in client's Discord user.
 * @extends {User}
 */
class ClientUser extends Structures.get('User') {
  constructor(client, data) {
    super(client, data);
    this._typing = new Map();
  }

  _patch(data) {
    super._patch(data);

    if ('verified' in data) {
      /**
       * Whether or not this account has been verified
       * @type {boolean}
       */
      this.verified = data.verified;
    }

    if ('mfa_enabled' in data) {
      /**
       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account
       * @type {?boolean}
       */
      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;
    } else if (typeof this.mfaEnabled === 'undefined') {
      this.mfaEnabled = null;
    }

    if (data.token) this.client.token = data.token;
  }

  /**
   * ClientUser's presence
   * @type {Presence}
   * @readonly
   */
  get presence() {
    return this.client.presence;
  }

  edit(data) {
    return this.client.api
      .users('@me')
      .patch({ data })
      .then(newData => {
        this.client.token = newData.token;
        const { updated } = this.client.actions.UserUpdate.handle(newData);
        if (updated) return updated;
        return this;
      });
  }

  /**
   * Sets the username of the logged in client.
   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests
   * every hour. Use this sparingly!</info>
   * @param {string} username The new username
   * @returns {Promise<ClientUser>}
   * @example
   * // Set username
   * client.user.setUsername('discordjs')
   *   .then(user => console.log(`My new username is ${user.username}`))
   *   .catch(console.error);
   */
  setUsername(username) {
    return this.edit({ username });
  }

  /**
   * Sets the avatar of the logged in client.
   * @param {BufferResolvable|Base64Resolvable} avatar The new avatar
   * @returns {Promise<ClientUser>}
   * @example
   * // Set avatar
   * client.user.setAvatar('./avatar.png')
   *   .then(user => console.log(`New avatar set!`))
   *   .catch(console.error);
   */
  async setAvatar(avatar) {
    return this.edit({ avatar: await DataResolver.resolveImage(avatar) });
  }

  /**
   * Data resembling a raw Discord presence.
   * @typedef {Object} PresenceData
   * @property {PresenceStatusData} [status] Status of the user
   * @property {boolean} [afk] Whether the user is AFK
   * @property {Object} [activity] Activity the user is playing
   * @property {string} [activity.name] Name of the activity
   * @property {ActivityType|number} [activity.type] Type of the activity
   * @property {string} [activity.url] Twitch / YouTube stream URL
   * @property {?number|number[]} [shardID] Shard Id(s) to have the activity set on
   */

  /**
   * Sets the full presence of the client user.
   * @param {PresenceData} data Data for the presence
   * @returns {Promise<Presence>}
   * @example
   * // Set the client user's presence
   * client.user.setPresence({ activity: { name: 'with discord.js' }, status: 'idle' })
   *   .then(console.log)
   *   .catch(console.error);
   */
  setPresence(data) {
    return this.client.presence.set(data);
  }

  /**
   * A user's status. Must be one of:
   * * `online`
   * * `idle`
   * * `invisible`
   * * `dnd` (do not disturb)
   * @typedef {string} PresenceStatusData
   */

  /**
   * Sets the status of the client user.
   * @param {PresenceStatusData} status Status to change to
   * @param {?number|number[]} [shardID] Shard ID(s) to have the activity set on
   * @returns {Promise<Presence>}
   * @example
   * // Set the client user's status
   * client.user.setStatus('idle')
   *   .then(console.log)
   *   .catch(console.error);
   */
  setStatus(status, shardID) {
    return this.setPresence({ status, shardID });
  }

  /**
   * Options for setting an activity.
   * @typedef ActivityOptions
   * @type {Object}
   * @property {string} [url] Twitch / YouTube stream URL
   * @property {ActivityType|number} [type] Type of the activity
   * @property {?number|number[]} [shardID] Shard Id(s) to have the activity set on
   */

  /**
   * Sets the activity the client user is playing.
   * @param {string|ActivityOptions} [name] Activity being played, or options for setting the activity
   * @param {ActivityOptions} [options] Options for setting the activity
   * @returns {Promise<Presence>}
   * @example
   * // Set the client user's activity
   * client.user.setActivity('discord.js', { type: 'WATCHING' })
   *   .then(presence => console.log(`Activity set to ${presence.activities[0].name}`))
   *   .catch(console.error);
   */
  setActivity(name, options = {}) {
    if (!name) return this.setPresence({ activity: null, shardID: options.shardID });

    const activity = Object.assign({}, options, typeof name === 'object' ? name : { name });
    return this.setPresence({ activity, shardID: activity.shardID });
  }

  /**
   * Sets/removes the AFK flag for the client user.
   * @param {boolean} afk Whether or not the user is AFK
   * @returns {Promise<Presence>}
   */
  setAFK(afk) {
    return this.setPresence({ afk });
  }
}

module.exports = ClientUser;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/DMChannel.js":
/*!*************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/DMChannel.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Channel = __webpack_require__(/*! ./Channel */ "./node_modules/discord.js/src/structures/Channel.js");
const TextBasedChannel = __webpack_require__(/*! ./interfaces/TextBasedChannel */ "./node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js");
const MessageManager = __webpack_require__(/*! ../managers/MessageManager */ "./node_modules/discord.js/src/managers/MessageManager.js");

/**
 * Represents a direct message channel between two users.
 * @extends {Channel}
 * @implements {TextBasedChannel}
 */
class DMChannel extends Channel {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the DM channel
   */
  constructor(client, data) {
    super(client, data);
    // Override the channel type so partials have a known type
    this.type = 'dm';
    /**
     * A manager of the messages belonging to this channel
     * @type {MessageManager}
     */
    this.messages = new MessageManager(this);
    this._typing = new Map();
  }

  _patch(data) {
    super._patch(data);

    if (data.recipients) {
      /**
       * The recipient on the other end of the DM
       * @type {User}
       */
      this.recipient = this.client.users.add(data.recipients[0]);
    }

    /**
     * The ID of the last message in the channel, if one was sent
     * @type {?Snowflake}
     */
    this.lastMessageID = data.last_message_id;

    /**
     * The timestamp when the last pinned message was pinned, if there was one
     * @type {?number}
     */
    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
  }

  /**
   * Whether this DMChannel is a partial
   * @type {boolean}
   * @readonly
   */
  get partial() {
    return typeof this.lastMessageID === 'undefined';
  }

  /**
   * Fetch this DMChannel.
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<DMChannel>}
   */
  fetch(force = false) {
    return this.recipient.createDM(force);
  }

  /**
   * When concatenated with a string, this automatically returns the recipient's mention instead of the
   * DMChannel object.
   * @returns {string}
   * @example
   * // Logs: Hello from <@123456789012345678>!
   * console.log(`Hello from ${channel}!`);
   */
  toString() {
    return this.recipient.toString();
  }

  // These are here only for documentation purposes - they are implemented by TextBasedChannel
  /* eslint-disable no-empty-function */
  get lastMessage() {}
  get lastPinAt() {}
  send() {}
  startTyping() {}
  stopTyping() {}
  get typing() {}
  get typingCount() {}
  createMessageCollector() {}
  awaitMessages() {}
  // Doesn't work on DM channels; bulkDelete() {}
}

TextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);

module.exports = DMChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Emoji.js":
/*!*********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Emoji.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");

/**
 * Represents an emoji, see {@link GuildEmoji} and {@link ReactionEmoji}.
 * @extends {Base}
 */
class Emoji extends Base {
  constructor(client, emoji) {
    super(client);
    /**
     * Whether this emoji is animated
     * @type {boolean}
     */
    this.animated = emoji.animated;

    /**
     * The name of this emoji
     * @type {string}
     */
    this.name = emoji.name;

    /**
     * The ID of this emoji
     * @type {?Snowflake}
     */
    this.id = emoji.id;

    /**
     * Whether this emoji has been deleted
     * @type {boolean}
     */
    this.deleted = false;
  }

  /**
   * The identifier of this emoji, used for message reactions
   * @type {string}
   * @readonly
   */
  get identifier() {
    if (this.id) return `${this.animated ? 'a:' : ''}${this.name}:${this.id}`;
    return encodeURIComponent(this.name);
  }

  /**
   * The URL to the emoji file if its a custom emoji
   * @type {?string}
   * @readonly
   */
  get url() {
    if (!this.id) return null;
    return this.client.rest.cdn.Emoji(this.id, this.animated ? 'gif' : 'png');
  }

  /**
   * The timestamp the emoji was created at, or null if unicode
   * @type {?number}
   * @readonly
   */
  get createdTimestamp() {
    if (!this.id) return null;
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the emoji was created at, or null if unicode
   * @type {?Date}
   * @readonly
   */
  get createdAt() {
    if (!this.id) return null;
    return new Date(this.createdTimestamp);
  }

  /**
   * When concatenated with a string, this automatically returns the text required to form a graphical emoji on Discord
   * instead of the Emoji object.
   * @returns {string}
   * @example
   * // Send a custom emoji from a guild:
   * const emoji = guild.emojis.cache.first();
   * msg.reply(`Hello! ${emoji}`);
   * @example
   * // Send the emoji used in a reaction to the channel the reaction is part of
   * reaction.message.channel.send(`The emoji used was: ${reaction.emoji}`);
   */
  toString() {
    return this.id ? `<${this.animated ? 'a' : ''}:${this.name}:${this.id}>` : this.name;
  }

  toJSON() {
    return super.toJSON({
      guild: 'guildID',
      createdTimestamp: true,
      url: true,
      identifier: true,
    });
  }
}

module.exports = Emoji;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Guild.js":
/*!*********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Guild.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { deprecate } = __webpack_require__(/*! util */ "?0bed");
const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const GuildAuditLogs = __webpack_require__(/*! ./GuildAuditLogs */ "./node_modules/discord.js/src/structures/GuildAuditLogs.js");
const GuildPreview = __webpack_require__(/*! ./GuildPreview */ "./node_modules/discord.js/src/structures/GuildPreview.js");
const GuildTemplate = __webpack_require__(/*! ./GuildTemplate */ "./node_modules/discord.js/src/structures/GuildTemplate.js");
const Integration = __webpack_require__(/*! ./Integration */ "./node_modules/discord.js/src/structures/Integration.js");
const Invite = __webpack_require__(/*! ./Invite */ "./node_modules/discord.js/src/structures/Invite.js");
const VoiceRegion = __webpack_require__(/*! ./VoiceRegion */ "./node_modules/discord.js/src/structures/VoiceRegion.js");
const Webhook = __webpack_require__(/*! ./Webhook */ "./node_modules/discord.js/src/structures/Webhook.js");
const { Error, TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const GuildChannelManager = __webpack_require__(/*! ../managers/GuildChannelManager */ "./node_modules/discord.js/src/managers/GuildChannelManager.js");
const GuildEmojiManager = __webpack_require__(/*! ../managers/GuildEmojiManager */ "./node_modules/discord.js/src/managers/GuildEmojiManager.js");
const GuildMemberManager = __webpack_require__(/*! ../managers/GuildMemberManager */ "./node_modules/discord.js/src/managers/GuildMemberManager.js");
const PresenceManager = __webpack_require__(/*! ../managers/PresenceManager */ "./node_modules/discord.js/src/managers/PresenceManager.js");
const RoleManager = __webpack_require__(/*! ../managers/RoleManager */ "./node_modules/discord.js/src/managers/RoleManager.js");
const VoiceStateManager = __webpack_require__(/*! ../managers/VoiceStateManager */ "./node_modules/discord.js/src/managers/VoiceStateManager.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const {
  browser,
  ChannelTypes,
  DefaultMessageNotifications,
  PartialTypes,
  VerificationLevels,
  ExplicitContentFilterLevels,
} = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");
const SystemChannelFlags = __webpack_require__(/*! ../util/SystemChannelFlags */ "./node_modules/discord.js/src/util/SystemChannelFlags.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a guild (or a server) on Discord.
 * <info>It's recommended to see if a guild is available before performing operations or reading data from it. You can
 * check this with `guild.available`.</info>
 * @extends {Base}
 */
class Guild extends Base {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the guild
   */
  constructor(client, data) {
    super(client);

    /**
     * A manager of the members belonging to this guild
     * @type {GuildMemberManager}
     */
    this.members = new GuildMemberManager(this);

    /**
     * A manager of the channels belonging to this guild
     * @type {GuildChannelManager}
     */
    this.channels = new GuildChannelManager(this);

    /**
     * A manager of the roles belonging to this guild
     * @type {RoleManager}
     */
    this.roles = new RoleManager(this);

    /**
     * A manager of the presences belonging to this guild
     * @type {PresenceManager}
     */
    this.presences = new PresenceManager(this.client);

    /**
     * A manager of the voice states of this guild
     * @type {VoiceStateManager}
     */
    this.voiceStates = new VoiceStateManager(this);

    /**
     * Whether the bot has been removed from the guild
     * @type {boolean}
     */
    this.deleted = false;

    if (!data) return;
    if (data.unavailable) {
      /**
       * Whether the guild is available to access. If it is not available, it indicates a server outage
       * @type {boolean}
       */
      this.available = false;

      /**
       * The Unique ID of the guild, useful for comparisons
       * @type {Snowflake}
       */
      this.id = data.id;
    } else {
      this._patch(data);
      if (!data.channels) this.available = false;
    }

    /**
     * The id of the shard this Guild belongs to.
     * @type {number}
     */
    this.shardID = data.shardID;
  }

  /**
   * The Shard this Guild belongs to.
   * @type {WebSocketShard}
   * @readonly
   */
  get shard() {
    return this.client.ws.shards.get(this.shardID);
  }

  /**
   * Sets up the guild.
   * @param {*} data The raw data of the guild
   * @private
   */
  _patch(data) {
    /**
     * The name of the guild
     * @type {string}
     */
    this.name = data.name;

    /**
     * The hash of the guild icon
     * @type {?string}
     */
    this.icon = data.icon;

    /**
     * The hash of the guild invite splash image
     * @type {?string}
     */
    this.splash = data.splash;

    /**
     * The hash of the guild discovery splash image
     * @type {?string}
     */
    this.discoverySplash = data.discovery_splash;

    /**
     * The region the guild is located in
     * @type {string}
     */
    this.region = data.region;

    /**
     * The full amount of members in this guild
     * @type {number}
     */
    this.memberCount = data.member_count || this.memberCount;

    /**
     * Whether the guild is "large" (has more than large_threshold members, 50 by default)
     * @type {boolean}
     */
    this.large = Boolean('large' in data ? data.large : this.large);

    /**
     * An array of enabled guild features, here are the possible values:
     * * ANIMATED_ICON
     * * BANNER
     * * COMMERCE
     * * COMMUNITY
     * * DISCOVERABLE
     * * FEATURABLE
     * * INVITE_SPLASH
     * * NEWS
     * * PARTNERED
     * * RELAY_ENABLED
     * * VANITY_URL
     * * VERIFIED
     * * VIP_REGIONS
     * * WELCOME_SCREEN_ENABLED
     * @typedef {string} Features
     */

    /**
     * An array of guild features partnered guilds have enabled
     * @type {Features[]}
     */
    this.features = data.features;

    /**
     * The ID of the application that created this guild (if applicable)
     * @type {?Snowflake}
     */
    this.applicationID = data.application_id;

    /**
     * The time in seconds before a user is counted as "away from keyboard"
     * @type {?number}
     */
    this.afkTimeout = data.afk_timeout;

    /**
     * The ID of the voice channel where AFK members are moved
     * @type {?Snowflake}
     */
    this.afkChannelID = data.afk_channel_id;

    /**
     * The ID of the system channel
     * @type {?Snowflake}
     */
    this.systemChannelID = data.system_channel_id;

    /**
     * Whether embedded images are enabled on this guild
     * @type {boolean}
     * @deprecated
     */
    this.embedEnabled = data.embed_enabled;

    /**
     * The type of premium tier:
     * * 0: NONE
     * * 1: TIER_1
     * * 2: TIER_2
     * * 3: TIER_3
     * @typedef {number} PremiumTier
     */

    /**
     * The premium tier on this guild
     * @type {PremiumTier}
     */
    this.premiumTier = data.premium_tier;

    if (typeof data.premium_subscription_count !== 'undefined') {
      /**
       * The total number of boosts for this server
       * @type {?number}
       */
      this.premiumSubscriptionCount = data.premium_subscription_count;
    }

    if (typeof data.widget_enabled !== 'undefined') {
      /**
       * Whether widget images are enabled on this guild
       * @type {?boolean}
       */
      this.widgetEnabled = data.widget_enabled;
    }

    if (typeof data.widget_channel_id !== 'undefined') {
      /**
       * The widget channel ID, if enabled
       * @type {?string}
       */
      this.widgetChannelID = data.widget_channel_id;
    }

    if (typeof data.embed_channel_id !== 'undefined') {
      /**
       * The embed channel ID, if enabled
       * @type {?string}
       * @deprecated
       */
      this.embedChannelID = data.embed_channel_id;
    }

    /**
     * The verification level of the guild
     * @type {VerificationLevel}
     */
    this.verificationLevel = VerificationLevels[data.verification_level];

    /**
     * The explicit content filter level of the guild
     * @type {ExplicitContentFilterLevel}
     */
    this.explicitContentFilter = ExplicitContentFilterLevels[data.explicit_content_filter];

    /**
     * The required MFA level for the guild
     * @type {number}
     */
    this.mfaLevel = data.mfa_level;

    /**
     * The timestamp the client user joined the guild at
     * @type {number}
     */
    this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp;

    /**
     * The value set for the guild's default message notifications
     * @type {DefaultMessageNotifications|number}
     */
    this.defaultMessageNotifications =
      DefaultMessageNotifications[data.default_message_notifications] || data.default_message_notifications;

    /**
     * The value set for the guild's system channel flags
     * @type {Readonly<SystemChannelFlags>}
     */
    this.systemChannelFlags = new SystemChannelFlags(data.system_channel_flags).freeze();

    if (typeof data.max_members !== 'undefined') {
      /**
       * The maximum amount of members the guild can have
       * @type {?number}
       */
      this.maximumMembers = data.max_members;
    } else if (typeof this.maximumMembers === 'undefined') {
      this.maximumMembers = null;
    }

    if (typeof data.max_presences !== 'undefined') {
      /**
       * The maximum amount of presences the guild can have
       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>
       * @type {?number}
       */
      this.maximumPresences = data.max_presences || 25000;
    } else if (typeof this.maximumPresences === 'undefined') {
      this.maximumPresences = null;
    }

    if (typeof data.approximate_member_count !== 'undefined') {
      /**
       * The approximate amount of members the guild has
       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>
       * @type {?number}
       */
      this.approximateMemberCount = data.approximate_member_count;
    } else if (typeof this.approximateMemberCount === 'undefined') {
      this.approximateMemberCount = null;
    }

    if (typeof data.approximate_presence_count !== 'undefined') {
      /**
       * The approximate amount of presences the guild has
       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>
       * @type {?number}
       */
      this.approximatePresenceCount = data.approximate_presence_count;
    } else if (typeof this.approximatePresenceCount === 'undefined') {
      this.approximatePresenceCount = null;
    }

    /**
     * The vanity invite code of the guild, if any
     * @type {?string}
     */
    this.vanityURLCode = data.vanity_url_code;

    /* eslint-disable max-len */
    /**
     * The use count of the vanity URL code of the guild, if any
     * <info>You will need to fetch this parameter using {@link Guild#fetchVanityData} if you want to receive it</info>
     * @type {?number}
     */
    this.vanityURLUses = null;
    /* eslint-enable max-len */

    /**
     * The description of the guild, if any
     * @type {?string}
     */
    this.description = data.description;

    /**
     * The hash of the guild banner
     * @type {?string}
     */
    this.banner = data.banner;

    this.id = data.id;
    this.available = !data.unavailable;
    this.features = data.features || this.features || [];

    /**
     * The ID of the rules channel for the guild
     * @type {?Snowflake}
     */
    this.rulesChannelID = data.rules_channel_id;

    /**
     * The ID of the community updates channel for the guild
     * @type {?Snowflake}
     */
    this.publicUpdatesChannelID = data.public_updates_channel_id;

    /**
     * The preferred locale of the guild, defaults to `en-US`
     * @type {string}
     */
    this.preferredLocale = data.preferred_locale;

    if (data.channels) {
      this.channels.cache.clear();
      for (const rawChannel of data.channels) {
        this.client.channels.add(rawChannel, this);
      }
    }

    if (data.roles) {
      this.roles.cache.clear();
      for (const role of data.roles) this.roles.add(role);
    }

    if (data.members) {
      this.members.cache.clear();
      for (const guildUser of data.members) this.members.add(guildUser);
    }

    if (data.owner_id) {
      /**
       * The user ID of this guild's owner
       * @type {Snowflake}
       */
      this.ownerID = data.owner_id;
    }

    if (data.presences) {
      for (const presence of data.presences) {
        this.presences.add(Object.assign(presence, { guild: this }));
      }
    }

    if (data.voice_states) {
      this.voiceStates.cache.clear();
      for (const voiceState of data.voice_states) {
        this.voiceStates.add(voiceState);
      }
    }

    if (!this.emojis) {
      /**
       * A manager of the emojis belonging to this guild
       * @type {GuildEmojiManager}
       */
      this.emojis = new GuildEmojiManager(this);
      if (data.emojis) for (const emoji of data.emojis) this.emojis.add(emoji);
    } else if (data.emojis) {
      this.client.actions.GuildEmojisUpdate.handle({
        guild_id: this.id,
        emojis: data.emojis,
      });
    }
  }

  /**
   * The URL to this guild's banner.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  bannerURL({ format, size } = {}) {
    if (!this.banner) return null;
    return this.client.rest.cdn.Banner(this.id, this.banner, format, size);
  }

  /**
   * The timestamp the guild was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the guild was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * The time the client user joined the guild
   * @type {Date}
   * @readonly
   */
  get joinedAt() {
    return new Date(this.joinedTimestamp);
  }

  /**
   * If this guild is partnered
   * @type {boolean}
   * @readonly
   */
  get partnered() {
    return this.features.includes('PARTNERED');
  }

  /**
   * If this guild is verified
   * @type {boolean}
   * @readonly
   */
  get verified() {
    return this.features.includes('VERIFIED');
  }

  /**
   * The URL to this guild's icon.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  iconURL({ format, size, dynamic } = {}) {
    if (!this.icon) return null;
    return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);
  }

  /**
   * The acronym that shows up in place of a guild icon.
   * @type {string}
   * @readonly
   */
  get nameAcronym() {
    return this.name
      .replace(/'s /g, ' ')
      .replace(/\w+/g, e => e[0])
      .replace(/\s/g, '');
  }

  /**
   * The URL to this guild's invite splash image.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  splashURL({ format, size } = {}) {
    if (!this.splash) return null;
    return this.client.rest.cdn.Splash(this.id, this.splash, format, size);
  }

  /**
   * The URL to this guild's discovery splash image.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  discoverySplashURL({ format, size } = {}) {
    if (!this.discoverySplash) return null;
    return this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);
  }

  /**
   * The owner of the guild
   * @type {?GuildMember}
   * @readonly
   */
  get owner() {
    return (
      this.members.cache.get(this.ownerID) ||
      (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER)
        ? this.members.add({ user: { id: this.ownerID } }, true)
        : null)
    );
  }

  /**
   * AFK voice channel for this guild
   * @type {?VoiceChannel}
   * @readonly
   */
  get afkChannel() {
    return this.client.channels.cache.get(this.afkChannelID) || null;
  }

  /**
   * System channel for this guild
   * @type {?TextChannel}
   * @readonly
   */
  get systemChannel() {
    return this.client.channels.cache.get(this.systemChannelID) || null;
  }

  /**
   * Widget channel for this guild
   * @type {?TextChannel}
   * @readonly
   */
  get widgetChannel() {
    return this.client.channels.cache.get(this.widgetChannelID) || null;
  }

  /**
   * Embed channel for this guild
   * @type {?TextChannel}
   * @readonly
   * @deprecated
   */
  get embedChannel() {
    return this.client.channels.cache.get(this.embedChannelID) || null;
  }

  /**
   * Rules channel for this guild
   * @type {?TextChannel}
   * @readonly
   */
  get rulesChannel() {
    return this.client.channels.cache.get(this.rulesChannelID) || null;
  }

  /**
   * Public updates channel for this guild
   * @type {?TextChannel}
   * @readonly
   */
  get publicUpdatesChannel() {
    return this.client.channels.cache.get(this.publicUpdatesChannelID) || null;
  }

  /**
   * The client user as a GuildMember of this guild
   * @type {?GuildMember}
   * @readonly
   */
  get me() {
    return (
      this.members.cache.get(this.client.user.id) ||
      (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER)
        ? this.members.add({ user: { id: this.client.user.id } }, true)
        : null)
    );
  }

  /**
   * The voice state for the client user of this guild, if any
   * @type {?VoiceState}
   * @readonly
   */
  get voice() {
    return this.voiceStates.cache.get(this.client.user.id);
  }

  /**
   * Returns the GuildMember form of a User object, if the user is present in the guild.
   * @param {UserResolvable} user The user that you want to obtain the GuildMember of
   * @returns {?GuildMember}
   * @example
   * // Get the guild member of a user
   * const member = guild.member(message.author);
   */
  member(user) {
    return this.members.resolve(user);
  }

  /**
   * Fetches this guild.
   * @returns {Promise<Guild>}
   */
  fetch() {
    return this.client.api
      .guilds(this.id)
      .get({ query: { with_counts: true } })
      .then(data => {
        this._patch(data);
        return this;
      });
  }

  /**
   * An object containing information about a guild member's ban.
   * @typedef {Object} BanInfo
   * @property {User} user User that was banned
   * @property {?string} reason Reason the user was banned
   */

  /**
   * Fetches information on a banned user from this guild.
   * @param {UserResolvable} user The User to fetch the ban info of
   * @returns {Promise<BanInfo>}
   */
  fetchBan(user) {
    const id = this.client.users.resolveID(user);
    if (!id) throw new Error('FETCH_BAN_RESOLVE_ID');
    return this.client.api
      .guilds(this.id)
      .bans(id)
      .get()
      .then(ban => ({
        reason: ban.reason,
        user: this.client.users.add(ban.user),
      }));
  }

  /**
   * Fetches a collection of banned users in this guild.
   * @returns {Promise<Collection<Snowflake, BanInfo>>}
   */
  fetchBans() {
    return this.client.api
      .guilds(this.id)
      .bans.get()
      .then(bans =>
        bans.reduce((collection, ban) => {
          collection.set(ban.user.id, {
            reason: ban.reason,
            user: this.client.users.add(ban.user),
          });
          return collection;
        }, new Collection()),
      );
  }

  /**
   * Fetches a collection of integrations to this guild.
   * Resolves with a collection mapping integrations by their ids.
   * @param {Object} [options] Options for fetching integrations
   * @param {boolean} [options.includeApplications] Whether to include bot and Oauth2 webhook integrations
   * @returns {Promise<Collection<string, Integration>>}
   * @example
   * // Fetch integrations
   * guild.fetchIntegrations()
   *   .then(integrations => console.log(`Fetched ${integrations.size} integrations`))
   *   .catch(console.error);
   */
  fetchIntegrations({ includeApplications = false } = {}) {
    return this.client.api
      .guilds(this.id)
      .integrations.get({
        query: {
          include_applications: includeApplications,
        },
      })
      .then(data =>
        data.reduce(
          (collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)),
          new Collection(),
        ),
      );
  }

  /**
   * Fetches a collection of templates from this guild.
   * Resolves with a collection mapping templates by their codes.
   * @returns {Promise<Collection<string, GuildTemplate>>}
   */
  fetchTemplates() {
    return this.client.api
      .guilds(this.id)
      .templates.get()
      .then(templates =>
        templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection()),
      );
  }

  /**
   * The data for creating an integration.
   * @typedef {Object} IntegrationData
   * @property {string} id The integration id
   * @property {string} type The integration type
   */

  /**
   * Creates an integration by attaching an integration object
   * @param {IntegrationData} data The data for the integration
   * @param {string} reason Reason for creating the integration
   * @returns {Promise<Guild>}
   */
  createIntegration(data, reason) {
    return this.client.api
      .guilds(this.id)
      .integrations.post({ data, reason })
      .then(() => this);
  }

  /**
   * Creates a template for the guild.
   * @param {string} name The name for the template
   * @param {string} [description] The description for the template
   * @returns {Promise<GuildTemplate>}
   */
  createTemplate(name, description) {
    return this.client.api
      .guilds(this.id)
      .templates.post({ data: { name, description } })
      .then(data => new GuildTemplate(this.client, data));
  }

  /**
   * Fetches a collection of invites to this guild.
   * Resolves with a collection mapping invites by their codes.
   * @returns {Promise<Collection<string, Invite>>}
   * @example
   * // Fetch invites
   * guild.fetchInvites()
   *   .then(invites => console.log(`Fetched ${invites.size} invites`))
   *   .catch(console.error);
   * @example
   * // Fetch invite creator by their id
   * guild.fetchInvites()
   *  .then(invites => console.log(invites.find(invite => invite.inviter.id === '84484653687267328')))
   *  .catch(console.error);
   */
  fetchInvites() {
    return this.client.api
      .guilds(this.id)
      .invites.get()
      .then(inviteItems => {
        const invites = new Collection();
        for (const inviteItem of inviteItems) {
          const invite = new Invite(this.client, inviteItem);
          invites.set(invite.code, invite);
        }
        return invites;
      });
  }

  /**
   * Obtains a guild preview for this guild from Discord.
   * @returns {Promise<GuildPreview>}
   */
  fetchPreview() {
    return this.client.api
      .guilds(this.id)
      .preview.get()
      .then(data => new GuildPreview(this.client, data));
  }

  /**
   * Fetches the vanity url invite code to this guild.
   * Resolves with a string matching the vanity url invite code, not the full url.
   * @returns {Promise<string>}
   * @deprecated
   * @example
   * // Fetch invites
   * guild.fetchVanityCode()
   *   .then(code => {
   *     console.log(`Vanity URL: https://discord.gg/${code}`);
   *   })
   *   .catch(console.error);
   */
  fetchVanityCode() {
    return this.fetchVanityData().then(vanity => vanity.code);
  }

  /**
   * An object containing information about a guild's vanity invite.
   * @typedef {Object} Vanity
   * @property {?string} code Vanity invite code
   * @property {?number} uses How many times this invite has been used
   */

  /**
   * Fetches the vanity url invite object to this guild.
   * Resolves with an object containing the vanity url invite code and the use count
   * @returns {Promise<Vanity>}
   * @example
   * // Fetch invite data
   * guild.fetchVanityData()
   *   .then(res => {
   *     console.log(`Vanity URL: https://discord.gg/${res.code} with ${res.uses} uses`);
   *   })
   *   .catch(console.error);
   */
  async fetchVanityData() {
    if (!this.features.includes('VANITY_URL')) {
      throw new Error('VANITY_URL');
    }
    const data = await this.client.api.guilds(this.id, 'vanity-url').get();
    this.vanityURLUses = data.uses;

    return data;
  }

  /**
   * Fetches all webhooks for the guild.
   * @returns {Promise<Collection<Snowflake, Webhook>>}
   * @example
   * // Fetch webhooks
   * guild.fetchWebhooks()
   *   .then(webhooks => console.log(`Fetched ${webhooks.size} webhooks`))
   *   .catch(console.error);
   */
  fetchWebhooks() {
    return this.client.api
      .guilds(this.id)
      .webhooks.get()
      .then(data => {
        const hooks = new Collection();
        for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));
        return hooks;
      });
  }

  /**
   * Fetches available voice regions.
   * @returns {Promise<Collection<string, VoiceRegion>>}
   */
  fetchVoiceRegions() {
    return this.client.api
      .guilds(this.id)
      .regions.get()
      .then(res => {
        const regions = new Collection();
        for (const region of res) regions.set(region.id, new VoiceRegion(region));
        return regions;
      });
  }

  /**
   * Data for the Guild Widget object
   * @typedef {Object} GuildWidget
   * @property {boolean} enabled Whether the widget is enabled
   * @property {?GuildChannel} channel The widget channel
   */

  /**
   * The Guild Widget object
   * @typedef {Object} GuildWidgetData
   * @property {boolean} enabled Whether the widget is enabled
   * @property {?GuildChannelResolvable} channel The widget channel
   */

  /**
   * Fetches the guild embed.
   * @returns {Promise<GuildWidget>}
   * @deprecated
   * @example
   * // Fetches the guild embed
   * guild.fetchEmbed()
   *   .then(embed => console.log(`The embed is ${embed.enabled ? 'enabled' : 'disabled'}`))
   *   .catch(console.error);
   */
  fetchEmbed() {
    return this.fetchWidget();
  }

  /**
   * Fetches the guild widget.
   * @returns {Promise<GuildWidget>}
   * @example
   * // Fetches the guild widget
   * guild.fetchWidget()
   *   .then(widget => console.log(`The widget is ${widget.enabled ? 'enabled' : 'disabled'}`))
   *   .catch(console.error);
   */
  async fetchWidget() {
    const data = await this.client.api.guilds(this.id).widget.get();
    this.widgetEnabled = this.embedEnabled = data.enabled;
    this.widgetChannelID = this.embedChannelID = data.channel_id;
    return {
      enabled: data.enabled,
      channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null,
    };
  }

  /**
   * Fetches audit logs for this guild.
   * @param {Object} [options={}] Options for fetching audit logs
   * @param {Snowflake|GuildAuditLogsEntry} [options.before] Limit to entries from before specified entry
   * @param {number} [options.limit] Limit number of entries
   * @param {UserResolvable} [options.user] Only show entries involving this user
   * @param {AuditLogAction|number} [options.type] Only show entries involving this action type
   * @returns {Promise<GuildAuditLogs>}
   * @example
   * // Output audit log entries
   * guild.fetchAuditLogs()
   *   .then(audit => console.log(audit.entries.first()))
   *   .catch(console.error);
   */
  fetchAuditLogs(options = {}) {
    if (options.before && options.before instanceof GuildAuditLogs.Entry) options.before = options.before.id;
    if (typeof options.type === 'string') options.type = GuildAuditLogs.Actions[options.type];

    return this.client.api
      .guilds(this.id)
      ['audit-logs'].get({
        query: {
          before: options.before,
          limit: options.limit,
          user_id: this.client.users.resolveID(options.user),
          action_type: options.type,
        },
      })
      .then(data => GuildAuditLogs.build(this, data));
  }

  /**
   * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.
   * @param {UserResolvable} user User to add to the guild
   * @param {Object} options Options for the addition
   * @param {string} options.accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the
   * bot's application
   * @param {string} [options.nick] Nickname to give the member (requires `MANAGE_NICKNAMES`)
   * @param {Collection<Snowflake, Role>|RoleResolvable[]} [options.roles] Roles to add to the member
   * (requires `MANAGE_ROLES`)
   * @param {boolean} [options.mute] Whether the member should be muted (requires `MUTE_MEMBERS`)
   * @param {boolean} [options.deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)
   * @returns {Promise<GuildMember>}
   */
  async addMember(user, options) {
    user = this.client.users.resolveID(user);
    if (!user) throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');
    if (this.members.cache.has(user)) return this.members.cache.get(user);
    options.access_token = options.accessToken;
    if (options.roles) {
      const roles = [];
      for (let role of options.roles instanceof Collection ? options.roles.values() : options.roles) {
        role = this.roles.resolve(role);
        if (!role) {
          throw new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true);
        }
        roles.push(role.id);
      }
      options.roles = roles;
    }
    const data = await this.client.api.guilds(this.id).members(user).put({ data: options });
    // Data is an empty buffer if the member is already part of the guild.
    return data instanceof (browser ? ArrayBuffer : Buffer) ? this.members.fetch(user) : this.members.add(data);
  }

  /**
   * The data for editing a guild.
   * @typedef {Object} GuildEditData
   * @property {string} [name] The name of the guild
   * @property {string} [region] The region of the guild
   * @property {VerificationLevel|number} [verificationLevel] The verification level of the guild
   * @property {ExplicitContentFilterLevel|number} [explicitContentFilter] The level of the explicit content filter
   * @property {ChannelResolvable} [afkChannel] The AFK channel of the guild
   * @property {ChannelResolvable} [systemChannel] The system channel of the guild
   * @property {number} [afkTimeout] The AFK timeout of the guild
   * @property {Base64Resolvable} [icon] The icon of the guild
   * @property {GuildMemberResolvable} [owner] The owner of the guild
   * @property {Base64Resolvable} [splash] The invite splash image of the guild
   * @property {Base64Resolvable} [discoverySplash] The discovery splash image of the guild
   * @property {Base64Resolvable} [banner] The banner of the guild
   * @property {DefaultMessageNotifications|number} [defaultMessageNotifications] The default message notifications
   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The system channel flags of the guild
   * @property {ChannelResolvable} [rulesChannel] The rules channel of the guild
   * @property {ChannelResolvable} [publicUpdatesChannel] The community updates channel of the guild
   * @property {string} [preferredLocale] The preferred locale of the guild
   */

  /**
   * Updates the guild with new information - e.g. a new name.
   * @param {GuildEditData} data The data to update the guild with
   * @param {string} [reason] Reason for editing this guild
   * @returns {Promise<Guild>}
   * @example
   * // Set the guild name and region
   * guild.edit({
   *   name: 'Discord Guild',
   *   region: 'london',
   * })
   *   .then(updated => console.log(`New guild name ${updated} in region ${updated.region}`))
   *   .catch(console.error);
   */
  edit(data, reason) {
    const _data = {};
    if (data.name) _data.name = data.name;
    if (data.region) _data.region = data.region;
    if (typeof data.verificationLevel !== 'undefined') {
      _data.verification_level =
        typeof data.verificationLevel === 'number'
          ? Number(data.verificationLevel)
          : VerificationLevels.indexOf(data.verificationLevel);
    }
    if (typeof data.afkChannel !== 'undefined') {
      _data.afk_channel_id = this.client.channels.resolveID(data.afkChannel);
    }
    if (typeof data.systemChannel !== 'undefined') {
      _data.system_channel_id = this.client.channels.resolveID(data.systemChannel);
    }
    if (data.afkTimeout) _data.afk_timeout = Number(data.afkTimeout);
    if (typeof data.icon !== 'undefined') _data.icon = data.icon;
    if (data.owner) _data.owner_id = this.client.users.resolveID(data.owner);
    if (data.splash) _data.splash = data.splash;
    if (data.discoverySplash) _data.discovery_splash = data.discoverySplash;
    if (data.banner) _data.banner = data.banner;
    if (typeof data.explicitContentFilter !== 'undefined') {
      _data.explicit_content_filter =
        typeof data.explicitContentFilter === 'number'
          ? data.explicitContentFilter
          : ExplicitContentFilterLevels.indexOf(data.explicitContentFilter);
    }
    if (typeof data.defaultMessageNotifications !== 'undefined') {
      _data.default_message_notifications =
        typeof data.defaultMessageNotifications === 'string'
          ? DefaultMessageNotifications.indexOf(data.defaultMessageNotifications)
          : data.defaultMessageNotifications;
    }
    if (typeof data.systemChannelFlags !== 'undefined') {
      _data.system_channel_flags = SystemChannelFlags.resolve(data.systemChannelFlags);
    }
    if (typeof data.rulesChannel !== 'undefined') {
      _data.rules_channel_id = this.client.channels.resolveID(data.rulesChannel);
    }
    if (typeof data.publicUpdatesChannel !== 'undefined') {
      _data.public_updates_channel_id = this.client.channels.resolveID(data.publicUpdatesChannel);
    }
    if (data.preferredLocale) _data.preferred_locale = data.preferredLocale;
    return this.client.api
      .guilds(this.id)
      .patch({ data: _data, reason })
      .then(newData => this.client.actions.GuildUpdate.handle(newData).updated);
  }

  /**
   * Edits the level of the explicit content filter.
   * @param {ExplicitContentFilterLevel|number} explicitContentFilter The new level of the explicit content filter
   * @param {string} [reason] Reason for changing the level of the guild's explicit content filter
   * @returns {Promise<Guild>}
   */
  setExplicitContentFilter(explicitContentFilter, reason) {
    return this.edit({ explicitContentFilter }, reason);
  }

  /* eslint-disable max-len */
  /**
   * Edits the setting of the default message notifications of the guild.
   * @param {DefaultMessageNotifications|number} defaultMessageNotifications The new setting for the default message notifications
   * @param {string} [reason] Reason for changing the setting of the default message notifications
   * @returns {Promise<Guild>}
   */
  setDefaultMessageNotifications(defaultMessageNotifications, reason) {
    return this.edit({ defaultMessageNotifications }, reason);
  }
  /* eslint-enable max-len */

  /**
   * Edits the flags of the default message notifications of the guild.
   * @param {SystemChannelFlagsResolvable} systemChannelFlags The new flags for the default message notifications
   * @param {string} [reason] Reason for changing the flags of the default message notifications
   * @returns {Promise<Guild>}
   */
  setSystemChannelFlags(systemChannelFlags, reason) {
    return this.edit({ systemChannelFlags }, reason);
  }

  /**
   * Edits the name of the guild.
   * @param {string} name The new name of the guild
   * @param {string} [reason] Reason for changing the guild's name
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild name
   * guild.setName('Discord Guild')
   *  .then(updated => console.log(`Updated guild name to ${updated.name}`))
   *  .catch(console.error);
   */
  setName(name, reason) {
    return this.edit({ name }, reason);
  }

  /**
   * Edits the region of the guild.
   * @param {string} region The new region of the guild
   * @param {string} [reason] Reason for changing the guild's region
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild region
   * guild.setRegion('london')
   *  .then(updated => console.log(`Updated guild region to ${updated.region}`))
   *  .catch(console.error);
   */
  setRegion(region, reason) {
    return this.edit({ region }, reason);
  }

  /**
   * Edits the verification level of the guild.
   * @param {VerificationLevel|number} verificationLevel The new verification level of the guild
   * @param {string} [reason] Reason for changing the guild's verification level
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild verification level
   * guild.setVerificationLevel(1)
   *  .then(updated => console.log(`Updated guild verification level to ${guild.verificationLevel}`))
   *  .catch(console.error);
   */
  setVerificationLevel(verificationLevel, reason) {
    return this.edit({ verificationLevel }, reason);
  }

  /**
   * Edits the AFK channel of the guild.
   * @param {ChannelResolvable} afkChannel The new AFK channel
   * @param {string} [reason] Reason for changing the guild's AFK channel
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild AFK channel
   * guild.setAFKChannel(channel)
   *  .then(updated => console.log(`Updated guild AFK channel to ${guild.afkChannel.name}`))
   *  .catch(console.error);
   */
  setAFKChannel(afkChannel, reason) {
    return this.edit({ afkChannel }, reason);
  }

  /**
   * Edits the system channel of the guild.
   * @param {ChannelResolvable} systemChannel The new system channel
   * @param {string} [reason] Reason for changing the guild's system channel
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild system channel
   * guild.setSystemChannel(channel)
   *  .then(updated => console.log(`Updated guild system channel to ${guild.systemChannel.name}`))
   *  .catch(console.error);
   */
  setSystemChannel(systemChannel, reason) {
    return this.edit({ systemChannel }, reason);
  }

  /**
   * Edits the AFK timeout of the guild.
   * @param {number} afkTimeout The time in seconds that a user must be idle to be considered AFK
   * @param {string} [reason] Reason for changing the guild's AFK timeout
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild AFK channel
   * guild.setAFKTimeout(60)
   *  .then(updated => console.log(`Updated guild AFK timeout to ${guild.afkTimeout}`))
   *  .catch(console.error);
   */
  setAFKTimeout(afkTimeout, reason) {
    return this.edit({ afkTimeout }, reason);
  }

  /**
   * Sets a new guild icon.
   * @param {Base64Resolvable|BufferResolvable} icon The new icon of the guild
   * @param {string} [reason] Reason for changing the guild's icon
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild icon
   * guild.setIcon('./icon.png')
   *  .then(updated => console.log('Updated the guild icon'))
   *  .catch(console.error);
   */
  async setIcon(icon, reason) {
    return this.edit({ icon: await DataResolver.resolveImage(icon), reason });
  }

  /**
   * Sets a new owner of the guild.
   * @param {GuildMemberResolvable} owner The new owner of the guild
   * @param {string} [reason] Reason for setting the new owner
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild owner
   * guild.setOwner(guild.members.cache.first())
   *  .then(updated => console.log(`Updated the guild owner to ${updated.owner.displayName}`))
   *  .catch(console.error);
   */
  setOwner(owner, reason) {
    return this.edit({ owner }, reason);
  }

  /**
   * Sets a new guild invite splash image.
   * @param {Base64Resolvable|BufferResolvable} splash The new invite splash image of the guild
   * @param {string} [reason] Reason for changing the guild's invite splash image
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild splash
   * guild.setSplash('./splash.png')
   *  .then(updated => console.log('Updated the guild splash'))
   *  .catch(console.error);
   */
  async setSplash(splash, reason) {
    return this.edit({ splash: await DataResolver.resolveImage(splash), reason });
  }

  /**
   * Sets a new guild discovery splash image.
   * @param {Base64Resolvable|BufferResolvable} discoverySplash The new discovery splash image of the guild
   * @param {string} [reason] Reason for changing the guild's discovery splash image
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild discovery splash
   * guild.setDiscoverySplash('./discoverysplash.png')
   *   .then(updated => console.log('Updated the guild discovery splash'))
   *   .catch(console.error);
   */
  async setDiscoverySplash(discoverySplash, reason) {
    return this.edit({ discoverySplash: await DataResolver.resolveImage(discoverySplash), reason });
  }

  /**
   * Sets a new guild banner.
   * @param {Base64Resolvable|BufferResolvable} banner The new banner of the guild
   * @param {string} [reason] Reason for changing the guild's banner
   * @returns {Promise<Guild>}
   * @example
   * guild.setBanner('./banner.png')
   *  .then(updated => console.log('Updated the guild banner'))
   *  .catch(console.error);
   */
  async setBanner(banner, reason) {
    return this.edit({ banner: await DataResolver.resolveImage(banner), reason });
  }

  /**
   * Edits the rules channel of the guild.
   * @param {ChannelResolvable} rulesChannel The new rules channel
   * @param {string} [reason] Reason for changing the guild's rules channel
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild rules channel
   * guild.setRulesChannel(channel)
   *  .then(updated => console.log(`Updated guild rules channel to ${guild.rulesChannel.name}`))
   *  .catch(console.error);
   */
  setRulesChannel(rulesChannel, reason) {
    return this.edit({ rulesChannel }, reason);
  }

  /**
   * Edits the community updates channel of the guild.
   * @param {ChannelResolvable} publicUpdatesChannel The new community updates channel
   * @param {string} [reason] Reason for changing the guild's community updates channel
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild community updates channel
   * guild.setPublicUpdatesChannel(channel)
   *  .then(updated => console.log(`Updated guild community updates channel to ${guild.publicUpdatesChannel.name}`))
   *  .catch(console.error);
   */
  setPublicUpdatesChannel(publicUpdatesChannel, reason) {
    return this.edit({ publicUpdatesChannel }, reason);
  }

  /**
   * Edits the preferred locale of the guild.
   * @param {string} preferredLocale The new preferred locale of the guild
   * @param {string} [reason] Reason for changing the guild's preferred locale
   * @returns {Promise<Guild>}
   * @example
   * // Edit the guild preferred locale
   * guild.setPreferredLocale('en-US')
   *  .then(updated => console.log(`Updated guild preferred locale to ${guild.preferredLocale}`))
   *  .catch(console.error);
   */
  setPreferredLocale(preferredLocale, reason) {
    return this.edit({ preferredLocale }, reason);
  }

  /**
   * The data needed for updating a channel's position.
   * @typedef {Object} ChannelPosition
   * @property {ChannelResolvable} channel Channel to update
   * @property {number} position New position for the channel
   */

  /**
   * Batch-updates the guild's channels' positions.
   * @param {ChannelPosition[]} channelPositions Channel positions to update
   * @returns {Promise<Guild>}
   * @example
   * guild.setChannelPositions([{ channel: channelID, position: newChannelIndex }])
   *   .then(guild => console.log(`Updated channel positions for ${guild}`))
   *   .catch(console.error);
   */
  setChannelPositions(channelPositions) {
    const updatedChannels = channelPositions.map(r => ({
      id: this.client.channels.resolveID(r.channel),
      position: r.position,
    }));

    return this.client.api
      .guilds(this.id)
      .channels.patch({ data: updatedChannels })
      .then(
        () =>
          this.client.actions.GuildChannelsPositionUpdate.handle({
            guild_id: this.id,
            channels: updatedChannels,
          }).guild,
      );
  }

  /**
   * The data needed for updating a guild role's position
   * @typedef {Object} GuildRolePosition
   * @property {RoleResolveable} role The ID of the role
   * @property {number} position The position to update
   */

  /**
   * Batch-updates the guild's role positions
   * @param {GuildRolePosition[]} rolePositions Role positions to update
   * @returns {Promise<Guild>}
   * @example
   * guild.setRolePositions([{ role: roleID, position: updatedRoleIndex }])
   *  .then(guild => console.log(`Role permissions updated for ${guild}`))
   *  .catch(console.error);
   */
  setRolePositions(rolePositions) {
    // Make sure rolePositions are prepared for API
    rolePositions = rolePositions.map(o => ({
      id: this.roles.resolveID(o.role),
      position: o.position,
    }));

    // Call the API to update role positions
    return this.client.api
      .guilds(this.id)
      .roles.patch({
        data: rolePositions,
      })
      .then(
        () =>
          this.client.actions.GuildRolesPositionUpdate.handle({
            guild_id: this.id,
            roles: rolePositions,
          }).guild,
      );
  }

  /**
   * Edits the guild's embed.
   * @param {GuildWidgetData} embed The embed for the guild
   * @param {string} [reason] Reason for changing the guild's embed
   * @returns {Promise<Guild>}
   * @deprecated
   */
  setEmbed(embed, reason) {
    return this.setWidget(embed, reason);
  }

  /**
   * Edits the guild's widget.
   * @param {GuildWidgetData} widget The widget for the guild
   * @param {string} [reason] Reason for changing the guild's widget
   * @returns {Promise<Guild>}
   */
  setWidget(widget, reason) {
    return this.client.api
      .guilds(this.id)
      .widget.patch({
        data: {
          enabled: widget.enabled,
          channel_id: this.channels.resolveID(widget.channel),
        },
        reason,
      })
      .then(() => this);
  }

  /**
   * Leaves the guild.
   * @returns {Promise<Guild>}
   * @example
   * // Leave a guild
   * guild.leave()
   *   .then(g => console.log(`Left the guild ${g}`))
   *   .catch(console.error);
   */
  leave() {
    if (this.ownerID === this.client.user.id) return Promise.reject(new Error('GUILD_OWNED'));
    return this.client.api
      .users('@me')
      .guilds(this.id)
      .delete()
      .then(() => this.client.actions.GuildDelete.handle({ id: this.id }).guild);
  }

  /**
   * Deletes the guild.
   * @returns {Promise<Guild>}
   * @example
   * // Delete a guild
   * guild.delete()
   *   .then(g => console.log(`Deleted the guild ${g}`))
   *   .catch(console.error);
   */
  delete() {
    return this.client.api
      .guilds(this.id)
      .delete()
      .then(() => this.client.actions.GuildDelete.handle({ id: this.id }).guild);
  }

  /**
   * Whether this guild equals another guild. It compares all properties, so for most operations
   * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often
   * what most users need.
   * @param {Guild} guild The guild to compare with
   * @returns {boolean}
   */
  equals(guild) {
    let equal =
      guild &&
      guild instanceof this.constructor &&
      this.id === guild.id &&
      this.available === guild.available &&
      this.splash === guild.splash &&
      this.discoverySplash === guild.discoverySplash &&
      this.region === guild.region &&
      this.name === guild.name &&
      this.memberCount === guild.memberCount &&
      this.large === guild.large &&
      this.icon === guild.icon &&
      this.ownerID === guild.ownerID &&
      this.verificationLevel === guild.verificationLevel &&
      this.embedEnabled === guild.embedEnabled &&
      (this.features === guild.features ||
        (this.features.length === guild.features.length &&
          this.features.every((feat, i) => feat === guild.features[i])));

    if (equal) {
      if (this.embedChannel) {
        if (!guild.embedChannel || this.embedChannel.id !== guild.embedChannel.id) equal = false;
      } else if (guild.embedChannel) {
        equal = false;
      }
    }

    return equal;
  }

  /**
   * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
   * @returns {string}
   * @example
   * // Logs: Hello from My Guild!
   * console.log(`Hello from ${guild}!`);
   */
  toString() {
    return this.name;
  }

  toJSON() {
    const json = super.toJSON({
      available: false,
      createdTimestamp: true,
      nameAcronym: true,
      presences: false,
      voiceStates: false,
    });
    json.iconURL = this.iconURL();
    json.splashURL = this.splashURL();
    json.discoverySplashURL = this.discoverySplashURL();
    json.bannerURL = this.bannerURL();
    return json;
  }

  /**
   * Creates a collection of this guild's roles, sorted by their position and IDs.
   * @returns {Collection<Role>}
   * @private
   */
  _sortedRoles() {
    return Util.discordSort(this.roles.cache);
  }

  /**
   * Creates a collection of this guild's or a specific category's channels, sorted by their position and IDs.
   * @param {GuildChannel} [channel] Category to get the channels of
   * @returns {Collection<GuildChannel>}
   * @private
   */
  _sortedChannels(channel) {
    const category = channel.type === ChannelTypes.CATEGORY;
    return Util.discordSort(
      this.channels.cache.filter(
        c =>
          (['text', 'news', 'store'].includes(channel.type)
            ? ['text', 'news', 'store'].includes(c.type)
            : c.type === channel.type) &&
          (category || c.parent === channel.parent),
      ),
    );
  }
}

Guild.prototype.setEmbed = deprecate(Guild.prototype.setEmbed, 'Guild#setEmbed: Use setWidget instead');

Guild.prototype.fetchEmbed = deprecate(Guild.prototype.fetchEmbed, 'Guild#fetchEmbed: Use fetchWidget instead');

Guild.prototype.fetchVanityCode = deprecate(
  Guild.prototype.fetchVanityCode,
  'Guild#fetchVanityCode: Use fetchVanityData() instead',
);

module.exports = Guild;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/GuildAuditLogs.js":
/*!******************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/GuildAuditLogs.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Integration = __webpack_require__(/*! ./Integration */ "./node_modules/discord.js/src/structures/Integration.js");
const Webhook = __webpack_require__(/*! ./Webhook */ "./node_modules/discord.js/src/structures/Webhook.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { PartialTypes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * The target type of an entry, e.g. `GUILD`. Here are the available types:
 * * GUILD
 * * CHANNEL
 * * USER
 * * ROLE
 * * INVITE
 * * WEBHOOK
 * * EMOJI
 * * MESSAGE
 * * INTEGRATION
 * @typedef {string} AuditLogTargetType
 */

/**
 * Key mirror of all available audit log targets.
 * @name GuildAuditLogs.Targets
 * @type {Object<string, string>}
 */
const Targets = {
  ALL: 'ALL',
  GUILD: 'GUILD',
  CHANNEL: 'CHANNEL',
  USER: 'USER',
  ROLE: 'ROLE',
  INVITE: 'INVITE',
  WEBHOOK: 'WEBHOOK',
  EMOJI: 'EMOJI',
  MESSAGE: 'MESSAGE',
  INTEGRATION: 'INTEGRATION',
  UNKNOWN: 'UNKNOWN',
};

/**
 * The action of an entry. Here are the available actions:
 * * ALL: null
 * * GUILD_UPDATE: 1
 * * CHANNEL_CREATE: 10
 * * CHANNEL_UPDATE: 11
 * * CHANNEL_DELETE: 12
 * * CHANNEL_OVERWRITE_CREATE: 13
 * * CHANNEL_OVERWRITE_UPDATE: 14
 * * CHANNEL_OVERWRITE_DELETE: 15
 * * MEMBER_KICK: 20
 * * MEMBER_PRUNE: 21
 * * MEMBER_BAN_ADD: 22
 * * MEMBER_BAN_REMOVE: 23
 * * MEMBER_UPDATE: 24
 * * MEMBER_ROLE_UPDATE: 25
 * * MEMBER_MOVE: 26
 * * MEMBER_DISCONNECT: 27
 * * BOT_ADD: 28,
 * * ROLE_CREATE: 30
 * * ROLE_UPDATE: 31
 * * ROLE_DELETE: 32
 * * INVITE_CREATE: 40
 * * INVITE_UPDATE: 41
 * * INVITE_DELETE: 42
 * * WEBHOOK_CREATE: 50
 * * WEBHOOK_UPDATE: 51
 * * WEBHOOK_DELETE: 52
 * * EMOJI_CREATE: 60
 * * EMOJI_UPDATE: 61
 * * EMOJI_DELETE: 62
 * * MESSAGE_DELETE: 72
 * * MESSAGE_BULK_DELETE: 73
 * * MESSAGE_PIN: 74
 * * MESSAGE_UNPIN: 75
 * * INTEGRATION_CREATE: 80
 * * INTEGRATION_UPDATE: 81
 * * INTEGRATION_DELETE: 82
 * @typedef {?number|string} AuditLogAction
 */

/**
 * All available actions keyed under their names to their numeric values.
 * @name GuildAuditLogs.Actions
 * @type {Object<string, number>}
 */
const Actions = {
  ALL: null,
  GUILD_UPDATE: 1,
  CHANNEL_CREATE: 10,
  CHANNEL_UPDATE: 11,
  CHANNEL_DELETE: 12,
  CHANNEL_OVERWRITE_CREATE: 13,
  CHANNEL_OVERWRITE_UPDATE: 14,
  CHANNEL_OVERWRITE_DELETE: 15,
  MEMBER_KICK: 20,
  MEMBER_PRUNE: 21,
  MEMBER_BAN_ADD: 22,
  MEMBER_BAN_REMOVE: 23,
  MEMBER_UPDATE: 24,
  MEMBER_ROLE_UPDATE: 25,
  MEMBER_MOVE: 26,
  MEMBER_DISCONNECT: 27,
  BOT_ADD: 28,
  ROLE_CREATE: 30,
  ROLE_UPDATE: 31,
  ROLE_DELETE: 32,
  INVITE_CREATE: 40,
  INVITE_UPDATE: 41,
  INVITE_DELETE: 42,
  WEBHOOK_CREATE: 50,
  WEBHOOK_UPDATE: 51,
  WEBHOOK_DELETE: 52,
  EMOJI_CREATE: 60,
  EMOJI_UPDATE: 61,
  EMOJI_DELETE: 62,
  MESSAGE_DELETE: 72,
  MESSAGE_BULK_DELETE: 73,
  MESSAGE_PIN: 74,
  MESSAGE_UNPIN: 75,
  INTEGRATION_CREATE: 80,
  INTEGRATION_UPDATE: 81,
  INTEGRATION_DELETE: 82,
};

/**
 * Audit logs entries are held in this class.
 */
class GuildAuditLogs {
  constructor(guild, data) {
    if (data.users) for (const user of data.users) guild.client.users.add(user);
    /**
     * Cached webhooks
     * @type {Collection<Snowflake, Webhook>}
     * @private
     */
    this.webhooks = new Collection();
    if (data.webhooks) {
      for (const hook of data.webhooks) {
        this.webhooks.set(hook.id, new Webhook(guild.client, hook));
      }
    }

    /**
     * Cached integrations
     * @type {Collection<Snowflake, Integration>}
     * @private
     */
    this.integrations = new Collection();
    if (data.integrations) {
      for (const integration of data.integrations) {
        this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
      }
    }

    /**
     * The entries for this guild's audit logs
     * @type {Collection<Snowflake, GuildAuditLogsEntry>}
     */
    this.entries = new Collection();
    for (const item of data.audit_log_entries) {
      const entry = new GuildAuditLogsEntry(this, guild, item);
      this.entries.set(entry.id, entry);
    }
  }

  /**
   * Handles possible promises for entry targets.
   * @returns {Promise<GuildAuditLogs>}
   */
  static build(...args) {
    const logs = new GuildAuditLogs(...args);
    return Promise.all(logs.entries.map(e => e.target)).then(() => logs);
  }

  /**
   * The target of an entry. It can be one of:
   * * A guild
   * * A user
   * * A role
   * * An emoji
   * * An invite
   * * A webhook
   * * An integration
   * * An object with an id key if target was deleted
   * * An object where the keys represent either the new value or the old value
   * @typedef {?Object|Guild|User|Role|GuildEmoji|Invite|Webhook|Integration} AuditLogEntryTarget
   */

  /**
   * Finds the target type from the entry action.
   * @param {AuditLogAction} target The action target
   * @returns {AuditLogTargetType}
   */
  static targetType(target) {
    if (target < 10) return Targets.GUILD;
    if (target < 20) return Targets.CHANNEL;
    if (target < 30) return Targets.USER;
    if (target < 40) return Targets.ROLE;
    if (target < 50) return Targets.INVITE;
    if (target < 60) return Targets.WEBHOOK;
    if (target < 70) return Targets.EMOJI;
    if (target < 80) return Targets.MESSAGE;
    if (target < 90) return Targets.INTEGRATION;
    return Targets.UNKNOWN;
  }

  /**
   * The action type of an entry, e.g. `CREATE`. Here are the available types:
   * * CREATE
   * * DELETE
   * * UPDATE
   * * ALL
   * @typedef {string} AuditLogActionType
   */

  /**
   * Finds the action type from the entry action.
   * @param {AuditLogAction} action The action target
   * @returns {AuditLogActionType}
   */
  static actionType(action) {
    if (
      [
        Actions.CHANNEL_CREATE,
        Actions.CHANNEL_OVERWRITE_CREATE,
        Actions.MEMBER_BAN_REMOVE,
        Actions.BOT_ADD,
        Actions.ROLE_CREATE,
        Actions.INVITE_CREATE,
        Actions.WEBHOOK_CREATE,
        Actions.EMOJI_CREATE,
        Actions.MESSAGE_PIN,
        Actions.INTEGRATION_CREATE,
      ].includes(action)
    ) {
      return 'CREATE';
    }

    if (
      [
        Actions.CHANNEL_DELETE,
        Actions.CHANNEL_OVERWRITE_DELETE,
        Actions.MEMBER_KICK,
        Actions.MEMBER_PRUNE,
        Actions.MEMBER_BAN_ADD,
        Actions.MEMBER_DISCONNECT,
        Actions.ROLE_DELETE,
        Actions.INVITE_DELETE,
        Actions.WEBHOOK_DELETE,
        Actions.EMOJI_DELETE,
        Actions.MESSAGE_DELETE,
        Actions.MESSAGE_BULK_DELETE,
        Actions.MESSAGE_UNPIN,
        Actions.INTEGRATION_DELETE,
      ].includes(action)
    ) {
      return 'DELETE';
    }

    if (
      [
        Actions.GUILD_UPDATE,
        Actions.CHANNEL_UPDATE,
        Actions.CHANNEL_OVERWRITE_UPDATE,
        Actions.MEMBER_UPDATE,
        Actions.MEMBER_ROLE_UPDATE,
        Actions.MEMBER_MOVE,
        Actions.ROLE_UPDATE,
        Actions.INVITE_UPDATE,
        Actions.WEBHOOK_UPDATE,
        Actions.EMOJI_UPDATE,
        Actions.INTEGRATION_UPDATE,
      ].includes(action)
    ) {
      return 'UPDATE';
    }

    return 'ALL';
  }

  toJSON() {
    return Util.flatten(this);
  }
}

/**
 * Audit logs entry.
 */
class GuildAuditLogsEntry {
  constructor(logs, guild, data) {
    const targetType = GuildAuditLogs.targetType(data.action_type);
    /**
     * The target type of this entry
     * @type {AuditLogTargetType}
     */
    this.targetType = targetType;

    /**
     * The action type of this entry
     * @type {AuditLogActionType}
     */
    this.actionType = GuildAuditLogs.actionType(data.action_type);

    /**
     * Specific action type of this entry in its string presentation
     * @type {AuditLogAction}
     */
    this.action = Object.keys(Actions).find(k => Actions[k] === data.action_type);

    /**
     * The reason of this entry
     * @type {?string}
     */
    this.reason = data.reason || null;

    /**
     * The user that executed this entry
     * @type {User}
     */
    this.executor = guild.client.options.partials.includes(PartialTypes.USER)
      ? guild.client.users.add({ id: data.user_id })
      : guild.client.users.cache.get(data.user_id);

    /**
     * An entry in the audit log representing a specific change.
     * @typedef {object} AuditLogChange
     * @property {string} key The property that was changed, e.g. `nick` for nickname changes
     * @property {*} [old] The old value of the change, e.g. for nicknames, the old nickname
     * @property {*} [new] The new value of the change, e.g. for nicknames, the new nickname
     */

    /**
     * Specific property changes
     * @type {AuditLogChange[]}
     */
    this.changes = data.changes ? data.changes.map(c => ({ key: c.key, old: c.old_value, new: c.new_value })) : null;

    /**
     * The ID of this entry
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * Any extra data from the entry
     * @type {?Object|Role|GuildMember}
     */
    this.extra = null;
    switch (data.action_type) {
      case Actions.MEMBER_PRUNE:
        this.extra = {
          removed: Number(data.options.members_removed),
          days: Number(data.options.delete_member_days),
        };
        break;

      case Actions.MEMBER_MOVE:
      case Actions.MESSAGE_DELETE:
      case Actions.MESSAGE_BULK_DELETE:
        this.extra = {
          channel: guild.channels.cache.get(data.options.channel_id) || { id: data.options.channel_id },
          count: Number(data.options.count),
        };
        break;

      case Actions.MESSAGE_PIN:
      case Actions.MESSAGE_UNPIN:
        this.extra = {
          channel: guild.client.channels.cache.get(data.options.channel_id) || { id: data.options.channel_id },
          messageID: data.options.message_id,
        };
        break;

      case Actions.MEMBER_DISCONNECT:
        this.extra = {
          count: Number(data.options.count),
        };
        break;

      case Actions.CHANNEL_OVERWRITE_CREATE:
      case Actions.CHANNEL_OVERWRITE_UPDATE:
      case Actions.CHANNEL_OVERWRITE_DELETE:
        switch (data.options.type) {
          case 'member':
            this.extra = guild.members.cache.get(data.options.id) || { id: data.options.id, type: 'member' };
            break;

          case 'role':
            this.extra = guild.roles.cache.get(data.options.id) || {
              id: data.options.id,
              name: data.options.role_name,
              type: 'role',
            };
            break;

          default:
            break;
        }
        break;

      default:
        break;
    }

    /**
     * The target of this entry
     * @type {?AuditLogEntryTarget}
     */
    this.target = null;
    if (targetType === Targets.UNKNOWN) {
      this.target = this.changes.reduce((o, c) => {
        o[c.key] = c.new || c.old;
        return o;
      }, {});
      this.target.id = data.target_id;
      // MEMBER_DISCONNECT and similar types do not provide a target_id.
    } else if (targetType === Targets.USER && data.target_id) {
      this.target = guild.client.options.partials.includes(PartialTypes.USER)
        ? guild.client.users.add({ id: data.target_id })
        : guild.client.users.cache.get(data.target_id);
    } else if (targetType === Targets.GUILD) {
      this.target = guild.client.guilds.cache.get(data.target_id);
    } else if (targetType === Targets.WEBHOOK) {
      this.target =
        logs.webhooks.get(data.target_id) ||
        new Webhook(
          guild.client,
          this.changes.reduce(
            (o, c) => {
              o[c.key] = c.new || c.old;
              return o;
            },
            {
              id: data.target_id,
              guild_id: guild.id,
            },
          ),
        );
    } else if (targetType === Targets.INVITE) {
      this.target = guild.members.fetch(guild.client.user.id).then(me => {
        if (me.permissions.has('MANAGE_GUILD')) {
          const change = this.changes.find(c => c.key === 'code');
          return guild.fetchInvites().then(invites => {
            this.target = invites.find(i => i.code === (change.new || change.old));
          });
        } else {
          this.target = this.changes.reduce((o, c) => {
            o[c.key] = c.new || c.old;
            return o;
          }, {});
          return this.target;
        }
      });
    } else if (targetType === Targets.MESSAGE) {
      // Discord sends a channel id for the MESSAGE_BULK_DELETE action type.
      this.target =
        data.action_type === Actions.MESSAGE_BULK_DELETE
          ? guild.channels.cache.get(data.target_id) || { id: data.target_id }
          : guild.client.users.cache.get(data.target_id);
    } else if (targetType === Targets.INTEGRATION) {
      this.target =
        logs.integrations.get(data.target_id) ||
        new Integration(
          guild.client,
          this.changes.reduce(
            (o, c) => {
              o[c.key] = c.new || c.old;
              return o;
            },
            { id: data.target_id },
          ),
          guild,
        );
    } else if (data.target_id) {
      this.target = guild[`${targetType.toLowerCase()}s`].cache.get(data.target_id) || { id: data.target_id };
    }
  }

  /**
   * The timestamp this entry was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time this entry was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  toJSON() {
    return Util.flatten(this, { createdTimestamp: true });
  }
}

GuildAuditLogs.Actions = Actions;
GuildAuditLogs.Targets = Targets;
GuildAuditLogs.Entry = GuildAuditLogsEntry;

module.exports = GuildAuditLogs;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/GuildChannel.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/GuildChannel.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Channel = __webpack_require__(/*! ./Channel */ "./node_modules/discord.js/src/structures/Channel.js");
const Invite = __webpack_require__(/*! ./Invite */ "./node_modules/discord.js/src/structures/Invite.js");
const PermissionOverwrites = __webpack_require__(/*! ./PermissionOverwrites */ "./node_modules/discord.js/src/structures/PermissionOverwrites.js");
const Role = __webpack_require__(/*! ./Role */ "./node_modules/discord.js/src/structures/Role.js");
const { Error, TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a guild channel from any of the following:
 * - {@link TextChannel}
 * - {@link VoiceChannel}
 * - {@link CategoryChannel}
 * - {@link NewsChannel}
 * - {@link StoreChannel}
 * @extends {Channel}
 * @abstract
 */
class GuildChannel extends Channel {
  /**
   * @param {Guild} guild The guild the guild channel is part of
   * @param {Object} data The data for the guild channel
   */
  constructor(guild, data) {
    super(guild.client, data);

    /**
     * The guild the channel is in
     * @type {Guild}
     */
    this.guild = guild;
  }

  _patch(data) {
    super._patch(data);

    /**
     * The name of the guild channel
     * @type {string}
     */
    this.name = data.name;

    /**
     * The raw position of the channel from discord
     * @type {number}
     */
    this.rawPosition = data.position;

    /**
     * The ID of the category parent of this channel
     * @type {?Snowflake}
     */
    this.parentID = data.parent_id || null;

    /**
     * A map of permission overwrites in this channel for roles and users
     * @type {Collection<Snowflake, PermissionOverwrites>}
     */
    this.permissionOverwrites = new Collection();
    if (data.permission_overwrites) {
      for (const overwrite of data.permission_overwrites) {
        this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));
      }
    }
  }

  /**
   * The category parent of this channel
   * @type {?CategoryChannel}
   * @readonly
   */
  get parent() {
    return this.guild.channels.cache.get(this.parentID) || null;
  }

  /**
   * If the permissionOverwrites match the parent channel, null if no parent
   * @type {?boolean}
   * @readonly
   */
  get permissionsLocked() {
    if (!this.parent) return null;
    if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size) return false;
    return this.permissionOverwrites.every((value, key) => {
      const testVal = this.parent.permissionOverwrites.get(key);
      return (
        testVal !== undefined &&
        testVal.deny.bitfield === value.deny.bitfield &&
        testVal.allow.bitfield === value.allow.bitfield
      );
    });
  }

  /**
   * The position of the channel
   * @type {number}
   * @readonly
   */
  get position() {
    const sorted = this.guild._sortedChannels(this);
    return sorted.array().indexOf(sorted.get(this.id));
  }

  /**
   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.
   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for
   * @returns {?Readonly<Permissions>}
   */
  permissionsFor(memberOrRole) {
    const member = this.guild.members.resolve(memberOrRole);
    if (member) return this.memberPermissions(member);
    const role = this.guild.roles.resolve(memberOrRole);
    if (role) return this.rolePermissions(role);
    return null;
  }

  overwritesFor(member, verified = false, roles = null) {
    if (!verified) member = this.guild.members.resolve(member);
    if (!member) return [];

    roles = roles || member.roles.cache;
    const roleOverwrites = [];
    let memberOverwrites;
    let everyoneOverwrites;

    for (const overwrite of this.permissionOverwrites.values()) {
      if (overwrite.id === this.guild.id) {
        everyoneOverwrites = overwrite;
      } else if (roles.has(overwrite.id)) {
        roleOverwrites.push(overwrite);
      } else if (overwrite.id === member.id) {
        memberOverwrites = overwrite;
      }
    }

    return {
      everyone: everyoneOverwrites,
      roles: roleOverwrites,
      member: memberOverwrites,
    };
  }

  /**
   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.
   * @param {GuildMember} member The member to obtain the overall permissions for
   * @returns {Readonly<Permissions>}
   * @private
   */
  memberPermissions(member) {
    if (member.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();

    const roles = member.roles.cache;
    const permissions = new Permissions(roles.map(role => role.permissions));

    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();

    const overwrites = this.overwritesFor(member, true, roles);

    return permissions
      .remove(overwrites.everyone ? overwrites.everyone.deny : 0)
      .add(overwrites.everyone ? overwrites.everyone.allow : 0)
      .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : 0)
      .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : 0)
      .remove(overwrites.member ? overwrites.member.deny : 0)
      .add(overwrites.member ? overwrites.member.allow : 0)
      .freeze();
  }

  /**
   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.
   * @param {Role} role The role to obtain the overall permissions for
   * @returns {Readonly<Permissions>}
   * @private
   */
  rolePermissions(role) {
    if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();

    const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);
    const roleOverwrites = this.permissionOverwrites.get(role.id);

    return role.permissions
      .remove(everyoneOverwrites ? everyoneOverwrites.deny : 0)
      .add(everyoneOverwrites ? everyoneOverwrites.allow : 0)
      .remove(roleOverwrites ? roleOverwrites.deny : 0)
      .add(roleOverwrites ? roleOverwrites.allow : 0)
      .freeze();
  }

  /**
   * Replaces the permission overwrites in this channel.
   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites
   * Permission overwrites the channel gets updated with
   * @param {string} [reason] Reason for updating the channel overwrites
   * @returns {Promise<GuildChannel>}
   * @example
   * channel.overwritePermissions([
   *   {
   *      id: message.author.id,
   *      deny: ['VIEW_CHANNEL'],
   *   },
   * ], 'Needed to change permissions');
   */
  overwritePermissions(overwrites, reason) {
    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {
      return Promise.reject(
        new TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true),
      );
    }
    return this.edit({ permissionOverwrites: overwrites, reason }).then(() => this);
  }

  /**
   * Updates Overwrites for a user or role in this channel. (creates if non-existent)
   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
   * @param {PermissionOverwriteOptions} options The options for the update
   * @param {string} [reason] Reason for creating/editing this overwrite
   * @returns {Promise<GuildChannel>}
   * @example
   * // Update or Create permission overwrites for a message author
   * message.channel.updateOverwrite(message.author, {
   *   SEND_MESSAGES: false
   * })
   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))
   *   .catch(console.error);
   */
  updateOverwrite(userOrRole, options, reason) {
    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);
    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));

    const existing = this.permissionOverwrites.get(userOrRole.id);
    if (existing) return existing.update(options, reason).then(() => this);
    return this.createOverwrite(userOrRole, options, reason);
  }

  /**
   * Overwrites the permissions for a user or role in this channel. (replaces if existent)
   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
   * @param {PermissionOverwriteOptions} options The options for the update
   * @param {string} [reason] Reason for creating/editing this overwrite
   * @returns {Promise<GuildChannel>}
   * @example
   * // Create or Replace permissions overwrites for a message author
   * message.channel.createOverwrite(message.author, {
   *   SEND_MESSAGES: false
   * })
   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))
   *   .catch(console.error);
   */
  createOverwrite(userOrRole, options, reason) {
    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);
    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));

    const type = userOrRole instanceof Role ? 'role' : 'member';
    const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options);

    return this.client.api
      .channels(this.id)
      .permissions[userOrRole.id].put({
        data: { id: userOrRole.id, type, allow: allow.bitfield, deny: deny.bitfield },
        reason,
      })
      .then(() => this);
  }

  /**
   * Locks in the permission overwrites from the parent channel.
   * @returns {Promise<GuildChannel>}
   */
  lockPermissions() {
    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));
    const permissionOverwrites = this.parent.permissionOverwrites.map(overwrite => overwrite.toJSON());
    return this.edit({ permissionOverwrites });
  }

  /**
   * A collection of members that can see this channel, mapped by their ID
   * @type {Collection<Snowflake, GuildMember>}
   * @readonly
   */
  get members() {
    const members = new Collection();
    for (const member of this.guild.members.cache.values()) {
      if (this.permissionsFor(member).has('VIEW_CHANNEL', false)) {
        members.set(member.id, member);
      }
    }
    return members;
  }

  /**
   * The data for a guild channel.
   * @typedef {Object} ChannelData
   * @property {string} [name] The name of the channel
   * @property {number} [position] The position of the channel
   * @property {string} [topic] The topic of the text channel
   * @property {boolean} [nsfw] Whether the channel is NSFW
   * @property {number} [bitrate] The bitrate of the voice channel
   * @property {number} [userLimit] The user limit of the voice channel
   * @property {?Snowflake} [parentID] The parent ID of the channel
   * @property {boolean} [lockPermissions]
   * Lock the permissions of the channel to what the parent's permissions are
   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]
   * Permission overwrites for the channel
   * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds
   */

  /**
   * Edits the channel.
   * @param {ChannelData} data The new data for the channel
   * @param {string} [reason] Reason for editing this channel
   * @returns {Promise<GuildChannel>}
   * @example
   * // Edit a channel
   * channel.edit({ name: 'new-channel' })
   *   .then(console.log)
   *   .catch(console.error);
   */
  async edit(data, reason) {
    if (typeof data.position !== 'undefined') {
      await Util.setPosition(
        this,
        data.position,
        false,
        this.guild._sortedChannels(this),
        this.client.api.guilds(this.guild.id).channels,
        reason,
      ).then(updatedChannels => {
        this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: updatedChannels,
        });
      });
    }

    let permission_overwrites;

    if (data.permissionOverwrites) {
      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));
    }

    if (data.lockPermissions) {
      if (data.parentID) {
        const newParent = this.guild.channels.resolve(data.parentID);
        if (newParent && newParent.type === 'category') {
          permission_overwrites = newParent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));
        }
      } else if (this.parent) {
        permission_overwrites = this.parent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));
      }
    }

    const newData = await this.client.api.channels(this.id).patch({
      data: {
        name: (data.name || this.name).trim(),
        topic: data.topic,
        nsfw: data.nsfw,
        bitrate: data.bitrate || this.bitrate,
        user_limit: typeof data.userLimit !== 'undefined' ? data.userLimit : this.userLimit,
        parent_id: data.parentID,
        lock_permissions: data.lockPermissions,
        rate_limit_per_user: data.rateLimitPerUser,
        permission_overwrites,
      },
      reason,
    });

    const clone = this._clone();
    clone._patch(newData);
    return clone;
  }

  /**
   * Sets a new name for the guild channel.
   * @param {string} name The new name for the guild channel
   * @param {string} [reason] Reason for changing the guild channel's name
   * @returns {Promise<GuildChannel>}
   * @example
   * // Set a new channel name
   * channel.setName('not_general')
   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))
   *   .catch(console.error);
   */
  setName(name, reason) {
    return this.edit({ name }, reason);
  }

  /**
   * Sets the category parent of this channel.
   * @param {?CategoryChannel|Snowflake} channel Parent channel
   * @param {Object} [options={}] Options to pass
   * @param {boolean} [options.lockPermissions=true] Lock the permissions to what the parent's permissions are
   * @param {string} [options.reason] Reason for modifying the parent of this channel
   * @returns {Promise<GuildChannel>}
   * @example
   * // Add a parent to a channel
   * message.channel.setParent('355908108431917066', { lockPermissions: false })
   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))
   *   .catch(console.error);
   */
  setParent(channel, { lockPermissions = true, reason } = {}) {
    return this.edit(
      {
        // eslint-disable-next-line no-prototype-builtins
        parentID: channel !== null ? (channel.hasOwnProperty('id') ? channel.id : channel) : null,
        lockPermissions,
      },
      reason,
    );
  }

  /**
   * Sets a new topic for the guild channel.
   * @param {?string} topic The new topic for the guild channel
   * @param {string} [reason] Reason for changing the guild channel's topic
   * @returns {Promise<GuildChannel>}
   * @example
   * // Set a new channel topic
   * channel.setTopic('needs more rate limiting')
   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
   *   .catch(console.error);
   */
  setTopic(topic, reason) {
    return this.edit({ topic }, reason);
  }

  /**
   * Sets a new position for the guild channel.
   * @param {number} position The new position for the guild channel
   * @param {Object} [options] Options for setting position
   * @param {boolean} [options.relative=false] Change the position relative to its current value
   * @param {string} [options.reason] Reason for changing the position
   * @returns {Promise<GuildChannel>}
   * @example
   * // Set a new channel position
   * channel.setPosition(2)
   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))
   *   .catch(console.error);
   */
  setPosition(position, { relative, reason } = {}) {
    return Util.setPosition(
      this,
      position,
      relative,
      this.guild._sortedChannels(this),
      this.client.api.guilds(this.guild.id).channels,
      reason,
    ).then(updatedChannels => {
      this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: updatedChannels,
      });
      return this;
    });
  }

  /**
   * Creates an invite to this guild channel.
   * @param {Object} [options={}] Options for the invite
   * @param {boolean} [options.temporary=false] Whether members that joined via the invite should be automatically
   * kicked after 24 hours if they have not yet received a role
   * @param {number} [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)
   * @param {number} [options.maxUses=0] Maximum number of uses
   * @param {boolean} [options.unique=false] Create a unique invite, or use an existing one with similar settings
   * @param {string} [options.reason] Reason for creating this
   * @returns {Promise<Invite>}
   * @example
   * // Create an invite to a channel
   * channel.createInvite()
   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
   *   .catch(console.error);
   */
  createInvite({ temporary = false, maxAge = 86400, maxUses = 0, unique, reason } = {}) {
    return this.client.api
      .channels(this.id)
      .invites.post({
        data: {
          temporary,
          max_age: maxAge,
          max_uses: maxUses,
          unique,
        },
        reason,
      })
      .then(invite => new Invite(this.client, invite));
  }

  /**
   * Fetches a collection of invites to this guild channel.
   * Resolves with a collection mapping invites by their codes.
   * @returns {Promise<Collection<string, Invite>>}
   */
  async fetchInvites() {
    const inviteItems = await this.client.api.channels(this.id).invites.get();
    const invites = new Collection();
    for (const inviteItem of inviteItems) {
      const invite = new Invite(this.client, inviteItem);
      invites.set(invite.code, invite);
    }
    return invites;
  }

  /* eslint-disable max-len */
  /**
   * Clones this channel.
   * @param {Object} [options] The options
   * @param {string} [options.name=this.name] Name of the new channel
   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites=this.permissionOverwrites]
   * Permission overwrites of the new channel
   * @param {string} [options.type=this.type] Type of the new channel
   * @param {string} [options.topic=this.topic] Topic of the new channel (only text)
   * @param {boolean} [options.nsfw=this.nsfw] Whether the new channel is nsfw (only text)
   * @param {number} [options.bitrate=this.bitrate] Bitrate of the new channel in bits (only voice)
   * @param {number} [options.userLimit=this.userLimit] Maximum amount of users allowed in the new channel (only voice)
   * @param {number} [options.rateLimitPerUser=this.rateLimitPerUser] Ratelimit per user for the new channel (only text)
   * @param {ChannelResolvable} [options.parent=this.parent] Parent of the new channel
   * @param {string} [options.reason] Reason for cloning this channel
   * @returns {Promise<GuildChannel>}
   */
  clone(options = {}) {
    Util.mergeDefault(
      {
        name: this.name,
        permissionOverwrites: this.permissionOverwrites,
        topic: this.topic,
        type: this.type,
        nsfw: this.nsfw,
        parent: this.parent,
        bitrate: this.bitrate,
        userLimit: this.userLimit,
        rateLimitPerUser: this.rateLimitPerUser,
        reason: null,
      },
      options,
    );
    return this.guild.channels.create(options.name, options);
  }
  /* eslint-enable max-len */

  /**
   * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.
   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.
   * @param {GuildChannel} channel Channel to compare with
   * @returns {boolean}
   */
  equals(channel) {
    let equal =
      channel &&
      this.id === channel.id &&
      this.type === channel.type &&
      this.topic === channel.topic &&
      this.position === channel.position &&
      this.name === channel.name;

    if (equal) {
      if (this.permissionOverwrites && channel.permissionOverwrites) {
        equal = this.permissionOverwrites.equals(channel.permissionOverwrites);
      } else {
        equal = !this.permissionOverwrites && !channel.permissionOverwrites;
      }
    }

    return equal;
  }

  /**
   * Whether the channel is deletable by the client user
   * @type {boolean}
   * @readonly
   */
  get deletable() {
    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);
  }

  /**
   * Whether the channel is manageable by the client user
   * @type {boolean}
   * @readonly
   */
  get manageable() {
    if (this.client.user.id === this.guild.ownerID) return true;
    if (this.type === 'voice') {
      if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {
        return false;
      }
    } else if (!this.viewable) {
      return false;
    }
    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);
  }

  /**
   * Whether the channel is viewable by the client user
   * @type {boolean}
   * @readonly
   */
  get viewable() {
    if (this.client.user.id === this.guild.ownerID) return true;
    const permissions = this.permissionsFor(this.client.user);
    if (!permissions) return false;
    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);
  }

  /**
   * Deletes this channel.
   * @param {string} [reason] Reason for deleting this channel
   * @returns {Promise<GuildChannel>}
   * @example
   * // Delete the channel
   * channel.delete('making room for new channels')
   *   .then(console.log)
   *   .catch(console.error);
   */
  delete(reason) {
    return this.client.api
      .channels(this.id)
      .delete({ reason })
      .then(() => this);
  }
}

module.exports = GuildChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/GuildEmoji.js":
/*!**************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/GuildEmoji.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseGuildEmoji = __webpack_require__(/*! ./BaseGuildEmoji */ "./node_modules/discord.js/src/structures/BaseGuildEmoji.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const GuildEmojiRoleManager = __webpack_require__(/*! ../managers/GuildEmojiRoleManager */ "./node_modules/discord.js/src/managers/GuildEmojiRoleManager.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");

/**
 * Represents a custom emoji.
 * @extends {BaseGuildEmoji}
 */
class GuildEmoji extends BaseGuildEmoji {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the guild emoji
   * @param {Guild} guild The guild the guild emoji is part of
   */
  constructor(client, data, guild) {
    super(client, data, guild);

    /**
     * The user who created this emoji
     * @type {?User}
     */
    this.author = null;
  }

  /**
   * The guild this emoji is part of
   * @type {Guild}
   * @name GuildEmoji#guild
   */

  _clone() {
    const clone = super._clone();
    clone._roles = this._roles.slice();
    return clone;
  }

  _patch(data) {
    super._patch(data);
    if (typeof data.user !== 'undefined') this.author = this.client.users.add(data.user);
  }

  /**
   * Whether the emoji is deletable by the client user
   * @type {boolean}
   * @readonly
   */
  get deletable() {
    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');
    return !this.managed && this.guild.me.hasPermission(Permissions.FLAGS.MANAGE_EMOJIS);
  }

  /**
   * A manager for roles this emoji is active for.
   * @type {GuildEmojiRoleManager}
   * @readonly
   */
  get roles() {
    return new GuildEmojiRoleManager(this);
  }

  /**
   * Fetches the author for this emoji
   * @returns {Promise<User>}
   */
  async fetchAuthor() {
    if (this.managed) {
      throw new Error('EMOJI_MANAGED');
    } else {
      if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');
      if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) {
        throw new Error('MISSING_MANAGE_EMOJIS_PERMISSION', this.guild);
      }
    }
    const data = await this.client.api.guilds(this.guild.id).emojis(this.id).get();
    this._patch(data);
    return this.author;
  }

  /**
   * Data for editing an emoji.
   * @typedef {Object} GuildEmojiEditData
   * @property {string} [name] The name of the emoji
   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to
   */

  /**
   * Edits the emoji.
   * @param {GuildEmojiEditData} data The new data for the emoji
   * @param {string} [reason] Reason for editing this emoji
   * @returns {Promise<GuildEmoji>}
   * @example
   * // Edit an emoji
   * emoji.edit({ name: 'newemoji' })
   *   .then(e => console.log(`Edited emoji ${e}`))
   *   .catch(console.error);
   */
  edit(data, reason) {
    const roles = data.roles ? data.roles.map(r => r.id || r) : undefined;
    return this.client.api
      .guilds(this.guild.id)
      .emojis(this.id)
      .patch({
        data: {
          name: data.name,
          roles,
        },
        reason,
      })
      .then(newData => {
        const clone = this._clone();
        clone._patch(newData);
        return clone;
      });
  }

  /**
   * Sets the name of the emoji.
   * @param {string} name The new name for the emoji
   * @param {string} [reason] Reason for changing the emoji's name
   * @returns {Promise<GuildEmoji>}
   */
  setName(name, reason) {
    return this.edit({ name }, reason);
  }

  /**
   * Deletes the emoji.
   * @param {string} [reason] Reason for deleting the emoji
   * @returns {Promise<GuildEmoji>}
   */
  delete(reason) {
    return this.client.api
      .guilds(this.guild.id)
      .emojis(this.id)
      .delete({ reason })
      .then(() => this);
  }

  /**
   * Whether this emoji is the same as another one.
   * @param {GuildEmoji|Object} other The emoji to compare it to
   * @returns {boolean} Whether the emoji is equal to the given emoji or not
   */
  equals(other) {
    if (other instanceof GuildEmoji) {
      return (
        other.id === this.id &&
        other.name === this.name &&
        other.managed === this.managed &&
        other.requiresColons === this.requiresColons &&
        other.roles.cache.size === this.roles.cache.size &&
        other.roles.cache.every(role => this.roles.cache.has(role.id))
      );
    } else {
      return (
        other.id === this.id &&
        other.name === this.name &&
        other.roles.length === this.roles.cache.size &&
        other.roles.every(role => this.roles.cache.has(role))
      );
    }
  }
}

module.exports = GuildEmoji;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/GuildMember.js":
/*!***************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/GuildMember.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const Role = __webpack_require__(/*! ./Role */ "./node_modules/discord.js/src/structures/Role.js");
const TextBasedChannel = __webpack_require__(/*! ./interfaces/TextBasedChannel */ "./node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const GuildMemberRoleManager = __webpack_require__(/*! ../managers/GuildMemberRoleManager */ "./node_modules/discord.js/src/managers/GuildMemberRoleManager.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
let Structures;

/**
 * Represents a member of a guild on Discord.
 * @implements {TextBasedChannel}
 * @extends {Base}
 */
class GuildMember extends Base {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the guild member
   * @param {Guild} guild The guild the member is part of
   */
  constructor(client, data, guild) {
    super(client);

    /**
     * The guild that this member is part of
     * @type {Guild}
     */
    this.guild = guild;

    /**
     * The timestamp the member joined the guild at
     * @type {?number}
     */
    this.joinedTimestamp = null;

    /**
     * The ID of the last message sent by the member in their guild, if one was sent
     * @type {?Snowflake}
     */
    this.lastMessageID = null;

    /**
     * The ID of the channel for the last message sent by the member in their guild, if one was sent
     * @type {?Snowflake}
     */
    this.lastMessageChannelID = null;

    /**
     * The timestamp of when the member used their Nitro boost on the guild, if it was used
     * @type {?number}
     */
    this.premiumSinceTimestamp = null;

    /**
     * Whether the member has been removed from the guild
     * @type {boolean}
     */
    this.deleted = false;

    /**
     * The nickname of this member, if they have one
     * @type {?string}
     */
    this.nickname = null;

    this._roles = [];
    if (data) this._patch(data);
  }

  _patch(data) {
    if ('user' in data) {
      /**
       * The user that this guild member instance represents
       * @type {User}
       */
      this.user = this.client.users.add(data.user, true);
    }

    if ('nick' in data) this.nickname = data.nick;
    if ('joined_at' in data) this.joinedTimestamp = new Date(data.joined_at).getTime();
    if ('premium_since' in data) this.premiumSinceTimestamp = new Date(data.premium_since).getTime();
    if ('roles' in data) this._roles = data.roles;
  }

  _clone() {
    const clone = super._clone();
    clone._roles = this._roles.slice();
    return clone;
  }

  /**
   * Whether this GuildMember is a partial
   * @type {boolean}
   * @readonly
   */
  get partial() {
    return !this.joinedTimestamp;
  }

  /**
   * A manager for the roles belonging to this member
   * @type {GuildMemberRoleManager}
   * @readonly
   */
  get roles() {
    return new GuildMemberRoleManager(this);
  }

  /**
   * The Message object of the last message sent by the member in their guild, if one was sent
   * @type {?Message}
   * @readonly
   */
  get lastMessage() {
    const channel = this.guild.channels.cache.get(this.lastMessageChannelID);
    return (channel && channel.messages.cache.get(this.lastMessageID)) || null;
  }

  /**
   * The voice state of this member
   * @type {VoiceState}
   * @readonly
   */
  get voice() {
    if (!Structures) Structures = __webpack_require__(/*! ../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");
    const VoiceState = Structures.get('VoiceState');
    return this.guild.voiceStates.cache.get(this.id) || new VoiceState(this.guild, { user_id: this.id });
  }

  /**
   * The time this member joined the guild
   * @type {?Date}
   * @readonly
   */
  get joinedAt() {
    return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;
  }

  /**
   * The time of when the member used their Nitro boost on the guild, if it was used
   * @type {?Date}
   * @readonly
   */
  get premiumSince() {
    return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;
  }

  /**
   * The presence of this guild member
   * @type {Presence}
   * @readonly
   */
  get presence() {
    if (!Structures) Structures = __webpack_require__(/*! ../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");
    const Presence = Structures.get('Presence');
    return (
      this.guild.presences.cache.get(this.id) ||
      new Presence(this.client, {
        user: {
          id: this.id,
        },
        guild: this.guild,
      })
    );
  }

  /**
   * The displayed color of this member in base 10
   * @type {number}
   * @readonly
   */
  get displayColor() {
    const role = this.roles.color;
    return (role && role.color) || 0;
  }

  /**
   * The displayed color of this member in hexadecimal
   * @type {string}
   * @readonly
   */
  get displayHexColor() {
    const role = this.roles.color;
    return (role && role.hexColor) || '#000000';
  }

  /**
   * The ID of this member
   * @type {Snowflake}
   * @readonly
   */
  get id() {
    return this.user.id;
  }

  /**
   * The nickname of this member, or their username if they don't have one
   * @type {?string}
   * @readonly
   */
  get displayName() {
    return this.nickname || this.user.username;
  }

  /**
   * The overall set of permissions for this member, taking only roles into account
   * @type {Readonly<Permissions>}
   * @readonly
   */
  get permissions() {
    if (this.user.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();
    return new Permissions(this.roles.cache.map(role => role.permissions)).freeze();
  }

  /**
   * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.
   * This is a prerequisite for many moderative actions.
   * @type {boolean}
   * @readonly
   */
  get manageable() {
    if (this.user.id === this.guild.ownerID) return false;
    if (this.user.id === this.client.user.id) return false;
    if (this.client.user.id === this.guild.ownerID) return true;
    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');
    return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
  }

  /**
   * Whether this member is kickable by the client user
   * @type {boolean}
   * @readonly
   */
  get kickable() {
    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.KICK_MEMBERS);
  }

  /**
   * Whether this member is bannable by the client user
   * @type {boolean}
   * @readonly
   */
  get bannable() {
    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.BAN_MEMBERS);
  }

  /**
   * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,
   * taking into account roles and permission overwrites.
   * @param {ChannelResolvable} channel The guild channel to use as context
   * @returns {Readonly<Permissions>}
   */
  permissionsIn(channel) {
    channel = this.guild.channels.resolve(channel);
    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');
    return channel.memberPermissions(this);
  }

  /**
   * Checks if any of this member's roles have a permission.
   * @param {PermissionResolvable} permission Permission(s) to check for
   * @param {Object} [options] Options
   * @param {boolean} [options.checkAdmin=true] Whether to allow the administrator permission to override
   * @param {boolean} [options.checkOwner=true] Whether to allow being the guild's owner to override
   * @returns {boolean}
   */
  hasPermission(permission, { checkAdmin = true, checkOwner = true } = {}) {
    if (checkOwner && this.user.id === this.guild.ownerID) return true;
    const permissions = new Permissions(this.roles.cache.map(role => role.permissions));
    return permissions.has(permission, checkAdmin);
  }

  /**
   * The data for editing a guild member.
   * @typedef {Object} GuildMemberEditData
   * @property {string} [nick] The nickname to set for the member
   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role IDs to apply
   * @property {boolean} [mute] Whether or not the member should be muted
   * @property {boolean} [deaf] Whether or not the member should be deafened
   * @property {ChannelResolvable|null} [channel] Channel to move member to (if they are connected to voice), or `null`
   * if you want to kick them from voice
   */

  /**
   * Edits this member.
   * @param {GuildMemberEditData} data The data to edit the member with
   * @param {string} [reason] Reason for editing this user
   * @returns {Promise<GuildMember>}
   */
  async edit(data, reason) {
    if (data.channel) {
      data.channel = this.guild.channels.resolve(data.channel);
      if (!data.channel || data.channel.type !== 'voice') {
        throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');
      }
      data.channel_id = data.channel.id;
      data.channel = undefined;
    } else if (data.channel === null) {
      data.channel_id = null;
      data.channel = undefined;
    }
    if (data.roles) data.roles = data.roles.map(role => (role instanceof Role ? role.id : role));
    let endpoint = this.client.api.guilds(this.guild.id);
    if (this.user.id === this.client.user.id) {
      const keys = Object.keys(data);
      if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;
      else endpoint = endpoint.members(this.id);
    } else {
      endpoint = endpoint.members(this.id);
    }
    await endpoint.patch({ data, reason });

    const clone = this._clone();
    data.user = this.user;
    clone._patch(data);
    return clone;
  }

  /**
   * Sets the nickname for this member.
   * @param {string} nick The nickname for the guild member
   * @param {string} [reason] Reason for setting the nickname
   * @returns {Promise<GuildMember>}
   */
  setNickname(nick, reason) {
    return this.edit({ nick }, reason);
  }

  /**
   * Creates a DM channel between the client and this member.
   * @returns {Promise<DMChannel>}
   */
  createDM() {
    return this.user.createDM();
  }

  /**
   * Deletes any DMs with this member.
   * @returns {Promise<DMChannel>}
   */
  deleteDM() {
    return this.user.deleteDM();
  }

  /**
   * Kicks this member from the guild.
   * @param {string} [reason] Reason for kicking user
   * @returns {Promise<GuildMember>}
   */
  kick(reason) {
    return this.client.api
      .guilds(this.guild.id)
      .members(this.user.id)
      .delete({ reason })
      .then(() => this);
  }

  /**
   * Bans this guild member.
   * @param {Object} [options] Options for the ban
   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7
   * @param {string} [options.reason] Reason for banning
   * @returns {Promise<GuildMember>}
   * @example
   * // ban a guild member
   * guildMember.ban({ days: 7, reason: 'They deserved it' })
   *   .then(console.log)
   *   .catch(console.error);
   */
  ban(options) {
    return this.guild.members.ban(this, options);
  }

  /**
   * Fetches this GuildMember.
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<GuildMember>}
   */
  fetch(force = false) {
    return this.guild.members.fetch({ user: this.id, cache: true, force });
  }

  /**
   * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.
   * @returns {string}
   * @example
   * // Logs: Hello from <@123456789012345678>!
   * console.log(`Hello from ${member}!`);
   */
  toString() {
    return `<@${this.nickname ? '!' : ''}${this.user.id}>`;
  }

  toJSON() {
    return super.toJSON({
      guild: 'guildID',
      user: 'userID',
      displayName: true,
      speaking: false,
      lastMessage: false,
      lastMessageID: false,
      roles: true,
    });
  }

  // These are here only for documentation purposes - they are implemented by TextBasedChannel
  /* eslint-disable no-empty-function */
  send() {}
}

TextBasedChannel.applyToClass(GuildMember);

module.exports = GuildMember;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/GuildPreview.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/GuildPreview.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const GuildPreviewEmoji = __webpack_require__(/*! ./GuildPreviewEmoji */ "./node_modules/discord.js/src/structures/GuildPreviewEmoji.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");

/**
 * Represents the data about the guild any bot can preview, connected to the specified guild.
 * @extends {Base}
 */
class GuildPreview extends Base {
  constructor(client, data) {
    super(client);

    if (!data) return;

    this._patch(data);
  }

  /**
   * Builds the guild with the provided data.
   * @param {*} data The raw data of the guild
   * @private
   */
  _patch(data) {
    /**
     * The id of this guild
     * @type {string}
     */
    this.id = data.id;

    /**
     * The name of this guild
     * @type {string}
     */
    this.name = data.name;

    /**
     * The icon of this guild
     * @type {?string}
     */
    this.icon = data.icon;

    /**
     * The splash icon of this guild
     * @type {?string}
     */
    this.splash = data.splash;

    /**
     * The discovery splash icon of this guild
     * @type {?string}
     */
    this.discoverySplash = data.discovery_splash;

    /**
     * An array of enabled guild features
     * @type {Features[]}
     */
    this.features = data.features;

    /**
     * The approximate count of members in this guild
     * @type {number}
     */
    this.approximateMemberCount = data.approximate_member_count;

    /**
     * The approximate count of online members in this guild
     * @type {number}
     */
    this.approximatePresenceCount = data.approximate_presence_count;

    /**
     * The description for this guild
     * @type {?string}
     */
    this.description = data.description || null;

    if (!this.emojis) {
      /**
       * Collection of emojis belonging to this guild
       * @type {Collection<Snowflake, GuildPreviewEmoji>}
       */
      this.emojis = new Collection();
    } else {
      this.emojis.clear();
    }
    for (const emoji of data.emojis) {
      this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
    }
  }

  /**
   * The URL to this guild's splash.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  splashURL({ format, size } = {}) {
    if (!this.splash) return null;
    return this.client.rest.cdn.Splash(this.id, this.splash, format, size);
  }

  /**
   * The URL to this guild's discovery splash.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  discoverySplashURL({ format, size } = {}) {
    if (!this.discoverySplash) return null;
    return this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);
  }

  /**
   * The URL to this guild's icon.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  iconURL({ format, size, dynamic } = {}) {
    if (!this.icon) return null;
    return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);
  }

  /**
   * Fetches this guild.
   * @returns {Promise<GuildPreview>}
   */
  fetch() {
    return this.client.api
      .guilds(this.id)
      .preview.get()
      .then(data => {
        this._patch(data);
        return this;
      });
  }

  /**
   * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
   * @returns {string}
   * @example
   * // Logs: Hello from My Guild!
   * console.log(`Hello from ${previewGuild}!`);
   */
  toString() {
    return this.name;
  }

  toJSON() {
    const json = super.toJSON();
    json.iconURL = this.iconURL();
    json.splashURL = this.splashURL();
    return json;
  }
}

module.exports = GuildPreview;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/GuildPreviewEmoji.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/GuildPreviewEmoji.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseGuildEmoji = __webpack_require__(/*! ./BaseGuildEmoji */ "./node_modules/discord.js/src/structures/BaseGuildEmoji.js");

/**
 * Represents an instance of an emoji belonging to a public guild obtained through Discord's preview endpoint.
 * @extends {BaseGuildEmoji}
 */
class GuildPreviewEmoji extends BaseGuildEmoji {
  /**
   * The public guild this emoji is part of
   * @type {GuildPreview}
   * @name GuildPreviewEmoji#guild
   */

  /**
   * Set of roles this emoji is active for
   * @type {Set<Snowflake>}
   * @readonly
   */
  get roles() {
    return new Set(this._roles);
  }
}

module.exports = GuildPreviewEmoji;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/GuildTemplate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/GuildTemplate.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const { Events } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");

/**
 * Represents the template for a guild.
 * @extends {Base}
 */
class GuildTemplate extends Base {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The raw data for the template
   */
  constructor(client, data) {
    super(client);
    this._patch(data);
  }

  /**
   * Builds or updates the template with the provided data.
   * @param {Object} data The raw data for the template
   * @returns {GuildTemplate}
   * @private
   */
  _patch(data) {
    /**
     * The unique code of this template
     * @type {string}
     */
    this.code = data.code;

    /**
     * The name of this template
     * @type {string}
     */
    this.name = data.name;

    /**
     * The description of this template
     * @type {?string}
     */
    this.description = data.description;

    /**
     * The amount of times this template has been used
     * @type {number}
     */
    this.usageCount = data.usage_count;

    /**
     * The ID of the user that created this template
     * @type {Snowflake}
     */
    this.creatorID = data.creator_id;

    /**
     * The user that created this template
     * @type {User}
     */
    this.creator = this.client.users.add(data.creator);

    /**
     * The time of when this template was created at
     * @type {Date}
     */
    this.createdAt = new Date(data.created_at);

    /**
     * The time of when this template was last synced to the guild
     * @type {Date}
     */
    this.updatedAt = new Date(data.updated_at);

    /**
     * The ID of the guild that this template belongs to
     * @type {Snowflake}
     */
    this.guildID = data.source_guild_id;

    /**
     * The data of the guild that this template would create
     * @type {Object}
     * @see {@link https://discord.com/developers/docs/resources/guild#guild-resource}
     */
    this.serializedGuild = data.serialized_source_guild;

    /**
     * Whether this template has unsynced changes
     * @type {?boolean}
     */
    this.unSynced = 'is_dirty' in data ? Boolean(data.is_dirty) : null;

    return this;
  }

  /**
   * Creates a guild based from this template.
   * <warn>This is only available to bots in fewer than 10 guilds.</warn>
   * @param {string} name The name of the guild
   * @param {BufferResolvable|Base64Resolvable} [icon] The icon for the guild
   * @returns {Promise<Guild>}
   */
  async createGuild(name, icon) {
    const { client } = this;
    const data = await client.api.guilds.templates(this.code).post({
      data: {
        name,
        icon: await DataResolver.resolveImage(icon),
      },
    });
    // eslint-disable-next-line consistent-return
    return new Promise(resolve => {
      const createdGuild = client.guilds.cache.get(data.id);
      if (createdGuild) return resolve(createdGuild);

      const resolveGuild = guild => {
        client.off(Events.GUILD_CREATE, handleGuild);
        client.decrementMaxListeners();
        resolve(guild);
      };

      const handleGuild = guild => {
        if (guild.id === data.id) {
          client.clearTimeout(timeout);
          resolveGuild(guild);
        }
      };

      client.incrementMaxListeners();
      client.on(Events.GUILD_CREATE, handleGuild);

      const timeout = client.setTimeout(() => resolveGuild(client.guilds.add(data)), 10000);
    });
  }

  /**
   * Updates the metadata on this template.
   * @param {Object} options Options for the template
   * @param {string} [options.name] The name of this template
   * @param {string} [options.description] The description of this template
   * @returns {Promise<GuildTemplate>}
   */
  edit({ name, description } = {}) {
    return this.client.api
      .guilds(this.guildID)
      .templates(this.code)
      .patch({ data: { name, description } })
      .then(data => this._patch(data));
  }

  /**
   * Deletes this template.
   * @returns {Promise<GuildTemplate>}
   */
  delete() {
    return this.client.api
      .guilds(this.guildID)
      .templates(this.code)
      .delete()
      .then(() => this);
  }

  /**
   * Syncs this template to the current state of the guild.
   * @returns {Promise<GuildTemplate>}
   */
  sync() {
    return this.client.api
      .guilds(this.guildID)
      .templates(this.code)
      .put()
      .then(data => this._patch(data));
  }

  /**
   * The timestamp of when this template was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return this.createdAt.getTime();
  }

  /**
   * The timestamp of when this template was last synced to the guild
   * @type {number}
   * @readonly
   */
  get updatedTimestamp() {
    return this.updatedAt.getTime();
  }

  /**
   * The guild that this template belongs to
   * @type {?Guild}
   * @readonly
   */
  get guild() {
    return this.client.guilds.cache.get(this.guildID) || null;
  }

  /**
   * The URL of this template
   * @type {string}
   * @readonly
   */
  get url() {
    return `${this.client.options.http.template}/${this.code}`;
  }

  /**
   * When concatenated with a string, this automatically returns the templates's code instead of the template object.
   * @returns {string}
   * @example
   * // Logs: Template: FKvmczH2HyUf
   * console.log(`Template: ${guildTemplate}!`);
   */
  toString() {
    return this.code;
  }
}

module.exports = GuildTemplate;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Integration.js":
/*!***************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Integration.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const IntegrationApplication = __webpack_require__(/*! ./IntegrationApplication */ "./node_modules/discord.js/src/structures/IntegrationApplication.js");

/**
 * The information account for an integration
 * @typedef {Object} IntegrationAccount
 * @property {string} id The id of the account
 * @property {string} name The name of the account
 */

/**
 *  Represents a guild integration.
 */
class Integration extends Base {
  constructor(client, data, guild) {
    super(client);

    /**
     * The guild this integration belongs to
     * @type {Guild}
     */
    this.guild = guild;

    /**
     * The integration id
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * The integration name
     * @type {string}
     */
    this.name = data.name;

    /**
     * The integration type (twitch, youtube, etc)
     * @type {string}
     */
    this.type = data.type;

    /**
     * Whether this integration is enabled
     * @type {boolean}
     */
    this.enabled = data.enabled;

    /**
     * Whether this integration is syncing
     * @type {boolean}
     */
    this.syncing = data.syncing;

    /**
     * The role that this integration uses for subscribers
     * @type {Role}
     */
    this.role = this.guild.roles.cache.get(data.role_id);

    if (data.user) {
      /**
       * The user for this integration
       * @type {?User}
       */
      this.user = this.client.users.add(data.user);
    } else {
      this.user = null;
    }

    /**
     * The account integration information
     * @type {IntegrationAccount}
     */
    this.account = data.account;

    /**
     * The last time this integration was last synced
     * @type {number}
     */
    this.syncedAt = data.synced_at;
    this._patch(data);
  }

  _patch(data) {
    /**
     * The behavior of expiring subscribers
     * @type {number}
     */
    this.expireBehavior = data.expire_behavior;

    /**
     * The grace period before expiring subscribers
     * @type {number}
     */
    this.expireGracePeriod = data.expire_grace_period;

    if ('application' in data) {
      if (this.application) {
        this.application._patch(data.application);
      } else {
        /**
         * The application for this integration
         * @type {?IntegrationApplication}
         */
        this.application = new IntegrationApplication(this.client, data.application);
      }
    } else if (!this.application) {
      this.application = null;
    }
  }

  /**
   * Sync this integration
   * @returns {Promise<Integration>}
   */
  sync() {
    this.syncing = true;
    return this.client.api
      .guilds(this.guild.id)
      .integrations(this.id)
      .post()
      .then(() => {
        this.syncing = false;
        this.syncedAt = Date.now();
        return this;
      });
  }

  /**
   * The data for editing an integration.
   * @typedef {Object} IntegrationEditData
   * @property {number} [expireBehavior] The new behaviour of expiring subscribers
   * @property {number} [expireGracePeriod] The new grace period before expiring subscribers
   */

  /**
   * Edits this integration.
   * @param {IntegrationEditData} data The data to edit this integration with
   * @param {string} reason Reason for editing this integration
   * @returns {Promise<Integration>}
   */
  edit(data, reason) {
    if ('expireBehavior' in data) {
      data.expire_behavior = data.expireBehavior;
      data.expireBehavior = null;
    }
    if ('expireGracePeriod' in data) {
      data.expire_grace_period = data.expireGracePeriod;
      data.expireGracePeriod = null;
    }
    // The option enable_emoticons is only available for Twitch at this moment
    return this.client.api
      .guilds(this.guild.id)
      .integrations(this.id)
      .patch({ data, reason })
      .then(() => {
        this._patch(data);
        return this;
      });
  }

  /**
   * Deletes this integration.
   * @returns {Promise<Integration>}
   * @param {string} [reason] Reason for deleting this integration
   */
  delete(reason) {
    return this.client.api
      .guilds(this.guild.id)
      .integrations(this.id)
      .delete({ reason })
      .then(() => this);
  }

  toJSON() {
    return super.toJSON({
      role: 'roleID',
      guild: 'guildID',
      user: 'userID',
    });
  }
}

module.exports = Integration;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/IntegrationApplication.js":
/*!**************************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/IntegrationApplication.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Application = __webpack_require__(/*! ./interfaces/Application */ "./node_modules/discord.js/src/structures/interfaces/Application.js");

/**
 * Represents an Integration's OAuth2 Application.
 * @extends {Application}
 */
class IntegrationApplication extends Application {
  _patch(data) {
    super._patch(data);

    if (typeof data.bot !== 'undefined') {
      /**
       * The bot {@link User user} for this application
       * @type {?User}
       */
      this.bot = this.client.users.add(data.bot);
    } else if (!this.bot) {
      this.bot = null;
    }
  }
}

module.exports = IntegrationApplication;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Invite.js":
/*!**********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Invite.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const { Endpoints } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");

/**
 * Represents an invitation to a guild channel.
 * <warn>The only guaranteed properties are `code`, `channel`, and `url`. Other properties can be missing.</warn>
 * @extends {Base}
 */
class Invite extends Base {
  constructor(client, data) {
    super(client);
    this._patch(data);
  }

  _patch(data) {
    /**
     * The guild the invite is for
     * @type {?Guild}
     */
    this.guild = data.guild ? this.client.guilds.add(data.guild, false) : null;

    /**
     * The code for this invite
     * @type {string}
     */
    this.code = data.code;

    /**
     * The approximate number of online members of the guild this invite is for
     * @type {?number}
     */
    this.presenceCount = 'approximate_presence_count' in data ? data.approximate_presence_count : null;

    /**
     * The approximate total number of members of the guild this invite is for
     * @type {?number}
     */
    this.memberCount = 'approximate_member_count' in data ? data.approximate_member_count : null;

    /**
     * Whether or not this invite is temporary
     * @type {?boolean}
     */
    this.temporary = 'temporary' in data ? data.temporary : null;

    /**
     * The maximum age of the invite, in seconds, 0 if never expires
     * @type {?number}
     */
    this.maxAge = 'max_age' in data ? data.max_age : null;

    /**
     * How many times this invite has been used
     * @type {?number}
     */
    this.uses = 'uses' in data ? data.uses : null;

    /**
     * The maximum uses of this invite
     * @type {?number}
     */
    this.maxUses = 'max_uses' in data ? data.max_uses : null;

    /**
     * The user who created this invite
     * @type {?User}
     */
    this.inviter = data.inviter ? this.client.users.add(data.inviter) : null;

    /**
     * The target user for this invite
     * @type {?User}
     */
    this.targetUser = data.target_user ? this.client.users.add(data.target_user) : null;

    /**
     * The type of the target user:
     * * 1: STREAM
     * @typedef {number} TargetUser
     */

    /**
     * The target user type
     * @type {?TargetUser}
     */
    this.targetUserType = typeof data.target_user_type === 'number' ? data.target_user_type : null;

    /**
     * The channel the invite is for
     * @type {Channel}
     */
    this.channel = this.client.channels.add(data.channel, this.guild, false);

    /**
     * The timestamp the invite was created at
     * @type {?number}
     */
    this.createdTimestamp = 'created_at' in data ? new Date(data.created_at).getTime() : null;
  }

  /**
   * The time the invite was created at
   * @type {?Date}
   * @readonly
   */
  get createdAt() {
    return this.createdTimestamp ? new Date(this.createdTimestamp) : null;
  }

  /**
   * Whether the invite is deletable by the client user
   * @type {boolean}
   * @readonly
   */
  get deletable() {
    const guild = this.guild;
    if (!guild || !this.client.guilds.cache.has(guild.id)) return false;
    if (!guild.me) throw new Error('GUILD_UNCACHED_ME');
    return (
      this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false) ||
      guild.me.permissions.has(Permissions.FLAGS.MANAGE_GUILD)
    );
  }

  /**
   * The timestamp the invite will expire at
   * @type {?number}
   * @readonly
   */
  get expiresTimestamp() {
    return this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1000 : null;
  }

  /**
   * The time the invite will expire at
   * @type {?Date}
   * @readonly
   */
  get expiresAt() {
    const { expiresTimestamp } = this;
    return expiresTimestamp ? new Date(expiresTimestamp) : null;
  }

  /**
   * The URL to the invite
   * @type {string}
   * @readonly
   */
  get url() {
    return Endpoints.invite(this.client.options.http.invite, this.code);
  }

  /**
   * Deletes this invite.
   * @param {string} [reason] Reason for deleting this invite
   * @returns {Promise<Invite>}
   */
  delete(reason) {
    return this.client.api.invites[this.code].delete({ reason }).then(() => this);
  }

  /**
   * When concatenated with a string, this automatically concatenates the invite's URL instead of the object.
   * @returns {string}
   * @example
   * // Logs: Invite: https://discord.gg/A1b2C3
   * console.log(`Invite: ${invite}`);
   */
  toString() {
    return this.url;
  }

  toJSON() {
    return super.toJSON({
      url: true,
      expiresTimestamp: true,
      presenceCount: false,
      memberCount: false,
      uses: false,
      channel: 'channelID',
      inviter: 'inviterID',
      guild: 'guildID',
    });
  }

  valueOf() {
    return this.code;
  }
}

module.exports = Invite;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Message.js":
/*!***********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Message.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const APIMessage = __webpack_require__(/*! ./APIMessage */ "./node_modules/discord.js/src/structures/APIMessage.js");
const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const ClientApplication = __webpack_require__(/*! ./ClientApplication */ "./node_modules/discord.js/src/structures/ClientApplication.js");
const MessageAttachment = __webpack_require__(/*! ./MessageAttachment */ "./node_modules/discord.js/src/structures/MessageAttachment.js");
const Embed = __webpack_require__(/*! ./MessageEmbed */ "./node_modules/discord.js/src/structures/MessageEmbed.js");
const Mentions = __webpack_require__(/*! ./MessageMentions */ "./node_modules/discord.js/src/structures/MessageMentions.js");
const ReactionCollector = __webpack_require__(/*! ./ReactionCollector */ "./node_modules/discord.js/src/structures/ReactionCollector.js");
const { Error, TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const ReactionManager = __webpack_require__(/*! ../managers/ReactionManager */ "./node_modules/discord.js/src/managers/ReactionManager.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { MessageTypes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const MessageFlags = __webpack_require__(/*! ../util/MessageFlags */ "./node_modules/discord.js/src/util/MessageFlags.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
const SnowflakeUtil = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a message on Discord.
 * @extends {Base}
 */
class Message extends Base {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the message
   * @param {TextChannel|DMChannel|NewsChannel} channel The channel the message was sent in
   */
  constructor(client, data, channel) {
    super(client);

    /**
     * The channel that the message was sent in
     * @type {TextChannel|DMChannel|NewsChannel}
     */
    this.channel = channel;

    /**
     * Whether this message has been deleted
     * @type {boolean}
     */
    this.deleted = false;

    if (data) this._patch(data);
  }

  _patch(data) {
    /**
     * The ID of the message
     * @type {Snowflake}
     */
    this.id = data.id;

    if ('type' in data) {
      /**
       * The type of the message
       * @type {?MessageType}
       */
      this.type = MessageTypes[data.type];

      /**
       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)
       * @type {?boolean}
       */
      this.system = data.type !== 0;
    } else if (typeof this.type !== 'string') {
      this.system = null;
      this.type = null;
    }

    if ('content' in data) {
      /**
       * The content of the message
       * @type {?string}
       */
      this.content = data.content;
    } else if (typeof this.content !== 'string') {
      this.content = null;
    }

    if ('author' in data) {
      /**
       * The author of the message
       * @type {?User}
       */
      this.author = this.client.users.add(data.author, !data.webhook_id);
    } else if (!this.author) {
      this.author = null;
    }

    if ('pinned' in data) {
      /**
       * Whether or not this message is pinned
       * @type {?boolean}
       */
      this.pinned = Boolean(data.pinned);
    } else if (typeof this.pinned !== 'boolean') {
      this.pinned = null;
    }

    if ('tts' in data) {
      /**
       * Whether or not the message was Text-To-Speech
       * @type {?boolean}
       */
      this.tts = data.tts;
    } else if (typeof this.tts !== 'boolean') {
      this.tts = null;
    }

    /**
     * A random number or string used for checking message delivery
     * <warn>This is only received after the message was sent successfully, and
     * lost if re-fetched</warn>
     * @type {?string}
     */
    this.nonce = 'nonce' in data ? data.nonce : null;

    /**
     * A list of embeds in the message - e.g. YouTube Player
     * @type {MessageEmbed[]}
     */
    this.embeds = (data.embeds || []).map(e => new Embed(e, true));

    /**
     * A collection of attachments in the message - e.g. Pictures - mapped by their ID
     * @type {Collection<Snowflake, MessageAttachment>}
     */
    this.attachments = new Collection();
    if (data.attachments) {
      for (const attachment of data.attachments) {
        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));
      }
    }

    /**
     * The timestamp the message was sent at
     * @type {number}
     */
    this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;

    /**
     * The timestamp the message was last edited at (if applicable)
     * @type {?number}
     */
    this.editedTimestamp = 'edited_timestamp' in data ? new Date(data.edited_timestamp).getTime() : null;

    /**
     * A manager of the reactions belonging to this message
     * @type {ReactionManager}
     */
    this.reactions = new ReactionManager(this);
    if (data.reactions && data.reactions.length > 0) {
      for (const reaction of data.reactions) {
        this.reactions.add(reaction);
      }
    }

    /**
     * All valid mentions that the message contains
     * @type {MessageMentions}
     */
    this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);

    /**
     * ID of the webhook that sent the message, if applicable
     * @type {?Snowflake}
     */
    this.webhookID = data.webhook_id || null;

    /**
     * Supplemental application information for group activities
     * @type {?ClientApplication}
     */
    this.application = data.application ? new ClientApplication(this.client, data.application) : null;

    /**
     * Group activity
     * @type {?MessageActivity}
     */
    this.activity = data.activity
      ? {
          partyID: data.activity.party_id,
          type: data.activity.type,
        }
      : null;

    /**
     * The previous versions of the message, sorted with the most recent first
     * @type {Message[]}
     * @private
     */
    this._edits = [];

    if (this.member && data.member) {
      this.member._patch(data.member);
    } else if (data.member && this.guild && this.author) {
      this.guild.members.add(Object.assign(data.member, { user: this.author }));
    }

    /**
     * Flags that are applied to the message
     * @type {Readonly<MessageFlags>}
     */
    this.flags = new MessageFlags(data.flags).freeze();

    /**
     * Reference data sent in a crossposted message.
     * @typedef {Object} MessageReference
     * @property {string} channelID ID of the channel the message was crossposted from
     * @property {?string} guildID ID of the guild the message was crossposted from
     * @property {?string} messageID ID of the message that was crossposted
     */

    /**
     * Message reference data
     * @type {?MessageReference}
     */
    this.reference = data.message_reference
      ? {
          channelID: data.message_reference.channel_id,
          guildID: data.message_reference.guild_id,
          messageID: data.message_reference.message_id,
        }
      : null;
  }

  /**
   * Whether or not this message is a partial
   * @type {boolean}
   * @readonly
   */
  get partial() {
    return typeof this.content !== 'string' || !this.author;
  }

  /**
   * Updates the message and returns the old message.
   * @param {Object} data Raw Discord message update data
   * @returns {Message}
   * @private
   */
  patch(data) {
    const clone = this._clone();
    const { messageEditHistoryMaxSize } = this.client.options;
    if (messageEditHistoryMaxSize !== 0) {
      const editsLimit = messageEditHistoryMaxSize === -1 ? Infinity : messageEditHistoryMaxSize;
      if (this._edits.unshift(clone) > editsLimit) this._edits.pop();
    }

    if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();
    if ('content' in data) this.content = data.content;
    if ('pinned' in data) this.pinned = data.pinned;
    if ('tts' in data) this.tts = data.tts;
    if ('embeds' in data) this.embeds = data.embeds.map(e => new Embed(e, true));
    else this.embeds = this.embeds.slice();

    if ('attachments' in data) {
      this.attachments = new Collection();
      for (const attachment of data.attachments) {
        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));
      }
    } else {
      this.attachments = new Collection(this.attachments);
    }

    this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mention_roles' in data ? data.mention_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone,
      'mention_channels' in data ? data.mention_channels : this.mentions.crosspostedChannels,
    );

    this.flags = new MessageFlags('flags' in data ? data.flags : 0).freeze();

    return clone;
  }

  /**
   * Represents the author of the message as a guild member.
   * Only available if the message comes from a guild where the author is still a member
   * @type {?GuildMember}
   * @readonly
   */
  get member() {
    return this.guild ? this.guild.member(this.author) || null : null;
  }

  /**
   * The time the message was sent at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * The time the message was last edited at (if applicable)
   * @type {?Date}
   * @readonly
   */
  get editedAt() {
    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;
  }

  /**
   * The guild the message was sent in (if in a guild channel)
   * @type {?Guild}
   * @readonly
   */
  get guild() {
    return this.channel.guild || null;
  }

  /**
   * The url to jump to this message
   * @type {string}
   * @readonly
   */
  get url() {
    return `https://discord.com/channels/${this.guild ? this.guild.id : '@me'}/${this.channel.id}/${this.id}`;
  }

  /**
   * The message contents with all mentions replaced by the equivalent text.
   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.
   * @type {string}
   * @readonly
   */
  get cleanContent() {
    // eslint-disable-next-line eqeqeq
    return this.content != null ? Util.cleanContent(this.content, this) : null;
  }

  /**
   * Creates a reaction collector.
   * @param {CollectorFilter} filter The filter to apply
   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector
   * @returns {ReactionCollector}
   * @example
   * // Create a reaction collector
   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID';
   * const collector = message.createReactionCollector(filter, { time: 15000 });
   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));
   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
   */
  createReactionCollector(filter, options = {}) {
    return new ReactionCollector(this, filter, options);
  }

  /**
   * An object containing the same properties as CollectorOptions, but a few more:
   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions
   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
   */

  /**
   * Similar to createReactionCollector but in promise form.
   * Resolves with a collection of reactions that pass the specified filter.
   * @param {CollectorFilter} filter The filter function to use
   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector
   * @returns {Promise<Collection<string, MessageReaction>>}
   * @example
   * // Create a reaction collector
   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'
   * message.awaitReactions(filter, { time: 15000 })
   *   .then(collected => console.log(`Collected ${collected.size} reactions`))
   *   .catch(console.error);
   */
  awaitReactions(filter, options = {}) {
    return new Promise((resolve, reject) => {
      const collector = this.createReactionCollector(filter, options);
      collector.once('end', (reactions, reason) => {
        if (options.errors && options.errors.includes(reason)) reject(reactions);
        else resolve(reactions);
      });
    });
  }

  /**
   * An array of cached versions of the message, including the current version
   * Sorted from latest (first) to oldest (last)
   * @type {Message[]}
   * @readonly
   */
  get edits() {
    const copy = this._edits.slice();
    copy.unshift(this);
    return copy;
  }

  /**
   * Whether the message is editable by the client user
   * @type {boolean}
   * @readonly
   */
  get editable() {
    return this.author.id === this.client.user.id;
  }

  /**
   * Whether the message is deletable by the client user
   * @type {boolean}
   * @readonly
   */
  get deletable() {
    return (
      !this.deleted &&
      (this.author.id === this.client.user.id ||
        (this.guild && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false)))
    );
  }

  /**
   * Whether the message is pinnable by the client user
   * @type {boolean}
   * @readonly
   */
  get pinnable() {
    return (
      this.type === 'DEFAULT' &&
      (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false))
    );
  }

  /**
   * Whether the message is crosspostable by the client user
   * @type {boolean}
   * @readonly
   */
  get crosspostable() {
    return (
      this.channel.type === 'news' &&
      !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) &&
      this.type === 'DEFAULT' &&
      this.channel.viewable &&
      this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.SEND_MESSAGES) &&
      (this.author.id === this.client.user.id ||
        this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES))
    );
  }

  /**
   * Options that can be passed into editMessage.
   * @typedef {Object} MessageEditOptions
   * @property {string} [content] Content to be edited
   * @property {MessageEmbed|Object} [embed] An embed to be added/edited
   * @property {string|boolean} [code] Language for optional codeblock formatting to apply
   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content
   */

  /**
   * Edits the content of the message.
   * @param {StringResolvable|APIMessage} [content] The new content for the message
   * @param {MessageEditOptions|MessageEmbed} [options] The options to provide
   * @returns {Promise<Message>}
   * @example
   * // Update the content of a message
   * message.edit('This is my new content!')
   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))
   *   .catch(console.error);
   */
  edit(content, options) {
    const { data } =
      content instanceof APIMessage ? content.resolveData() : APIMessage.create(this, content, options).resolveData();
    return this.client.api.channels[this.channel.id].messages[this.id].patch({ data }).then(d => {
      const clone = this._clone();
      clone._patch(d);
      return clone;
    });
  }

  /**
   * Publishes a message in an announcement channel to all channels following it.
   * @returns {Promise<Message>}
   * @example
   * // Crosspost a message
   * if (message.channel.type === 'news') {
   *   message.crosspost()
   *     .then(() => console.log('Crossposted message'))
   *     .catch(console.error);
   * }
   */
  async crosspost() {
    await this.client.api.channels(this.channel.id).messages(this.id).crosspost.post();
    return this;
  }

  /**
   * Pins this message to the channel's pinned messages.
   * @param {Object} [options] Options for pinning
   * @param {string} [options.reason] Reason for pinning
   * @returns {Promise<Message>}
   * @example
   * // Pin a message with a reason
   * message.pin({ reason: 'important' })
   *   .then(console.log)
   *   .catch(console.error)
   */
  pin(options) {
    return this.client.api
      .channels(this.channel.id)
      .pins(this.id)
      .put(options)
      .then(() => this);
  }

  /**
   * Unpins this message from the channel's pinned messages.
   * @param {Object} [options] Options for unpinning
   * @param {string} [options.reason] Reason for unpinning
   * @returns {Promise<Message>}
   * @example
   * // Unpin a message with a reason
   * message.unpin({ reason: 'no longer relevant' })
   *   .then(console.log)
   *   .catch(console.error)
   */
  unpin(options) {
    return this.client.api
      .channels(this.channel.id)
      .pins(this.id)
      .delete(options)
      .then(() => this);
  }

  /**
   * Adds a reaction to the message.
   * @param {EmojiIdentifierResolvable} emoji The emoji to react with
   * @returns {Promise<MessageReaction>}
   * @example
   * // React to a message with a unicode emoji
   * message.react('🤔')
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // React to a message with a custom emoji
   * message.react(message.guild.emojis.cache.get('123456789012345678'))
   *   .then(console.log)
   *   .catch(console.error);
   */
  react(emoji) {
    emoji = this.client.emojis.resolveIdentifier(emoji);
    if (!emoji) throw new TypeError('EMOJI_TYPE');

    return this.client.api
      .channels(this.channel.id)
      .messages(this.id)
      .reactions(emoji, '@me')
      .put()
      .then(
        () =>
          this.client.actions.MessageReactionAdd.handle({
            user: this.client.user,
            channel: this.channel,
            message: this,
            emoji: Util.parseEmoji(emoji),
          }).reaction,
      );
  }

  /**
   * Deletes the message.
   * @param {Object} [options] Options
   * @param {number} [options.timeout=0] How long to wait to delete the message in milliseconds
   * @param {string} [options.reason] Reason for deleting this message, if it does not belong to the client user
   * @returns {Promise<Message>}
   * @example
   * // Delete a message
   * message.delete({ timeout: 5000 })
   *   .then(msg => console.log(`Deleted message from ${msg.author.username} after 5 seconds`))
   *   .catch(console.error);
   */
  delete(options = {}) {
    if (typeof options !== 'object') return Promise.reject(new TypeError('INVALID_TYPE', 'options', 'object', true));
    const { timeout = 0, reason } = options;
    if (timeout <= 0) {
      return this.channel.messages.delete(this.id, reason).then(() => this);
    } else {
      return new Promise(resolve => {
        this.client.setTimeout(() => {
          resolve(this.delete({ reason }));
        }, timeout);
      });
    }
  }

  /**
   * Replies to the message.
   * @param {StringResolvable|APIMessage} [content=''] The content for the message
   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide
   * @returns {Promise<Message|Message[]>}
   * @example
   * // Reply to a message
   * message.reply('Hey, I\'m a reply!')
   *   .then(() => console.log(`Sent a reply to ${message.author.username}`))
   *   .catch(console.error);
   */
  reply(content, options) {
    return this.channel.send(
      content instanceof APIMessage
        ? content
        : APIMessage.transformOptions(content, options, { reply: this.member || this.author }),
    );
  }

  /**
   * Fetch this message.
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<Message>}
   */
  fetch(force = false) {
    return this.channel.messages.fetch(this.id, true, force);
  }

  /**
   * Fetches the webhook used to create this message.
   * @returns {Promise<?Webhook>}
   */
  fetchWebhook() {
    if (!this.webhookID) return Promise.reject(new Error('WEBHOOK_MESSAGE'));
    return this.client.fetchWebhook(this.webhookID);
  }

  /**
   * Suppresses or unsuppresses embeds on a message
   * @param {boolean} [suppress=true] If the embeds should be suppressed or not
   * @returns {Promise<Message>}
   */
  suppressEmbeds(suppress = true) {
    const flags = new MessageFlags(this.flags.bitfield);

    if (suppress) {
      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
    } else {
      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
    }

    return this.edit({ flags });
  }

  /**
   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages
   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This
   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.
   * @param {Message} message The message to compare it to
   * @param {Object} rawData Raw data passed through the WebSocket about this message
   * @returns {boolean}
   */
  equals(message, rawData) {
    if (!message) return false;
    const embedUpdate = !message.author && !message.attachments;
    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;

    let equal =
      this.id === message.id &&
      this.author.id === message.author.id &&
      this.content === message.content &&
      this.tts === message.tts &&
      this.nonce === message.nonce &&
      this.embeds.length === message.embeds.length &&
      this.attachments.length === message.attachments.length;

    if (equal && rawData) {
      equal =
        this.mentions.everyone === message.mentions.everyone &&
        this.createdTimestamp === new Date(rawData.timestamp).getTime() &&
        this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();
    }

    return equal;
  }

  /**
   * When concatenated with a string, this automatically concatenates the message's content instead of the object.
   * @returns {string}
   * @example
   * // Logs: Message: This is a message!
   * console.log(`Message: ${message}`);
   */
  toString() {
    return this.content;
  }

  toJSON() {
    return super.toJSON({
      channel: 'channelID',
      author: 'authorID',
      application: 'applicationID',
      guild: 'guildID',
      cleanContent: true,
      member: false,
      reactions: false,
    });
  }
}

module.exports = Message;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/MessageAttachment.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/MessageAttachment.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents an attachment in a message.
 */
class MessageAttachment {
  /**
   * @param {BufferResolvable|Stream} attachment The file
   * @param {string} [name=null] The name of the file, if any
   * @param {Object} [data] Extra data
   */
  constructor(attachment, name = null, data) {
    this.attachment = attachment;
    /**
     * The name of this attachment
     * @type {?string}
     */
    this.name = name;
    if (data) this._patch(data);
  }

  /**
   * Sets the file of this attachment.
   * @param {BufferResolvable|Stream} attachment The file
   * @param {string} [name=null] The name of the file, if any
   * @returns {MessageAttachment} This attachment
   */
  setFile(attachment, name = null) {
    this.attachment = attachment;
    this.name = name;
    return this;
  }

  /**
   * Sets the name of this attachment.
   * @param {string} name The name of the file
   * @returns {MessageAttachment} This attachment
   */
  setName(name) {
    this.name = name;
    return this;
  }

  _patch(data) {
    /**
     * The ID of this attachment
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * The size of this attachment in bytes
     * @type {number}
     */
    this.size = data.size;

    /**
     * The URL to this attachment
     * @type {string}
     */
    this.url = data.url;

    /**
     * The Proxy URL to this attachment
     * @type {string}
     */
    this.proxyURL = data.proxy_url;

    /**
     * The height of this attachment (if an image or video)
     * @type {?number}
     */
    this.height = typeof data.height !== 'undefined' ? data.height : null;

    /**
     * The width of this attachment (if an image or video)
     * @type {?number}
     */
    this.width = typeof data.width !== 'undefined' ? data.width : null;
  }

  /**
   * Whether or not this attachment has been marked as a spoiler
   * @type {boolean}
   * @readonly
   */
  get spoiler() {
    return Util.basename(this.url).startsWith('SPOILER_');
  }

  toJSON() {
    return Util.flatten(this);
  }
}

module.exports = MessageAttachment;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/MessageCollector.js":
/*!********************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/MessageCollector.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Collector = __webpack_require__(/*! ./interfaces/Collector */ "./node_modules/discord.js/src/structures/interfaces/Collector.js");
const { Events } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/**
 * @typedef {CollectorOptions} MessageCollectorOptions
 * @property {number} max The maximum amount of messages to collect
 * @property {number} maxProcessed The maximum amount of messages to process
 */

/**
 * Collects messages on a channel.
 * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.
 * @extends {Collector}
 */
class MessageCollector extends Collector {
  /**
   * @param {TextChannel|DMChannel} channel The channel
   * @param {CollectorFilter} filter The filter to be applied to this collector
   * @param {MessageCollectorOptions} options The options to be applied to this collector
   * @emits MessageCollector#message
   */
  constructor(channel, filter, options = {}) {
    super(channel.client, filter, options);

    /**
     * The channel
     * @type {TextBasedChannel}
     */
    this.channel = channel;

    /**
     * Total number of messages that were received in the channel during message collection
     * @type {number}
     */
    this.received = 0;

    const bulkDeleteListener = messages => {
      for (const message of messages.values()) this.handleDispose(message);
    };
    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);

    this.client.incrementMaxListeners();
    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);
    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);
    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);
    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);
    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);

    this.once('end', () => {
      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);
      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);
      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);
      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);
      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);
      this.client.decrementMaxListeners();
    });
  }

  /**
   * Handles a message for possible collection.
   * @param {Message} message The message that could be collected
   * @returns {?Snowflake}
   * @private
   */
  collect(message) {
    /**
     * Emitted whenever a message is collected.
     * @event MessageCollector#collect
     * @param {Message} message The message that was collected
     */
    if (message.channel.id !== this.channel.id) return null;
    this.received++;
    return message.id;
  }

  /**
   * Handles a message for possible disposal.
   * @param {Message} message The message that could be disposed of
   * @returns {?Snowflake}
   */
  dispose(message) {
    /**
     * Emitted whenever a message is disposed of.
     * @event MessageCollector#dispose
     * @param {Message} message The message that was disposed of
     */
    return message.channel.id === this.channel.id ? message.id : null;
  }

  /**
   * Checks after un/collection to see if the collector is done.
   * @returns {?string}
   * @private
   */
  endReason() {
    if (this.options.max && this.collected.size >= this.options.max) return 'limit';
    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';
    return null;
  }

  /**
   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
   * @private
   * @param {GuildChannel} channel The channel that was deleted
   * @returns {void}
   */
  _handleChannelDeletion(channel) {
    if (channel.id === this.channel.id) {
      this.stop('channelDelete');
    }
  }

  /**
   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
   * @private
   * @param {Guild} guild The guild that was deleted
   * @returns {void}
   */
  _handleGuildDeletion(guild) {
    if (this.channel.guild && guild.id === this.channel.guild.id) {
      this.stop('guildDelete');
    }
  }
}

module.exports = MessageCollector;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/MessageEmbed.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/MessageEmbed.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RangeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents an embed in a message (image/video preview, rich embed, etc.)
 */
class MessageEmbed {
  /**
   * @name MessageEmbed
   * @kind constructor
   * @memberof MessageEmbed
   * @param {MessageEmbed|Object} [data={}] MessageEmbed to clone or raw embed data
   */

  constructor(data = {}, skipValidation = false) {
    this.setup(data, skipValidation);
  }

  setup(data, skipValidation) {
    /**
     * The type of this embed, either:
     * * `rich` - a rich embed
     * * `image` - an image embed
     * * `video` - a video embed
     * * `gifv` - a gifv embed
     * * `article` - an article embed
     * * `link` - a link embed
     * @type {string}
     */
    this.type = data.type || 'rich';

    /**
     * The title of this embed
     * @type {?string}
     */
    this.title = 'title' in data ? data.title : null;

    /**
     * The description of this embed
     * @type {?string}
     */
    this.description = 'description' in data ? data.description : null;

    /**
     * The URL of this embed
     * @type {?string}
     */
    this.url = 'url' in data ? data.url : null;

    /**
     * The color of this embed
     * @type {?number}
     */
    this.color = 'color' in data ? Util.resolveColor(data.color) : null;

    /**
     * The timestamp of this embed
     * @type {?number}
     */
    this.timestamp = 'timestamp' in data ? new Date(data.timestamp).getTime() : null;

    /**
     * Represents a field of a MessageEmbed
     * @typedef {Object} EmbedField
     * @property {string} name The name of this field
     * @property {string} value The value of this field
     * @property {boolean} inline If this field will be displayed inline
     */

    /**
     * The fields of this embed
     * @type {EmbedField[]}
     */
    this.fields = [];
    if (data.fields) {
      this.fields = skipValidation ? data.fields.map(Util.cloneObject) : this.constructor.normalizeFields(data.fields);
    }

    /**
     * Represents the thumbnail of a MessageEmbed
     * @typedef {Object} MessageEmbedThumbnail
     * @property {string} url URL for this thumbnail
     * @property {string} proxyURL ProxyURL for this thumbnail
     * @property {number} height Height of this thumbnail
     * @property {number} width Width of this thumbnail
     */

    /**
     * The thumbnail of this embed (if there is one)
     * @type {?MessageEmbedThumbnail}
     */
    this.thumbnail = data.thumbnail
      ? {
          url: data.thumbnail.url,
          proxyURL: data.thumbnail.proxyURL || data.thumbnail.proxy_url,
          height: data.thumbnail.height,
          width: data.thumbnail.width,
        }
      : null;

    /**
     * Represents the image of a MessageEmbed
     * @typedef {Object} MessageEmbedImage
     * @property {string} url URL for this image
     * @property {string} proxyURL ProxyURL for this image
     * @property {number} height Height of this image
     * @property {number} width Width of this image
     */

    /**
     * The image of this embed, if there is one
     * @type {?MessageEmbedImage}
     */
    this.image = data.image
      ? {
          url: data.image.url,
          proxyURL: data.image.proxyURL || data.image.proxy_url,
          height: data.image.height,
          width: data.image.width,
        }
      : null;

    /**
     * Represents the video of a MessageEmbed
     * @typedef {Object} MessageEmbedVideo
     * @property {string} url URL of this video
     * @property {string} proxyURL ProxyURL for this video
     * @property {number} height Height of this video
     * @property {number} width Width of this video
     */

    /**
     * The video of this embed (if there is one)
     * @type {?MessageEmbedVideo}
     * @readonly
     */
    this.video = data.video
      ? {
          url: data.video.url,
          proxyURL: data.video.proxyURL || data.video.proxy_url,
          height: data.video.height,
          width: data.video.width,
        }
      : null;

    /**
     * Represents the author field of a MessageEmbed
     * @typedef {Object} MessageEmbedAuthor
     * @property {string} name The name of this author
     * @property {string} url URL of this author
     * @property {string} iconURL URL of the icon for this author
     * @property {string} proxyIconURL Proxied URL of the icon for this author
     */

    /**
     * The author of this embed (if there is one)
     * @type {?MessageEmbedAuthor}
     */
    this.author = data.author
      ? {
          name: data.author.name,
          url: data.author.url,
          iconURL: data.author.iconURL || data.author.icon_url,
          proxyIconURL: data.author.proxyIconURL || data.author.proxy_icon_url,
        }
      : null;

    /**
     * Represents the provider of a MessageEmbed
     * @typedef {Object} MessageEmbedProvider
     * @property {string} name The name of this provider
     * @property {string} url URL of this provider
     */

    /**
     * The provider of this embed (if there is one)
     * @type {?MessageEmbedProvider}
     */
    this.provider = data.provider
      ? {
          name: data.provider.name,
          url: data.provider.name,
        }
      : null;

    /**
     * Represents the footer field of a MessageEmbed
     * @typedef {Object} MessageEmbedFooter
     * @property {string} text The text of this footer
     * @property {string} iconURL URL of the icon for this footer
     * @property {string} proxyIconURL Proxied URL of the icon for this footer
     */

    /**
     * The footer of this embed
     * @type {?MessageEmbedFooter}
     */
    this.footer = data.footer
      ? {
          text: data.footer.text,
          iconURL: data.footer.iconURL || data.footer.icon_url,
          proxyIconURL: data.footer.proxyIconURL || data.footer.proxy_icon_url,
        }
      : null;

    /**
     * The files of this embed
     * @type {Array<FileOptions|string|MessageAttachment>}
     */
    this.files = data.files || [];
  }

  /**
   * The date displayed on this embed
   * @type {?Date}
   * @readonly
   */
  get createdAt() {
    return this.timestamp ? new Date(this.timestamp) : null;
  }

  /**
   * The hexadecimal version of the embed color, with a leading hash
   * @type {?string}
   * @readonly
   */
  get hexColor() {
    return this.color ? `#${this.color.toString(16).padStart(6, '0')}` : null;
  }

  /**
   * The accumulated length for the embed title, description, fields and footer text
   * @type {number}
   * @readonly
   */
  get length() {
    return (
      (this.title ? this.title.length : 0) +
      (this.description ? this.description.length : 0) +
      (this.fields.length >= 1
        ? this.fields.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0)
        : 0) +
      (this.footer ? this.footer.text.length : 0)
    );
  }

  /**
   * Adds a field to the embed (max 25).
   * @param {StringResolvable} name The name of this field
   * @param {StringResolvable} value The value of this field
   * @param {boolean} [inline=false] If this field will be displayed inline
   * @returns {MessageEmbed}
   */
  addField(name, value, inline) {
    return this.addFields({ name, value, inline });
  }

  /**
   * Adds fields to the embed (max 25).
   * @param {...EmbedFieldData|EmbedFieldData[]} fields The fields to add
   * @returns {MessageEmbed}
   */
  addFields(...fields) {
    this.fields.push(...this.constructor.normalizeFields(fields));
    return this;
  }

  /**
   * Removes, replaces, and inserts fields in the embed (max 25).
   * @param {number} index The index to start at
   * @param {number} deleteCount The number of fields to remove
   * @param {...EmbedFieldData|EmbedFieldData[]} [fields] The replacing field objects
   * @returns {MessageEmbed}
   */
  spliceFields(index, deleteCount, ...fields) {
    this.fields.splice(index, deleteCount, ...this.constructor.normalizeFields(...fields));
    return this;
  }

  /**
   * Sets the file to upload alongside the embed. This file can be accessed via `attachment://fileName.extension` when
   * setting an embed image or author/footer icons. Multiple files can be attached.
   * @param {Array<FileOptions|string|MessageAttachment>} files Files to attach
   * @returns {MessageEmbed}
   */
  attachFiles(files) {
    this.files = this.files.concat(files);
    return this;
  }

  /**
   * Sets the author of this embed.
   * @param {StringResolvable} name The name of the author
   * @param {string} [iconURL] The icon URL of the author
   * @param {string} [url] The URL of the author
   * @returns {MessageEmbed}
   */
  setAuthor(name, iconURL, url) {
    this.author = { name: Util.resolveString(name), iconURL, url };
    return this;
  }

  /**
   * Sets the color of this embed.
   * @param {ColorResolvable} color The color of the embed
   * @returns {MessageEmbed}
   */
  setColor(color) {
    this.color = Util.resolveColor(color);
    return this;
  }

  /**
   * Sets the description of this embed.
   * @param {StringResolvable} description The description
   * @returns {MessageEmbed}
   */
  setDescription(description) {
    description = Util.resolveString(description);
    this.description = description;
    return this;
  }

  /**
   * Sets the footer of this embed.
   * @param {StringResolvable} text The text of the footer
   * @param {string} [iconURL] The icon URL of the footer
   * @returns {MessageEmbed}
   */
  setFooter(text, iconURL) {
    text = Util.resolveString(text);
    this.footer = { text, iconURL };
    return this;
  }

  /**
   * Sets the image of this embed.
   * @param {string} url The URL of the image
   * @returns {MessageEmbed}
   */
  setImage(url) {
    this.image = { url };
    return this;
  }

  /**
   * Sets the thumbnail of this embed.
   * @param {string} url The URL of the thumbnail
   * @returns {MessageEmbed}
   */
  setThumbnail(url) {
    this.thumbnail = { url };
    return this;
  }

  /**
   * Sets the timestamp of this embed.
   * @param {Date|number} [timestamp=Date.now()] The timestamp or date
   * @returns {MessageEmbed}
   */
  setTimestamp(timestamp = Date.now()) {
    if (timestamp instanceof Date) timestamp = timestamp.getTime();
    this.timestamp = timestamp;
    return this;
  }

  /**
   * Sets the title of this embed.
   * @param {StringResolvable} title The title
   * @returns {MessageEmbed}
   */
  setTitle(title) {
    title = Util.resolveString(title);
    this.title = title;
    return this;
  }

  /**
   * Sets the URL of this embed.
   * @param {string} url The URL
   * @returns {MessageEmbed}
   */
  setURL(url) {
    this.url = url;
    return this;
  }

  /**
   * Transforms the embed to a plain object.
   * @returns {Object} The raw data of this embed
   */
  toJSON() {
    return {
      title: this.title,
      type: 'rich',
      description: this.description,
      url: this.url,
      timestamp: this.timestamp ? new Date(this.timestamp) : null,
      color: this.color,
      fields: this.fields,
      thumbnail: this.thumbnail,
      image: this.image,
      author: this.author
        ? {
            name: this.author.name,
            url: this.author.url,
            icon_url: this.author.iconURL,
          }
        : null,
      footer: this.footer
        ? {
            text: this.footer.text,
            icon_url: this.footer.iconURL,
          }
        : null,
    };
  }

  /**
   * Normalizes field input and resolves strings.
   * @param {StringResolvable} name The name of the field
   * @param {StringResolvable} value The value of the field
   * @param {boolean} [inline=false] Set the field to display inline
   * @returns {EmbedField}
   */
  static normalizeField(name, value, inline = false) {
    name = Util.resolveString(name);
    if (!name) throw new RangeError('EMBED_FIELD_NAME');
    value = Util.resolveString(value);
    if (!value) throw new RangeError('EMBED_FIELD_VALUE');
    return { name, value, inline };
  }

  /**
   * @typedef {Object} EmbedFieldData
   * @property {StringResolvable} name The name of this field
   * @property {StringResolvable} value The value of this field
   * @property {boolean} [inline] If this field will be displayed inline
   */

  /**
   * Normalizes field input and resolves strings.
   * @param  {...EmbedFieldData|EmbedFieldData[]} fields Fields to normalize
   * @returns {EmbedField[]}
   */
  static normalizeFields(...fields) {
    return fields
      .flat(2)
      .map(field =>
        this.normalizeField(
          field && field.name,
          field && field.value,
          field && typeof field.inline === 'boolean' ? field.inline : false,
        ),
      );
  }
}

module.exports = MessageEmbed;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/MessageMentions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/MessageMentions.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { ChannelTypes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Keeps track of mentions in a {@link Message}.
 */
class MessageMentions {
  constructor(message, users, roles, everyone, crosspostedChannels) {
    /**
     * The client the message is from
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: message.client });

    /**
     * The guild the message is in
     * @type {?Guild}
     * @readonly
     */
    Object.defineProperty(this, 'guild', { value: message.guild });

    /**
     * The initial message content
     * @type {string}
     * @readonly
     * @private
     */
    Object.defineProperty(this, '_content', { value: message.content });

    /**
     * Whether `@everyone` or `@here` were mentioned
     * @type {boolean}
     */
    this.everyone = Boolean(everyone);

    if (users) {
      if (users instanceof Collection) {
        /**
         * Any users that were mentioned
         * <info>Order as received from the API, not as they appear in the message content</info>
         * @type {Collection<Snowflake, User>}
         */
        this.users = new Collection(users);
      } else {
        this.users = new Collection();
        for (const mention of users) {
          if (mention.member && message.guild) {
            message.guild.members.add(Object.assign(mention.member, { user: mention }));
          }
          const user = message.client.users.add(mention);
          this.users.set(user.id, user);
        }
      }
    } else {
      this.users = new Collection();
    }

    if (roles) {
      if (roles instanceof Collection) {
        /**
         * Any roles that were mentioned
         * <info>Order as received from the API, not as they appear in the message content</info>
         * @type {Collection<Snowflake, Role>}
         */
        this.roles = new Collection(roles);
      } else {
        this.roles = new Collection();
        for (const mention of roles) {
          const role = message.channel.guild.roles.cache.get(mention);
          if (role) this.roles.set(role.id, role);
        }
      }
    } else {
      this.roles = new Collection();
    }

    /**
     * Cached members for {@link MessageMentions#members}
     * @type {?Collection<Snowflake, GuildMember>}
     * @private
     */
    this._members = null;

    /**
     * Cached channels for {@link MessageMentions#channels}
     * @type {?Collection<Snowflake, GuildChannel>}
     * @private
     */
    this._channels = null;

    /**
     * Crossposted channel data.
     * @typedef {Object} CrosspostedChannel
     * @property {string} channelID ID of the mentioned channel
     * @property {string} guildID ID of the guild that has the channel
     * @property {string} type Type of the channel
     * @property {string} name The name of the channel
     */

    if (crosspostedChannels) {
      if (crosspostedChannels instanceof Collection) {
        /**
         * A collection of crossposted channels
         * <info>Order as received from the API, not as they appear in the message content</info>
         * @type {Collection<Snowflake, CrosspostedChannel>}
         */
        this.crosspostedChannels = new Collection(crosspostedChannels);
      } else {
        this.crosspostedChannels = new Collection();
        const channelTypes = Object.keys(ChannelTypes);
        for (const d of crosspostedChannels) {
          const type = channelTypes[d.type];
          this.crosspostedChannels.set(d.id, {
            channelID: d.id,
            guildID: d.guild_id,
            type: type ? type.toLowerCase() : 'unknown',
            name: d.name,
          });
        }
      }
    } else {
      this.crosspostedChannels = new Collection();
    }
  }

  /**
   * Any members that were mentioned (only in {@link TextChannel}s)
   * <info>Order as received from the API, not as they appear in the message content</info>
   * @type {?Collection<Snowflake, GuildMember>}
   * @readonly
   */
  get members() {
    if (this._members) return this._members;
    if (!this.guild) return null;
    this._members = new Collection();
    this.users.forEach(user => {
      const member = this.guild.member(user);
      if (member) this._members.set(member.user.id, member);
    });
    return this._members;
  }

  /**
   * Any channels that were mentioned
   * <info>Order as they appear first in the message content</info>
   * @type {Collection<Snowflake, GuildChannel>}
   * @readonly
   */
  get channels() {
    if (this._channels) return this._channels;
    this._channels = new Collection();
    let matches;
    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {
      const chan = this.client.channels.cache.get(matches[1]);
      if (chan) this._channels.set(chan.id, chan);
    }
    return this._channels;
  }

  /**
   * Checks if a user, guild member, role, or channel is mentioned.
   * Takes into account user mentions, role mentions, and @everyone/@here mentions.
   * @param {UserResolvable|RoleResolvable|GuildChannelResolvable} data User/Role/Channel to check
   * @param {Object} [options] Options
   * @param {boolean} [options.ignoreDirect=false] - Whether to ignore direct mentions to the item
   * @param {boolean} [options.ignoreRoles=false] - Whether to ignore role mentions to a guild member
   * @param {boolean} [options.ignoreEveryone=false] - Whether to ignore everyone/here mentions
   * @returns {boolean}
   */
  has(data, { ignoreDirect = false, ignoreRoles = false, ignoreEveryone = false } = {}) {
    if (!ignoreEveryone && this.everyone) return true;
    const GuildMember = __webpack_require__(/*! ./GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js");
    if (!ignoreRoles && data instanceof GuildMember) {
      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;
    }

    if (!ignoreDirect) {
      const id =
        this.client.users.resolveID(data) ||
        (this.guild && this.guild.roles.resolveID(data)) ||
        this.client.channels.resolveID(data);

      return this.users.has(id) || this.channels.has(id) || this.roles.has(id);
    }

    return false;
  }

  toJSON() {
    return Util.flatten(this, {
      members: true,
      channels: true,
    });
  }
}

/**
 * Regular expression that globally matches `@everyone` and `@here`
 * @type {RegExp}
 */
MessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;

/**
 * Regular expression that globally matches user mentions like `<@81440962496172032>`
 * @type {RegExp}
 */
MessageMentions.USERS_PATTERN = /<@!?(\d{17,19})>/g;

/**
 * Regular expression that globally matches role mentions like `<@&297577916114403338>`
 * @type {RegExp}
 */
MessageMentions.ROLES_PATTERN = /<@&(\d{17,19})>/g;

/**
 * Regular expression that globally matches channel mentions like `<#222079895583457280>`
 * @type {RegExp}
 */
MessageMentions.CHANNELS_PATTERN = /<#(\d{17,19})>/g;

module.exports = MessageMentions;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/MessageReaction.js":
/*!*******************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/MessageReaction.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const GuildEmoji = __webpack_require__(/*! ./GuildEmoji */ "./node_modules/discord.js/src/structures/GuildEmoji.js");
const ReactionEmoji = __webpack_require__(/*! ./ReactionEmoji */ "./node_modules/discord.js/src/structures/ReactionEmoji.js");
const ReactionUserManager = __webpack_require__(/*! ../managers/ReactionUserManager */ "./node_modules/discord.js/src/managers/ReactionUserManager.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a reaction to a message.
 */
class MessageReaction {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the message reaction
   * @param {Message} message The message the reaction refers to
   */
  constructor(client, data, message) {
    /**
     * The client that instantiated this message reaction
     * @name MessageReaction#client
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: client });
    /**
     * The message that this reaction refers to
     * @type {Message}
     */
    this.message = message;

    /**
     * A manager of the users that have given this reaction
     * @type {ReactionUserManager}
     */
    this.users = new ReactionUserManager(client, undefined, this);

    this._emoji = new ReactionEmoji(this, data.emoji);

    this._patch(data);
  }

  _patch(data) {
    // eslint-disable-next-line eqeqeq
    if (this.count == undefined) {
      /**
       * The number of people that have given the same reaction
       * @type {?number}
       */
      this.count = data.count;
    }

    /**
     * Whether the client has given this reaction
     * @type {boolean}
     */
    this.me = data.me;
  }

  /**
   * Removes all users from this reaction.
   * @returns {Promise<MessageReaction>}
   */
  async remove() {
    await this.client.api
      .channels(this.message.channel.id)
      .messages(this.message.id)
      .reactions(this._emoji.identifier)
      .delete();
    return this;
  }

  /**
   * The emoji of this reaction, either an GuildEmoji object for known custom emojis, or a ReactionEmoji
   * object which has fewer properties. Whatever the prototype of the emoji, it will still have
   * `name`, `id`, `identifier` and `toString()`
   * @type {GuildEmoji|ReactionEmoji}
   * @readonly
   */
  get emoji() {
    if (this._emoji instanceof GuildEmoji) return this._emoji;
    // Check to see if the emoji has become known to the client
    if (this._emoji.id) {
      const emojis = this.message.client.emojis.cache;
      if (emojis.has(this._emoji.id)) {
        const emoji = emojis.get(this._emoji.id);
        this._emoji = emoji;
        return emoji;
      }
    }
    return this._emoji;
  }

  /**
   * Whether or not this reaction is a partial
   * @type {boolean}
   * @readonly
   */
  get partial() {
    return this.count === null;
  }

  /**
   * Fetch this reaction.
   * @returns {Promise<MessageReaction>}
   */
  async fetch() {
    const message = await this.message.fetch();
    const existing = message.reactions.cache.get(this.emoji.id || this.emoji.name);
    // The reaction won't get set when it has been completely removed
    this._patch(existing || { count: 0 });
    return this;
  }

  toJSON() {
    return Util.flatten(this, { emoji: 'emojiID', message: 'messageID' });
  }

  _add(user) {
    if (this.partial) return;
    this.users.cache.set(user.id, user);
    if (!this.me || user.id !== this.message.client.user.id || this.count === 0) this.count++;
    if (!this.me) this.me = user.id === this.message.client.user.id;
  }

  _remove(user) {
    if (this.partial) return;
    this.users.cache.delete(user.id);
    if (!this.me || user.id !== this.message.client.user.id) this.count--;
    if (user.id === this.message.client.user.id) this.me = false;
    if (this.count <= 0 && this.users.cache.size === 0) {
      this.message.reactions.cache.delete(this.emoji.id || this.emoji.name);
    }
  }
}

module.exports = MessageReaction;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/NewsChannel.js":
/*!***************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/NewsChannel.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const TextChannel = __webpack_require__(/*! ./TextChannel */ "./node_modules/discord.js/src/structures/TextChannel.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");

/**
 * Represents a guild news channel on Discord.
 * @extends {TextChannel}
 */
class NewsChannel extends TextChannel {
  _patch(data) {
    super._patch(data);

    // News channels don't have a rate limit per user, remove it
    this.rateLimitPerUser = undefined;
  }

  /**
   * Adds the target to this channel's followers.
   * @param {GuildChannelResolvable} channel The channel where the webhook should be created
   * @param {string} [reason] Reason for creating the webhook
   * @returns {Promise<NewsChannel>}
   * @example
   * if (channel.type === 'news') {
   *   channel.addFollower('222197033908436994', 'Important announcements')
   *     .then(() => console.log('Added follower'))
   *     .catch(console.error);
   * }
   */
  async addFollower(channel, reason) {
    const channelID = this.guild.channels.resolveID(channel);
    if (!channelID) throw new Error('GUILD_CHANNEL_RESOLVE');
    await this.client.api.channels(this.id).followers.post({ data: { webhook_channel_id: channelID }, reason });
    return this;
  }
}

module.exports = NewsChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/PartialGroupDMChannel.js":
/*!*************************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/PartialGroupDMChannel.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Channel = __webpack_require__(/*! ./Channel */ "./node_modules/discord.js/src/structures/Channel.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");

/**
 * Represents a Partial Group DM Channel on Discord.
 * @extends {Channel}
 */
class PartialGroupDMChannel extends Channel {
  constructor(client, data) {
    super(client, data);

    /**
     * The name of this Group DM Channel
     * @type {string}
     */
    this.name = data.name;

    /**
     * The hash of the channel icon
     * @type {?string}
     */
    this.icon = data.icon;
  }

  /**
   * The URL to this channel's icon.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  iconURL({ format, size } = {}) {
    if (!this.icon) return null;
    return this.client.rest.cdn.GDMIcon(this.id, this.icon, format, size);
  }

  delete() {
    return Promise.reject(new Error('DELETE_GROUP_DM_CHANNEL'));
  }

  fetch() {
    return Promise.reject(new Error('FETCH_GROUP_DM_CHANNEL'));
  }
}

module.exports = PartialGroupDMChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/PermissionOverwrites.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/PermissionOverwrites.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Role = __webpack_require__(/*! ./Role */ "./node_modules/discord.js/src/structures/Role.js");
const { TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a permission overwrite for a role or member in a guild channel.
 */
class PermissionOverwrites {
  constructor(guildChannel, data) {
    /**
     * The GuildChannel this overwrite is for
     * @name PermissionOverwrites#channel
     * @type {GuildChannel}
     * @readonly
     */
    Object.defineProperty(this, 'channel', { value: guildChannel });

    if (data) this._patch(data);
  }

  _patch(data) {
    /**
     * The ID of this overwrite, either a user ID or a role ID
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * The type of a permission overwrite. It can be one of:
     * * member
     * * role
     * @typedef {string} OverwriteType
     */

    /**
     * The type of this overwrite
     * @type {OverwriteType}
     */
    this.type = data.type;

    /**
     * The permissions that are denied for the user or role.
     * @type {Readonly<Permissions>}
     */
    this.deny = new Permissions(data.deny).freeze();

    /**
     * The permissions that are allowed for the user or role.
     * @type {Readonly<Permissions>}
     */
    this.allow = new Permissions(data.allow).freeze();
  }

  /**
   * Updates this permissionOverwrites.
   * @param {PermissionOverwriteOptions} options The options for the update
   * @param {string} [reason] Reason for creating/editing this overwrite
   * @returns {Promise<PermissionOverwrites>}
   * @example
   * // Update permission overwrites
   * permissionOverwrites.update({
   *   SEND_MESSAGES: false
   * })
   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))
   *   .catch(console.error);
   */
  update(options, reason) {
    const { allow, deny } = this.constructor.resolveOverwriteOptions(options, this);

    return this.channel.client.api
      .channels(this.channel.id)
      .permissions[this.id].put({
        data: { id: this.id, type: this.type, allow: allow.bitfield, deny: deny.bitfield },
        reason,
      })
      .then(() => this);
  }

  /**
   * Deletes this Permission Overwrite.
   * @param {string} [reason] Reason for deleting this overwrite
   * @returns {Promise<PermissionOverwrites>}
   */
  delete(reason) {
    return this.channel.client.api.channels[this.channel.id].permissions[this.id].delete({ reason }).then(() => this);
  }

  toJSON() {
    return Util.flatten(this);
  }

  /**
   * An object mapping permission flags to `true` (enabled), `null` (unset) or `false` (disabled).
   * ```js
   * {
   *  'SEND_MESSAGES': true,
   *  'EMBED_LINKS': null,
   *  'ATTACH_FILES': false,
   * }
   * ```
   * @typedef {Object} PermissionOverwriteOptions
   */

  /**
   * @typedef {object} ResolvedOverwriteOptions
   * @property {Permissions} allow The allowed permissions
   * @property {Permissions} deny The denied permissions
   */

  /**
   * Resolves bitfield permissions overwrites from an object.
   * @param {PermissionOverwriteOptions} options The options for the update
   * @param {Object} initialPermissions The initial permissions
   * @param {PermissionResolvable} initialPermissions.allow Initial allowed permissions
   * @param {PermissionResolvable} initialPermissions.deny Initial denied permissions
   * @returns {ResolvedOverwriteOptions}
   */
  static resolveOverwriteOptions(options, { allow, deny } = {}) {
    allow = new Permissions(allow);
    deny = new Permissions(deny);

    for (const [perm, value] of Object.entries(options)) {
      if (value === true) {
        allow.add(Permissions.FLAGS[perm]);
        deny.remove(Permissions.FLAGS[perm]);
      } else if (value === false) {
        allow.remove(Permissions.FLAGS[perm]);
        deny.add(Permissions.FLAGS[perm]);
      } else if (value === null) {
        allow.remove(Permissions.FLAGS[perm]);
        deny.remove(Permissions.FLAGS[perm]);
      }
    }

    return { allow, deny };
  }

  /**
   * The raw data for a permission overwrite
   * @typedef {Object} RawOverwriteData
   * @property {Snowflake} id The id of the overwrite
   * @property {number} allow The permissions to allow
   * @property {number} deny The permissions to deny
   * @property {OverwriteType} type The type of this OverwriteData
   */

  /**
   * Data that can be resolved into {@link RawOverwriteData}
   * @typedef {PermissionOverwrites|OverwriteData} OverwriteResolvable
   */

  /**
   * Data that can be used for a permission overwrite
   * @typedef {Object} OverwriteData
   * @property {GuildMemberResolvable|RoleResolvable} id Member or role this overwrite is for
   * @property {PermissionResolvable} [allow] The permissions to allow
   * @property {PermissionResolvable} [deny] The permissions to deny
   * @property {OverwriteType} [type] The type of this OverwriteData
   */

  /**
   * Resolves an overwrite into {@link RawOverwriteData}.
   * @param {OverwriteResolvable} overwrite The overwrite-like data to resolve
   * @param {Guild} guild The guild to resolve from
   * @returns {RawOverwriteData}
   */
  static resolve(overwrite, guild) {
    if (overwrite instanceof this) return overwrite.toJSON();
    if (typeof overwrite.id === 'string' && ['role', 'member'].includes(overwrite.type)) {
      return { ...overwrite, allow: Permissions.resolve(overwrite.allow), deny: Permissions.resolve(overwrite.deny) };
    }

    const userOrRole = guild.roles.resolve(overwrite.id) || guild.client.users.resolve(overwrite.id);
    if (!userOrRole) throw new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role');
    const type = userOrRole instanceof Role ? 'role' : 'member';

    return {
      id: userOrRole.id,
      type,
      allow: Permissions.resolve(overwrite.allow),
      deny: Permissions.resolve(overwrite.deny),
    };
  }
}

module.exports = PermissionOverwrites;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Presence.js":
/*!************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Presence.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const Emoji = __webpack_require__(/*! ./Emoji */ "./node_modules/discord.js/src/structures/Emoji.js");
const ActivityFlags = __webpack_require__(/*! ../util/ActivityFlags */ "./node_modules/discord.js/src/util/ActivityFlags.js");
const { ActivityTypes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Activity sent in a message.
 * @typedef {Object} MessageActivity
 * @property {string} [partyID] Id of the party represented in activity
 * @property {number} [type] Type of activity sent
 */

/**
 * The status of this presence:
 * * **`online`** - user is online
 * * **`idle`** - user is AFK
 * * **`offline`** - user is offline or invisible
 * * **`dnd`** - user is in Do Not Disturb
 * @typedef {string} PresenceStatus
 */

/**
 * The status of this presence:
 * * **`online`** - user is online
 * * **`idle`** - user is AFK
 * * **`dnd`** - user is in Do Not Disturb
 * @typedef {string} ClientPresenceStatus
 */

/**
 * Represents a user's presence.
 */
class Presence {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} [data={}] The data for the presence
   */
  constructor(client, data = {}) {
    /**
     * The client that instantiated this
     * @name Presence#client
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: client });
    /**
     * The user ID of this presence
     * @type {Snowflake}
     */
    this.userID = data.user.id;

    /**
     * The guild of this presence
     * @type {?Guild}
     */
    this.guild = data.guild || null;

    this.patch(data);
  }

  /**
   * The user of this presence
   * @type {?User}
   * @readonly
   */
  get user() {
    return this.client.users.cache.get(this.userID) || null;
  }

  /**
   * The member of this presence
   * @type {?GuildMember}
   * @readonly
   */
  get member() {
    return this.guild.members.cache.get(this.userID) || null;
  }

  patch(data) {
    /**
     * The status of this presence
     * @type {PresenceStatus}
     */
    this.status = data.status || this.status || 'offline';

    if (data.activities) {
      /**
       * The activities of this presence
       * @type {Activity[]}
       */
      this.activities = data.activities.map(activity => new Activity(this, activity));
    } else if (data.activity || data.game) {
      this.activities = [new Activity(this, data.game || data.activity)];
    } else {
      this.activities = [];
    }

    /**
     * The devices this presence is on
     * @type {?Object}
     * @property {?ClientPresenceStatus} web The current presence in the web application
     * @property {?ClientPresenceStatus} mobile The current presence in the mobile application
     * @property {?ClientPresenceStatus} desktop The current presence in the desktop application
     */
    this.clientStatus = data.client_status || null;

    return this;
  }

  _clone() {
    const clone = Object.assign(Object.create(this), this);
    if (this.activities) clone.activities = this.activities.map(activity => activity._clone());
    return clone;
  }

  /**
   * Whether this presence is equal to another.
   * @param {Presence} presence The presence to compare with
   * @returns {boolean}
   */
  equals(presence) {
    return (
      this === presence ||
      (presence &&
        this.status === presence.status &&
        this.activities.length === presence.activities.length &&
        this.activities.every((activity, index) => activity.equals(presence.activities[index])) &&
        this.clientStatus.web === presence.clientStatus.web &&
        this.clientStatus.mobile === presence.clientStatus.mobile &&
        this.clientStatus.desktop === presence.clientStatus.desktop)
    );
  }

  toJSON() {
    return Util.flatten(this);
  }
}

/**
 * Represents an activity that is part of a user's presence.
 */
class Activity {
  constructor(presence, data) {
    Object.defineProperty(this, 'presence', { value: presence });

    /**
     * The name of the activity being played
     * @type {string}
     */
    this.name = data.name;

    /**
     * The type of the activity status
     * @type {ActivityType}
     */
    this.type = ActivityTypes[data.type];

    /**
     * If the activity is being streamed, a link to the stream
     * @type {?string}
     */
    this.url = data.url || null;

    /**
     * Details about the activity
     * @type {?string}
     */
    this.details = data.details || null;

    /**
     * State of the activity
     * @type {?string}
     */
    this.state = data.state || null;

    /**
     * Application ID associated with this activity
     * @type {?Snowflake}
     */
    this.applicationID = data.application_id || null;

    /**
     * Timestamps for the activity
     * @type {?Object}
     * @property {?Date} start When the activity started
     * @property {?Date} end When the activity will end
     */
    this.timestamps = data.timestamps
      ? {
          start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
          end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null,
        }
      : null;

    /**
     * Party of the activity
     * @type {?Object}
     * @property {?string} id ID of the party
     * @property {number[]} size Size of the party as `[current, max]`
     */
    this.party = data.party || null;

    /**
     * Assets for rich presence
     * @type {?RichPresenceAssets}
     */
    this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;

    this.syncID = data.sync_id;

    /**
     * Flags that describe the activity
     * @type {Readonly<ActivityFlags>}
     */
    this.flags = new ActivityFlags(data.flags).freeze();

    /**
     * Emoji for a custom activity
     * @type {?Emoji}
     */
    this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;

    /**
     * Creation date of the activity
     * @type {number}
     */
    this.createdTimestamp = new Date(data.created_at).getTime();
  }

  /**
   * Whether this activity is equal to another activity.
   * @param {Activity} activity The activity to compare with
   * @returns {boolean}
   */
  equals(activity) {
    return (
      this === activity ||
      (activity && this.name === activity.name && this.type === activity.type && this.url === activity.url)
    );
  }

  /**
   * The time the activity was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * When concatenated with a string, this automatically returns the activities' name instead of the Activity object.
   * @returns {string}
   */
  toString() {
    return this.name;
  }

  _clone() {
    return Object.assign(Object.create(this), this);
  }
}

/**
 * Assets for a rich presence
 */
class RichPresenceAssets {
  constructor(activity, assets) {
    Object.defineProperty(this, 'activity', { value: activity });

    /**
     * Hover text for the large image
     * @type {?string}
     */
    this.largeText = assets.large_text || null;

    /**
     * Hover text for the small image
     * @type {?string}
     */
    this.smallText = assets.small_text || null;

    /**
     * ID of the large image asset
     * @type {?Snowflake}
     */
    this.largeImage = assets.large_image || null;

    /**
     * ID of the small image asset
     * @type {?Snowflake}
     */
    this.smallImage = assets.small_image || null;
  }

  /**
   * Gets the URL of the small image asset
   * @param {Object} [options] Options for the image url
   * @param {string} [options.format] Format of the image
   * @param {number} [options.size] Size of the image
   * @returns {?string} The small image URL
   */
  smallImageURL({ format, size } = {}) {
    if (!this.smallImage) return null;
    return this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationID, this.smallImage, {
      format,
      size,
    });
  }

  /**
   * Gets the URL of the large image asset
   * @param {Object} [options] Options for the image url
   * @param {string} [options.format] Format of the image
   * @param {number} [options.size] Size of the image
   * @returns {?string} The large image URL
   */
  largeImageURL({ format, size } = {}) {
    if (!this.largeImage) return null;
    if (/^spotify:/.test(this.largeImage)) {
      return `https://i.scdn.co/image/${this.largeImage.slice(8)}`;
    } else if (/^twitch:/.test(this.largeImage)) {
      return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${this.largeImage.slice(7)}.png`;
    }
    return this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationID, this.largeImage, {
      format,
      size,
    });
  }
}

exports.Presence = Presence;
exports.Activity = Activity;
exports.RichPresenceAssets = RichPresenceAssets;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/ReactionCollector.js":
/*!*********************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/ReactionCollector.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Collector = __webpack_require__(/*! ./interfaces/Collector */ "./node_modules/discord.js/src/structures/interfaces/Collector.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { Events } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/**
 * @typedef {CollectorOptions} ReactionCollectorOptions
 * @property {number} max The maximum total amount of reactions to collect
 * @property {number} maxEmojis The maximum number of emojis to collect
 * @property {number} maxUsers The maximum number of users to react
 */

/**
 * Collects reactions on messages.
 * Will automatically stop if the message (`'messageDelete'`),
 * channel (`'channelDelete'`), or guild (`'guildDelete'`) are deleted.
 * @extends {Collector}
 */
class ReactionCollector extends Collector {
  /**
   * @param {Message} message The message upon which to collect reactions
   * @param {CollectorFilter} filter The filter to apply to this collector
   * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector
   */
  constructor(message, filter, options = {}) {
    super(message.client, filter, options);

    /**
     * The message upon which to collect reactions
     * @type {Message}
     */
    this.message = message;

    /**
     * The users which have reacted to this message
     * @type {Collection}
     */
    this.users = new Collection();

    /**
     * The total number of reactions collected
     * @type {number}
     */
    this.total = 0;

    this.empty = this.empty.bind(this);
    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
    this._handleMessageDeletion = this._handleMessageDeletion.bind(this);

    this.client.incrementMaxListeners();
    this.client.on(Events.MESSAGE_REACTION_ADD, this.handleCollect);
    this.client.on(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);
    this.client.on(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);
    this.client.on(Events.MESSAGE_DELETE, this._handleMessageDeletion);
    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);
    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);

    this.once('end', () => {
      this.client.removeListener(Events.MESSAGE_REACTION_ADD, this.handleCollect);
      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE, this.handleDispose);
      this.client.removeListener(Events.MESSAGE_REACTION_REMOVE_ALL, this.empty);
      this.client.removeListener(Events.MESSAGE_DELETE, this._handleMessageDeletion);
      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);
      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);
      this.client.decrementMaxListeners();
    });

    this.on('collect', (reaction, user) => {
      this.total++;
      this.users.set(user.id, user);
    });

    this.on('remove', (reaction, user) => {
      this.total--;
      if (!this.collected.some(r => r.users.cache.has(user.id))) this.users.delete(user.id);
    });
  }

  /**
   * Handles an incoming reaction for possible collection.
   * @param {MessageReaction} reaction The reaction to possibly collect
   * @returns {?Snowflake|string}
   * @private
   */
  collect(reaction) {
    /**
     * Emitted whenever a reaction is collected.
     * @event ReactionCollector#collect
     * @param {MessageReaction} reaction The reaction that was collected
     * @param {User} user The user that added the reaction
     */
    if (reaction.message.id !== this.message.id) return null;
    return ReactionCollector.key(reaction);
  }

  /**
   * Handles a reaction deletion for possible disposal.
   * @param {MessageReaction} reaction The reaction to possibly dispose of
   * @param {User} user The user that removed the reaction
   * @returns {?Snowflake|string}
   */
  dispose(reaction, user) {
    /**
     * Emitted when the reaction had all the users removed and the `dispose` option is set to true.
     * @event ReactionCollector#dispose
     * @param {MessageReaction} reaction The reaction that was disposed of
     * @param {User} user The user that removed the reaction
     */
    if (reaction.message.id !== this.message.id) return null;

    /**
     * Emitted when the reaction had one user removed and the `dispose` option is set to true.
     * @event ReactionCollector#remove
     * @param {MessageReaction} reaction The reaction that was removed
     * @param {User} user The user that removed the reaction
     */
    if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
      this.emit('remove', reaction, user);
    }
    return reaction.count ? null : ReactionCollector.key(reaction);
  }

  /**
   * Empties this reaction collector.
   */
  empty() {
    this.total = 0;
    this.collected.clear();
    this.users.clear();
    this.checkEnd();
  }

  endReason() {
    if (this.options.max && this.total >= this.options.max) return 'limit';
    if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis) return 'emojiLimit';
    if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return 'userLimit';
    return null;
  }

  /**
   * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.
   * @private
   * @param {Message} message The message that was deleted
   * @returns {void}
   */
  _handleMessageDeletion(message) {
    if (message.id === this.message.id) {
      this.stop('messageDelete');
    }
  }

  /**
   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
   * @private
   * @param {GuildChannel} channel The channel that was deleted
   * @returns {void}
   */
  _handleChannelDeletion(channel) {
    if (channel.id === this.message.channel.id) {
      this.stop('channelDelete');
    }
  }

  /**
   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
   * @private
   * @param {Guild} guild The guild that was deleted
   * @returns {void}
   */
  _handleGuildDeletion(guild) {
    if (this.message.guild && guild.id === this.message.guild.id) {
      this.stop('guildDelete');
    }
  }

  /**
   * Gets the collector key for a reaction.
   * @param {MessageReaction} reaction The message reaction to get the key for
   * @returns {Snowflake|string}
   */
  static key(reaction) {
    return reaction.emoji.id || reaction.emoji.name;
  }
}

module.exports = ReactionCollector;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/ReactionEmoji.js":
/*!*****************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/ReactionEmoji.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Emoji = __webpack_require__(/*! ./Emoji */ "./node_modules/discord.js/src/structures/Emoji.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a limited emoji set used for both custom and unicode emojis. Custom emojis
 * will use this class opposed to the Emoji class when the client doesn't know enough
 * information about them.
 * @extends {Emoji}
 */
class ReactionEmoji extends Emoji {
  constructor(reaction, emoji) {
    super(reaction.message.client, emoji);
    /**
     * The message reaction this emoji refers to
     * @type {MessageReaction}
     */
    this.reaction = reaction;
  }

  toJSON() {
    return Util.flatten(this, { identifier: true });
  }

  valueOf() {
    return this.id;
  }
}

module.exports = ReactionEmoji;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Role.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Role.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const { Error, TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a role on Discord.
 * @extends {Base}
 */
class Role extends Base {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the role
   * @param {Guild} guild The guild the role is part of
   */
  constructor(client, data, guild) {
    super(client);

    /**
     * The guild that the role belongs to
     * @type {Guild}
     */
    this.guild = guild;

    if (data) this._patch(data);
  }

  _patch(data) {
    /**
     * The ID of the role (unique to the guild it is part of)
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * The name of the role
     * @type {string}
     */
    this.name = data.name;

    /**
     * The base 10 color of the role
     * @type {number}
     */
    this.color = data.color;

    /**
     * If true, users that are part of this role will appear in a separate category in the users list
     * @type {boolean}
     */
    this.hoist = data.hoist;

    /**
     * The raw position of the role from the API
     * @type {number}
     */
    this.rawPosition = data.position;

    /**
     * The permissions of the role
     * @type {Readonly<Permissions>}
     */
    this.permissions = new Permissions(data.permissions).freeze();

    /**
     * Whether or not the role is managed by an external service
     * @type {boolean}
     */
    this.managed = data.managed;

    /**
     * Whether or not the role can be mentioned by anyone
     * @type {boolean}
     */
    this.mentionable = data.mentionable;

    /**
     * Whether the role has been deleted
     * @type {boolean}
     */
    this.deleted = false;
  }

  /**
   * The timestamp the role was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the role was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * The hexadecimal version of the role color, with a leading hashtag
   * @type {string}
   * @readonly
   */
  get hexColor() {
    return `#${this.color.toString(16).padStart(6, '0')}`;
  }

  /**
   * The cached guild members that have this role
   * @type {Collection<Snowflake, GuildMember>}
   * @readonly
   */
  get members() {
    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));
  }

  /**
   * Whether the role is editable by the client user
   * @type {boolean}
   * @readonly
   */
  get editable() {
    if (this.managed) return false;
    const clientMember = this.guild.member(this.client.user);
    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;
    return clientMember.roles.highest.comparePositionTo(this) > 0;
  }

  /**
   * The position of the role in the role manager
   * @type {number}
   * @readonly
   */
  get position() {
    const sorted = this.guild._sortedRoles();
    return sorted.array().indexOf(sorted.get(this.id));
  }

  /**
   * Compares this role's position to another role's.
   * @param {RoleResolvable} role Role to compare to this one
   * @returns {number} Negative number if this role's position is lower (other role's is higher),
   * positive number if this one is higher (other's is lower), 0 if equal
   */
  comparePositionTo(role) {
    role = this.guild.roles.resolve(role);
    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');
    return this.constructor.comparePositions(this, role);
  }

  /**
   * The data for a role.
   * @typedef {Object} RoleData
   * @property {string} [name] The name of the role
   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
   * @property {boolean} [hoist] Whether or not the role should be hoisted
   * @property {number} [position] The position of the role
   * @property {PermissionResolvable} [permissions] The permissions of the role
   * @property {boolean} [mentionable] Whether or not the role should be mentionable
   */

  /**
   * Edits the role.
   * @param {RoleData} data The new data for the role
   * @param {string} [reason] Reason for editing this role
   * @returns {Promise<Role>}
   * @example
   * // Edit a role
   * role.edit({ name: 'new role' })
   *   .then(updated => console.log(`Edited role name to ${updated.name}`))
   *   .catch(console.error);
   */
  async edit(data, reason) {
    if (typeof data.permissions !== 'undefined') data.permissions = Permissions.resolve(data.permissions);
    else data.permissions = this.permissions.bitfield;
    if (typeof data.position !== 'undefined') {
      await Util.setPosition(
        this,
        data.position,
        false,
        this.guild._sortedRoles(),
        this.client.api.guilds(this.guild.id).roles,
        reason,
      ).then(updatedRoles => {
        this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: updatedRoles,
        });
      });
    }
    return this.client.api.guilds[this.guild.id].roles[this.id]
      .patch({
        data: {
          name: data.name || this.name,
          color: data.color !== null ? Util.resolveColor(data.color || this.color) : null,
          hoist: typeof data.hoist !== 'undefined' ? data.hoist : this.hoist,
          permissions: data.permissions,
          mentionable: typeof data.mentionable !== 'undefined' ? data.mentionable : this.mentionable,
        },
        reason,
      })
      .then(role => {
        const clone = this._clone();
        clone._patch(role);
        return clone;
      });
  }

  /**
   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,
   * taking into account permission overwrites.
   * @param {ChannelResolvable} channel The guild channel to use as context
   * @returns {Readonly<Permissions>}
   */
  permissionsIn(channel) {
    channel = this.guild.channels.resolve(channel);
    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');
    return channel.rolePermissions(this);
  }

  /**
   * Sets a new name for the role.
   * @param {string} name The new name of the role
   * @param {string} [reason] Reason for changing the role's name
   * @returns {Promise<Role>}
   * @example
   * // Set the name of the role
   * role.setName('new role')
   *   .then(updated => console.log(`Updated role name to ${updated.name}`))
   *   .catch(console.error);
   */
  setName(name, reason) {
    return this.edit({ name }, reason);
  }

  /**
   * Sets a new color for the role.
   * @param {ColorResolvable} color The color of the role
   * @param {string} [reason] Reason for changing the role's color
   * @returns {Promise<Role>}
   * @example
   * // Set the color of a role
   * role.setColor('#FF0000')
   *   .then(updated => console.log(`Set color of role to ${updated.color}`))
   *   .catch(console.error);
   */
  setColor(color, reason) {
    return this.edit({ color }, reason);
  }

  /**
   * Sets whether or not the role should be hoisted.
   * @param {boolean} hoist Whether or not to hoist the role
   * @param {string} [reason] Reason for setting whether or not the role should be hoisted
   * @returns {Promise<Role>}
   * @example
   * // Set the hoist of the role
   * role.setHoist(true)
   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))
   *   .catch(console.error);
   */
  setHoist(hoist, reason) {
    return this.edit({ hoist }, reason);
  }

  /**
   * Sets the permissions of the role.
   * @param {PermissionResolvable} permissions The permissions of the role
   * @param {string} [reason] Reason for changing the role's permissions
   * @returns {Promise<Role>}
   * @example
   * // Set the permissions of the role
   * role.setPermissions(['KICK_MEMBERS', 'BAN_MEMBERS'])
   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
   *   .catch(console.error);
   * @example
   * // Remove all permissions from a role
   * role.setPermissions(0)
   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
   *   .catch(console.error);
   */
  setPermissions(permissions, reason) {
    return this.edit({ permissions }, reason);
  }

  /**
   * Sets whether this role is mentionable.
   * @param {boolean} mentionable Whether this role should be mentionable
   * @param {string} [reason] Reason for setting whether or not this role should be mentionable
   * @returns {Promise<Role>}
   * @example
   * // Make the role mentionable
   * role.setMentionable(true)
   *   .then(updated => console.log(`Role updated ${updated.name}`))
   *   .catch(console.error);
   */
  setMentionable(mentionable, reason) {
    return this.edit({ mentionable }, reason);
  }

  /**
   * Sets the position of the role.
   * @param {number} position The position of the role
   * @param {Object} [options] Options for setting position
   * @param {boolean} [options.relative=false] Change the position relative to its current value
   * @param {string} [options.reason] Reason for changing the position
   * @returns {Promise<Role>}
   * @example
   * // Set the position of the role
   * role.setPosition(1)
   *   .then(updated => console.log(`Role position: ${updated.position}`))
   *   .catch(console.error);
   */
  setPosition(position, { relative, reason } = {}) {
    return Util.setPosition(
      this,
      position,
      relative,
      this.guild._sortedRoles(),
      this.client.api.guilds(this.guild.id).roles,
      reason,
    ).then(updatedRoles => {
      this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: updatedRoles,
      });
      return this;
    });
  }

  /**
   * Deletes the role.
   * @param {string} [reason] Reason for deleting this role
   * @returns {Promise<Role>}
   * @example
   * // Delete a role
   * role.delete('The role needed to go')
   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))
   *   .catch(console.error);
   */
  delete(reason) {
    return this.client.api.guilds[this.guild.id].roles[this.id].delete({ reason }).then(() => {
      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: this.id });
      return this;
    });
  }

  /**
   * Whether this role equals another role. It compares all properties, so for most operations
   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often
   * what most users need.
   * @param {Role} role Role to compare with
   * @returns {boolean}
   */
  equals(role) {
    return (
      role &&
      this.id === role.id &&
      this.name === role.name &&
      this.color === role.color &&
      this.hoist === role.hoist &&
      this.position === role.position &&
      this.permissions.bitfield === role.permissions.bitfield &&
      this.managed === role.managed
    );
  }

  /**
   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.
   * @returns {string}
   * @example
   * // Logs: Role: <@&123456789012345678>
   * console.log(`Role: ${role}`);
   */
  toString() {
    if (this.id === this.guild.id) return '@everyone';
    return `<@&${this.id}>`;
  }

  toJSON() {
    return super.toJSON({ createdTimestamp: true });
  }

  /**
   * Compares the positions of two roles.
   * @param {Role} role1 First role to compare
   * @param {Role} role2 Second role to compare
   * @returns {number} Negative number if the first role's position is lower (second role's is higher),
   * positive number if the first's is higher (second's is lower), 0 if equal
   */
  static comparePositions(role1, role2) {
    if (role1.position === role2.position) return role2.id - role1.id;
    return role1.position - role2.position;
  }
}

module.exports = Role;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/StoreChannel.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/StoreChannel.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const GuildChannel = __webpack_require__(/*! ./GuildChannel */ "./node_modules/discord.js/src/structures/GuildChannel.js");

/**
 * Represents a guild store channel on Discord.
 * @extends {GuildChannel}
 */
class StoreChannel extends GuildChannel {
  /**
   * @param {*} guild The guild the store channel is part of
   * @param {*} data The data for the store channel
   */
  constructor(guild, data) {
    super(guild, data);

    /**
     * If the guild considers this channel NSFW
     * @type {boolean}
     * @readonly
     */
    this.nsfw = Boolean(data.nsfw);
  }

  _patch(data) {
    super._patch(data);

    if (typeof data.nsfw !== 'undefined') this.nsfw = Boolean(data.nsfw);
  }
}

module.exports = StoreChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Team.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Team.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const TeamMember = __webpack_require__(/*! ./TeamMember */ "./node_modules/discord.js/src/structures/TeamMember.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");

/**
 * Represents a Client OAuth2 Application Team.
 * @extends {Base}
 */
class Team extends Base {
  constructor(client, data) {
    super(client);
    this._patch(data);
  }

  _patch(data) {
    /**
     * The ID of the Team
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * The name of the Team
     * @type {string}
     */
    this.name = data.name;

    /**
     * The Team's icon hash
     * @type {?string}
     */
    this.icon = data.icon || null;

    /**
     * The Team's owner id
     * @type {?string}
     */
    this.ownerID = data.owner_user_id || null;

    /**
     * The Team's members
     * @type {Collection<Snowflake, TeamMember>}
     */
    this.members = new Collection();

    for (const memberData of data.members) {
      const member = new TeamMember(this, memberData);
      this.members.set(member.id, member);
    }
  }

  /**
   * The owner of this team
   * @type {?TeamMember}
   * @readonly
   */
  get owner() {
    return this.members.get(this.ownerID) || null;
  }

  /**
   * The timestamp the team was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the team was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * A link to the teams's icon.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string} URL to the icon
   */
  iconURL({ format, size } = {}) {
    if (!this.icon) return null;
    return this.client.rest.cdn.TeamIcon(this.id, this.icon, { format, size });
  }

  /**
   * When concatenated with a string, this automatically returns the Team's name instead of the
   * Team object.
   * @returns {string}
   * @example
   * // Logs: Team name: My Team
   * console.log(`Team name: ${team}`);
   */
  toString() {
    return this.name;
  }

  toJSON() {
    return super.toJSON({ createdTimestamp: true });
  }
}

module.exports = Team;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/TeamMember.js":
/*!**************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/TeamMember.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const { MembershipStates } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/**
 * Represents a Client OAuth2 Application Team Member.
 * @extends {Base}
 */
class TeamMember extends Base {
  constructor(team, data) {
    super(team.client);

    /**
     * The Team this member is part of
     * @type {Team}
     */
    this.team = team;

    this._patch(data);
  }

  _patch(data) {
    /**
     * The permissions this Team Member has with regard to the team
     * @type {string[]}
     */
    this.permissions = data.permissions;

    /**
     * The permissions this Team Member has with regard to the team
     * @type {MembershipStates}
     */
    this.membershipState = MembershipStates[data.membership_state];

    /**
     * The user for this Team Member
     * @type {User}
     */
    this.user = this.client.users.add(data.user);
  }

  /**
   * The ID of the Team Member
   * @type {Snowflake}
   * @readonly
   */
  get id() {
    return this.user.id;
  }

  /**
   * When concatenated with a string, this automatically returns the team members's mention instead of the
   * TeamMember object.
   * @returns {string}
   * @example
   * // Logs: Team Member's mention: <@123456789012345678>
   * console.log(`Team Member's mention: ${teamMember}`);
   */
  toString() {
    return this.user.toString();
  }
}

module.exports = TeamMember;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/TextChannel.js":
/*!***************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/TextChannel.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const GuildChannel = __webpack_require__(/*! ./GuildChannel */ "./node_modules/discord.js/src/structures/GuildChannel.js");
const Webhook = __webpack_require__(/*! ./Webhook */ "./node_modules/discord.js/src/structures/Webhook.js");
const TextBasedChannel = __webpack_require__(/*! ./interfaces/TextBasedChannel */ "./node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js");
const MessageManager = __webpack_require__(/*! ../managers/MessageManager */ "./node_modules/discord.js/src/managers/MessageManager.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");

/**
 * Represents a guild text channel on Discord.
 * @extends {GuildChannel}
 * @implements {TextBasedChannel}
 */
class TextChannel extends GuildChannel {
  /**
   * @param {Guild} guild The guild the text channel is part of
   * @param {Object} data The data for the text channel
   */
  constructor(guild, data) {
    super(guild, data);
    /**
     * A manager of the messages sent to this channel
     * @type {MessageManager}
     */
    this.messages = new MessageManager(this);

    /**
     * If the guild considers this channel NSFW
     * @type {boolean}
     * @readonly
     */
    this.nsfw = Boolean(data.nsfw);
    this._typing = new Map();
  }

  _patch(data) {
    super._patch(data);

    /**
     * The topic of the text channel
     * @type {?string}
     */
    this.topic = data.topic;

    if (typeof data.nsfw !== 'undefined') this.nsfw = Boolean(data.nsfw);

    /**
     * The ID of the last message sent in this channel, if one was sent
     * @type {?Snowflake}
     */
    this.lastMessageID = data.last_message_id;

    /**
     * The ratelimit per user for this channel in seconds
     * @type {number}
     */
    this.rateLimitPerUser = data.rate_limit_per_user || 0;

    /**
     * The timestamp when the last pinned message was pinned, if there was one
     * @type {?number}
     */
    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;

    if (data.messages) for (const message of data.messages) this.messages.add(message);
  }

  /**
   * Sets the rate limit per user for this channel.
   * @param {number} rateLimitPerUser The new ratelimit in seconds
   * @param {string} [reason] Reason for changing the channel's ratelimits
   * @returns {Promise<TextChannel>}
   */
  setRateLimitPerUser(rateLimitPerUser, reason) {
    return this.edit({ rateLimitPerUser }, reason);
  }

  /**
   * Sets whether this channel is flagged as NSFW.
   * @param {boolean} nsfw Whether the channel should be considered NSFW
   * @param {string} [reason] Reason for changing the channel's NSFW flag
   * @returns {Promise<TextChannel>}
   */
  setNSFW(nsfw, reason) {
    return this.edit({ nsfw }, reason);
  }

  /**
   * Fetches all webhooks for the channel.
   * @returns {Promise<Collection<Snowflake, Webhook>>}
   * @example
   * // Fetch webhooks
   * channel.fetchWebhooks()
   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))
   *   .catch(console.error);
   */
  fetchWebhooks() {
    return this.client.api.channels[this.id].webhooks.get().then(data => {
      const hooks = new Collection();
      for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    });
  }

  /**
   * Creates a webhook for the channel.
   * @param {string} name The name of the webhook
   * @param {Object} [options] Options for creating the webhook
   * @param {BufferResolvable|Base64Resolvable} [options.avatar] Avatar for the webhook
   * @param {string} [options.reason] Reason for creating the webhook
   * @returns {Promise<Webhook>} webhook The created webhook
   * @example
   * // Create a webhook for the current channel
   * channel.createWebhook('Snek', {
   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',
   *   reason: 'Needed a cool new Webhook'
   * })
   *   .then(console.log)
   *   .catch(console.error)
   */
  async createWebhook(name, { avatar, reason } = {}) {
    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {
      avatar = await DataResolver.resolveImage(avatar);
    }
    return this.client.api.channels[this.id].webhooks
      .post({
        data: {
          name,
          avatar,
        },
        reason,
      })
      .then(data => new Webhook(this.client, data));
  }

  // These are here only for documentation purposes - they are implemented by TextBasedChannel
  /* eslint-disable no-empty-function */
  get lastMessage() {}
  get lastPinAt() {}
  send() {}
  startTyping() {}
  stopTyping() {}
  get typing() {}
  get typingCount() {}
  createMessageCollector() {}
  awaitMessages() {}
  bulkDelete() {}
}

TextBasedChannel.applyToClass(TextChannel, true);

module.exports = TextChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/User.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/User.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const TextBasedChannel = __webpack_require__(/*! ./interfaces/TextBasedChannel */ "./node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");
const UserFlags = __webpack_require__(/*! ../util/UserFlags */ "./node_modules/discord.js/src/util/UserFlags.js");

let Structures;

/**
 * Represents a user on Discord.
 * @implements {TextBasedChannel}
 * @extends {Base}
 */
class User extends Base {
  /**
   * @param {Client} client The instantiating client
   * @param {Object} data The data for the user
   */
  constructor(client, data) {
    super(client);

    /**
     * The ID of the user
     * @type {Snowflake}
     */
    this.id = data.id;

    this.system = null;
    this.locale = null;
    this.flags = null;

    this._patch(data);
  }

  _patch(data) {
    if ('username' in data) {
      /**
       * The username of the user
       * @type {?string}
       */
      this.username = data.username;
    } else if (typeof this.username !== 'string') {
      this.username = null;
    }

    if ('bot' in data || typeof this.bot !== 'boolean') {
      /**
       * Whether or not the user is a bot
       * @type {boolean}
       */
      this.bot = Boolean(data.bot);
    }

    if ('discriminator' in data) {
      /**
       * A discriminator based on username for the user
       * @type {?string}
       */
      this.discriminator = data.discriminator;
    } else if (typeof this.discriminator !== 'string') {
      this.discriminator = null;
    }

    if ('avatar' in data) {
      /**
       * The ID of the user's avatar
       * @type {?string}
       */
      this.avatar = data.avatar;
    } else if (typeof this.avatar !== 'string') {
      this.avatar = null;
    }

    if ('system' in data) {
      /**
       * Whether the user is an Official Discord System user (part of the urgent message system)
       * @type {?boolean}
       */
      this.system = Boolean(data.system);
    }

    if ('locale' in data) {
      /**
       * The locale of the user's client (ISO 639-1)
       * @type {?string}
       */
      this.locale = data.locale;
    }

    if ('public_flags' in data) {
      /**
       * The flags for this user
       * @type {?UserFlags}
       */
      this.flags = new UserFlags(data.public_flags);
    }

    /**
     * The ID of the last message sent by the user, if one was sent
     * @type {?Snowflake}
     */
    this.lastMessageID = null;

    /**
     * The ID of the channel for the last message sent by the user, if one was sent
     * @type {?Snowflake}
     */
    this.lastMessageChannelID = null;
  }

  /**
   * Whether this User is a partial
   * @type {boolean}
   * @readonly
   */
  get partial() {
    return typeof this.username !== 'string';
  }

  /**
   * The timestamp the user was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the user was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * The Message object of the last message sent by the user, if one was sent
   * @type {?Message}
   * @readonly
   */
  get lastMessage() {
    const channel = this.client.channels.cache.get(this.lastMessageChannelID);
    return (channel && channel.messages.cache.get(this.lastMessageID)) || null;
  }

  /**
   * The presence of this user
   * @type {Presence}
   * @readonly
   */
  get presence() {
    for (const guild of this.client.guilds.cache.values()) {
      if (guild.presences.cache.has(this.id)) return guild.presences.cache.get(this.id);
    }
    if (!Structures) Structures = __webpack_require__(/*! ../util/Structures */ "./node_modules/discord.js/src/util/Structures.js");
    const Presence = Structures.get('Presence');
    return new Presence(this.client, { user: { id: this.id } });
  }

  /**
   * A link to the user's avatar.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  avatarURL({ format, size, dynamic } = {}) {
    if (!this.avatar) return null;
    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);
  }

  /**
   * A link to the user's default avatar
   * @type {string}
   * @readonly
   */
  get defaultAvatarURL() {
    return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5);
  }

  /**
   * A link to the user's avatar if they have one.
   * Otherwise a link to their default avatar will be returned.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {string}
   */
  displayAvatarURL(options) {
    return this.avatarURL(options) || this.defaultAvatarURL;
  }

  /**
   * The Discord "tag" (e.g. `hydrabolt#0001`) for this user
   * @type {?string}
   * @readonly
   */
  get tag() {
    return typeof this.username === 'string' ? `${this.username}#${this.discriminator}` : null;
  }

  /**
   * Checks whether the user is typing in a channel.
   * @param {ChannelResolvable} channel The channel to check in
   * @returns {boolean}
   */
  typingIn(channel) {
    channel = this.client.channels.resolve(channel);
    return channel._typing.has(this.id);
  }

  /**
   * Gets the time that the user started typing.
   * @param {ChannelResolvable} channel The channel to get the time in
   * @returns {?Date}
   */
  typingSinceIn(channel) {
    channel = this.client.channels.resolve(channel);
    return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;
  }

  /**
   * Gets the amount of time the user has been typing in a channel for (in milliseconds), or -1 if they're not typing.
   * @param {ChannelResolvable} channel The channel to get the time in
   * @returns {number}
   */
  typingDurationIn(channel) {
    channel = this.client.channels.resolve(channel);
    return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;
  }

  /**
   * The DM between the client's user and this user
   * @type {?DMChannel}
   * @readonly
   */
  get dmChannel() {
    return this.client.channels.cache.find(c => c.type === 'dm' && c.recipient.id === this.id) || null;
  }

  /**
   * Creates a DM channel between the client and the user.
   * @param {boolean} [force=false] Whether to skip the cache check and request the API
   * @returns {Promise<DMChannel>}
   */
  async createDM(force = false) {
    if (!force) {
      const { dmChannel } = this;
      if (dmChannel && !dmChannel.partial) return dmChannel;
    }

    const data = await this.client.api.users(this.client.user.id).channels.post({
      data: {
        recipient_id: this.id,
      },
    });
    return this.client.actions.ChannelCreate.handle(data).channel;
  }

  /**
   * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.
   * @returns {Promise<DMChannel>}
   */
  async deleteDM() {
    const { dmChannel } = this;
    if (!dmChannel) throw new Error('USER_NO_DMCHANNEL');
    const data = await this.client.api.channels(dmChannel.id).delete();
    return this.client.actions.ChannelDelete.handle(data).channel;
  }

  /**
   * Checks if the user is equal to another. It compares ID, username, discriminator, avatar, and bot flags.
   * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.
   * @param {User} user User to compare with
   * @returns {boolean}
   */
  equals(user) {
    let equal =
      user &&
      this.id === user.id &&
      this.username === user.username &&
      this.discriminator === user.discriminator &&
      this.avatar === user.avatar;

    return equal;
  }

  /**
   * Fetches this user's flags.
   * @param {boolean} [force=false] Whether to skip the cache check and request the AP
   * @returns {Promise<UserFlags>}
   */
  async fetchFlags(force = false) {
    if (this.flags && !force) return this.flags;
    const data = await this.client.api.users(this.id).get();
    this._patch(data);
    return this.flags;
  }

  /**
   * Fetches this user.
   * @param {boolean} [force=false] Whether to skip the cache check and request the AP
   * @returns {Promise<User>}
   */
  fetch(force = false) {
    return this.client.users.fetch(this.id, true, force);
  }

  /**
   * When concatenated with a string, this automatically returns the user's mention instead of the User object.
   * @returns {string}
   * @example
   * // Logs: Hello from <@123456789012345678>!
   * console.log(`Hello from ${user}!`);
   */
  toString() {
    return `<@${this.id}>`;
  }

  toJSON(...props) {
    const json = super.toJSON(
      {
        createdTimestamp: true,
        defaultAvatarURL: true,
        tag: true,
        lastMessage: false,
        lastMessageID: false,
      },
      ...props,
    );
    json.avatarURL = this.avatarURL();
    json.displayAvatarURL = this.displayAvatarURL();
    return json;
  }

  // These are here only for documentation purposes - they are implemented by TextBasedChannel
  /* eslint-disable no-empty-function */
  send() {}
}

TextBasedChannel.applyToClass(User);

module.exports = User;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/VoiceChannel.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/VoiceChannel.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const GuildChannel = __webpack_require__(/*! ./GuildChannel */ "./node_modules/discord.js/src/structures/GuildChannel.js");
const { Error } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const Collection = __webpack_require__(/*! ../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { browser } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Permissions = __webpack_require__(/*! ../util/Permissions */ "./node_modules/discord.js/src/util/Permissions.js");

/**
 * Represents a guild voice channel on Discord.
 * @extends {GuildChannel}
 */
class VoiceChannel extends GuildChannel {
  _patch(data) {
    super._patch(data);
    /**
     * The bitrate of this voice channel
     * @type {number}
     */
    this.bitrate = data.bitrate;

    /**
     * The maximum amount of users allowed in this channel - 0 means unlimited.
     * @type {number}
     */
    this.userLimit = data.user_limit;
  }

  /**
   * The members in this voice channel
   * @type {Collection<Snowflake, GuildMember>}
   * @readonly
   */
  get members() {
    const coll = new Collection();
    for (const state of this.guild.voiceStates.cache.values()) {
      if (state.channelID === this.id && state.member) {
        coll.set(state.id, state.member);
      }
    }
    return coll;
  }

  /**
   * Checks if the voice channel is full
   * @type {boolean}
   * @readonly
   */
  get full() {
    return this.userLimit > 0 && this.members.size >= this.userLimit;
  }

  /**
   * Whether the channel is deletable by the client user
   * @type {boolean}
   * @readonly
   */
  get deletable() {
    return super.deletable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);
  }

  /**
   * Whether the channel is editable by the client user
   * @type {boolean}
   * @readonly
   */
  get editable() {
    return this.manageable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);
  }

  /**
   * Whether the channel is joinable by the client user
   * @type {boolean}
   * @readonly
   */
  get joinable() {
    if (browser) return false;
    if (!this.viewable) return false;
    if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) return false;
    if (this.full && !this.permissionsFor(this.client.user).has(Permissions.FLAGS.MOVE_MEMBERS, false)) return false;
    return true;
  }

  /**
   * Checks if the client has permission to send audio to the voice channel
   * @type {boolean}
   * @readonly
   */
  get speakable() {
    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.SPEAK, false);
  }

  /**
   * Sets the bitrate of the channel.
   * @param {number} bitrate The new bitrate
   * @param {string} [reason] Reason for changing the channel's bitrate
   * @returns {Promise<VoiceChannel>}
   * @example
   * // Set the bitrate of a voice channel
   * voiceChannel.setBitrate(48000)
   *   .then(vc => console.log(`Set bitrate to ${vc.bitrate}bps for ${vc.name}`))
   *   .catch(console.error);
   */
  setBitrate(bitrate, reason) {
    return this.edit({ bitrate }, reason);
  }

  /**
   * Sets the user limit of the channel.
   * @param {number} userLimit The new user limit
   * @param {string} [reason] Reason for changing the user limit
   * @returns {Promise<VoiceChannel>}
   * @example
   * // Set the user limit of a voice channel
   * voiceChannel.setUserLimit(42)
   *   .then(vc => console.log(`Set user limit to ${vc.userLimit} for ${vc.name}`))
   *   .catch(console.error);
   */
  setUserLimit(userLimit, reason) {
    return this.edit({ userLimit }, reason);
  }

  /**
   * Attempts to join this voice channel.
   * @returns {Promise<VoiceConnection>}
   * @example
   * // Join a voice channel
   * voiceChannel.join()
   *   .then(connection => console.log('Connected!'))
   *   .catch(console.error);
   */
  join() {
    if (browser) return Promise.reject(new Error('VOICE_NO_BROWSER'));
    return this.client.voice.joinChannel(this);
  }

  /**
   * Leaves this voice channel.
   * @example
   * // Leave a voice channel
   * voiceChannel.leave();
   */
  leave() {
    if (browser) return;
    const connection = this.client.voice.connections.get(this.guild.id);
    if (connection && connection.channel.id === this.id) connection.disconnect();
  }
}

module.exports = VoiceChannel;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/VoiceRegion.js":
/*!***************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/VoiceRegion.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Represents a Discord voice region for guilds.
 */
class VoiceRegion {
  constructor(data) {
    /**
     * The ID of the region
     * @type {string}
     */
    this.id = data.id;

    /**
     * Name of the region
     * @type {string}
     */
    this.name = data.name;

    /**
     * Whether the region is VIP-only
     * @type {boolean}
     */
    this.vip = data.vip;

    /**
     * Whether the region is deprecated
     * @type {boolean}
     */
    this.deprecated = data.deprecated;

    /**
     * Whether the region is optimal
     * @type {boolean}
     */
    this.optimal = data.optimal;

    /**
     * Whether the region is custom
     * @type {boolean}
     */
    this.custom = data.custom;
  }

  toJSON() {
    return Util.flatten(this);
  }
}

module.exports = VoiceRegion;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/VoiceState.js":
/*!**************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/VoiceState.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(/*! ./Base */ "./node_modules/discord.js/src/structures/Base.js");
const { Error, TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const { browser } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");

/**
 * Represents the voice state for a Guild Member.
 */
class VoiceState extends Base {
  /**
   * @param {Guild} guild The guild the voice state is part of
   * @param {Object} data The data for the voice state
   */
  constructor(guild, data) {
    super(guild.client);
    /**
     * The guild of this voice state
     * @type {Guild}
     */
    this.guild = guild;
    /**
     * The ID of the member of this voice state
     * @type {Snowflake}
     */
    this.id = data.user_id;
    this._patch(data);
  }

  _patch(data) {
    /**
     * Whether this member is deafened server-wide
     * @type {?boolean}
     */
    this.serverDeaf = 'deaf' in data ? data.deaf : null;
    /**
     * Whether this member is muted server-wide
     * @type {?boolean}
     */
    this.serverMute = 'mute' in data ? data.mute : null;
    /**
     * Whether this member is self-deafened
     * @type {?boolean}
     */
    this.selfDeaf = 'self_deaf' in data ? data.self_deaf : null;
    /**
     * Whether this member is self-muted
     * @type {?boolean}
     */
    this.selfMute = 'self_mute' in data ? data.self_mute : null;
    /**
     * Whether this member's camera is enabled
     * @type {?boolean}
     */
    this.selfVideo = 'self_video' in data ? data.self_video : null;
    /**
     * The session ID of this member's connection
     * @type {?string}
     */
    this.sessionID = 'session_id' in data ? data.session_id : null;
    /**
     * Whether this member is streaming using "Go Live"
     * @type {boolean}
     */
    this.streaming = data.self_stream || false;
    /**
     * The ID of the voice channel that this member is in
     * @type {?Snowflake}
     */
    this.channelID = data.channel_id || null;
    return this;
  }

  /**
   * The member that this voice state belongs to
   * @type {?GuildMember}
   * @readonly
   */
  get member() {
    return this.guild.members.cache.get(this.id) || null;
  }

  /**
   * The channel that the member is connected to
   * @type {?VoiceChannel}
   * @readonly
   */
  get channel() {
    return this.guild.channels.cache.get(this.channelID) || null;
  }

  /**
   * If this is a voice state of the client user, then this will refer to the active VoiceConnection for this guild
   * @type {?VoiceConnection}
   * @readonly
   */
  get connection() {
    if (browser || this.id !== this.client.user.id) return null;
    return this.client.voice.connections.get(this.guild.id) || null;
  }

  /**
   * Whether this member is either self-deafened or server-deafened
   * @type {?boolean}
   * @readonly
   */
  get deaf() {
    return this.serverDeaf || this.selfDeaf;
  }

  /**
   * Whether this member is either self-muted or server-muted
   * @type {?boolean}
   * @readonly
   */
  get mute() {
    return this.serverMute || this.selfMute;
  }

  /**
   * Whether this member is currently speaking. A boolean if the information is available (aka
   * the bot is connected to any voice channel in the guild), otherwise this is null
   * @type {?boolean}
   * @readonly
   */
  get speaking() {
    return this.channel && this.channel.connection ? Boolean(this.channel.connection._speaking.get(this.id)) : null;
  }

  /**
   * Mutes/unmutes the member of this voice state.
   * @param {boolean} mute Whether or not the member should be muted
   * @param {string} [reason] Reason for muting or unmuting
   * @returns {Promise<GuildMember>}
   */
  setMute(mute, reason) {
    return this.member ? this.member.edit({ mute }, reason) : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));
  }

  /**
   * Deafens/undeafens the member of this voice state.
   * @param {boolean} deaf Whether or not the member should be deafened
   * @param {string} [reason] Reason for deafening or undeafening
   * @returns {Promise<GuildMember>}
   */
  setDeaf(deaf, reason) {
    return this.member ? this.member.edit({ deaf }, reason) : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));
  }

  /**
   * Kicks the member from the voice channel.
   * @param {string} [reason] Reason for kicking member from the channel
   * @returns {Promise<GuildMember>}
   */
  kick(reason) {
    return this.setChannel(null, reason);
  }

  /**
   * Moves the member to a different channel, or disconnects them from the one they're in.
   * @param {ChannelResolvable|null} [channel] Channel to move the member to, or `null` if you want to disconnect them
   * from voice.
   * @param {string} [reason] Reason for moving member to another channel or disconnecting
   * @returns {Promise<GuildMember>}
   */
  setChannel(channel, reason) {
    return this.member
      ? this.member.edit({ channel }, reason)
      : Promise.reject(new Error('VOICE_STATE_UNCACHED_MEMBER'));
  }

  /**
   * Self-mutes/unmutes the bot for this voice state.
   * @param {boolean} mute Whether or not the bot should be self-muted
   * @returns {Promise<boolean>} true if the voice state was successfully updated, otherwise false
   */
  async setSelfMute(mute) {
    if (this.id !== this.client.user.id) throw new Error('VOICE_STATE_NOT_OWN');
    if (typeof mute !== 'boolean') throw new TypeError('VOICE_STATE_INVALID_TYPE', 'mute');
    if (!this.connection) return false;
    this.selfMute = mute;
    await this.connection.sendVoiceStateUpdate();
    return true;
  }

  /**
   * Self-deafens/undeafens the bot for this voice state.
   * @param {boolean} deaf Whether or not the bot should be self-deafened
   * @returns {Promise<boolean>} true if the voice state was successfully updated, otherwise false
   */
  async setSelfDeaf(deaf) {
    if (this.id !== this.client.user.id) return new Error('VOICE_STATE_NOT_OWN');
    if (typeof deaf !== 'boolean') return new TypeError('VOICE_STATE_INVALID_TYPE', 'deaf');
    if (!this.connection) return false;
    this.selfDeaf = deaf;
    await this.connection.sendVoiceStateUpdate();
    return true;
  }

  toJSON() {
    return super.toJSON({
      id: true,
      serverDeaf: true,
      serverMute: true,
      selfDeaf: true,
      selfMute: true,
      sessionID: true,
      channelID: 'channel',
    });
  }
}

module.exports = VoiceState;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/Webhook.js":
/*!***********************************************************!*\
  !*** ./node_modules/discord.js/src/structures/Webhook.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const APIMessage = __webpack_require__(/*! ./APIMessage */ "./node_modules/discord.js/src/structures/APIMessage.js");
const Channel = __webpack_require__(/*! ./Channel */ "./node_modules/discord.js/src/structures/Channel.js");
const { WebhookTypes } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const DataResolver = __webpack_require__(/*! ../util/DataResolver */ "./node_modules/discord.js/src/util/DataResolver.js");
const Snowflake = __webpack_require__(/*! ../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");

/**
 * Represents a webhook.
 */
class Webhook {
  constructor(client, data) {
    /**
     * The client that instantiated the webhook
     * @name Webhook#client
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: client });
    if (data) this._patch(data);
  }

  _patch(data) {
    /**
     * The name of the webhook
     * @type {string}
     */
    this.name = data.name;

    /**
     * The token for the webhook
     * @name Webhook#token
     * @type {?string}
     */
    Object.defineProperty(this, 'token', { value: data.token || null, writable: true, configurable: true });

    /**
     * The avatar for the webhook
     * @type {?string}
     */
    this.avatar = data.avatar;

    /**
     * The ID of the webhook
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * The type of the webhook
     * @type {WebhookTypes}
     */
    this.type = WebhookTypes[data.type];

    /**
     * The guild the webhook belongs to
     * @type {Snowflake}
     */
    this.guildID = data.guild_id;

    /**
     * The channel the webhook belongs to
     * @type {Snowflake}
     */
    this.channelID = data.channel_id;

    if (data.user) {
      /**
       * The owner of the webhook
       * @type {?User|Object}
       */
      this.owner = this.client.users ? this.client.users.cache.get(data.user.id) : data.user;
    } else {
      this.owner = null;
    }
  }

  /**
   * Options that can be passed into send.
   * @typedef {Object} WebhookMessageOptions
   * @property {string} [username=this.name] Username override for the message
   * @property {string} [avatarURL] Avatar URL override for the message
   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud
   * @property {string} [nonce=''] The nonce for the message
   * @property {Object[]} [embeds] An array of embeds for the message
   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content
   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)
   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or
   * everyone/here mentions should be sanitized to prevent unexpected mentions
   * @property {FileOptions[]|string[]} [files] Files to send with the message
   * @property {string|boolean} [code] Language for optional codeblock formatting to apply
   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if
   * it exceeds the character limit. If an object is provided, these are the options for splitting the message.
   */

  /**
   * Sends a message with this webhook.
   * @param {StringResolvable|APIMessage} [content=''] The content to send
   * @param {WebhookMessageOptions|MessageAdditions} [options={}] The options to provide
   * @returns {Promise<Message|Object>}
   * @example
   * // Send a basic message
   * webhook.send('hello!')
   *   .then(message => console.log(`Sent message: ${message.content}`))
   *   .catch(console.error);
   * @example
   * // Send a remote file
   * webhook.send({
   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
   * })
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send a local file
   * webhook.send({
   *   files: [{
   *     attachment: 'entire/path/to/file.jpg',
   *     name: 'file.jpg'
   *   }]
   * })
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send an embed with a local image inside
   * webhook.send('This is an embed', {
   *   embeds: [{
   *     thumbnail: {
   *          url: 'attachment://file.jpg'
   *       }
   *    }],
   *    files: [{
   *       attachment: 'entire/path/to/file.jpg',
   *       name: 'file.jpg'
   *    }]
   * })
   *   .then(console.log)
   *   .catch(console.error);
   */
  async send(content, options) {
    let apiMessage;

    if (content instanceof APIMessage) {
      apiMessage = content.resolveData();
    } else {
      apiMessage = APIMessage.create(this, content, options).resolveData();
      if (Array.isArray(apiMessage.data.content)) {
        return Promise.all(apiMessage.split().map(this.send.bind(this)));
      }
    }

    const { data, files } = await apiMessage.resolveFiles();
    return this.client.api
      .webhooks(this.id, this.token)
      .post({
        data,
        files,
        query: { wait: true },
        auth: false,
      })
      .then(d => {
        const channel = this.client.channels ? this.client.channels.cache.get(d.channel_id) : undefined;
        if (!channel) return d;
        return channel.messages.add(d, false);
      });
  }

  /**
   * Sends a raw slack message with this webhook.
   * @param {Object} body The raw body to send
   * @returns {Promise<boolean>}
   * @example
   * // Send a slack message
   * webhook.sendSlackMessage({
   *   'username': 'Wumpus',
   *   'attachments': [{
   *     'pretext': 'this looks pretty cool',
   *     'color': '#F0F',
   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',
   *     'footer': 'Powered by sneks',
   *     'ts': Date.now() / 1000
   *   }]
   * }).catch(console.error);
   */
  sendSlackMessage(body) {
    return this.client.api
      .webhooks(this.id, this.token)
      .slack.post({
        query: { wait: true },
        auth: false,
        data: body,
      })
      .then(data => data.toString() === 'ok');
  }

  /**
   * Edits the webhook.
   * @param {Object} options Options
   * @param {string} [options.name=this.name] New name for this webhook
   * @param {BufferResolvable} [options.avatar] New avatar for this webhook
   * @param {ChannelResolvable} [options.channel] New channel for this webhook
   * @param {string} [reason] Reason for editing this webhook
   * @returns {Promise<Webhook>}
   */
  async edit({ name = this.name, avatar, channel }, reason) {
    if (avatar && typeof avatar === 'string' && !avatar.startsWith('data:')) {
      avatar = await DataResolver.resolveImage(avatar);
    }
    if (channel) channel = channel instanceof Channel ? channel.id : channel;
    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({
      data: { name, avatar, channel_id: channel },
      reason,
    });

    this.name = data.name;
    this.avatar = data.avatar;
    this.channelID = data.channel_id;
    return this;
  }

  /**
   * Deletes the webhook.
   * @param {string} [reason] Reason for deleting this webhook
   * @returns {Promise}
   */
  delete(reason) {
    return this.client.api.webhooks(this.id, this.token).delete({ reason });
  }
  /**
   * The timestamp the webhook was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the webhook was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * The url of this webhook
   * @type {string}
   * @readonly
   */
  get url() {
    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);
  }

  /**
   * A link to the webhook's avatar.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string}
   */
  avatarURL({ format, size } = {}) {
    if (!this.avatar) return null;
    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);
  }

  static applyToClass(structure) {
    for (const prop of ['send', 'sendSlackMessage', 'edit', 'delete', 'createdTimestamp', 'createdAt', 'url']) {
      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));
    }
  }
}

module.exports = Webhook;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/interfaces/Application.js":
/*!**************************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/interfaces/Application.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ClientApplicationAssetTypes, Endpoints } = __webpack_require__(/*! ../../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Snowflake = __webpack_require__(/*! ../../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");
const Base = __webpack_require__(/*! ../Base */ "./node_modules/discord.js/src/structures/Base.js");

const AssetTypes = Object.keys(ClientApplicationAssetTypes);

/**
 * Represents an OAuth2 Application.
 * @abstract
 */
class Application extends Base {
  constructor(client, data) {
    super(client);
    this._patch(data);
  }

  _patch(data) {
    /**
     * The ID of the app
     * @type {Snowflake}
     */
    this.id = data.id;

    /**
     * The name of the app
     * @type {string}
     */
    this.name = data.name;

    /**
     * The app's description
     * @type {string}
     */
    this.description = data.description;

    /**
     * The app's icon hash
     * @type {string}
     */
    this.icon = data.icon;
  }

  /**
   * The timestamp the app was created at
   * @type {number}
   * @readonly
   */
  get createdTimestamp() {
    return Snowflake.deconstruct(this.id).timestamp;
  }

  /**
   * The time the app was created at
   * @type {Date}
   * @readonly
   */
  get createdAt() {
    return new Date(this.createdTimestamp);
  }

  /**
   * A link to the application's icon.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string} URL to the icon
   */
  iconURL({ format, size } = {}) {
    if (!this.icon) return null;
    return this.client.rest.cdn.AppIcon(this.id, this.icon, { format, size });
  }

  /**
   * A link to this application's cover image.
   * @param {ImageURLOptions} [options={}] Options for the Image URL
   * @returns {?string} URL to the cover image
   */
  coverImage({ format, size } = {}) {
    if (!this.cover) return null;
    return Endpoints.CDN(this.client.options.http.cdn).AppIcon(this.id, this.cover, { format, size });
  }

  /**
   * Asset data.
   * @typedef {Object} ApplicationAsset
   * @property {Snowflake} id The asset ID
   * @property {string} name The asset name
   * @property {string} type The asset type
   */

  /**
   * Gets the clients rich presence assets.
   * @returns {Promise<Array<ApplicationAsset>>}
   */
  fetchAssets() {
    return this.client.api.oauth2
      .applications(this.id)
      .assets.get()
      .then(assets =>
        assets.map(a => ({
          id: a.id,
          name: a.name,
          type: AssetTypes[a.type - 1],
        })),
      );
  }

  /**
   * When concatenated with a string, this automatically returns the application's name instead of the
   * Oauth2Application object.
   * @returns {string}
   * @example
   * // Logs: Application name: My App
   * console.log(`Application name: ${application}`);
   */
  toString() {
    return this.name;
  }

  toJSON() {
    return super.toJSON({ createdTimestamp: true });
  }
}

module.exports = Application;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/interfaces/Collector.js":
/*!************************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/interfaces/Collector.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const Collection = __webpack_require__(/*! ../../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const Util = __webpack_require__(/*! ../../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * Filter to be applied to the collector.
 * @typedef {Function} CollectorFilter
 * @param {...*} args Any arguments received by the listener
 * @param {Collection} collection The items collected by this collector
 * @returns {boolean|Promise<boolean>}
 */

/**
 * Options to be applied to the collector.
 * @typedef {Object} CollectorOptions
 * @property {number} [time] How long to run the collector for in milliseconds
 * @property {number} [idle] How long to stop the collector after inactivity in milliseconds
 * @property {boolean} [dispose=false] Whether to dispose data when it's deleted
 */

/**
 * Abstract class for defining a new Collector.
 * @abstract
 */
class Collector extends EventEmitter {
  constructor(client, filter, options = {}) {
    super();

    /**
     * The client that instantiated this Collector
     * @name Collector#client
     * @type {Client}
     * @readonly
     */
    Object.defineProperty(this, 'client', { value: client });

    /**
     * The filter applied to this collector
     * @type {CollectorFilter}
     */
    this.filter = filter;

    /**
     * The options of this collector
     * @type {CollectorOptions}
     */
    this.options = options;

    /**
     * The items collected by this collector
     * @type {Collection}
     */
    this.collected = new Collection();

    /**
     * Whether this collector has finished collecting
     * @type {boolean}
     */
    this.ended = false;

    /**
     * Timeout for cleanup
     * @type {?Timeout}
     * @private
     */
    this._timeout = null;

    /**
     * Timeout for cleanup due to inactivity
     * @type {?Timeout}
     * @private
     */
    this._idletimeout = null;

    this.handleCollect = this.handleCollect.bind(this);
    this.handleDispose = this.handleDispose.bind(this);

    if (options.time) this._timeout = this.client.setTimeout(() => this.stop('time'), options.time);
    if (options.idle) this._idletimeout = this.client.setTimeout(() => this.stop('idle'), options.idle);
  }

  /**
   * Call this to handle an event as a collectable element. Accepts any event data as parameters.
   * @param {...*} args The arguments emitted by the listener
   * @emits Collector#collect
   */
  async handleCollect(...args) {
    const collect = this.collect(...args);

    if (collect && (await this.filter(...args, this.collected))) {
      this.collected.set(collect, args[0]);

      /**
       * Emitted whenever an element is collected.
       * @event Collector#collect
       * @param {...*} args The arguments emitted by the listener
       */
      this.emit('collect', ...args);

      if (this._idletimeout) {
        this.client.clearTimeout(this._idletimeout);
        this._idletimeout = this.client.setTimeout(() => this.stop('idle'), this.options.idle);
      }
    }
    this.checkEnd();
  }

  /**
   * Call this to remove an element from the collection. Accepts any event data as parameters.
   * @param {...*} args The arguments emitted by the listener
   * @emits Collector#dispose
   */
  handleDispose(...args) {
    if (!this.options.dispose) return;

    const dispose = this.dispose(...args);
    if (!dispose || !this.filter(...args) || !this.collected.has(dispose)) return;
    this.collected.delete(dispose);

    /**
     * Emitted whenever an element is disposed of.
     * @event Collector#dispose
     * @param {...*} args The arguments emitted by the listener
     */
    this.emit('dispose', ...args);
    this.checkEnd();
  }

  /**
   * Returns a promise that resolves with the next collected element;
   * rejects with collected elements if the collector finishes without receiving a next element
   * @type {Promise}
   * @readonly
   */
  get next() {
    return new Promise((resolve, reject) => {
      if (this.ended) {
        reject(this.collected);
        return;
      }

      const cleanup = () => {
        this.removeListener('collect', onCollect);
        this.removeListener('end', onEnd);
      };

      const onCollect = item => {
        cleanup();
        resolve(item);
      };

      const onEnd = () => {
        cleanup();
        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors
      };

      this.on('collect', onCollect);
      this.on('end', onEnd);
    });
  }

  /**
   * Stops this collector and emits the `end` event.
   * @param {string} [reason='user'] The reason this collector is ending
   * @emits Collector#end
   */
  stop(reason = 'user') {
    if (this.ended) return;

    if (this._timeout) {
      this.client.clearTimeout(this._timeout);
      this._timeout = null;
    }
    if (this._idletimeout) {
      this.client.clearTimeout(this._idletimeout);
      this._idletimeout = null;
    }
    this.ended = true;

    /**
     * Emitted when the collector is finished collecting.
     * @event Collector#end
     * @param {Collection} collected The elements collected by the collector
     * @param {string} reason The reason the collector ended
     */
    this.emit('end', this.collected, reason);
  }

  /**
   * Resets the collectors timeout and idle timer.
   * @param {Object} [options] Options
   * @param {number} [options.time] How long to run the collector for in milliseconds
   * @param {number} [options.idle] How long to stop the collector after inactivity in milliseconds
   */
  resetTimer({ time, idle } = {}) {
    if (this._timeout) {
      this.client.clearTimeout(this._timeout);
      this._timeout = this.client.setTimeout(() => this.stop('time'), time || this.options.time);
    }
    if (this._idletimeout) {
      this.client.clearTimeout(this._idletimeout);
      this._idletimeout = this.client.setTimeout(() => this.stop('idle'), idle || this.options.idle);
    }
  }

  /**
   * Checks whether the collector should end, and if so, ends it.
   */
  checkEnd() {
    const reason = this.endReason();
    if (reason) this.stop(reason);
  }

  /**
   * Allows collectors to be consumed with for-await-of loops
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}
   */
  async *[Symbol.asyncIterator]() {
    const queue = [];
    const onCollect = item => queue.push(item);
    this.on('collect', onCollect);

    try {
      while (queue.length || !this.ended) {
        if (queue.length) {
          yield queue.shift();
        } else {
          // eslint-disable-next-line no-await-in-loop
          await new Promise(resolve => {
            const tick = () => {
              this.removeListener('collect', tick);
              this.removeListener('end', tick);
              return resolve();
            };
            this.on('collect', tick);
            this.on('end', tick);
          });
        }
      }
    } finally {
      this.removeListener('collect', onCollect);
    }
  }

  toJSON() {
    return Util.flatten(this);
  }

  /* eslint-disable no-empty-function, valid-jsdoc */
  /**
   * Handles incoming events from the `handleCollect` function. Returns null if the event should not
   * be collected, or returns an object describing the data that should be stored.
   * @see Collector#handleCollect
   * @param {...*} args Any args the event listener emits
   * @returns {?{key, value}} Data to insert into collection, if any
   * @abstract
   */
  collect() {}

  /**
   * Handles incoming events from the `handleDispose`. Returns null if the event should not
   * be disposed, or returns the key that should be removed.
   * @see Collector#handleDispose
   * @param {...*} args Any args the event listener emits
   * @returns {?*} Key to remove from the collection, if any
   * @abstract
   */
  dispose() {}

  /**
   * The reason this collector has ended or will end with.
   * @returns {?string} Reason to end the collector, if any
   * @abstract
   */
  endReason() {}
  /* eslint-enable no-empty-function, valid-jsdoc */
}

module.exports = Collector;


/***/ }),

/***/ "./node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable import/order */
const MessageCollector = __webpack_require__(/*! ../MessageCollector */ "./node_modules/discord.js/src/structures/MessageCollector.js");
const APIMessage = __webpack_require__(/*! ../APIMessage */ "./node_modules/discord.js/src/structures/APIMessage.js");
const Snowflake = __webpack_require__(/*! ../../util/Snowflake */ "./node_modules/discord.js/src/util/Snowflake.js");
const Collection = __webpack_require__(/*! ../../util/Collection */ "./node_modules/discord.js/src/util/Collection.js");
const { RangeError, TypeError } = __webpack_require__(/*! ../../errors */ "./node_modules/discord.js/src/errors/index.js");

/**
 * Interface for classes that have text-channel-like features.
 * @interface
 */
class TextBasedChannel {
  constructor() {
    /**
     * A manager of the messages sent to this channel
     * @type {MessageManager}
     */
    this.messages = new MessageManager(this);

    /**
     * The ID of the last message in the channel, if one was sent
     * @type {?Snowflake}
     */
    this.lastMessageID = null;

    /**
     * The timestamp when the last pinned message was pinned, if there was one
     * @type {?number}
     */
    this.lastPinTimestamp = null;
  }

  /**
   * The Message object of the last message in the channel, if one was sent
   * @type {?Message}
   * @readonly
   */
  get lastMessage() {
    return this.messages.cache.get(this.lastMessageID) || null;
  }

  /**
   * The date when the last pinned message was pinned, if there was one
   * @type {?Date}
   * @readonly
   */
  get lastPinAt() {
    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;
  }

  /**
   * Options provided when sending or editing a message.
   * @typedef {Object} MessageOptions
   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud
   * @property {string} [nonce=''] The nonce for the message
   * @property {string} [content=''] The content for the message
   * @property {MessageEmbed|Object} [embed] An embed for the message
   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)
   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content
   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or
   * everyone/here mentions should be sanitized to prevent unexpected mentions
   * @property {FileOptions[]|BufferResolvable[]} [files] Files to send with the message
   * @property {string|boolean} [code] Language for optional codeblock formatting to apply
   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if
   * it exceeds the character limit. If an object is provided, these are the options for splitting the message
   * @property {UserResolvable} [reply] User to reply to (prefixes the message with a mention, except in DMs)
   */

  /**
   * Options provided to control parsing of mentions by Discord
   * @typedef {Object} MessageMentionOptions
   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed
   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions
   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions
   */

  /**
   * Types of mentions to enable in MessageMentionOptions.
   * - `roles`
   * - `users`
   * - `everyone`
   * @typedef {string} MessageMentionTypes
   */

  /**
   * The type of mentions to disable.
   * - `none`
   * - `all`
   * - `everyone`
   * @typedef {string} DisableMentionType
   */

  /**
   * @typedef {Object} FileOptions
   * @property {BufferResolvable} attachment File to attach
   * @property {string} [name='file.jpg'] Filename of the attachment
   */

  /**
   * Options for splitting a message.
   * @typedef {Object} SplitOptions
   * @property {number} [maxLength=2000] Maximum character length per message piece
   * @property {string} [char='\n'] Character to split the message with
   * @property {string} [prepend=''] Text to prepend to every piece except the first
   * @property {string} [append=''] Text to append to every piece except the last
   */

  /**
   * Sends a message to this channel.
   * @param {StringResolvable|APIMessage} [content=''] The content to send
   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide
   * @returns {Promise<Message|Message[]>}
   * @example
   * // Send a basic message
   * channel.send('hello!')
   *   .then(message => console.log(`Sent message: ${message.content}`))
   *   .catch(console.error);
   * @example
   * // Send a remote file
   * channel.send({
   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
   * })
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send a local file
   * channel.send({
   *   files: [{
   *     attachment: 'entire/path/to/file.jpg',
   *     name: 'file.jpg'
   *   }]
   * })
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send an embed with a local image inside
   * channel.send('This is an embed', {
   *   embed: {
   *     thumbnail: {
   *          url: 'attachment://file.jpg'
   *       }
   *    },
   *    files: [{
   *       attachment: 'entire/path/to/file.jpg',
   *       name: 'file.jpg'
   *    }]
   * })
   *   .then(console.log)
   *   .catch(console.error);
   */
  async send(content, options) {
    const User = __webpack_require__(/*! ../User */ "./node_modules/discord.js/src/structures/User.js");
    const GuildMember = __webpack_require__(/*! ../GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js");

    if (this instanceof User || this instanceof GuildMember) {
      return this.createDM().then(dm => dm.send(content, options));
    }

    let apiMessage;

    if (content instanceof APIMessage) {
      apiMessage = content.resolveData();
    } else {
      apiMessage = APIMessage.create(this, content, options).resolveData();
      if (Array.isArray(apiMessage.data.content)) {
        return Promise.all(apiMessage.split().map(this.send.bind(this)));
      }
    }

    const { data, files } = await apiMessage.resolveFiles();
    return this.client.api.channels[this.id].messages
      .post({ data, files })
      .then(d => this.client.actions.MessageCreate.handle(d).message);
  }

  /**
   * Starts a typing indicator in the channel.
   * @param {number} [count=1] The number of times startTyping should be considered to have been called
   * @returns {Promise} Resolves once the bot stops typing gracefully, or rejects when an error occurs
   * @example
   * // Start typing in a channel, or increase the typing count by one
   * channel.startTyping();
   * @example
   * // Start typing in a channel with a typing count of five, or set it to five
   * channel.startTyping(5);
   */
  startTyping(count) {
    if (typeof count !== 'undefined' && count < 1) throw new RangeError('TYPING_COUNT');
    if (this.client.user._typing.has(this.id)) {
      const entry = this.client.user._typing.get(this.id);
      entry.count = count || entry.count + 1;
      return entry.promise;
    }

    const entry = {};
    entry.promise = new Promise((resolve, reject) => {
      const endpoint = this.client.api.channels[this.id].typing;
      Object.assign(entry, {
        count: count || 1,
        interval: this.client.setInterval(() => {
          endpoint.post().catch(error => {
            this.client.clearInterval(entry.interval);
            this.client.user._typing.delete(this.id);
            reject(error);
          });
        }, 9000),
        resolve,
      });
      endpoint.post().catch(error => {
        this.client.clearInterval(entry.interval);
        this.client.user._typing.delete(this.id);
        reject(error);
      });
      this.client.user._typing.set(this.id, entry);
    });
    return entry.promise;
  }

  /**
   * Stops the typing indicator in the channel.
   * The indicator will only stop if this is called as many times as startTyping().
   * <info>It can take a few seconds for the client user to stop typing.</info>
   * @param {boolean} [force=false] Whether or not to reset the call count and force the indicator to stop
   * @example
   * // Reduce the typing count by one and stop typing if it reached 0
   * channel.stopTyping();
   * @example
   * // Force typing to fully stop regardless of typing count
   * channel.stopTyping(true);
   */
  stopTyping(force = false) {
    if (this.client.user._typing.has(this.id)) {
      const entry = this.client.user._typing.get(this.id);
      entry.count--;
      if (entry.count <= 0 || force) {
        this.client.clearInterval(entry.interval);
        this.client.user._typing.delete(this.id);
        entry.resolve();
      }
    }
  }

  /**
   * Whether or not the typing indicator is being shown in the channel
   * @type {boolean}
   * @readonly
   */
  get typing() {
    return this.client.user._typing.has(this.id);
  }

  /**
   * Number of times `startTyping` has been called
   * @type {number}
   * @readonly
   */
  get typingCount() {
    if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;
    return 0;
  }

  /**
   * Creates a Message Collector.
   * @param {CollectorFilter} filter The filter to create the collector with
   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector
   * @returns {MessageCollector}
   * @example
   * // Create a message collector
   * const filter = m => m.content.includes('discord');
   * const collector = channel.createMessageCollector(filter, { time: 15000 });
   * collector.on('collect', m => console.log(`Collected ${m.content}`));
   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
   */
  createMessageCollector(filter, options = {}) {
    return new MessageCollector(this, filter, options);
  }

  /**
   * An object containing the same properties as CollectorOptions, but a few more:
   * @typedef {MessageCollectorOptions} AwaitMessagesOptions
   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
   */

  /**
   * Similar to createMessageCollector but in promise form.
   * Resolves with a collection of messages that pass the specified filter.
   * @param {CollectorFilter} filter The filter function to use
   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector
   * @returns {Promise<Collection<Snowflake, Message>>}
   * @example
   * // Await !vote messages
   * const filter = m => m.content.startsWith('!vote');
   * // Errors: ['time'] treats ending because of the time limit as an error
   * channel.awaitMessages(filter, { max: 4, time: 60000, errors: ['time'] })
   *   .then(collected => console.log(collected.size))
   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));
   */
  awaitMessages(filter, options = {}) {
    return new Promise((resolve, reject) => {
      const collector = this.createMessageCollector(filter, options);
      collector.once('end', (collection, reason) => {
        if (options.errors && options.errors.includes(reason)) {
          reject(collection);
        } else {
          resolve(collection);
        }
      });
    });
  }

  /**
   * Bulk deletes given messages that are newer than two weeks.
   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages
   * Messages or number of messages to delete
   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically
   * @returns {Promise<Collection<Snowflake, Message>>} Deleted messages
   * @example
   * // Bulk delete messages
   * channel.bulkDelete(5)
   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))
   *   .catch(console.error);
   */
  async bulkDelete(messages, filterOld = false) {
    if (Array.isArray(messages) || messages instanceof Collection) {
      let messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(m => m.id || m);
      if (filterOld) {
        messageIDs = messageIDs.filter(id => Date.now() - Snowflake.deconstruct(id).date.getTime() < 1209600000);
      }
      if (messageIDs.length === 0) return new Collection();
      if (messageIDs.length === 1) {
        await this.client.api.channels(this.id).messages(messageIDs[0]).delete();
        const message = this.client.actions.MessageDelete.getMessage(
          {
            message_id: messageIDs[0],
          },
          this,
        );
        return message ? new Collection([[message.id, message]]) : new Collection();
      }
      await this.client.api.channels[this.id].messages['bulk-delete'].post({ data: { messages: messageIDs } });
      return messageIDs.reduce(
        (col, id) =>
          col.set(
            id,
            this.client.actions.MessageDeleteBulk.getMessage(
              {
                message_id: id,
              },
              this,
            ),
          ),
        new Collection(),
      );
    }
    if (!isNaN(messages)) {
      const msgs = await this.messages.fetch({ limit: messages });
      return this.bulkDelete(msgs, filterOld);
    }
    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');
  }

  static applyToClass(structure, full = false, ignore = []) {
    const props = ['send'];
    if (full) {
      props.push(
        'lastMessage',
        'lastPinAt',
        'bulkDelete',
        'startTyping',
        'stopTyping',
        'typing',
        'typingCount',
        'createMessageCollector',
        'awaitMessages',
      );
    }
    for (const prop of props) {
      if (ignore.includes(prop)) continue;
      Object.defineProperty(
        structure.prototype,
        prop,
        Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop),
      );
    }
  }
}

module.exports = TextBasedChannel;

// Fixes Circular
const MessageManager = __webpack_require__(/*! ../../managers/MessageManager */ "./node_modules/discord.js/src/managers/MessageManager.js");


/***/ }),

/***/ "./node_modules/discord.js/src/util/ActivityFlags.js":
/*!***********************************************************!*\
  !*** ./node_modules/discord.js/src/util/ActivityFlags.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BitField = __webpack_require__(/*! ./BitField */ "./node_modules/discord.js/src/util/BitField.js");

/**
 * Data structure that makes it easy to interact with an {@link Activity#flags} bitfield.
 * @extends {BitField}
 */
class ActivityFlags extends BitField {}

/**
 * @name ActivityFlags
 * @kind constructor
 * @memberof ActivityFlags
 * @param {BitFieldResolvable} [bits=0] Bit(s) to read from
 */

/**
 * Numeric activity flags. All available properties:
 * * `INSTANCE`
 * * `JOIN`
 * * `SPECTATE`
 * * `JOIN_REQUEST`
 * * `SYNC`
 * * `PLAY`
 * @type {Object}
 * @see {@link https://discord.com/developers/docs/topics/gateway#activity-object-activity-flags}
 */
ActivityFlags.FLAGS = {
  INSTANCE: 1 << 0,
  JOIN: 1 << 1,
  SPECTATE: 1 << 2,
  JOIN_REQUEST: 1 << 3,
  SYNC: 1 << 4,
  PLAY: 1 << 5,
};

module.exports = ActivityFlags;


/***/ }),

/***/ "./node_modules/discord.js/src/util/BitField.js":
/*!******************************************************!*\
  !*** ./node_modules/discord.js/src/util/BitField.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { RangeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");

/**
 * Data structure that makes it easy to interact with a bitfield.
 */
class BitField {
  /**
   * @param {BitFieldResolvable} [bits=0] Bit(s) to read from
   */
  constructor(bits) {
    /**
     * Bitfield of the packed bits
     * @type {number}
     */
    this.bitfield = this.constructor.resolve(bits);
  }

  /**
   * Checks whether the bitfield has a bit, or any of multiple bits.
   * @param {BitFieldResolvable} bit Bit(s) to check for
   * @returns {boolean}
   */
  any(bit) {
    return (this.bitfield & this.constructor.resolve(bit)) !== 0;
  }

  /**
   * Checks if this bitfield equals another
   * @param {BitFieldResolvable} bit Bit(s) to check for
   * @returns {boolean}
   */
  equals(bit) {
    return this.bitfield === this.constructor.resolve(bit);
  }

  /**
   * Checks whether the bitfield has a bit, or multiple bits.
   * @param {BitFieldResolvable} bit Bit(s) to check for
   * @returns {boolean}
   */
  has(bit) {
    if (Array.isArray(bit)) return bit.every(p => this.has(p));
    bit = this.constructor.resolve(bit);
    return (this.bitfield & bit) === bit;
  }

  /**
   * Gets all given bits that are missing from the bitfield.
   * @param {BitFieldResolvable} bits Bit(s) to check for
   * @param {...*} hasParams Additional parameters for the has method, if any
   * @returns {string[]}
   */
  missing(bits, ...hasParams) {
    if (!Array.isArray(bits)) bits = new this.constructor(bits).toArray(false);
    return bits.filter(p => !this.has(p, ...hasParams));
  }

  /**
   * Freezes these bits, making them immutable.
   * @returns {Readonly<BitField>} These bits
   */
  freeze() {
    return Object.freeze(this);
  }

  /**
   * Adds bits to these ones.
   * @param {...BitFieldResolvable} [bits] Bits to add
   * @returns {BitField} These bits or new BitField if the instance is frozen.
   */
  add(...bits) {
    let total = 0;
    for (const bit of bits) {
      total |= this.constructor.resolve(bit);
    }
    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);
    this.bitfield |= total;
    return this;
  }

  /**
   * Removes bits from these.
   * @param {...BitFieldResolvable} [bits] Bits to remove
   * @returns {BitField} These bits or new BitField if the instance is frozen.
   */
  remove(...bits) {
    let total = 0;
    for (const bit of bits) {
      total |= this.constructor.resolve(bit);
    }
    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);
    this.bitfield &= ~total;
    return this;
  }

  /**
   * Gets an object mapping field names to a {@link boolean} indicating whether the
   * bit is available.
   * @param {...*} hasParams Additional parameters for the has method, if any
   * @returns {Object}
   */
  serialize(...hasParams) {
    const serialized = {};
    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);
    return serialized;
  }

  /**
   * Gets an {@link Array} of bitfield names based on the bits available.
   * @param {...*} hasParams Additional parameters for the has method, if any
   * @returns {string[]}
   */
  toArray(...hasParams) {
    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));
  }

  toJSON() {
    return this.bitfield;
  }

  valueOf() {
    return this.bitfield;
  }

  *[Symbol.iterator]() {
    yield* this.toArray();
  }

  /**
   * Data that can be resolved to give a bitfield. This can be:
   * * A string (see {@link BitField.FLAGS})
   * * A bit number
   * * An instance of BitField
   * * An Array of BitFieldResolvable
   * @typedef {string|number|BitField|BitFieldResolvable[]} BitFieldResolvable
   */

  /**
   * Resolves bitfields to their numeric form.
   * @param {BitFieldResolvable} [bit=0] - bit(s) to resolve
   * @returns {number}
   */
  static resolve(bit = 0) {
    if (typeof bit === 'number' && bit >= 0) return bit;
    if (bit instanceof BitField) return bit.bitfield;
    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, 0);
    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];
    const error = new RangeError('BITFIELD_INVALID');
    error.bit = bit;
    throw error;
  }
}

/**
 * Numeric bitfield flags.
 * <info>Defined in extension classes</info>
 * @type {Object}
 * @abstract
 */
BitField.FLAGS = {};

module.exports = BitField;


/***/ }),

/***/ "./node_modules/discord.js/src/util/Collection.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/util/Collection.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseCollection = __webpack_require__(/*! @discordjs/collection */ "./node_modules/@discordjs/collection/dist/index.js");
const Util = __webpack_require__(/*! ./Util */ "./node_modules/discord.js/src/util/Util.js");

class Collection extends BaseCollection {
  toJSON() {
    return this.map(e => (typeof e.toJSON === 'function' ? e.toJSON() : Util.flatten(e)));
  }
}

module.exports = Collection;

/**
 * @external Collection
 * @see {@link https://discord.js.org/#/docs/collection/master/class/Collection}
 */


/***/ }),

/***/ "./node_modules/discord.js/src/util/Constants.js":
/*!*******************************************************!*\
  !*** ./node_modules/discord.js/src/util/Constants.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const Package = (exports.Package = __webpack_require__(/*! ../../package.json */ "./node_modules/discord.js/package.json"));
const { Error, RangeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const browser = (exports.browser = typeof window !== 'undefined');

/**
 * Options for a client.
 * @typedef {Object} ClientOptions
 * @property {number|number[]|string} [shards] ID of the shard to run, or an array of shard IDs. If not specified,
 * the client will spawn {@link ClientOptions#shardCount} shards. If set to `auto`, it will fetch the
 * recommended amount of shards from Discord and spawn that amount
 * @property {number} [shardCount=1] The total amount of shards used by all processes of this bot
 * (e.g. recommended shard count, shard count of the ShardingManager)
 * @property {number} [messageCacheMaxSize=200] Maximum number of messages to cache per channel
 * (-1 or Infinity for unlimited - don't do this without message sweeping, otherwise memory usage will climb
 * indefinitely)
 * @property {number} [messageCacheLifetime=0] How long a message should stay in the cache until it is considered
 * sweepable (in seconds, 0 for forever)
 * @property {number} [messageSweepInterval=0] How frequently to remove messages from the cache that are older than
 * the message cache lifetime (in seconds, 0 for never)
 * @property {number} [messageEditHistoryMaxSize=-1] Maximum number of previous versions to hold for an edited message
 * (-1 or Infinity for unlimited - don't do this without sweeping, otherwise memory usage may climb indefinitely.)
 * @property {boolean} [fetchAllMembers=false] Whether to cache all guild members and users upon startup, as well as
 * upon joining a guild (should be avoided whenever possible)
 * @property {DisableMentionType} [disableMentions='none'] Default value for {@link MessageOptions#disableMentions}
 * @property {MessageMentionOptions} [allowedMentions] Default value for {@link MessageOptions#allowedMentions}
 * @property {PartialType[]} [partials] Structures allowed to be partial. This means events can be emitted even when
 * they're missing all the data for a particular structure. See the "Partials" topic listed in the sidebar for some
 * important usage information, as partials require you to put checks in place when handling data.
 * @property {number} [restWsBridgeTimeout=5000] Maximum time permitted between REST responses and their
 * corresponding websocket events
 * @property {number} [restTimeOffset=500] Extra time in milliseconds to wait before continuing to make REST
 * requests (higher values will reduce rate-limiting errors on bad connections)
 * @property {number} [restRequestTimeout=15000] Time to wait before cancelling a REST request, in milliseconds
 * @property {number} [restSweepInterval=60] How frequently to delete inactive request buckets, in seconds
 * (or 0 for never)
 * @property {number} [retryLimit=1] How many times to retry on 5XX errors (Infinity for indefinite amount of retries)
 * @property {PresenceData} [presence] Presence data to use upon login
 * @property {WebsocketOptions} [ws] Options for the WebSocket
 * @property {HTTPOptions} [http] HTTP options
 */
exports.DefaultOptions = {
  shardCount: 1,
  messageCacheMaxSize: 200,
  messageCacheLifetime: 0,
  messageSweepInterval: 0,
  messageEditHistoryMaxSize: -1,
  fetchAllMembers: false,
  disableMentions: 'none',
  partials: [],
  restWsBridgeTimeout: 5000,
  restRequestTimeout: 15000,
  retryLimit: 1,
  restTimeOffset: 500,
  restSweepInterval: 60,
  presence: {},

  /**
   * WebSocket options (these are left as snake_case to match the API)
   * @typedef {Object} WebsocketOptions
   * @property {number} [large_threshold=50] Number of members in a guild after which offline users will no longer be
   * sent in the initial guild member list, must be between 50 and 250
   * @property {IntentsResolvable} [intents] Intents to enable for this connection
   */
  ws: {
    large_threshold: 50,
    compress: false,
    properties: {
      $os: browser ? 'browser' : process.platform,
      $browser: 'discord.js',
      $device: 'discord.js',
    },
    version: 6,
  },

  /**
   * HTTP options
   * @typedef {Object} HTTPOptions
   * @property {number} [version=7] API version to use
   * @property {string} [api='https://discord.com/api'] Base url of the API
   * @property {string} [cdn='https://cdn.discordapp.com'] Base url of the CDN
   * @property {string} [invite='https://discord.gg'] Base url of invites
   * @property {string} [template='https://discord.new'] Base url of templates
   */
  http: {
    version: 7,
    api: 'https://discord.com/api',
    cdn: 'https://cdn.discordapp.com',
    invite: 'https://discord.gg',
    template: 'https://discord.new',
  },
};

exports.UserAgent = browser
  ? null
  : `DiscordBot (${Package.homepage.split('#')[0]}, ${Package.version}) Node.js/${process.version}`;

exports.WSCodes = {
  1000: 'WS_CLOSE_REQUESTED',
  4004: 'TOKEN_INVALID',
  4010: 'SHARDING_INVALID',
  4011: 'SHARDING_REQUIRED',
  4013: 'INVALID_INTENTS',
  4014: 'DISALLOWED_INTENTS',
};

const AllowedImageFormats = ['webp', 'png', 'jpg', 'jpeg', 'gif'];

const AllowedImageSizes = Array.from({ length: 9 }, (e, i) => 2 ** (i + 4));

function makeImageUrl(root, { format = 'webp', size } = {}) {
  if (format && !AllowedImageFormats.includes(format)) throw new Error('IMAGE_FORMAT', format);
  if (size && !AllowedImageSizes.includes(size)) throw new RangeError('IMAGE_SIZE', size);
  return `${root}.${format}${size ? `?size=${size}` : ''}`;
}
/**
 * Options for Image URLs.
 * @typedef {Object} ImageURLOptions
 * @property {string} [format] One of `webp`, `png`, `jpg`, `jpeg`, `gif`. If no format is provided,
 * defaults to `webp`.
 * @property {boolean} [dynamic] If true, the format will dynamically change to `gif` for
 * animated avatars; the default is false.
 * @property {number} [size] One of `16`, `32`, `64`, `128`, `256`, `512`, `1024`, `2048`, `4096`
 */

exports.Endpoints = {
  CDN(root) {
    return {
      Emoji: (emojiID, format = 'png') => `${root}/emojis/${emojiID}.${format}`,
      Asset: name => `${root}/assets/${name}`,
      DefaultAvatar: discriminator => `${root}/embed/avatars/${discriminator}.png`,
      Avatar: (userID, hash, format = 'webp', size, dynamic = false) => {
        if (dynamic) format = hash.startsWith('a_') ? 'gif' : format;
        return makeImageUrl(`${root}/avatars/${userID}/${hash}`, { format, size });
      },
      Banner: (guildID, hash, format = 'webp', size) =>
        makeImageUrl(`${root}/banners/${guildID}/${hash}`, { format, size }),
      Icon: (guildID, hash, format = 'webp', size, dynamic = false) => {
        if (dynamic) format = hash.startsWith('a_') ? 'gif' : format;
        return makeImageUrl(`${root}/icons/${guildID}/${hash}`, { format, size });
      },
      AppIcon: (clientID, hash, { format = 'webp', size } = {}) =>
        makeImageUrl(`${root}/app-icons/${clientID}/${hash}`, { size, format }),
      AppAsset: (clientID, hash, { format = 'webp', size } = {}) =>
        makeImageUrl(`${root}/app-assets/${clientID}/${hash}`, { size, format }),
      GDMIcon: (channelID, hash, format = 'webp', size) =>
        makeImageUrl(`${root}/channel-icons/${channelID}/${hash}`, { size, format }),
      Splash: (guildID, hash, format = 'webp', size) =>
        makeImageUrl(`${root}/splashes/${guildID}/${hash}`, { size, format }),
      DiscoverySplash: (guildID, hash, format = 'webp', size) =>
        makeImageUrl(`${root}/discovery-splashes/${guildID}/${hash}`, { size, format }),
      TeamIcon: (teamID, hash, { format = 'webp', size } = {}) =>
        makeImageUrl(`${root}/team-icons/${teamID}/${hash}`, { size, format }),
    };
  },
  invite: (root, code) => `${root}/${code}`,
  botGateway: '/gateway/bot',
};

/**
 * The current status of the client. Here are the available statuses:
 * * READY: 0
 * * CONNECTING: 1
 * * RECONNECTING: 2
 * * IDLE: 3
 * * NEARLY: 4
 * * DISCONNECTED: 5
 * * WAITING_FOR_GUILDS: 6
 * * IDENTIFYING: 7
 * * RESUMING: 8
 * @typedef {number} Status
 */
exports.Status = {
  READY: 0,
  CONNECTING: 1,
  RECONNECTING: 2,
  IDLE: 3,
  NEARLY: 4,
  DISCONNECTED: 5,
  WAITING_FOR_GUILDS: 6,
  IDENTIFYING: 7,
  RESUMING: 8,
};

/**
 * The current status of a voice connection. Here are the available statuses:
 * * CONNECTED: 0
 * * CONNECTING: 1
 * * AUTHENTICATING: 2
 * * RECONNECTING: 3
 * * DISCONNECTED: 4
 * @typedef {number} VoiceStatus
 */
exports.VoiceStatus = {
  CONNECTED: 0,
  CONNECTING: 1,
  AUTHENTICATING: 2,
  RECONNECTING: 3,
  DISCONNECTED: 4,
};

exports.OPCodes = {
  DISPATCH: 0,
  HEARTBEAT: 1,
  IDENTIFY: 2,
  STATUS_UPDATE: 3,
  VOICE_STATE_UPDATE: 4,
  VOICE_GUILD_PING: 5,
  RESUME: 6,
  RECONNECT: 7,
  REQUEST_GUILD_MEMBERS: 8,
  INVALID_SESSION: 9,
  HELLO: 10,
  HEARTBEAT_ACK: 11,
};

exports.VoiceOPCodes = {
  IDENTIFY: 0,
  SELECT_PROTOCOL: 1,
  READY: 2,
  HEARTBEAT: 3,
  SESSION_DESCRIPTION: 4,
  SPEAKING: 5,
  HELLO: 8,
  CLIENT_CONNECT: 12,
  CLIENT_DISCONNECT: 13,
};

exports.Events = {
  RATE_LIMIT: 'rateLimit',
  CLIENT_READY: 'ready',
  GUILD_CREATE: 'guildCreate',
  GUILD_DELETE: 'guildDelete',
  GUILD_UPDATE: 'guildUpdate',
  GUILD_UNAVAILABLE: 'guildUnavailable',
  GUILD_AVAILABLE: 'guildAvailable',
  GUILD_MEMBER_ADD: 'guildMemberAdd',
  GUILD_MEMBER_REMOVE: 'guildMemberRemove',
  GUILD_MEMBER_UPDATE: 'guildMemberUpdate',
  GUILD_MEMBER_AVAILABLE: 'guildMemberAvailable',
  GUILD_MEMBER_SPEAKING: 'guildMemberSpeaking',
  GUILD_MEMBERS_CHUNK: 'guildMembersChunk',
  GUILD_INTEGRATIONS_UPDATE: 'guildIntegrationsUpdate',
  GUILD_ROLE_CREATE: 'roleCreate',
  GUILD_ROLE_DELETE: 'roleDelete',
  INVITE_CREATE: 'inviteCreate',
  INVITE_DELETE: 'inviteDelete',
  GUILD_ROLE_UPDATE: 'roleUpdate',
  GUILD_EMOJI_CREATE: 'emojiCreate',
  GUILD_EMOJI_DELETE: 'emojiDelete',
  GUILD_EMOJI_UPDATE: 'emojiUpdate',
  GUILD_BAN_ADD: 'guildBanAdd',
  GUILD_BAN_REMOVE: 'guildBanRemove',
  CHANNEL_CREATE: 'channelCreate',
  CHANNEL_DELETE: 'channelDelete',
  CHANNEL_UPDATE: 'channelUpdate',
  CHANNEL_PINS_UPDATE: 'channelPinsUpdate',
  MESSAGE_CREATE: 'message',
  MESSAGE_DELETE: 'messageDelete',
  MESSAGE_UPDATE: 'messageUpdate',
  MESSAGE_BULK_DELETE: 'messageDeleteBulk',
  MESSAGE_REACTION_ADD: 'messageReactionAdd',
  MESSAGE_REACTION_REMOVE: 'messageReactionRemove',
  MESSAGE_REACTION_REMOVE_ALL: 'messageReactionRemoveAll',
  MESSAGE_REACTION_REMOVE_EMOJI: 'messageReactionRemoveEmoji',
  USER_UPDATE: 'userUpdate',
  PRESENCE_UPDATE: 'presenceUpdate',
  VOICE_SERVER_UPDATE: 'voiceServerUpdate',
  VOICE_STATE_UPDATE: 'voiceStateUpdate',
  VOICE_BROADCAST_SUBSCRIBE: 'subscribe',
  VOICE_BROADCAST_UNSUBSCRIBE: 'unsubscribe',
  TYPING_START: 'typingStart',
  TYPING_STOP: 'typingStop',
  WEBHOOKS_UPDATE: 'webhookUpdate',
  ERROR: 'error',
  WARN: 'warn',
  DEBUG: 'debug',
  SHARD_DISCONNECT: 'shardDisconnect',
  SHARD_ERROR: 'shardError',
  SHARD_RECONNECTING: 'shardReconnecting',
  SHARD_READY: 'shardReady',
  SHARD_RESUME: 'shardResume',
  INVALIDATED: 'invalidated',
  RAW: 'raw',
};

exports.ShardEvents = {
  CLOSE: 'close',
  DESTROYED: 'destroyed',
  INVALID_SESSION: 'invalidSession',
  READY: 'ready',
  RESUMED: 'resumed',
  ALL_READY: 'allReady',
};

/**
 * The type of Structure allowed to be a partial:
 * * USER
 * * CHANNEL (only affects DMChannels)
 * * GUILD_MEMBER
 * * MESSAGE
 * * REACTION
 * <warn>Partials require you to put checks in place when handling data, read the Partials topic listed in the
 * sidebar for more information.</warn>
 * @typedef {string} PartialType
 */
exports.PartialTypes = keyMirror(['USER', 'CHANNEL', 'GUILD_MEMBER', 'MESSAGE', 'REACTION']);

/**
 * The type of a websocket message event, e.g. `MESSAGE_CREATE`. Here are the available events:
 * * READY
 * * RESUMED
 * * GUILD_CREATE
 * * GUILD_DELETE
 * * GUILD_UPDATE
 * * INVITE_CREATE
 * * INVITE_DELETE
 * * GUILD_MEMBER_ADD
 * * GUILD_MEMBER_REMOVE
 * * GUILD_MEMBER_UPDATE
 * * GUILD_MEMBERS_CHUNK
 * * GUILD_INTEGRATIONS_UPDATE
 * * GUILD_ROLE_CREATE
 * * GUILD_ROLE_DELETE
 * * GUILD_ROLE_UPDATE
 * * GUILD_BAN_ADD
 * * GUILD_BAN_REMOVE
 * * GUILD_EMOJIS_UPDATE
 * * CHANNEL_CREATE
 * * CHANNEL_DELETE
 * * CHANNEL_UPDATE
 * * CHANNEL_PINS_UPDATE
 * * MESSAGE_CREATE
 * * MESSAGE_DELETE
 * * MESSAGE_UPDATE
 * * MESSAGE_DELETE_BULK
 * * MESSAGE_REACTION_ADD
 * * MESSAGE_REACTION_REMOVE
 * * MESSAGE_REACTION_REMOVE_ALL
 * * MESSAGE_REACTION_REMOVE_EMOJI
 * * USER_UPDATE
 * * PRESENCE_UPDATE
 * * TYPING_START
 * * VOICE_STATE_UPDATE
 * * VOICE_SERVER_UPDATE
 * * WEBHOOKS_UPDATE
 * @typedef {string} WSEventType
 */
exports.WSEvents = keyMirror([
  'READY',
  'RESUMED',
  'GUILD_CREATE',
  'GUILD_DELETE',
  'GUILD_UPDATE',
  'INVITE_CREATE',
  'INVITE_DELETE',
  'GUILD_MEMBER_ADD',
  'GUILD_MEMBER_REMOVE',
  'GUILD_MEMBER_UPDATE',
  'GUILD_MEMBERS_CHUNK',
  'GUILD_INTEGRATIONS_UPDATE',
  'GUILD_ROLE_CREATE',
  'GUILD_ROLE_DELETE',
  'GUILD_ROLE_UPDATE',
  'GUILD_BAN_ADD',
  'GUILD_BAN_REMOVE',
  'GUILD_EMOJIS_UPDATE',
  'CHANNEL_CREATE',
  'CHANNEL_DELETE',
  'CHANNEL_UPDATE',
  'CHANNEL_PINS_UPDATE',
  'MESSAGE_CREATE',
  'MESSAGE_DELETE',
  'MESSAGE_UPDATE',
  'MESSAGE_DELETE_BULK',
  'MESSAGE_REACTION_ADD',
  'MESSAGE_REACTION_REMOVE',
  'MESSAGE_REACTION_REMOVE_ALL',
  'MESSAGE_REACTION_REMOVE_EMOJI',
  'USER_UPDATE',
  'PRESENCE_UPDATE',
  'TYPING_START',
  'VOICE_STATE_UPDATE',
  'VOICE_SERVER_UPDATE',
  'WEBHOOKS_UPDATE',
]);

/**
 * The type of a message, e.g. `DEFAULT`. Here are the available types:
 * * DEFAULT
 * * RECIPIENT_ADD
 * * RECIPIENT_REMOVE
 * * CALL
 * * CHANNEL_NAME_CHANGE
 * * CHANNEL_ICON_CHANGE
 * * PINS_ADD
 * * GUILD_MEMBER_JOIN
 * * USER_PREMIUM_GUILD_SUBSCRIPTION
 * * USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1
 * * USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2
 * * USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3
 * * CHANNEL_FOLLOW_ADD
 * * GUILD_DISCOVERY_DISQUALIFIED
 * * GUILD_DISCOVERY_REQUALIFIED
 * @typedef {string} MessageType
 */
exports.MessageTypes = [
  'DEFAULT',
  'RECIPIENT_ADD',
  'RECIPIENT_REMOVE',
  'CALL',
  'CHANNEL_NAME_CHANGE',
  'CHANNEL_ICON_CHANGE',
  'PINS_ADD',
  'GUILD_MEMBER_JOIN',
  'USER_PREMIUM_GUILD_SUBSCRIPTION',
  'USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1',
  'USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2',
  'USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3',
  'CHANNEL_FOLLOW_ADD',
  null,
  'GUILD_DISCOVERY_DISQUALIFIED',
  'GUILD_DISCOVERY_REQUALIFIED',
];

/**
 * <info>Bots cannot set a `CUSTOM_STATUS`, it is only for custom statuses received from users</info>
 * The type of an activity of a users presence, e.g. `PLAYING`. Here are the available types:
 * * PLAYING
 * * STREAMING
 * * LISTENING
 * * WATCHING
 * * CUSTOM_STATUS
 * * COMPETING
 * @typedef {string} ActivityType
 */
exports.ActivityTypes = ['PLAYING', 'STREAMING', 'LISTENING', 'WATCHING', 'CUSTOM_STATUS', 'COMPETING'];

exports.ChannelTypes = {
  TEXT: 0,
  DM: 1,
  VOICE: 2,
  GROUP: 3,
  CATEGORY: 4,
  NEWS: 5,
  STORE: 6,
};

exports.ClientApplicationAssetTypes = {
  SMALL: 1,
  BIG: 2,
};

exports.Colors = {
  DEFAULT: 0x000000,
  WHITE: 0xffffff,
  AQUA: 0x1abc9c,
  GREEN: 0x2ecc71,
  BLUE: 0x3498db,
  YELLOW: 0xffff00,
  PURPLE: 0x9b59b6,
  LUMINOUS_VIVID_PINK: 0xe91e63,
  GOLD: 0xf1c40f,
  ORANGE: 0xe67e22,
  RED: 0xe74c3c,
  GREY: 0x95a5a6,
  NAVY: 0x34495e,
  DARK_AQUA: 0x11806a,
  DARK_GREEN: 0x1f8b4c,
  DARK_BLUE: 0x206694,
  DARK_PURPLE: 0x71368a,
  DARK_VIVID_PINK: 0xad1457,
  DARK_GOLD: 0xc27c0e,
  DARK_ORANGE: 0xa84300,
  DARK_RED: 0x992d22,
  DARK_GREY: 0x979c9f,
  DARKER_GREY: 0x7f8c8d,
  LIGHT_GREY: 0xbcc0c0,
  DARK_NAVY: 0x2c3e50,
  BLURPLE: 0x7289da,
  GREYPLE: 0x99aab5,
  DARK_BUT_NOT_BLACK: 0x2c2f33,
  NOT_QUITE_BLACK: 0x23272a,
};

/**
 * The value set for the explicit content filter levels for a guild:
 * * DISABLED
 * * MEMBERS_WITHOUT_ROLES
 * * ALL_MEMBERS
 * @typedef {string} ExplicitContentFilterLevel
 */
exports.ExplicitContentFilterLevels = ['DISABLED', 'MEMBERS_WITHOUT_ROLES', 'ALL_MEMBERS'];

/**
 * The value set for the verification levels for a guild:
 * * NONE
 * * LOW
 * * MEDIUM
 * * HIGH
 * * VERY_HIGH
 * @typedef {string} VerificationLevel
 */
exports.VerificationLevels = ['NONE', 'LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH'];

/**
 * An error encountered while performing an API request. Here are the potential errors:
 * * UNKNOWN_ACCOUNT
 * * UNKNOWN_APPLICATION
 * * UNKNOWN_CHANNEL
 * * UNKNOWN_GUILD
 * * UNKNOWN_INTEGRATION
 * * UNKNOWN_INVITE
 * * UNKNOWN_MEMBER
 * * UNKNOWN_MESSAGE
 * * UNKNOWN_OVERWRITE
 * * UNKNOWN_PROVIDER
 * * UNKNOWN_ROLE
 * * UNKNOWN_TOKEN
 * * UNKNOWN_USER
 * * UNKNOWN_EMOJI
 * * UNKNOWN_WEBHOOK
 * * UNKNOWN_BAN
 * * UNKNOWN_GUILD_TEMPLATE
 * * BOT_PROHIBITED_ENDPOINT
 * * BOT_ONLY_ENDPOINT
 * * CHANNEL_HIT_WRITE_RATELIMIT
 * * MAXIMUM_GUILDS
 * * MAXIMUM_FRIENDS
 * * MAXIMUM_PINS
 * * MAXIMUM_ROLES
 * * MAXIMUM_WEBHOOKS
 * * MAXIMUM_REACTIONS
 * * MAXIMUM_CHANNELS
 * * MAXIMUM_ATTACHMENTS
 * * MAXIMUM_INVITES
 * * GUILD_ALREADY_HAS_TEMPLATE
 * * UNAUTHORIZED
 * * ACCOUNT_VERIFICATION_REQUIRED
 * * REQUEST_ENTITY_TOO_LARGE
 * * FEATURE_TEMPORARILY_DISABLED
 * * USER_BANNED
 * * ALREADY_CROSSPOSTED
 * * MISSING_ACCESS
 * * INVALID_ACCOUNT_TYPE
 * * CANNOT_EXECUTE_ON_DM
 * * EMBED_DISABLED
 * * CANNOT_EDIT_MESSAGE_BY_OTHER
 * * CANNOT_SEND_EMPTY_MESSAGE
 * * CANNOT_MESSAGE_USER
 * * CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL
 * * CHANNEL_VERIFICATION_LEVEL_TOO_HIGH
 * * OAUTH2_APPLICATION_BOT_ABSENT
 * * MAXIMUM_OAUTH2_APPLICATIONS
 * * INVALID_OAUTH_STATE
 * * MISSING_PERMISSIONS
 * * INVALID_AUTHENTICATION_TOKEN
 * * NOTE_TOO_LONG
 * * INVALID_BULK_DELETE_QUANTITY
 * * CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL
 * * INVALID_OR_TAKEN_INVITE_CODE
 * * CANNOT_EXECUTE_ON_SYSTEM_MESSAGE
 * * INVALID_OAUTH_TOKEN
 * * BULK_DELETE_MESSAGE_TOO_OLD
 * * INVALID_FORM_BODY
 * * INVITE_ACCEPTED_TO_GUILD_NOT_CONTAINING_BOT
 * * INVALID_API_VERSION
 * * CANNOT_DELETE_COMMUNITY_REQUIRED_CHANNEL
 * * REACTION_BLOCKED
 * * RESOURCE_OVERLOADED
 * @typedef {string} APIError
 */
exports.APIErrors = {
  UNKNOWN_ACCOUNT: 10001,
  UNKNOWN_APPLICATION: 10002,
  UNKNOWN_CHANNEL: 10003,
  UNKNOWN_GUILD: 10004,
  UNKNOWN_INTEGRATION: 10005,
  UNKNOWN_INVITE: 10006,
  UNKNOWN_MEMBER: 10007,
  UNKNOWN_MESSAGE: 10008,
  UNKNOWN_OVERWRITE: 10009,
  UNKNOWN_PROVIDER: 10010,
  UNKNOWN_ROLE: 10011,
  UNKNOWN_TOKEN: 10012,
  UNKNOWN_USER: 10013,
  UNKNOWN_EMOJI: 10014,
  UNKNOWN_WEBHOOK: 10015,
  UNKNOWN_BAN: 10026,
  UNKNOWN_GUILD_TEMPLATE: 10057,
  BOT_PROHIBITED_ENDPOINT: 20001,
  BOT_ONLY_ENDPOINT: 20002,
  CHANNEL_HIT_WRITE_RATELIMIT: 20028,
  MAXIMUM_GUILDS: 30001,
  MAXIMUM_FRIENDS: 30002,
  MAXIMUM_PINS: 30003,
  MAXIMUM_ROLES: 30005,
  MAXIMUM_WEBHOOKS: 30007,
  MAXIMUM_REACTIONS: 30010,
  MAXIMUM_CHANNELS: 30013,
  MAXIMUM_ATTACHMENTS: 30015,
  MAXIMUM_INVITES: 30016,
  GUILD_ALREADY_HAS_TEMPLATE: 30031,
  UNAUTHORIZED: 40001,
  ACCOUNT_VERIFICATION_REQUIRED: 40002,
  REQUEST_ENTITY_TOO_LARGE: 40005,
  FEATURE_TEMPORARILY_DISABLED: 40006,
  USER_BANNED: 40007,
  ALREADY_CROSSPOSTED: 40033,
  MISSING_ACCESS: 50001,
  INVALID_ACCOUNT_TYPE: 50002,
  CANNOT_EXECUTE_ON_DM: 50003,
  EMBED_DISABLED: 50004,
  CANNOT_EDIT_MESSAGE_BY_OTHER: 50005,
  CANNOT_SEND_EMPTY_MESSAGE: 50006,
  CANNOT_MESSAGE_USER: 50007,
  CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL: 50008,
  CHANNEL_VERIFICATION_LEVEL_TOO_HIGH: 50009,
  OAUTH2_APPLICATION_BOT_ABSENT: 50010,
  MAXIMUM_OAUTH2_APPLICATIONS: 50011,
  INVALID_OAUTH_STATE: 50012,
  MISSING_PERMISSIONS: 50013,
  INVALID_AUTHENTICATION_TOKEN: 50014,
  NOTE_TOO_LONG: 50015,
  INVALID_BULK_DELETE_QUANTITY: 50016,
  CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL: 50019,
  INVALID_OR_TAKEN_INVITE_CODE: 50020,
  CANNOT_EXECUTE_ON_SYSTEM_MESSAGE: 50021,
  INVALID_OAUTH_TOKEN: 50025,
  BULK_DELETE_MESSAGE_TOO_OLD: 50034,
  INVALID_FORM_BODY: 50035,
  INVITE_ACCEPTED_TO_GUILD_NOT_CONTAINING_BOT: 50036,
  INVALID_API_VERSION: 50041,
  CANNOT_DELETE_COMMUNITY_REQUIRED_CHANNEL: 50074,
  REACTION_BLOCKED: 90001,
  RESOURCE_OVERLOADED: 130000,
};

/**
 * The value set for a guild's default message notifications, e.g. `ALL`. Here are the available types:
 * * ALL
 * * MENTIONS
 * @typedef {string} DefaultMessageNotifications
 */
exports.DefaultMessageNotifications = ['ALL', 'MENTIONS'];

/**
 * The value set for a team members's membership state:
 * * INVITED
 * * ACCEPTED
 * @typedef {string} MembershipStates
 */
exports.MembershipStates = [
  // They start at 1
  null,
  'INVITED',
  'ACCEPTED',
];

/**
 * The value set for a webhook's type:
 * * Incoming
 * * Channel Follower
 * @typedef {string} WebhookTypes
 */
exports.WebhookTypes = [
  // They start at 1
  null,
  'Incoming',
  'Channel Follower',
];

function keyMirror(arr) {
  let tmp = Object.create(null);
  for (const value of arr) tmp[value] = value;
  return tmp;
}


/***/ }),

/***/ "./node_modules/discord.js/src/util/DataResolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/discord.js/src/util/DataResolver.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "?65c5");
const path = __webpack_require__(/*! path */ "?0f27");
const stream = __webpack_require__(/*! stream */ "?cc48");
const fetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
const { Error: DiscordError, TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const { browser } = __webpack_require__(/*! ../util/Constants */ "./node_modules/discord.js/src/util/Constants.js");
const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

/**
 * The DataResolver identifies different objects and tries to resolve a specific piece of information from them.
 * @private
 */
class DataResolver {
  constructor() {
    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
  }

  /**
   * Data that can be resolved to give an invite code. This can be:
   * * An invite code
   * * An invite URL
   * @typedef {string} InviteResolvable
   */

  /**
   * Data that can be resolved to give an template code. This can be:
   * * A template code
   * * A template URL
   * @typedef {string} GuildTemplateResolvable
   */

  /**
   * Resolves the string to a code based on the passed regex.
   * @param {string} data The string to resolve
   * @param {RegExp} regex The RegExp used to extract the code
   * @returns {string}
   */
  static resolveCode(data, regex) {
    const match = regex.exec(data);
    return match ? match[1] || data : data;
  }

  /**
   * Resolves InviteResolvable to an invite code.
   * @param {InviteResolvable} data The invite resolvable to resolve
   * @returns {string}
   */
  static resolveInviteCode(data) {
    return this.resolveCode(data, /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/([\w-]{2,255})/i);
  }

  /**
   * Resolves GuildTemplateResolvable to a template code.
   * @param {GuildTemplateResolvable} data The template resolvable to resolve
   * @returns {string}
   */
  static resolveGuildTemplateCode(data) {
    return this.resolveCode(data, /discord(?:app)?\.(?:com\/template|new)\/([\w-]{2,255})/i);
  }

  /**
   * Resolves a Base64Resolvable, a string, or a BufferResolvable to a Base 64 image.
   * @param {BufferResolvable|Base64Resolvable} image The image to be resolved
   * @returns {Promise<?string>}
   */
  static async resolveImage(image) {
    if (!image) return null;
    if (typeof image === 'string' && image.startsWith('data:')) {
      return image;
    }
    const file = await this.resolveFileAsBuffer(image);
    return DataResolver.resolveBase64(file);
  }

  /**
   * Data that resolves to give a Base64 string, typically for image uploading. This can be:
   * * A Buffer
   * * A base64 string
   * @typedef {Buffer|string} Base64Resolvable
   */

  /**
   * Resolves a Base64Resolvable to a Base 64 image.
   * @param {Base64Resolvable} data The base 64 resolvable you want to resolve
   * @returns {?string}
   */
  static resolveBase64(data) {
    if (Buffer.isBuffer(data)) return `data:image/jpg;base64,${data.toString('base64')}`;
    return data;
  }

  /**
   * Data that can be resolved to give a Buffer. This can be:
   * * A Buffer
   * * The path to a local file
   * * A URL
   * @typedef {string|Buffer} BufferResolvable
   */

  /**
   * @external Stream
   * @see {@link https://nodejs.org/api/stream.html}
   */

  /**
   * Resolves a BufferResolvable to a Buffer or a Stream.
   * @param {BufferResolvable|Stream} resource The buffer or stream resolvable to resolve
   * @returns {Promise<Buffer|Stream>}
   */
  static async resolveFile(resource) {
    if (!browser && Buffer.isBuffer(resource)) return resource;
    if (browser && resource instanceof ArrayBuffer) return Util.convertToBuffer(resource);
    // eslint-disable-next-line no-undef
    if (browser && resource instanceof Blob) return resource;
    if (resource instanceof stream.Readable) return resource;

    if (typeof resource === 'string') {
      if (/^https?:\/\//.test(resource)) {
        const res = await fetch(resource);
        return browser ? res.blob() : res.body;
      } else if (!browser) {
        return new Promise((resolve, reject) => {
          const file = path.resolve(resource);
          fs.stat(file, (err, stats) => {
            if (err) return reject(err);
            if (!stats.isFile()) return reject(new DiscordError('FILE_NOT_FOUND', file));
            return resolve(fs.createReadStream(file));
          });
        });
      }
    }

    throw new TypeError('REQ_RESOURCE_TYPE');
  }

  /**
   * Resolves a BufferResolvable to a Buffer.
   * @param {BufferResolvable|Stream} resource The buffer or stream resolvable to resolve
   * @returns {Promise<Buffer>}
   */
  static async resolveFileAsBuffer(resource) {
    const file = await this.resolveFile(resource);
    if (Buffer.isBuffer(file)) return file;

    const buffers = [];
    for await (const data of file) buffers.push(data);
    return Buffer.concat(buffers);
  }
}

module.exports = DataResolver;


/***/ }),

/***/ "./node_modules/discord.js/src/util/Intents.js":
/*!*****************************************************!*\
  !*** ./node_modules/discord.js/src/util/Intents.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BitField = __webpack_require__(/*! ./BitField */ "./node_modules/discord.js/src/util/BitField.js");

/**
 * Data structure that makes it easy to calculate intents.
 * @extends {BitField}
 */
class Intents extends BitField {}

/**
 * @name Intents
 * @kind constructor
 * @memberof Intents
 * @param {IntentsResolvable} [bits=0] Bit(s) to read from
 */

/**
 * Data that can be resolved to give a permission number. This can be:
 * * A string (see {@link Intents.FLAGS})
 * * An intents flag
 * * An instance of Intents
 * * An array of IntentsResolvable
 * @typedef {string|number|Intents|IntentsResolvable[]} IntentsResolvable
 */

/**
 * Numeric websocket intents. All available properties:
 * * `GUILDS`
 * * `GUILD_MEMBERS`
 * * `GUILD_BANS`
 * * `GUILD_EMOJIS`
 * * `GUILD_INTEGRATIONS`
 * * `GUILD_WEBHOOKS`
 * * `GUILD_INVITES`
 * * `GUILD_VOICE_STATES`
 * * `GUILD_PRESENCES`
 * * `GUILD_MESSAGES`
 * * `GUILD_MESSAGE_REACTIONS`
 * * `GUILD_MESSAGE_TYPING`
 * * `DIRECT_MESSAGES`
 * * `DIRECT_MESSAGE_REACTIONS`
 * * `DIRECT_MESSAGE_TYPING`
 * @type {Object}
 * @see {@link https://discord.com/developers/docs/topics/gateway#list-of-intents}
 */
Intents.FLAGS = {
  GUILDS: 1 << 0,
  GUILD_MEMBERS: 1 << 1,
  GUILD_BANS: 1 << 2,
  GUILD_EMOJIS: 1 << 3,
  GUILD_INTEGRATIONS: 1 << 4,
  GUILD_WEBHOOKS: 1 << 5,
  GUILD_INVITES: 1 << 6,
  GUILD_VOICE_STATES: 1 << 7,
  GUILD_PRESENCES: 1 << 8,
  GUILD_MESSAGES: 1 << 9,
  GUILD_MESSAGE_REACTIONS: 1 << 10,
  GUILD_MESSAGE_TYPING: 1 << 11,
  DIRECT_MESSAGES: 1 << 12,
  DIRECT_MESSAGE_REACTIONS: 1 << 13,
  DIRECT_MESSAGE_TYPING: 1 << 14,
};

/**
 * Bitfield representing all privileged intents
 * @type {number}
 * @see {@link https://discord.com/developers/docs/topics/gateway#privileged-intents}
 */
Intents.PRIVILEGED = Intents.FLAGS.GUILD_MEMBERS | Intents.FLAGS.GUILD_PRESENCES;

/**
 * Bitfield representing all intents combined
 * @type {number}
 */
Intents.ALL = Object.values(Intents.FLAGS).reduce((acc, p) => acc | p, 0);

/**
 * Bitfield representing all non-privileged intents
 * @type {number}
 */
Intents.NON_PRIVILEGED = Intents.ALL & ~Intents.PRIVILEGED;

module.exports = Intents;


/***/ }),

/***/ "./node_modules/discord.js/src/util/LimitedCollection.js":
/*!***************************************************************!*\
  !*** ./node_modules/discord.js/src/util/LimitedCollection.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Collection = __webpack_require__(/*! ./Collection.js */ "./node_modules/discord.js/src/util/Collection.js");

/**
 * A Collection which holds a max amount of entries. The first key is deleted if the Collection has
 * reached max size.
 * @extends {Collection}
 * @param {number} [maxSize=0] The maximum size of the Collection
 * @param {Iterable} [iterable=null] Optional entries passed to the Map constructor.
 * @private
 */
class LimitedCollection extends Collection {
  constructor(maxSize = 0, iterable = null) {
    super(iterable);
    /**
     * The max size of the Collection.
     * @type {number}
     */
    this.maxSize = maxSize;
  }

  set(key, value) {
    if (this.maxSize === 0) return this;
    if (this.size >= this.maxSize && !this.has(key)) this.delete(this.firstKey());
    return super.set(key, value);
  }

  static get [Symbol.species]() {
    return Collection;
  }
}

module.exports = LimitedCollection;


/***/ }),

/***/ "./node_modules/discord.js/src/util/MessageFlags.js":
/*!**********************************************************!*\
  !*** ./node_modules/discord.js/src/util/MessageFlags.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BitField = __webpack_require__(/*! ./BitField */ "./node_modules/discord.js/src/util/BitField.js");

/**
 * Data structure that makes it easy to interact with an {@link Message#flags} bitfield.
 * @extends {BitField}
 */
class MessageFlags extends BitField {}

/**
 * @name MessageFlags
 * @kind constructor
 * @memberof MessageFlags
 * @param {BitFieldResolvable} [bits=0] Bit(s) to read from
 */

/**
 * Numeric message flags. All available properties:
 * * `CROSSPOSTED`
 * * `IS_CROSSPOST`
 * * `SUPPRESS_EMBEDS`
 * * `SOURCE_MESSAGE_DELETED`
 * * `URGENT`
 * @type {Object}
 * @see {@link https://discord.com/developers/docs/resources/channel#message-object-message-flags}
 */
MessageFlags.FLAGS = {
  CROSSPOSTED: 1 << 0,
  IS_CROSSPOST: 1 << 1,
  SUPPRESS_EMBEDS: 1 << 2,
  SOURCE_MESSAGE_DELETED: 1 << 3,
  URGENT: 1 << 4,
};

module.exports = MessageFlags;


/***/ }),

/***/ "./node_modules/discord.js/src/util/Permissions.js":
/*!*********************************************************!*\
  !*** ./node_modules/discord.js/src/util/Permissions.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BitField = __webpack_require__(/*! ./BitField */ "./node_modules/discord.js/src/util/BitField.js");

/**
 * Data structure that makes it easy to interact with a permission bitfield. All {@link GuildMember}s have a set of
 * permissions in their guild, and each channel in the guild may also have {@link PermissionOverwrites} for the member
 * that override their default permissions.
 * @extends {BitField}
 */
class Permissions extends BitField {
  /**
   * @name Permissions
   * @kind constructor
   * @memberof Permissions
   * @param {PermissionResolvable} [bits=0] Bit(s) to read from
   */

  /**
   * Data that can be resolved to give a permission number. This can be:
   * * A string (see {@link Permissions.FLAGS})
   * * A permission number
   * * An instance of Permissions
   * * An Array of PermissionResolvable
   * @typedef {string|number|Permissions|PermissionResolvable[]} PermissionResolvable
   */

  /**
   * Checks whether the bitfield has a permission, or any of multiple permissions.
   * @param {PermissionResolvable} permission Permission(s) to check for
   * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
   * @returns {boolean}
   */
  any(permission, checkAdmin = true) {
    return (checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR)) || super.any(permission);
  }

  /**
   * Checks whether the bitfield has a permission, or multiple permissions.
   * @param {PermissionResolvable} permission Permission(s) to check for
   * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
   * @returns {boolean}
   */
  has(permission, checkAdmin = true) {
    return (checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR)) || super.has(permission);
  }
}

/**
 * Numeric permission flags. All available properties:
 * * `ADMINISTRATOR` (implicitly has *all* permissions, and bypasses all channel overwrites)
 * * `CREATE_INSTANT_INVITE` (create invitations to the guild)
 * * `KICK_MEMBERS`
 * * `BAN_MEMBERS`
 * * `MANAGE_CHANNELS` (edit and reorder channels)
 * * `MANAGE_GUILD` (edit the guild information, region, etc.)
 * * `ADD_REACTIONS` (add new reactions to messages)
 * * `VIEW_AUDIT_LOG`
 * * `PRIORITY_SPEAKER`
 * * `STREAM`
 * * `VIEW_CHANNEL`
 * * `SEND_MESSAGES`
 * * `SEND_TTS_MESSAGES`
 * * `MANAGE_MESSAGES` (delete messages and reactions)
 * * `EMBED_LINKS` (links posted will have a preview embedded)
 * * `ATTACH_FILES`
 * * `READ_MESSAGE_HISTORY` (view messages that were posted prior to opening Discord)
 * * `MENTION_EVERYONE`
 * * `USE_EXTERNAL_EMOJIS` (use emojis from different guilds)
 * * `VIEW_GUILD_INSIGHTS`
 * * `CONNECT` (connect to a voice channel)
 * * `SPEAK` (speak in a voice channel)
 * * `MUTE_MEMBERS` (mute members across all voice channels)
 * * `DEAFEN_MEMBERS` (deafen members across all voice channels)
 * * `MOVE_MEMBERS` (move members between voice channels)
 * * `USE_VAD` (use voice activity detection)
 * * `CHANGE_NICKNAME`
 * * `MANAGE_NICKNAMES` (change other members' nicknames)
 * * `MANAGE_ROLES`
 * * `MANAGE_WEBHOOKS`
 * * `MANAGE_EMOJIS`
 * @type {Object}
 * @see {@link https://discord.com/developers/docs/topics/permissions}
 */
Permissions.FLAGS = {
  CREATE_INSTANT_INVITE: 1 << 0,
  KICK_MEMBERS: 1 << 1,
  BAN_MEMBERS: 1 << 2,
  ADMINISTRATOR: 1 << 3,
  MANAGE_CHANNELS: 1 << 4,
  MANAGE_GUILD: 1 << 5,
  ADD_REACTIONS: 1 << 6,
  VIEW_AUDIT_LOG: 1 << 7,
  PRIORITY_SPEAKER: 1 << 8,
  STREAM: 1 << 9,
  VIEW_CHANNEL: 1 << 10,
  SEND_MESSAGES: 1 << 11,
  SEND_TTS_MESSAGES: 1 << 12,
  MANAGE_MESSAGES: 1 << 13,
  EMBED_LINKS: 1 << 14,
  ATTACH_FILES: 1 << 15,
  READ_MESSAGE_HISTORY: 1 << 16,
  MENTION_EVERYONE: 1 << 17,
  USE_EXTERNAL_EMOJIS: 1 << 18,
  VIEW_GUILD_INSIGHTS: 1 << 19,
  CONNECT: 1 << 20,
  SPEAK: 1 << 21,
  MUTE_MEMBERS: 1 << 22,
  DEAFEN_MEMBERS: 1 << 23,
  MOVE_MEMBERS: 1 << 24,
  USE_VAD: 1 << 25,
  CHANGE_NICKNAME: 1 << 26,
  MANAGE_NICKNAMES: 1 << 27,
  MANAGE_ROLES: 1 << 28,
  MANAGE_WEBHOOKS: 1 << 29,
  MANAGE_EMOJIS: 1 << 30,
};

/**
 * Bitfield representing every permission combined
 * @type {number}
 */
Permissions.ALL = Object.values(Permissions.FLAGS).reduce((all, p) => all | p, 0);

/**
 * Bitfield representing the default permissions for users
 * @type {number}
 */
Permissions.DEFAULT = 104324673;

module.exports = Permissions;


/***/ }),

/***/ "./node_modules/discord.js/src/util/Snowflake.js":
/*!*******************************************************!*\
  !*** ./node_modules/discord.js/src/util/Snowflake.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Util = __webpack_require__(/*! ../util/Util */ "./node_modules/discord.js/src/util/Util.js");

// Discord epoch (2015-01-01T00:00:00.000Z)
const EPOCH = 1420070400000;
let INCREMENT = 0;

/**
 * A container for useful snowflake-related methods.
 */
class SnowflakeUtil {
  constructor() {
    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
  }

  /**
   * A Twitter snowflake, except the epoch is 2015-01-01T00:00:00.000Z
   * ```
   * If we have a snowflake '266241948824764416' we can represent it as binary:
   *
   * 64                                          22     17     12          0
   *  000000111011000111100001101001000101000000  00001  00000  000000000000
   *       number of ms since Discord epoch       worker  pid    increment
   * ```
   * @typedef {string} Snowflake
   */

  /**
   * Generates a Discord snowflake.
   * <info>This hardcodes the worker ID as 1 and the process ID as 0.</info>
   * @param {number|Date} [timestamp=Date.now()] Timestamp or date of the snowflake to generate
   * @returns {Snowflake} The generated snowflake
   */
  static generate(timestamp = Date.now()) {
    if (timestamp instanceof Date) timestamp = timestamp.getTime();
    if (typeof timestamp !== 'number' || isNaN(timestamp)) {
      throw new TypeError(
        `"timestamp" argument must be a number (received ${isNaN(timestamp) ? 'NaN' : typeof timestamp})`,
      );
    }
    if (INCREMENT >= 4095) INCREMENT = 0;
    const BINARY = `${(timestamp - EPOCH).toString(2).padStart(42, '0')}0000100000${(INCREMENT++)
      .toString(2)
      .padStart(12, '0')}`;
    return Util.binaryToID(BINARY);
  }

  /**
   * A deconstructed snowflake.
   * @typedef {Object} DeconstructedSnowflake
   * @property {number} timestamp Timestamp the snowflake was created
   * @property {Date} date Date the snowflake was created
   * @property {number} workerID Worker ID in the snowflake
   * @property {number} processID Process ID in the snowflake
   * @property {number} increment Increment in the snowflake
   * @property {string} binary Binary representation of the snowflake
   */

  /**
   * Deconstructs a Discord snowflake.
   * @param {Snowflake} snowflake Snowflake to deconstruct
   * @returns {DeconstructedSnowflake} Deconstructed snowflake
   */
  static deconstruct(snowflake) {
    const BINARY = Util.idToBinary(snowflake).toString(2).padStart(64, '0');
    const res = {
      timestamp: parseInt(BINARY.substring(0, 42), 2) + EPOCH,
      workerID: parseInt(BINARY.substring(42, 47), 2),
      processID: parseInt(BINARY.substring(47, 52), 2),
      increment: parseInt(BINARY.substring(52, 64), 2),
      binary: BINARY,
    };
    Object.defineProperty(res, 'date', {
      get: function get() {
        return new Date(this.timestamp);
      },
      enumerable: true,
    });
    return res;
  }

  /**
   * Discord's epoch value (2015-01-01T00:00:00.000Z).
   * @type {number}
   * @readonly
   */
  static get EPOCH() {
    return EPOCH;
  }
}

module.exports = SnowflakeUtil;


/***/ }),

/***/ "./node_modules/discord.js/src/util/Speaking.js":
/*!******************************************************!*\
  !*** ./node_modules/discord.js/src/util/Speaking.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BitField = __webpack_require__(/*! ./BitField */ "./node_modules/discord.js/src/util/BitField.js");

/**
 * Data structure that makes it easy to interact with a {@link VoiceConnection#speaking}
 * and {@link guildMemberSpeaking} event bitfields.
 * @extends {BitField}
 */
class Speaking extends BitField {}

/**
 * @name Speaking
 * @kind constructor
 * @memberof Speaking
 * @param {BitFieldResolvable} [bits=0] Bit(s) to read from
 */

/**
 * Numeric speaking flags. All available properties:
 * * `SPEAKING`
 * * `SOUNDSHARE`
 * * `PRIORITY_SPEAKING`
 * @type {Object}
 * @see {@link https://discord.com/developers/docs/topics/voice-connections#speaking}
 */
Speaking.FLAGS = {
  SPEAKING: 1 << 0,
  SOUNDSHARE: 1 << 1,
  PRIORITY_SPEAKING: 1 << 2,
};

module.exports = Speaking;


/***/ }),

/***/ "./node_modules/discord.js/src/util/Structures.js":
/*!********************************************************!*\
  !*** ./node_modules/discord.js/src/util/Structures.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * An extendable structure:
 * * **`GuildEmoji`**
 * * **`DMChannel`**
 * * **`TextChannel`**
 * * **`VoiceChannel`**
 * * **`CategoryChannel`**
 * * **`NewsChannel`**
 * * **`StoreChannel`**
 * * **`GuildMember`**
 * * **`Guild`**
 * * **`Message`**
 * * **`MessageReaction`**
 * * **`Presence`**
 * * **`ClientPresence`**
 * * **`VoiceState`**
 * * **`Role`**
 * * **`User`**
 * @typedef {string} ExtendableStructure
 */

/**
 * Allows for the extension of built-in Discord.js structures that are instantiated by {@link BaseManager Managers}.
 */
class Structures {
  constructor() {
    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
  }

  /**
   * Retrieves a structure class.
   * @param {string} structure Name of the structure to retrieve
   * @returns {Function}
   */
  static get(structure) {
    if (typeof structure === 'string') return structures[structure];
    throw new TypeError(`"structure" argument must be a string (received ${typeof structure})`);
  }

  /**
   * Extends a structure.
   * <warn> Make sure to extend all structures before instantiating your client.
   * Extending after doing so may not work as expected. </warn>
   * @param {ExtendableStructure} structure Name of the structure class to extend
   * @param {Function} extender Function that takes the base class to extend as its only parameter and returns the
   * extended class/prototype
   * @returns {Function} Extended class/prototype returned from the extender
   * @example
   * const { Structures } = require('discord.js');
   *
   * Structures.extend('Guild', Guild => {
   *   class CoolGuild extends Guild {
   *     constructor(client, data) {
   *       super(client, data);
   *       this.cool = true;
   *     }
   *   }
   *
   *   return CoolGuild;
   * });
   */
  static extend(structure, extender) {
    if (!structures[structure]) throw new RangeError(`"${structure}" is not a valid extensible structure.`);
    if (typeof extender !== 'function') {
      const received = `(received ${typeof extender})`;
      throw new TypeError(
        `"extender" argument must be a function that returns the extended structure class/prototype ${received}.`,
      );
    }

    const extended = extender(structures[structure]);
    if (typeof extended !== 'function') {
      const received = `(received ${typeof extended})`;
      throw new TypeError(`The extender function must return the extended structure class/prototype ${received}.`);
    }

    if (!(extended.prototype instanceof structures[structure])) {
      const prototype = Object.getPrototypeOf(extended);
      const received = `${extended.name || 'unnamed'}${prototype.name ? ` extends ${prototype.name}` : ''}`;
      throw new Error(
        'The class/prototype returned from the extender function must extend the existing structure class/prototype' +
          ` (received function ${received}; expected extension of ${structures[structure].name}).`,
      );
    }

    structures[structure] = extended;
    return extended;
  }
}

const structures = {
  GuildEmoji: __webpack_require__(/*! ../structures/GuildEmoji */ "./node_modules/discord.js/src/structures/GuildEmoji.js"),
  DMChannel: __webpack_require__(/*! ../structures/DMChannel */ "./node_modules/discord.js/src/structures/DMChannel.js"),
  TextChannel: __webpack_require__(/*! ../structures/TextChannel */ "./node_modules/discord.js/src/structures/TextChannel.js"),
  VoiceChannel: __webpack_require__(/*! ../structures/VoiceChannel */ "./node_modules/discord.js/src/structures/VoiceChannel.js"),
  CategoryChannel: __webpack_require__(/*! ../structures/CategoryChannel */ "./node_modules/discord.js/src/structures/CategoryChannel.js"),
  NewsChannel: __webpack_require__(/*! ../structures/NewsChannel */ "./node_modules/discord.js/src/structures/NewsChannel.js"),
  StoreChannel: __webpack_require__(/*! ../structures/StoreChannel */ "./node_modules/discord.js/src/structures/StoreChannel.js"),
  GuildMember: __webpack_require__(/*! ../structures/GuildMember */ "./node_modules/discord.js/src/structures/GuildMember.js"),
  Guild: __webpack_require__(/*! ../structures/Guild */ "./node_modules/discord.js/src/structures/Guild.js"),
  Message: __webpack_require__(/*! ../structures/Message */ "./node_modules/discord.js/src/structures/Message.js"),
  MessageReaction: __webpack_require__(/*! ../structures/MessageReaction */ "./node_modules/discord.js/src/structures/MessageReaction.js"),
  Presence: __webpack_require__(/*! ../structures/Presence */ "./node_modules/discord.js/src/structures/Presence.js").Presence,
  ClientPresence: __webpack_require__(/*! ../structures/ClientPresence */ "./node_modules/discord.js/src/structures/ClientPresence.js"),
  VoiceState: __webpack_require__(/*! ../structures/VoiceState */ "./node_modules/discord.js/src/structures/VoiceState.js"),
  Role: __webpack_require__(/*! ../structures/Role */ "./node_modules/discord.js/src/structures/Role.js"),
  User: __webpack_require__(/*! ../structures/User */ "./node_modules/discord.js/src/structures/User.js"),
};

module.exports = Structures;


/***/ }),

/***/ "./node_modules/discord.js/src/util/SystemChannelFlags.js":
/*!****************************************************************!*\
  !*** ./node_modules/discord.js/src/util/SystemChannelFlags.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BitField = __webpack_require__(/*! ./BitField */ "./node_modules/discord.js/src/util/BitField.js");

/**
 * Data structure that makes it easy to interact with a {@link Guild#systemChannelFlags} bitfield.
 * <info>Note that all event message types are enabled by default,
 * and by setting their corresponding flags you are disabling them</info>
 * @extends {BitField}
 */
class SystemChannelFlags extends BitField {}

/**
 * @name SystemChannelFlags
 * @kind constructor
 * @memberof SystemChannelFlags
 * @param {SystemChannelFlagsResolvable} [bits=0] Bit(s) to read from
 */

/**
 * Data that can be resolved to give a sytem channel flag bitfield. This can be:
 * * A string (see {@link SystemChannelFlags.FLAGS})
 * * A sytem channel flag
 * * An instance of SystemChannelFlags
 * * An Array of SystemChannelFlagsResolvable
 * @typedef {string|number|SystemChannelFlags|SystemChannelFlagsResolvable[]} SystemChannelFlagsResolvable
 */

/**
 * Numeric system channel flags. All available properties:
 * * `WELCOME_MESSAGE_DISABLED`
 * * `BOOST_MESSAGE_DISABLED`
 * @type {Object}
 */
SystemChannelFlags.FLAGS = {
  WELCOME_MESSAGE_DISABLED: 1 << 0,
  BOOST_MESSAGE_DISABLED: 1 << 1,
};

module.exports = SystemChannelFlags;


/***/ }),

/***/ "./node_modules/discord.js/src/util/UserFlags.js":
/*!*******************************************************!*\
  !*** ./node_modules/discord.js/src/util/UserFlags.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BitField = __webpack_require__(/*! ./BitField */ "./node_modules/discord.js/src/util/BitField.js");

/**
 * Data structure that makes it easy to interact with a {@link User#flags} bitfield.
 * @extends {BitField}
 */
class UserFlags extends BitField {}

/**
 * @name UserFlags
 * @kind constructor
 * @memberof UserFlags
 * @param {BitFieldResolvable} [bits=0] Bit(s) to read from
 */

/**
 * Numeric user flags. All available properties:
 * * `DISCORD_EMPLOYEE`
 * * `PARTNERED_SERVER_OWNER`
 * * `DISCORD_PARTNER` **(deprecated)**
 * * `HYPESQUAD_EVENTS`
 * * `BUGHUNTER_LEVEL_1`
 * * `HOUSE_BRAVERY`
 * * `HOUSE_BRILLIANCE`
 * * `HOUSE_BALANCE`
 * * `EARLY_SUPPORTER`
 * * `TEAM_USER`
 * * `SYSTEM`
 * * `BUGHUNTER_LEVEL_2`
 * * `VERIFIED_BOT`
 * * `EARLY_VERIFIED_BOT_DEVELOPER`
 * * `VERIFIED_DEVELOPER` **(deprecated)**
 * @type {Object}
 * @see {@link https://discord.com/developers/docs/resources/user#user-object-user-flags}
 */
UserFlags.FLAGS = {
  DISCORD_EMPLOYEE: 1 << 0,
  PARTNERED_SERVER_OWNER: 1 << 1,
  DISCORD_PARTNER: 1 << 1,
  HYPESQUAD_EVENTS: 1 << 2,
  BUGHUNTER_LEVEL_1: 1 << 3,
  HOUSE_BRAVERY: 1 << 6,
  HOUSE_BRILLIANCE: 1 << 7,
  HOUSE_BALANCE: 1 << 8,
  EARLY_SUPPORTER: 1 << 9,
  TEAM_USER: 1 << 10,
  SYSTEM: 1 << 12,
  BUGHUNTER_LEVEL_2: 1 << 14,
  VERIFIED_BOT: 1 << 16,
  EARLY_VERIFIED_DEVELOPER: 1 << 17,
  VERIFIED_DEVELOPER: 1 << 17,
};

module.exports = UserFlags;


/***/ }),

/***/ "./node_modules/discord.js/src/util/Util.js":
/*!**************************************************!*\
  !*** ./node_modules/discord.js/src/util/Util.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { parse } = __webpack_require__(/*! path */ "?0f27");
const fetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
const { Colors, DefaultOptions, Endpoints } = __webpack_require__(/*! ./Constants */ "./node_modules/discord.js/src/util/Constants.js");
const { Error: DiscordError, RangeError, TypeError } = __webpack_require__(/*! ../errors */ "./node_modules/discord.js/src/errors/index.js");
const has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);
const isObject = d => typeof d === 'object' && d !== null;

/**
 * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.
 */
class Util {
  constructor() {
    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
  }

  /**
   * Flatten an object. Any properties that are collections will get converted to an array of keys.
   * @param {Object} obj The object to flatten.
   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.
   * @returns {Object}
   */
  static flatten(obj, ...props) {
    if (!isObject(obj)) return obj;

    const objProps = Object.keys(obj)
      .filter(k => !k.startsWith('_'))
      .map(k => ({ [k]: true }));

    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);

    const out = {};

    for (let [prop, newProp] of Object.entries(props)) {
      if (!newProp) continue;
      newProp = newProp === true ? prop : newProp;

      const element = obj[prop];
      const elemIsObj = isObject(element);
      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;

      // If it's a Collection, make the array of keys
      if (element instanceof __webpack_require__(/*! ./Collection */ "./node_modules/discord.js/src/util/Collection.js")) out[newProp] = Array.from(element.keys());
      // If the valueOf is a Collection, use its array of keys
      else if (valueOf instanceof __webpack_require__(/*! ./Collection */ "./node_modules/discord.js/src/util/Collection.js")) out[newProp] = Array.from(valueOf.keys());
      // If it's an array, flatten each element
      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e));
      // If it's an object with a primitive `valueOf`, use that value
      else if (typeof valueOf !== 'object') out[newProp] = valueOf;
      // If it's a primitive
      else if (!elemIsObj) out[newProp] = element;
    }

    return out;
  }

  /**
   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.
   * @param {StringResolvable} text Content to split
   * @param {SplitOptions} [options] Options controlling the behavior of the split
   * @returns {string[]}
   */
  static splitMessage(text, { maxLength = 2000, char = '\n', prepend = '', append = '' } = {}) {
    text = Util.resolveString(text);
    if (text.length <= maxLength) return [text];
    const splitText = text.split(char);
    if (splitText.some(chunk => chunk.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');
    const messages = [];
    let msg = '';
    for (const chunk of splitText) {
      if (msg && (msg + char + chunk + append).length > maxLength) {
        messages.push(msg + append);
        msg = prepend;
      }
      msg += (msg && msg !== prepend ? char : '') + chunk;
    }
    return messages.concat(msg).filter(m => m);
  }

  /**
   * Escapes any Discord-flavour markdown in a string.
   * @param {string} text Content to escape
   * @param {Object} [options={}] What types of markdown to escape
   * @param {boolean} [options.codeBlock=true] Whether to escape code blocks or not
   * @param {boolean} [options.inlineCode=true] Whether to escape inline code or not
   * @param {boolean} [options.bold=true] Whether to escape bolds or not
   * @param {boolean} [options.italic=true] Whether to escape italics or not
   * @param {boolean} [options.underline=true] Whether to escape underlines or not
   * @param {boolean} [options.strikethrough=true] Whether to escape strikethroughs or not
   * @param {boolean} [options.spoiler=true] Whether to escape spoilers or not
   * @param {boolean} [options.codeBlockContent=true] Whether to escape text inside code blocks or not
   * @param {boolean} [options.inlineCodeContent=true] Whether to escape text inside inline code or not
   * @returns {string}
   */
  static escapeMarkdown(
    text,
    {
      codeBlock = true,
      inlineCode = true,
      bold = true,
      italic = true,
      underline = true,
      strikethrough = true,
      spoiler = true,
      codeBlockContent = true,
      inlineCodeContent = true,
    } = {},
  ) {
    if (!codeBlockContent) {
      return text
        .split('```')
        .map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1) return subString;
          return Util.escapeMarkdown(subString, {
            inlineCode,
            bold,
            italic,
            underline,
            strikethrough,
            spoiler,
            inlineCodeContent,
          });
        })
        .join(codeBlock ? '\\`\\`\\`' : '```');
    }
    if (!inlineCodeContent) {
      return text
        .split(/(?<=^|[^`])`(?=[^`]|$)/g)
        .map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1) return subString;
          return Util.escapeMarkdown(subString, {
            codeBlock,
            bold,
            italic,
            underline,
            strikethrough,
            spoiler,
          });
        })
        .join(inlineCode ? '\\`' : '`');
    }
    if (inlineCode) text = Util.escapeInlineCode(text);
    if (codeBlock) text = Util.escapeCodeBlock(text);
    if (italic) text = Util.escapeItalic(text);
    if (bold) text = Util.escapeBold(text);
    if (underline) text = Util.escapeUnderline(text);
    if (strikethrough) text = Util.escapeStrikethrough(text);
    if (spoiler) text = Util.escapeSpoiler(text);
    return text;
  }

  /**
   * Escapes code block markdown in a string.
   * @param {string} text Content to escape
   * @returns {string}
   */
  static escapeCodeBlock(text) {
    return text.replace(/```/g, '\\`\\`\\`');
  }

  /**
   * Escapes inline code markdown in a string.
   * @param {string} text Content to escape
   * @returns {string}
   */
  static escapeInlineCode(text) {
    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\`');
  }

  /**
   * Escapes italic markdown in a string.
   * @param {string} text Content to escape
   * @returns {string}
   */
  static escapeItalic(text) {
    let i = 0;
    text = text.replace(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
      if (match === '**') return ++i % 2 ? `\\*${match}` : `${match}\\*`;
      return `\\*${match}`;
    });
    i = 0;
    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {
      if (match === '__') return ++i % 2 ? `\\_${match}` : `${match}\\_`;
      return `\\_${match}`;
    });
  }

  /**
   * Escapes bold markdown in a string.
   * @param {string} text Content to escape
   * @returns {string}
   */
  static escapeBold(text) {
    let i = 0;
    return text.replace(/\*\*(\*)?/g, (_, match) => {
      if (match) return ++i % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
      return '\\*\\*';
    });
  }

  /**
   * Escapes underline markdown in a string.
   * @param {string} text Content to escape
   * @returns {string}
   */
  static escapeUnderline(text) {
    let i = 0;
    return text.replace(/__(_)?/g, (_, match) => {
      if (match) return ++i % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
      return '\\_\\_';
    });
  }

  /**
   * Escapes strikethrough markdown in a string.
   * @param {string} text Content to escape
   * @returns {string}
   */
  static escapeStrikethrough(text) {
    return text.replace(/~~/g, '\\~\\~');
  }

  /**
   * Escapes spoiler markdown in a string.
   * @param {string} text Content to escape
   * @returns {string}
   */
  static escapeSpoiler(text) {
    return text.replace(/\|\|/g, '\\|\\|');
  }

  /**
   * Gets the recommended shard count from Discord.
   * @param {string} token Discord auth token
   * @param {number} [guildsPerShard=1000] Number of guilds per shard
   * @returns {Promise<number>} The recommended number of shards
   */
  static fetchRecommendedShards(token, guildsPerShard = 1000) {
    if (!token) throw new DiscordError('TOKEN_MISSING');
    return fetch(`${DefaultOptions.http.api}/v${DefaultOptions.http.version}${Endpoints.botGateway}`, {
      method: 'GET',
      headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, '')}` },
    })
      .then(res => {
        if (res.ok) return res.json();
        if (res.status === 401) throw new DiscordError('TOKEN_INVALID');
        throw res;
      })
      .then(data => data.shards * (1000 / guildsPerShard));
  }

  /**
   * Parses emoji info out of a string. The string must be one of:
   * * A UTF-8 emoji (no ID)
   * * A URL-encoded UTF-8 emoji (no ID)
   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)
   * @param {string} text Emoji string to parse
   * @returns {Object} Object with `animated`, `name`, and `id` properties
   * @private
   */
  static parseEmoji(text) {
    if (text.includes('%')) text = decodeURIComponent(text);
    if (!text.includes(':')) return { animated: false, name: text, id: null };
    const m = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
    if (!m) return null;
    return { animated: Boolean(m[1]), name: m[2], id: m[3] || null };
  }

  /**
   * Shallow-copies an object with its class/prototype intact.
   * @param {Object} obj Object to clone
   * @returns {Object}
   * @private
   */
  static cloneObject(obj) {
    return Object.assign(Object.create(obj), obj);
  }

  /**
   * Sets default properties on an object that aren't already specified.
   * @param {Object} def Default properties
   * @param {Object} given Object to assign defaults to
   * @returns {Object}
   * @private
   */
  static mergeDefault(def, given) {
    if (!given) return def;
    for (const key in def) {
      if (!has(given, key) || given[key] === undefined) {
        given[key] = def[key];
      } else if (given[key] === Object(given[key])) {
        given[key] = Util.mergeDefault(def[key], given[key]);
      }
    }

    return given;
  }

  /**
   * Converts an ArrayBuffer or string to a Buffer.
   * @param {ArrayBuffer|string} ab ArrayBuffer to convert
   * @returns {Buffer}
   * @private
   */
  static convertToBuffer(ab) {
    if (typeof ab === 'string') ab = Util.str2ab(ab);
    return Buffer.from(ab);
  }

  /**
   * Converts a string to an ArrayBuffer.
   * @param {string} str String to convert
   * @returns {ArrayBuffer}
   * @private
   */
  static str2ab(str) {
    const buffer = new ArrayBuffer(str.length * 2);
    const view = new Uint16Array(buffer);
    for (var i = 0, strLen = str.length; i < strLen; i++) view[i] = str.charCodeAt(i);
    return buffer;
  }

  /**
   * Makes an Error from a plain info object.
   * @param {Object} obj Error info
   * @param {string} obj.name Error type
   * @param {string} obj.message Message for the error
   * @param {string} obj.stack Stack for the error
   * @returns {Error}
   * @private
   */
  static makeError(obj) {
    const err = new Error(obj.message);
    err.name = obj.name;
    err.stack = obj.stack;
    return err;
  }

  /**
   * Makes a plain error info object from an Error.
   * @param {Error} err Error to get info from
   * @returns {Object}
   * @private
   */
  static makePlainError(err) {
    return {
      name: err.name,
      message: err.message,
      stack: err.stack,
    };
  }

  /**
   * Moves an element in an array *in place*.
   * @param {Array<*>} array Array to modify
   * @param {*} element Element to move
   * @param {number} newIndex Index or offset to move the element to
   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index
   * @returns {number}
   * @private
   */
  static moveElementInArray(array, element, newIndex, offset = false) {
    const index = array.indexOf(element);
    newIndex = (offset ? index : 0) + newIndex;
    if (newIndex > -1 && newIndex < array.length) {
      const removedElement = array.splice(index, 1)[0];
      array.splice(newIndex, 0, removedElement);
    }
    return array.indexOf(element);
  }

  /**
   * Data that can be resolved to give a string. This can be:
   * * A string
   * * An array (joined with a new line delimiter to give a string)
   * * Any value
   * @typedef {string|Array|*} StringResolvable
   */

  /**
   * Resolves a StringResolvable to a string.
   * @param {StringResolvable} data The string resolvable to resolve
   * @returns {string}
   */
  static resolveString(data) {
    if (typeof data === 'string') return data;
    if (Array.isArray(data)) return data.join('\n');
    return String(data);
  }

  /**
   * Can be a number, hex string, an RGB array like:
   * ```js
   * [255, 0, 255] // purple
   * ```
   * or one of the following strings:
   * - `DEFAULT`
   * - `WHITE`
   * - `AQUA`
   * - `GREEN`
   * - `BLUE`
   * - `YELLOW`
   * - `PURPLE`
   * - `LUMINOUS_VIVID_PINK`
   * - `GOLD`
   * - `ORANGE`
   * - `RED`
   * - `GREY`
   * - `DARKER_GREY`
   * - `NAVY`
   * - `DARK_AQUA`
   * - `DARK_GREEN`
   * - `DARK_BLUE`
   * - `DARK_PURPLE`
   * - `DARK_VIVID_PINK`
   * - `DARK_GOLD`
   * - `DARK_ORANGE`
   * - `DARK_RED`
   * - `DARK_GREY`
   * - `LIGHT_GREY`
   * - `DARK_NAVY`
   * - `BLURPLE`
   * - `GREYPLE`
   * - `DARK_BUT_NOT_BLACK`
   * - `NOT_QUITE_BLACK`
   * - `RANDOM`
   * @typedef {string|number|number[]} ColorResolvable
   */

  /**
   * Resolves a ColorResolvable into a color number.
   * @param {ColorResolvable} color Color to resolve
   * @returns {number} A color
   */
  static resolveColor(color) {
    if (typeof color === 'string') {
      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));
      if (color === 'DEFAULT') return 0;
      color = Colors[color] || parseInt(color.replace('#', ''), 16);
    } else if (Array.isArray(color)) {
      color = (color[0] << 16) + (color[1] << 8) + color[2];
    }

    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');
    else if (color && isNaN(color)) throw new TypeError('COLOR_CONVERT');

    return color;
  }

  /**
   * Sorts by Discord's position and ID.
   * @param  {Collection} collection Collection of objects to sort
   * @returns {Collection}
   */
  static discordSort(collection) {
    return collection.sorted(
      (a, b) =>
        a.rawPosition - b.rawPosition ||
        parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) ||
        parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)),
    );
  }

  /**
   * Sets the position of a Channel or Role.
   * @param {Channel|Role} item Object to set the position of
   * @param {number} position New position for the object
   * @param {boolean} relative Whether `position` is relative to its current position
   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly
   * @param {APIRouter} route Route to call PATCH on
   * @param {string} [reason] Reason for the change
   * @returns {Promise<Object[]>} Updated item list, with `id` and `position` properties
   * @private
   */
  static setPosition(item, position, relative, sorted, route, reason) {
    let updatedItems = sorted.array();
    Util.moveElementInArray(updatedItems, item, position, relative);
    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
    return route.patch({ data: updatedItems, reason }).then(() => updatedItems);
  }

  /**
   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.
   * @param {string} path Path to get the basename of
   * @param {string} [ext] File extension to remove
   * @returns {string} Basename of the path
   * @private
   */
  static basename(path, ext) {
    let res = parse(path);
    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];
  }

  /**
   * Transforms a snowflake from a decimal string to a bit string.
   * @param  {Snowflake} num Snowflake to be transformed
   * @returns {string}
   * @private
   */
  static idToBinary(num) {
    let bin = '';
    let high = parseInt(num.slice(0, -10)) || 0;
    let low = parseInt(num.slice(-10));
    while (low > 0 || high > 0) {
      bin = String(low & 1) + bin;
      low = Math.floor(low / 2);
      if (high > 0) {
        low += 5000000000 * (high % 2);
        high = Math.floor(high / 2);
      }
    }
    return bin;
  }

  /**
   * Transforms a snowflake from a bit string to a decimal string.
   * @param  {string} num Bit string to be transformed
   * @returns {Snowflake}
   * @private
   */
  static binaryToID(num) {
    let dec = '';

    while (num.length > 50) {
      const high = parseInt(num.slice(0, -32), 2);
      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);

      dec = (low % 10).toString() + dec;
      num =
        Math.floor(high / 10).toString(2) +
        Math.floor(low / 10)
          .toString(2)
          .padStart(32, '0');
    }

    num = parseInt(num, 2);
    while (num > 0) {
      dec = (num % 10).toString() + dec;
      num = Math.floor(num / 10);
    }

    return dec;
  }

  /**
   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character
   * @param {string} str The string to sanitize
   * @returns {string}
   */
  static removeMentions(str) {
    return str.replace(/@/g, '@\u200b');
  }

  /**
   * The content to have all mentions replaced by the equivalent text.
   * @param {string} str The string to be converted
   * @param {Message} message The message object to reference
   * @returns {string}
   */
  static cleanContent(str, message) {
    str = str
      .replace(/<@!?[0-9]+>/g, input => {
        const id = input.replace(/<|!|>|@/g, '');
        if (message.channel.type === 'dm') {
          const user = message.client.users.cache.get(id);
          return user ? Util.removeMentions(`@${user.username}`) : input;
        }

        const member = message.channel.guild.members.cache.get(id);
        if (member) {
          return Util.removeMentions(`@${member.displayName}`);
        } else {
          const user = message.client.users.cache.get(id);
          return user ? Util.removeMentions(`@${user.username}`) : input;
        }
      })
      .replace(/<#[0-9]+>/g, input => {
        const channel = message.client.channels.cache.get(input.replace(/<|#|>/g, ''));
        return channel ? `#${channel.name}` : input;
      })
      .replace(/<@&[0-9]+>/g, input => {
        if (message.channel.type === 'dm') return input;
        const role = message.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));
        return role ? `@${role.name}` : input;
      });
    if (message.client.options.disableMentions === 'everyone') {
      str = str.replace(/@([^<>@ ]*)/gmsu, (match, target) => {
        if (target.match(/^[&!]?\d+$/)) {
          return `@${target}`;
        } else {
          return `@\u200b${target}`;
        }
      });
    }
    if (message.client.options.disableMentions === 'all') {
      return Util.removeMentions(str);
    } else {
      return str;
    }
  }

  /**
   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.
   * @param {string} text The string to be converted
   * @returns {string}
   */
  static cleanCodeBlockContent(text) {
    return text.replace(/```/g, '`\u200b``');
  }

  /**
   * Creates a Promise that resolves after a specified duration.
   * @param {number} ms How long to wait before resolving (in milliseconds)
   * @returns {Promise<void>}
   * @private
   */
  static delayFor(ms) {
    return new Promise(resolve => {
      setTimeout(resolve, ms);
    });
  }
}

module.exports = Util;


/***/ }),

/***/ "./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* @flow */
/*::

type DotenvParseOptions = {
  debug?: boolean
}

// keys and values from src
type DotenvParseOutput = { [string]: string }

type DotenvConfigOptions = {
  path?: string, // path to .env file
  encoding?: string, // encoding of .env file
  debug?: string // turn on logging for debugging purposes
}

type DotenvConfigOutput = {
  parsed?: DotenvParseOutput,
  error?: Error
}

*/

const fs = __webpack_require__(/*! fs */ "?65c5")
const path = __webpack_require__(/*! path */ "?0f27")

function log (message /*: string */) {
  console.log(`[dotenv][DEBUG] ${message}`)
}

const NEWLINE = '\n'
const RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/
const RE_NEWLINES = /\\n/g
const NEWLINES_MATCH = /\n|\r|\r\n/

// Parses src into an Object
function parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {
  const debug = Boolean(options && options.debug)
  const obj = {}

  // convert Buffers before splitting into lines and processing
  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {
    // matching "KEY' and 'VAL' in 'KEY=VAL'
    const keyValueArr = line.match(RE_INI_KEY_VAL)
    // matched?
    if (keyValueArr != null) {
      const key = keyValueArr[1]
      // default undefined or missing values to empty string
      let val = (keyValueArr[2] || '')
      const end = val.length - 1
      const isDoubleQuoted = val[0] === '"' && val[end] === '"'
      const isSingleQuoted = val[0] === "'" && val[end] === "'"

      // if single or double quoted, remove quotes
      if (isSingleQuoted || isDoubleQuoted) {
        val = val.substring(1, end)

        // if double quoted, expand newlines
        if (isDoubleQuoted) {
          val = val.replace(RE_NEWLINES, NEWLINE)
        }
      } else {
        // remove surrounding whitespace
        val = val.trim()
      }

      obj[key] = val
    } else if (debug) {
      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)
    }
  })

  return obj
}

// Populates process.env from .env file
function config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {
  let dotenvPath = path.resolve(process.cwd(), '.env')
  let encoding /*: string */ = 'utf8'
  let debug = false

  if (options) {
    if (options.path != null) {
      dotenvPath = options.path
    }
    if (options.encoding != null) {
      encoding = options.encoding
    }
    if (options.debug != null) {
      debug = true
    }
  }

  try {
    // specifying an encoding returns a string instead of a buffer
    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })

    Object.keys(parsed).forEach(function (key) {
      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
        process.env[key] = parsed[key]
      } else if (debug) {
        log(`"${key}" is already defined in \`process.env\` and will not be overwritten`)
      }
    })

    return { parsed }
  } catch (e) {
    return { error: e }
  }
}

module.exports.config = config
module.exports.parse = parse


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports.default = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof __webpack_require__.g === "undefined" ? this : __webpack_require__.g : self));


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
var dotenv = __webpack_require__(/*! dotenv */ "./node_modules/dotenv/lib/main.js");
var _8ball_1 = __webpack_require__(/*! 8ball */ "./node_modules/8ball/index.js");
var Discord = __webpack_require__(/*! discord.js */ "./node_modules/discord.js/src/index.js");
var lib_1 = __webpack_require__(/*! ./lib */ "./src/lib.ts");
dotenv.config();
var bot = new Discord.Client();
var TOKEN = process.env.TOKEN;
bot.login(TOKEN);
bot.on('message', function (msg) {
    if (msg.author.bot)
        return false;
    if (msg.mentions.has(bot.user.id) && msg.content.endsWith("?")) {
        msg.reply(_8ball_1["default"]());
    }
    if (msg.mentions.has(bot.user.id) && msg.content.includes("check library")) {
        msg.reply(lib_1.echo());
    }
});


/***/ }),

/***/ "./src/lib.ts":
/*!********************!*\
  !*** ./src/lib.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.echo = void 0;
function echo() {
    return "hello from the library";
}
exports.echo = echo;


/***/ }),

/***/ "?e41f":
/*!*********************************************!*\
  !*** ../sharding/ShardClientUtil (ignored) ***!
  \*********************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9d4d":
/*!**********************************!*\
  !*** ./sharding/Shard (ignored) ***!
  \**********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7ce5":
/*!********************************************!*\
  !*** ./sharding/ShardClientUtil (ignored) ***!
  \********************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?271f":
/*!********************************************!*\
  !*** ./sharding/ShardingManager (ignored) ***!
  \********************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?5b33":
/*!********************************************!*\
  !*** ./voice/ClientVoiceManager (ignored) ***!
  \********************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?a56a":
/*!*************************!*\
  !*** erlpack (ignored) ***!
  \*************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?65c5":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8ff5":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0f27":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?cc48":
/*!************************!*\
  !*** stream (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0bed":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1797":
/*!********************************!*\
  !*** worker_threads (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?98fa":
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?ca8b":
/*!***************************!*\
  !*** zlib-sync (ignored) ***!
  \***************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy84YmFsbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9AZGlzY29yZGpzL2NvbGxlY3Rpb24vZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9AZGlzY29yZGpzL2Zvcm0tZGF0YS9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9hYm9ydC1jb250cm9sbGVyL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvV2ViU29ja2V0LmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9CYXNlQ2xpZW50LmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9DbGllbnQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L1dlYmhvb2tDbGllbnQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvQWN0aW9uLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL0FjdGlvbnNNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL0NoYW5uZWxDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvQ2hhbm5lbERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9DaGFubmVsVXBkYXRlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL0d1aWxkQmFuUmVtb3ZlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL0d1aWxkQ2hhbm5lbHNQb3NpdGlvblVwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZEVtb2ppQ3JlYXRlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL0d1aWxkRW1vamlEZWxldGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvR3VpbGRFbW9qaVVwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZEVtb2ppc1VwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZEludGVncmF0aW9uc1VwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZE1lbWJlclJlbW92ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZE1lbWJlclVwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZFJvbGVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvR3VpbGRSb2xlRGVsZXRlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL0d1aWxkUm9sZVVwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9HdWlsZFJvbGVzUG9zaXRpb25VcGRhdGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvR3VpbGRVcGRhdGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvSW52aXRlQ3JlYXRlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL0ludml0ZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9NZXNzYWdlQ3JlYXRlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL01lc3NhZ2VEZWxldGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvTWVzc2FnZURlbGV0ZUJ1bGsuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvTWVzc2FnZVJlYWN0aW9uQWRkLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL01lc3NhZ2VSZWFjdGlvblJlbW92ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9NZXNzYWdlUmVhY3Rpb25SZW1vdmVBbGwuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvTWVzc2FnZVJlYWN0aW9uUmVtb3ZlRW1vamkuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvTWVzc2FnZVVwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9QcmVzZW5jZVVwZGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9UeXBpbmdTdGFydC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvYWN0aW9ucy9Vc2VyVXBkYXRlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC9hY3Rpb25zL1ZvaWNlU3RhdGVVcGRhdGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L2FjdGlvbnMvV2ViaG9va3NVcGRhdGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9XZWJTb2NrZXRNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvV2ViU29ja2V0U2hhcmQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9DSEFOTkVMX0NSRUFURS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0NIQU5ORUxfREVMRVRFLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvQ0hBTk5FTF9QSU5TX1VQREFURS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0NIQU5ORUxfVVBEQVRFLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfQkFOX0FERC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0dVSUxEX0JBTl9SRU1PVkUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9DUkVBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9ERUxFVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9FTU9KSVNfVVBEQVRFLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfSU5URUdSQVRJT05TX1VQREFURS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0dVSUxEX01FTUJFUlNfQ0hVTksuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9NRU1CRVJfQURELmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfTUVNQkVSX1JFTU9WRS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0dVSUxEX01FTUJFUl9VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9ST0xFX0NSRUFURS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0dVSUxEX1JPTEVfREVMRVRFLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfUk9MRV9VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9JTlZJVEVfQ1JFQVRFLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvSU5WSVRFX0RFTEVURS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfQ1JFQVRFLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvTUVTU0FHRV9ERUxFVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9NRVNTQUdFX0RFTEVURV9CVUxLLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvTUVTU0FHRV9SRUFDVElPTl9BREQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9NRVNTQUdFX1JFQUNUSU9OX1JFTU9WRS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFX0FMTC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFX0VNT0pJLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvTUVTU0FHRV9VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9QUkVTRU5DRV9VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9SRUFEWS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL1JFU1VNRUQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9UWVBJTkdfU1RBUlQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9VU0VSX1VQREFURS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL1ZPSUNFX1NFUlZFUl9VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9WT0lDRV9TVEFURV9VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9XRUJIT09LU19VUERBVEUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzfHN5bmN8L14vLiovLmpzJCIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9lcnJvcnMvREpTRXJyb3IuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvZXJyb3JzL01lc3NhZ2VzLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2Vycm9ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9tYW5hZ2Vycy9CYXNlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9tYW5hZ2Vycy9DaGFubmVsTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9tYW5hZ2Vycy9HdWlsZENoYW5uZWxNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL21hbmFnZXJzL0d1aWxkRW1vamlNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL21hbmFnZXJzL0d1aWxkRW1vamlSb2xlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9tYW5hZ2Vycy9HdWlsZE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvbWFuYWdlcnMvR3VpbGRNZW1iZXJNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL21hbmFnZXJzL0d1aWxkTWVtYmVyUm9sZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvbWFuYWdlcnMvTWVzc2FnZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvbWFuYWdlcnMvUHJlc2VuY2VNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL21hbmFnZXJzL1JlYWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9tYW5hZ2Vycy9SZWFjdGlvblVzZXJNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL21hbmFnZXJzL1JvbGVNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL21hbmFnZXJzL1VzZXJNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL21hbmFnZXJzL1ZvaWNlU3RhdGVNYW5hZ2VyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3Jlc3QvQVBJUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9yZXN0L0FQSVJvdXRlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9yZXN0L0FzeW5jUXVldWUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvcmVzdC9EaXNjb3JkQVBJRXJyb3IuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvcmVzdC9IVFRQRXJyb3IuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvcmVzdC9SRVNUTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9yZXN0L1JlcXVlc3RIYW5kbGVyLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvQVBJTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0Jhc2UuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9CYXNlR3VpbGRFbW9qaS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0NhdGVnb3J5Q2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0NoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9DbGllbnRBcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0NsaWVudFByZXNlbmNlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvQ2xpZW50VXNlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0RNQ2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0Vtb2ppLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvR3VpbGQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9HdWlsZEF1ZGl0TG9ncy5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0d1aWxkQ2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0d1aWxkRW1vamkuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9HdWlsZE1lbWJlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0d1aWxkUHJldmlldy5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0d1aWxkUHJldmlld0Vtb2ppLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvR3VpbGRUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0ludGVncmF0aW9uLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvSW50ZWdyYXRpb25BcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL0ludml0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL01lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9NZXNzYWdlQXR0YWNobWVudC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL01lc3NhZ2VDb2xsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9NZXNzYWdlRW1iZWQuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9NZXNzYWdlTWVudGlvbnMuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9NZXNzYWdlUmVhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9OZXdzQ2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL1BhcnRpYWxHcm91cERNQ2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL1Blcm1pc3Npb25PdmVyd3JpdGVzLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvUHJlc2VuY2UuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9SZWFjdGlvbkNvbGxlY3Rvci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL1JlYWN0aW9uRW1vamkuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9Sb2xlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvU3RvcmVDaGFubmVsLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvVGVhbS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL1RlYW1NZW1iZXIuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9UZXh0Q2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL1VzZXIuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9Wb2ljZUNoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9Wb2ljZVJlZ2lvbi5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL1ZvaWNlU3RhdGUuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvc3RydWN0dXJlcy9XZWJob29rLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvaW50ZXJmYWNlcy9BcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9zdHJ1Y3R1cmVzL2ludGVyZmFjZXMvQ29sbGVjdG9yLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3N0cnVjdHVyZXMvaW50ZXJmYWNlcy9UZXh0QmFzZWRDaGFubmVsLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3V0aWwvQWN0aXZpdHlGbGFncy5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy91dGlsL0JpdEZpZWxkLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3V0aWwvQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy91dGlsL0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy91dGlsL0RhdGFSZXNvbHZlci5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy91dGlsL0ludGVudHMuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvdXRpbC9MaW1pdGVkQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy91dGlsL01lc3NhZ2VGbGFncy5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy91dGlsL1Blcm1pc3Npb25zLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3V0aWwvU25vd2ZsYWtlLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3V0aWwvU3BlYWtpbmcuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvdXRpbC9TdHJ1Y3R1cmVzLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3V0aWwvU3lzdGVtQ2hhbm5lbEZsYWdzLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3V0aWwvVXNlckZsYWdzLmpzIiwid2VicGFjazovL3NlbGVjdF9zdGFyLy4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL3V0aWwvVXRpbC5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9kb3RlbnYvbGliL21haW4uanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci8uL3NyYy9saWIudHMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvaWdub3JlZHwuLi9zaGFyZGluZy9TaGFyZENsaWVudFV0aWwiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvaWdub3JlZHwuL3NoYXJkaW5nL1NoYXJkIiwid2VicGFjazovL3NlbGVjdF9zdGFyL2lnbm9yZWR8Li9zaGFyZGluZy9TaGFyZENsaWVudFV0aWwiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvaWdub3JlZHwuL3NoYXJkaW5nL1NoYXJkaW5nTWFuYWdlciIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci9pZ25vcmVkfC4vdm9pY2UvQ2xpZW50Vm9pY2VNYW5hZ2VyIiwid2VicGFjazovL3NlbGVjdF9zdGFyL2lnbm9yZWR8ZXJscGFjayIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci9pZ25vcmVkfGZzIiwid2VicGFjazovL3NlbGVjdF9zdGFyL2lnbm9yZWR8aHR0cHMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvaWdub3JlZHxwYXRoIiwid2VicGFjazovL3NlbGVjdF9zdGFyL2lnbm9yZWR8c3RyZWFtIiwid2VicGFjazovL3NlbGVjdF9zdGFyL2lnbm9yZWR8dXRpbCIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci9pZ25vcmVkfHdvcmtlcl90aHJlYWRzIiwid2VicGFjazovL3NlbGVjdF9zdGFyL2lnbm9yZWR8d3MiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvaWdub3JlZHx6bGliLXN5bmMiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2VsZWN0X3N0YXIvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9zZWxlY3Rfc3Rhci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3NlbGVjdF9zdGFyL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDdkJhO0FBQ2IsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwrQ0FBK0Msa0RBQWtEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0RBQWtELGtEQUFrRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVMsbURBQW1EO0FBQzNFO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsMkNBQTJDLDJpaEQ7Ozs7Ozs7Ozs7QUN2WTNDO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ1k7O0FBRVo7QUFDQSxPQUFPLCtCQUErQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWlQ7O0FBRWIsT0FBTyxVQUFVLEdBQUcsbUJBQU8sQ0FBQyx5RUFBa0I7O0FBRTlDOztBQUVBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHNCQUFTO0FBQzdCO0FBQ0EsQ0FBQyxTQUFTOztBQUVWOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DLEVBQUUsaUJBQWlCLG9CQUFvQjtBQUN2QyxDQUFDO0FBQ0QsZ0JBQWdCLG9EQUEyQjtBQUMzQyxFQUFFLDBEQUFpQztBQUNuQzs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCLFlBQVk7O0FBRVosY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLEdBQUcsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2hEYTs7QUFFYixtQkFBTyxDQUFDLGlFQUFjO0FBQ3RCLHFCQUFxQixtQkFBTyxDQUFDLCtDQUFRO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFxQjtBQUNqRCxPQUFPLGlCQUFpQixHQUFHLG1CQUFPLENBQUMsMEVBQW1CO0FBQ3RELGFBQWEsbUJBQU8sQ0FBQyxnRUFBYzs7QUFFbkM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN4S2E7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWM7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ3pELDJCQUEyQixtQkFBTyxDQUFDLHlDQUE0QjtBQUMvRCx5QkFBeUIsbUJBQU8sQ0FBQyx3R0FBOEI7QUFDL0QsT0FBTywrQkFBK0IsR0FBRyxtQkFBTyxDQUFDLGdFQUFXO0FBQzVELHVCQUF1QixtQkFBTyxDQUFDLDRGQUE0QjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyxrR0FBK0I7QUFDakUscUJBQXFCLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLHNGQUF5QjtBQUNyRCx3QkFBd0IsbUJBQU8sQ0FBQywwQ0FBNkI7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsc0dBQWlDO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLDRGQUE0QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RkFBNkI7QUFDM0QsZUFBZSxtQkFBTyxDQUFDLGdGQUFzQjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQywwRkFBMkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQXVCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFvQjtBQUMvQyxPQUFPLGtDQUFrQyxHQUFHLG1CQUFPLENBQUMsMEVBQW1CO0FBQ3ZFLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFzQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQXFCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFvQjs7QUFFL0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSwwQkFBMEI7QUFDMUIseUJBQXlCLG9CQUFvQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFvQztBQUNqRCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkUsc0JBQXNCO0FBQ25HLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLDBDQUEwQyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsaUVBQWlFLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTLG9CQUFvQixFQUFFO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGVBQWU7QUFDZjtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSw4REFBOEQsOENBQThDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQiwrREFBK0Q7QUFDL0QsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTLHVCQUF1QixTQUFTLGNBQWMsU0FBUztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQixFQUFFLDBCQUEwQixHQUFHLE1BQU07QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSw0RkFBNEY7QUFDeEc7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUMsYUFBYSxPQUFPO0FBQ3BCLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOzs7Ozs7Ozs7Ozs7QUN2ZmE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWM7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQXVCOztBQUUvQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0EsMENBQTBDLG1EQUFtRDtBQUM3RjtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM5QmE7O0FBRWIsT0FBTyxlQUFlLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRXZEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDeEdhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLDhGQUFxQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLHNHQUF5QjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBNEI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsZ0hBQThCO0FBQ3hELGtCQUFrQixtQkFBTyxDQUFDLHNGQUFpQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFlO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFlO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFnQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsOEZBQXFCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLDhGQUFxQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsMEZBQW1CO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLDBGQUFtQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBbUI7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFjO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLDRGQUFvQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBb0I7QUFDOUMsa0JBQWtCLG1CQUFPLENBQUMsNEZBQW9CO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLDRGQUFvQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBcUI7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsNEdBQTRCO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLGtIQUErQjtBQUN6RCxrQkFBa0IsbUJBQU8sQ0FBQywwR0FBMkI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFlO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM5Q2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsNkVBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN0QmE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHlGQUE0QjtBQUN0RCxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNwQ2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUEwQjtBQUNsRCxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDaENhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3BCYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDcEJhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbEVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNuQmE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsNkVBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25CYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNuQmE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNqQ2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsNkVBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbEJhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLGlCQUFpQixHQUFHLG1CQUFPLENBQUMsNkVBQXNCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM3QmE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLE9BQU8saUJBQWlCLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRXpEO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzNDYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDeEJhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzdCYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN0Q2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3BCYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2hDYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG1GQUF5QjtBQUNoRCxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDM0JhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsbUZBQXlCO0FBQ2hELE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsNkVBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGlCQUFpQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNUJhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDdENhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNUJhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQywrRUFBdUI7QUFDbEQsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDMUNhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjtBQUNqRCxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFdkQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsTUFBTSxFQUFFO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLEtBQUs7QUFDcEI7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDdERhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsS0FBSztBQUNwQjtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM1Q2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsNkVBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNUJhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMzQmE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQW9EO0FBQ2pFLHVDQUF1QyxvREFBb0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3ZCYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzNDYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsYUFBYSxXQUFXLFdBQVc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN6RGE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsNkVBQXNCOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEIsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsQ2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsNkVBQXNCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLCtFQUF1Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdCQUF3Qjs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFLHFCQUFxQjtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzVDYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyw2RUFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsQmE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsK0NBQVE7QUFDckMsdUJBQXVCLG1CQUFPLENBQUMsMEZBQWtCO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLG9GQUFZO0FBQzNDLE9BQU8sa0JBQWtCLEdBQUcsbUJBQU8sQ0FBQyxtRUFBYztBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQywrRUFBdUI7QUFDbEQsT0FBTyxpREFBaUQsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjtBQUN6RixhQUFhLG1CQUFPLENBQUMsbUVBQWlCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQXlEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCOztBQUUzRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1DQUFtQzs7QUFFbEY7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTs7QUFFNUQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCLFNBQVMsY0FBYyxJQUFJLFFBQVE7QUFDakc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMOztBQUVBLFdBQVcsZ0NBQWdDOztBQUUzQztBQUNBLFdBQVc7QUFDWCwwQkFBMEIsa0JBQWtCOztBQUU1QztBQUNBLGFBQWE7QUFDYixpQkFBaUIsVUFBVTs7QUFFM0Isc0JBQXNCLFdBQVc7O0FBRWpDLFNBQVMsU0FBUzs7QUFFbEI7QUFDQSwyRUFBMkUsa0JBQWtCO0FBQzdGO0FBQ0Esd0RBQXdELDRCQUE0QjtBQUNwRjs7QUFFQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCLHVDQUF1QztBQUNoRTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDO0FBQzFGO0FBQ0E7QUFDQSw2REFBNkQsd0RBQXdEO0FBQ3JIOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLDhFQUE4RSxXQUFXO0FBQ3pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsZ0VBQWdFLElBQUksSUFBSSxVQUFVO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3BiYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQywrQ0FBUTtBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBaUI7QUFDM0MsT0FBTywwREFBMEQsR0FBRyxtQkFBTyxDQUFDLDZFQUFzQjs7QUFFbEc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHdCQUFXO0FBQzlCLEdBQUcsU0FBUztBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsK0NBQStDLDhCQUE4Qjs7QUFFN0U7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDRDQUE0Qyw4QkFBOEI7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaURBQWlELDhCQUE4Qjs7QUFFL0U7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtREFBbUQsK0JBQStCOztBQUVsRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG1EQUFtRCw4QkFBOEI7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaURBQWlELDhCQUE4Qjs7QUFFL0U7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnREFBZ0QsMkJBQTJCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDZDQUE2QztBQUMxRCxzQkFBc0IsY0FBYztBQUNwQzs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CLDhCQUE4QjtBQUNqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsTUFBTSw4QkFBOEI7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQixxQ0FBcUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxlQUFlLGNBQWMsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5Qjs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLFlBQVksSUFBSTtBQUNoQix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QixtRkFBbUY7QUFDM0c7O0FBRUEsb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBOztBQUVBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLDBDQUEwQztBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxRQUFRLEdBQUcsMEJBQTBCO0FBQ3hFLGVBQWUsMEJBQTBCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLGVBQWUsYUFBYSxtQkFBbUI7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSx3QkFBd0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Qsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXLHVEQUF1RDtBQUN0RjtBQUNBO0FBQ0EsV0FBVywyREFBMkQsS0FBSztBQUMzRTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0IsS0FBSztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdDQUFnQyw2Q0FBNkM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2x3QmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsZ0ZBQXlCOztBQUVwRCwyQkFBMkIsVUFBVTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckJhOztBQUViLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsZ0ZBQXlCOztBQUVwRDtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYixPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLGdGQUF5Qjs7QUFFcEQsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDZmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYixPQUFPLGlCQUFpQixHQUFHLG1CQUFPLENBQUMsZ0ZBQXlCOztBQUU1RCxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsSUFBSSxJQUFJLFVBQVU7QUFDcEc7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLElBQUksSUFBSSxVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25DYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBMEI7QUFDckQsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQyxnRkFBeUI7O0FBRXBELDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGLFFBQVE7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQzdCYTs7QUFFYixPQUFPLGlCQUFpQixHQUFHLG1CQUFPLENBQUMsZ0ZBQXlCOztBQUU1RCwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbEJhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsZ0ZBQXlCOztBQUVwRDtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2ZhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7O0FBRUEsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0MsbUJBQU8sQ0FBQyw4RkFBZ0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDcEJhOztBQUViLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsZ0ZBQXlCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2JhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBLHlEQUF5RCx1QkFBdUI7QUFDaEY7QUFDQTs7Ozs7Ozs7Ozs7O0FDTGE7O0FBRWI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0phOztBQUViLE9BQU8sV0FBVyxHQUFHLG1CQUFPLENBQUMsZ0ZBQXlCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDhHQUFRLEdBQUcsRUFBRSxLQUFLLElBQUksQ0FBQztBQUM1QyxHQUFHLFNBQVM7QUFDWjs7QUFFQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Rzs7Ozs7Ozs7Ozs7QUMxRGE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVcsSUFBSSxZQUFZO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNURhOztBQUViLE9BQU8sV0FBVyxHQUFHLG1CQUFPLENBQUMsb0VBQVk7O0FBRXpDO0FBQ0EsZ0RBQWdELEtBQUssa0JBQWtCLEtBQUs7QUFDNUU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFLEtBQUs7O0FBRXJFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDLHdEQUF3RCxNQUFNO0FBQzlELDBDQUEwQyxHQUFHO0FBQzdDLHlDQUF5QyxHQUFHO0FBQzVDLHlDQUF5QyxHQUFHO0FBQzVDLDhDQUE4QyxHQUFHO0FBQ2pELHNDQUFzQyxHQUFHO0FBQ3pDLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0EsZ0NBQWdDLE1BQU0sYUFBYSxNQUFNLFFBQVEsTUFBTTs7QUFFdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNEQUFzRCxLQUFLOztBQUUzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUyxvQkFBb0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1EQUFtRCxPQUFPO0FBQzFELDZDQUE2QyxLQUFLOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNFQUFzRSxzQkFBc0I7QUFDNUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RCxLQUFLLFdBQVcsY0FBYyxHQUFHLFNBQVM7O0FBRXRHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNOztBQUUvRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzlHYTs7QUFFYiwwR0FBc0M7QUFDdEMsbUhBQStDOzs7Ozs7Ozs7Ozs7QUNIbEM7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLCtEQUFhOztBQUVsQztBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLCtFQUFxQjtBQUMzQyxVQUFVLG1CQUFPLENBQUMsdUVBQWlCO0FBQ25DLFNBQVMsbUJBQU8sQ0FBQywrQkFBa0I7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMseUNBQTRCO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLHlDQUE0QjtBQUN2RCxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBd0I7O0FBRWpEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQy9DLFlBQVksbUJBQU8sQ0FBQyx1RUFBaUI7QUFDckMsY0FBYyxtQkFBTyxDQUFDLDJFQUFtQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMseUVBQWtCO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFxQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMscUZBQXdCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLHFGQUF3QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMseUVBQWtCO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFxQjtBQUM3QyxXQUFXLG1CQUFPLENBQUMscUVBQWdCO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLHVFQUFpQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMseUVBQWtCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFrQjtBQUMzQyxjQUFjLG1CQUFPLENBQUMsMkVBQW1CO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLDJGQUEyQjtBQUN6RCxhQUFhLG1CQUFPLENBQUMseUVBQWtCO0FBQ3ZDO0FBQ0EsV0FBVyw0RkFBa0M7O0FBRTdDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLHFHQUFnQztBQUMvRCxxQkFBcUIsbUJBQU8sQ0FBQyxpR0FBOEI7QUFDM0QseUJBQXlCLG1CQUFPLENBQUMseUdBQWtDO0FBQ25FLHNCQUFzQixtQkFBTyxDQUFDLG1HQUErQjtBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQywyR0FBbUM7QUFDckUsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQXlCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDZGQUE0QjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyxxR0FBZ0M7QUFDL0Qsa0JBQWtCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDZGQUE0QjtBQUN2RCxlQUFlLG1CQUFPLENBQUMscUZBQXdCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxxRkFBd0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtHQUFxQztBQUM1RCxRQUFRLG1CQUFPLENBQUMsMkVBQW1CO0FBQ25DLFlBQVksaUhBQXlDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyx1RkFBeUI7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsK0ZBQTZCO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLGlHQUE4QjtBQUN6RCxXQUFXLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLHFHQUFnQztBQUM3RDtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHVGQUF5QjtBQUM1QyxHQUFHO0FBQ0gsYUFBYSxtQkFBTyxDQUFDLDJHQUFtQztBQUN4RCxhQUFhLG1CQUFPLENBQUMscUZBQXdCO0FBQzdDLFNBQVMsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDckMsU0FBUyxtQkFBTyxDQUFDLDZFQUFvQjtBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQywrRkFBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ25ELGNBQWMsbUJBQU8sQ0FBQyx1RkFBeUI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHlGQUEwQjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQywyRkFBMkI7QUFDbkQsaUJBQWlCLG1CQUFPLENBQUMsNkZBQTRCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyx5RkFBMEI7QUFDakQsVUFBVSxtQkFBTyxDQUFDLCtFQUFxQjtBQUN2QyxXQUFXLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLHFHQUFnQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBK0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLGlHQUE4QjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBOEI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLHlGQUEwQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQywyR0FBbUM7QUFDbkUsWUFBWSxpSEFBeUM7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsK0ZBQTZCO0FBQ3ZELHFCQUFxQixtQkFBTyxDQUFDLHFHQUFnQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBNEI7QUFDckQsc0JBQXNCLDJIQUFtRDtBQUN6RSxRQUFRLG1CQUFPLENBQUMsMkVBQW1CO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDJGQUEyQjtBQUNuRCxRQUFRLG1CQUFPLENBQUMsMkVBQW1CO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx1RkFBeUI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHlGQUEwQjtBQUNqRCxRQUFRLG1CQUFPLENBQUMsMkVBQW1CO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDJGQUEyQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMseUZBQTBCO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyx1RkFBeUI7QUFDL0MsV0FBVyxtQkFBTyxDQUFDLGlGQUFzQjs7QUFFekMsYUFBYSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xDOzs7Ozs7Ozs7Ozs7QUMzR2E7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW9CO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLDRFQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZDQUE2Qzs7QUFFdkY7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCOztBQUUzRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsa0JBQWtCLEtBQUs7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2hGYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBZTtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBdUI7QUFDL0MsT0FBTyxTQUFTLEdBQUcsbUJBQU8sQ0FBQywwRUFBbUI7O0FBRTlDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwRkFBMEYsUUFBUSxHQUFHLFVBQVU7QUFDL0c7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMvRmE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWU7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsNEZBQTRCO0FBQ3pELDZCQUE2QixtQkFBTyxDQUFDLDRHQUFvQztBQUN6RSxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLDBFQUFtQjs7QUFFcEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxpRUFBaUU7QUFDOUU7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsSWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWU7QUFDM0MsT0FBTyxZQUFZLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBMEI7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsOEZBQTZCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFvQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDbkQsT0FBTyxhQUFhLEdBQUcsbUJBQU8sQ0FBQyxnRUFBYzs7QUFFN0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyx1QkFBdUI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxXQUFXO0FBQzVFO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDdkQ7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCLEVBQUUsU0FBUyxFQUFFLGFBQWEsT0FBTyxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN0SWE7O0FBRWIsT0FBTyxZQUFZLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBb0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3RIYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBZTtBQUMzQyxjQUFjLG1CQUFPLENBQUMsOEVBQXFCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDRGQUE0QjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBMEI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsMEZBQTJCO0FBQ3ZELGVBQWUsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLDRFQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQywwRUFBbUI7QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFxQjtBQUNqRCxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLGdFQUFjOztBQUUvQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdFQUFnRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGdCQUFnQjtBQUNoQyxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsNEJBQTRCO0FBQzVDLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IscUJBQXFCO0FBQ3JDLGdCQUFnQixxQkFBcUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEMsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsa0JBQWtCO0FBQy9CLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxTQUFTLG9CQUFvQixFQUFFO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDM1BhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFlO0FBQzNDLE9BQU8sK0JBQStCLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUM1RCxvQkFBb0IsbUJBQU8sQ0FBQywwRkFBMkI7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW9CO0FBQy9DLE9BQU8sa0JBQWtCLEdBQUcsbUJBQU8sQ0FBQywwRUFBbUI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsMEVBQW1COztBQUVqRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHlDQUF5QztBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsZ0NBQWdDO0FBQ2hELGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNEQUFzRDtBQUNuRTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlFQUF5RTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsT0FBTztBQUNwQixlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNDQUFzQztBQUNoRSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQXlDO0FBQ25FLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQSxTQUFTLCtFQUErRSxLQUFLO0FBQzdGOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQ0FBaUMsUUFBUSxXQUFXO0FBQy9GO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxRQUFRLFdBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEtBQUs7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNwVWE7O0FBRWIsT0FBTyxZQUFZLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBb0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsNERBQTREO0FBQ3pFLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxR0FBcUcsU0FBUzs7QUFFOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekUsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdHQUF3RyxTQUFTOztBQUVqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0I7QUFDckY7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNoS2E7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWU7QUFDM0MsT0FBTyxZQUFZLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBdUI7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW9CO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLDBGQUEyQjs7QUFFN0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixVQUFVO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QyxpREFBaUQsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrREFBK0Q7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFLFNBQVM7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbEphOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFlO0FBQzNDLE9BQU8sV0FBVyxHQUFHLG1CQUFPLENBQUMsb0ZBQXdCOztBQUVyRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUUsbUJBQW1CO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDMURhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFlO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLGtHQUErQjs7QUFFL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQywrREFBK0Q7QUFDbEc7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNwRWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWU7QUFDM0MsT0FBTyxRQUFRLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBb0I7O0FBRS9DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0EsZUFBZSw2QkFBNkIsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsdUJBQXVCLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2pFYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBZTtBQUMzQyxhQUFhLG1CQUFPLENBQUMsNEVBQW9CO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFxQjtBQUNqRCxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLGdFQUFjOztBQUUvQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVSxVQUFVLEtBQUs7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDakphOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFlO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDBGQUEyQjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBdUI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLDRFQUFvQjs7QUFFekM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN2RWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWU7O0FBRTNDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2xDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLG9FQUFrQjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsd0RBQVk7QUFDbEMsT0FBTyxxQkFBcUIsR0FBRyxtQkFBTyxDQUFDLDBFQUFtQjs7QUFFMUQsOENBQThDLGtCQUFrQjs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLLEVBQUUsbUJBQW1CLFlBQVksRUFBRTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLElBQUksaUNBQWlDO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbEVhOztBQUViLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTywwQ0FBMEM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM5RmE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWMsSUFBSSxVQUFVOztBQUUvRTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxJQUFJLEdBQUcsRUFBRSxPQUFPLElBQUksR0FBRyxFQUFFOztBQUVuRTtBQUNBLHlCQUF5QixPQUFPLElBQUksd0NBQXdDO0FBQzVFLE9BQU87QUFDUCx5QkFBeUIsWUFBWSxPQUFPLFNBQVMsRUFBRSxVQUFVO0FBQ2pFLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNuRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDcENhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFjO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLG9FQUFhO0FBQzFDLHVCQUF1QixtQkFBTyxDQUFDLDhFQUFrQjtBQUNqRCxPQUFPLFFBQVEsR0FBRyxtQkFBTyxDQUFDLGdFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFvQjtBQUMvQyxPQUFPLFlBQVksR0FBRyxtQkFBTyxDQUFDLDBFQUFtQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUIsR0FBRyxNQUFNO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMxRGE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWM7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3ZDO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsMEVBQW1CO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxnRUFBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNUthOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFxQjtBQUN2RCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDN0MsT0FBTyxhQUFhLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUMxQyxPQUFPLFVBQVUsR0FBRyxtQkFBTyxDQUFDLDBFQUFtQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDbkQscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyxnRUFBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLHFDQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxzRUFBVztBQUN2QywwQkFBMEIsbUJBQU8sQ0FBQyxzRkFBeUI7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFRO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLDhFQUFlO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxzRUFBVztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDhFQUFlOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLFNBQVM7QUFDVCwyQkFBMkIsT0FBTztBQUNsQztBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9GQUFvRixFQUFFLEdBQUc7QUFDbEg7QUFDQSxrQ0FBa0MsWUFBWSxFQUFFLDJCQUEyQjtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZLFFBQVEsU0FBUyxJQUFJLG9DQUFvQztBQUMxRjtBQUNBLG9DQUFvQywyQkFBMkIsUUFBUSxTQUFTO0FBQ2hGLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQSxPQUFPO0FBQ1AscUJBQXFCLFlBQVksRUFBRSxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsc0RBQXNEO0FBQ25FLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25ELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLHNEQUFzRCxZQUFZO0FBQy9FLGFBQWEscUNBQXFDLFVBQVU7QUFDNUQsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQix1Q0FBdUMsSUFBSTtBQUNyRSxLQUFLO0FBQ0wsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsbUNBQW1DLElBQUk7QUFDakUsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLElBQUk7QUFDMUQ7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLHNEQUFzRCxZQUFZO0FBQy9FLGFBQWEscUNBQXFDLFVBQVU7QUFDNUQsZUFBZTtBQUNmO0FBQ0Esb0RBQW9EO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLHNFQUFXO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLHNGQUF5Qjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw2REFBNkQ7QUFDMUU7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUVBQXFFO0FBQ2xGOzs7Ozs7Ozs7Ozs7QUMzWWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGdFQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDMUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxrRUFBUzs7QUFFL0I7QUFDQSxxQkFBcUIsaUJBQWlCLE1BQU0sd0JBQXdCO0FBQ3BFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCOztBQUV2RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNqRWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWdCOztBQUU3QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxPQUFPLFlBQVk7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDaENhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxnRUFBUTtBQUM3QixPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLDBFQUFtQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBbUI7O0FBRTdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDRFQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNDQUFzQyxtQkFBTyxDQUFDLGtHQUF5QjtBQUN2RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNoS2E7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGdFQUFRO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLG9HQUEwQjs7QUFFdEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDN0NhOztBQUViLE9BQU8sV0FBVyxHQUFHLG1CQUFPLENBQUMsd0VBQVk7QUFDekMsT0FBTyxZQUFZLEdBQUcsbUJBQU8sQ0FBQyxnRUFBVztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBb0I7QUFDL0MsT0FBTyx5QkFBeUIsR0FBRyxtQkFBTyxDQUFDLDBFQUFtQjs7QUFFOUQ7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU8sU0FBUztBQUM3QjtBQUNBLCtCQUErQjtBQUMvQix1Q0FBdUMsMEJBQTBCLFdBQVcsRUFBRTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUM7QUFDdkUsS0FBSztBQUNMO0FBQ0EsaURBQWlELHVDQUF1QztBQUN4RjtBQUNBLEtBQUs7QUFDTCx3REFBd0QsdUNBQXVDO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN0RmE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFvQjs7QUFFL0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrREFBa0Q7QUFDeEU7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixvQkFBb0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsOEJBQThCLFlBQVksMEJBQTBCLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLGlCQUFpQjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0Isb0JBQW9CO0FBQ3BDLGdCQUFnQixpQkFBaUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRCx3REFBd0QsNEJBQTRCO0FBQ3BGO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0NBQXdDLDJDQUEyQzs7QUFFbkYscUNBQXFDLDhDQUE4QyxPQUFPO0FBQzFGLDZCQUE2QixzQ0FBc0M7QUFDbkU7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2pMYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBVztBQUNuQyx5QkFBeUIsbUJBQU8sQ0FBQyw4R0FBK0I7QUFDaEUsdUJBQXVCLG1CQUFPLENBQUMsNEZBQTRCOztBQUUzRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbEdhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxnRUFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBbUI7O0FBRTdDO0FBQ0EsNkJBQTZCLGlCQUFpQixNQUFNLG9CQUFvQjtBQUN4RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEIsRUFBRSxVQUFVLEdBQUcsUUFBUTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0EsMERBQTBELGVBQWU7QUFDekU7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUIsR0FBRyxVQUFVLEdBQUcsUUFBUTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDdkdhOztBQUViLE9BQU8sWUFBWSxHQUFHLG1CQUFPLENBQUMsbUJBQU07QUFDcEMsYUFBYSxtQkFBTyxDQUFDLGdFQUFRO0FBQzdCLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFrQjtBQUNqRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsa0ZBQWlCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFlO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxvRUFBVTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBZTtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBVztBQUNuQyxPQUFPLG1CQUFtQixHQUFHLG1CQUFPLENBQUMsZ0VBQVc7QUFDaEQsNEJBQTRCLG1CQUFPLENBQUMsc0dBQWlDO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLGtHQUErQjtBQUNqRSwyQkFBMkIsbUJBQU8sQ0FBQyxvR0FBZ0M7QUFDbkUsd0JBQXdCLG1CQUFPLENBQUMsOEZBQTZCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLHNGQUF5QjtBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyxrR0FBK0I7QUFDakUsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsMEVBQW1CO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFzQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBbUI7QUFDN0MsMkJBQTJCLG1CQUFPLENBQUMsNEZBQTRCO0FBQy9ELGFBQWEsbUJBQU8sQ0FBQyxnRUFBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDRCQUE0QjtBQUN0RixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQixZQUFZO0FBQ3pDLGVBQWU7QUFDZjtBQUNBLGFBQWEsZUFBZSxLQUFLO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQixZQUFZO0FBQ3pDLGVBQWU7QUFDZjtBQUNBLFdBQVcsd0JBQXdCLEtBQUs7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0IsWUFBWTtBQUN6QyxlQUFlO0FBQ2Y7QUFDQSxhQUFhLGVBQWUsS0FBSztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCLFlBQVk7QUFDekMsZUFBZTtBQUNmO0FBQ0Esc0JBQXNCLGVBQWUsS0FBSztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxtQkFBbUIsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRLDBCQUEwQixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUyxvQkFBb0IsRUFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsS0FBSztBQUNyQixnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxvQkFBb0IsRUFBRTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVMsUUFBUSxTQUFTO0FBQ2pGLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixjQUFjO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLHdCQUF3QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVDQUF1QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHdDQUF3QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sWUFBWTtBQUNoQyxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLE9BQU87QUFDcEIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsc0JBQXNCO0FBQ25DLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLDZDQUE2QztBQUMxRDtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZ0JBQWdCO0FBQzFGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCLGtDQUFrQztBQUNsRCxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixtQ0FBbUM7QUFDbkQsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0RBQXNELFFBQVEsYUFBYSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsOERBQThELGVBQWU7QUFDN0U7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHdCQUF3QjtBQUNsRztBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxzQkFBc0I7QUFDekY7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHlCQUF5QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFzRDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsMEJBQTBCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUEwRDtBQUNoRjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0RUFBNEU7QUFDbEc7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUEwRDtBQUNoRjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsd0JBQXdCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixnQ0FBZ0M7QUFDakg7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHNCQUFzQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsZUFBZTtBQUNmO0FBQ0EsaUNBQWlDLGdEQUFnRDtBQUNqRixtRUFBbUUsTUFBTTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGVBQWU7QUFDZjtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekUsaUVBQWlFLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM5aURhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFlO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFXO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFvQjtBQUMvQyxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLDBFQUFtQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBbUI7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLGdFQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUE4RDtBQUM3RTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6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QUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlC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Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0NyQkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBLENBQUMsSTs7Ozs7V0NQRCx3Rjs7OztVQ0FBO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6ImluZGV4LWJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlc3BvbnNlcyA9IFtcbiAgJ2l0IGlzIGNlcnRhaW4nLFxuICAnaXQgaXMgZGVjaWRlZGx5IHNvJyxcbiAgJ3dpdGhvdXQgYSBkb3VidCcsXG4gICd5ZXMg4oCUIGRlZmluaXRlbHknLFxuICAneW91IG1heSByZWx5IG9uIGl0JyxcbiAgJ2FzIEkgc2VlIGl0LCB5ZXMnLFxuICAnbW9zdCBsaWtlbHknLFxuICAnb3V0bG9vayBnb29kJyxcbiAgJ3llcycsXG4gICdzaWducyBwb2ludCB0byB5ZXMnLFxuICAncmVwbHkgaGF6eSwgdHJ5IGFnYWluJyxcbiAgJ2FzayBhZ2FpbiBsYXRlcicsXG4gICdiZXR0ZXIgbm90IHRlbGwgeW91IG5vdycsXG4gICdjYW5ub3QgcHJlZGljdCBub3cnLFxuICAnY29uY2VudHJhdGUgYW5kIGFzayBhZ2FpbicsXG4gICdkb27igJl0IGNvdW50IG9uIGl0JyxcbiAgJ215IHJlcGx5IGlzIG5vJyxcbiAgJ215IHNvdXJjZXMgc2F5IG5vJyxcbiAgJ291dGxvb2sgbm90IHNvIGdvb2QnLFxuICAndmVyeSBkb3VidGZ1bCdcbl1cblxubW9kdWxlLmV4cG9ydHMgPSAoKSA9PiByZXNwb25zZXNbTWF0aC5mbG9vcihyZXNwb25zZXMubGVuZ3RoICogTWF0aC5yYW5kb20oKSldXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sbGVjdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogQSBNYXAgd2l0aCBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcy4gVGhpcyBpcyB1c2VkIHRocm91Z2hvdXQgZGlzY29yZC5qcyByYXRoZXIgdGhhbiBBcnJheXMgZm9yIGFueXRoaW5nIHRoYXQgaGFzXG4gKiBhbiBJRCwgZm9yIHNpZ25pZmljYW50bHkgaW1wcm92ZWQgcGVyZm9ybWFuY2UgYW5kIGVhc2Utb2YtdXNlLlxuICogQGV4dGVuZHMge01hcH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIC0gVGhlIGFtb3VudCBvZiBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24uXG4gKi9cbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgc3VwZXIoZW50cmllcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZWQgYXJyYXkgZm9yIHRoZSBgYXJyYXkoKWAgbWV0aG9kIC0gd2lsbCBiZSByZXNldCB0byBgbnVsbGAgd2hlbmV2ZXIgYHNldCgpYCBvciBgZGVsZXRlKClgIGFyZSBjYWxsZWRcbiAgICAgICAgICogQG5hbWUgQ29sbGVjdGlvbiNfYXJyYXlcbiAgICAgICAgICogQHR5cGUgez9BcnJheX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2FycmF5JywgeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlZCBhcnJheSBmb3IgdGhlIGBrZXlBcnJheSgpYCBtZXRob2QgLSB3aWxsIGJlIHJlc2V0IHRvIGBudWxsYCB3aGVuZXZlciBgc2V0KClgIG9yIGBkZWxldGUoKWAgYXJlIGNhbGxlZFxuICAgICAgICAgKiBAbmFtZSBDb2xsZWN0aW9uI19rZXlBcnJheVxuICAgICAgICAgKiBAdHlwZSB7P0FycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfa2V5QXJyYXknLCB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZGVudGljYWwgdG8gW01hcC5nZXQoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwL2dldCkuXG4gICAgICogR2V0cyBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXksIGFuZCByZXR1cm5zIGl0cyB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgLSBUaGUga2V5IHRvIGdldCBmcm9tIHRoaXMgY29sbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHsqIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZGVudGljYWwgdG8gW01hcC5zZXQoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwL3NldCkuXG4gICAgICogU2V0cyBhIG5ldyBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FycmF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fa2V5QXJyYXkgPSBudWxsO1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZGVudGljYWwgdG8gW01hcC5oYXMoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwL2hhcykuXG4gICAgICogQ2hlY2tzIGlmIGFuIGVsZW1lbnQgZXhpc3RzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBlbGVtZW50IGV4aXN0cywgYGZhbHNlYCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5oYXMoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWRlbnRpY2FsIHRvIFtNYXAuZGVsZXRlKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcC9kZWxldGUpLlxuICAgICAqIERlbGV0ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSB0byBkZWxldGUgZnJvbSB0aGUgY29sbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQsIGBmYWxzZWAgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICB0aGlzLl9hcnJheSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2tleUFycmF5ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZGVudGljYWwgdG8gW01hcC5jbGVhcigpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAvY2xlYXIpLlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb3JkZXJlZCBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoaXMgY29sbGVjdGlvbiwgYW5kIGNhY2hlcyBpdCBpbnRlcm5hbGx5LiBUaGUgYXJyYXkgd2lsbCBvbmx5IGJlXG4gICAgICogcmVjb25zdHJ1Y3RlZCBpZiBhbiBpdGVtIGlzIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbiwgb3IgaWYgeW91IGNoYW5nZSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICAgICAqIGl0c2VsZi4gSWYgeW91IGRvbid0IHdhbnQgdGhpcyBjYWNoaW5nIGJlaGF2aW9yLCB1c2UgYFsuLi5jb2xsZWN0aW9uLnZhbHVlcygpXWAgb3JcbiAgICAgKiBgQXJyYXkuZnJvbShjb2xsZWN0aW9uLnZhbHVlcygpKWAgaW5zdGVhZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgYXJyYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXJyYXkgfHwgdGhpcy5fYXJyYXkubGVuZ3RoICE9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICB0aGlzLl9hcnJheSA9IFsuLi50aGlzLnZhbHVlcygpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9yZGVyZWQgYXJyYXkgb2YgdGhlIGtleXMgb2YgdGhpcyBjb2xsZWN0aW9uLCBhbmQgY2FjaGVzIGl0IGludGVybmFsbHkuIFRoZSBhcnJheSB3aWxsIG9ubHkgYmVcbiAgICAgKiByZWNvbnN0cnVjdGVkIGlmIGFuIGl0ZW0gaXMgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLCBvciBpZiB5b3UgY2hhbmdlIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG4gICAgICogaXRzZWxmLiBJZiB5b3UgZG9uJ3Qgd2FudCB0aGlzIGNhY2hpbmcgYmVoYXZpb3IsIHVzZSBgWy4uLmNvbGxlY3Rpb24ua2V5cygpXWAgb3JcbiAgICAgKiBgQXJyYXkuZnJvbShjb2xsZWN0aW9uLmtleXMoKSlgIGluc3RlYWQuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGtleUFycmF5KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2tleUFycmF5IHx8IHRoaXMuX2tleUFycmF5Lmxlbmd0aCAhPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgdGhpcy5fa2V5QXJyYXkgPSBbLi4udGhpcy5rZXlzKCldO1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5QXJyYXk7XG4gICAgfVxuICAgIGZpcnN0KGFtb3VudCkge1xuICAgICAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIGlmIChhbW91bnQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdChhbW91bnQgKiAtMSk7XG4gICAgICAgIGFtb3VudCA9IE1hdGgubWluKHRoaXMuc2l6ZSwgYW1vdW50KTtcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBhbW91bnQgfSwgKCkgPT4gaXRlci5uZXh0KCkudmFsdWUpO1xuICAgIH1cbiAgICBmaXJzdEtleShhbW91bnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgaWYgKGFtb3VudCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0S2V5KGFtb3VudCAqIC0xKTtcbiAgICAgICAgYW1vdW50ID0gTWF0aC5taW4odGhpcy5zaXplLCBhbW91bnQpO1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5rZXlzKCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBhbW91bnQgfSwgKCkgPT4gaXRlci5uZXh0KCkudmFsdWUpO1xuICAgIH1cbiAgICBsYXN0KGFtb3VudCkge1xuICAgICAgICBjb25zdCBhcnIgPSB0aGlzLmFycmF5KCk7XG4gICAgICAgIGlmICh0eXBlb2YgYW1vdW50ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYW1vdW50IDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0KGFtb3VudCAqIC0xKTtcbiAgICAgICAgaWYgKCFhbW91bnQpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UoLWFtb3VudCk7XG4gICAgfVxuICAgIGxhc3RLZXkoYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHRoaXMua2V5QXJyYXkoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChhbW91bnQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RLZXkoYW1vdW50ICogLTEpO1xuICAgICAgICBpZiAoIWFtb3VudClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZSgtYW1vdW50KTtcbiAgICB9XG4gICAgcmFuZG9tKGFtb3VudCkge1xuICAgICAgICBsZXQgYXJyID0gdGhpcy5hcnJheSgpO1xuICAgICAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gYXJyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpXTtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDAgfHwgIWFtb3VudClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgYXJyID0gYXJyLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBhbW91bnQgfSwgKCkgPT4gYXJyLnNwbGljZShNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnIubGVuZ3RoKSwgMSlbMF0pO1xuICAgIH1cbiAgICByYW5kb21LZXkoYW1vdW50KSB7XG4gICAgICAgIGxldCBhcnIgPSB0aGlzLmtleUFycmF5KCk7XG4gICAgICAgIGlmICh0eXBlb2YgYW1vdW50ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiBhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldO1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCB8fCAhYW1vdW50KVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBhcnIgPSBhcnIuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGFtb3VudCB9LCAoKSA9PiBhcnIuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpLCAxKVswXSk7XG4gICAgfVxuICAgIGZpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChmbih2YWwsIGtleSwgdGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kS2V5KGZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBmbiA9IGZuLmJpbmQodGhpc0FyZyk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAoZm4odmFsLCBrZXksIHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dlZXAoZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTaXplID0gdGhpcy5zaXplO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKGZuKHZhbCwga2V5LCB0aGlzKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c1NpemUgLSB0aGlzLnNpemU7XG4gICAgfVxuICAgIGZpbHRlcihmbiwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgZm4gPSBmbi5iaW5kKHRoaXNBcmcpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAoZm4odmFsLCBrZXksIHRoaXMpKVxuICAgICAgICAgICAgICAgIHJlc3VsdHMuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcGFydGl0aW9uKGZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBmbiA9IGZuLmJpbmQodGhpc0FyZyk7XG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIHJlbW92aW5nIHRoZSA8SywgVj4gZnJvbSB0aGUgY29uc3RydWN0b3JzIGFmdGVyIFRTIDMuNy4wIGlzIHJlbGVhc2VkLCBhcyBpdCBpbmZlcnMgaXRcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10oKSwgbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKCldO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKGZuKHZhbCwga2V5LCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbMF0uc2V0KGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbMV0uc2V0KGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgZmxhdE1hcChmbiwgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9ucyA9IHRoaXMubWFwKGZuLCB0aGlzQXJnKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXSgpLmNvbmNhdCguLi5jb2xsZWN0aW9ucyk7XG4gICAgfVxuICAgIG1hcChmbiwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgZm4gPSBmbi5iaW5kKHRoaXNBcmcpO1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5lbnRyaWVzKCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0aGlzLnNpemUgfSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlci5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUsIGtleSwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBWYWx1ZXMoZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcbiAgICAgICAgY29uc3QgY29sbCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXSgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcylcbiAgICAgICAgICAgIGNvbGwuc2V0KGtleSwgZm4odmFsLCBrZXksIHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgfVxuICAgIHNvbWUoZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGZuID0gZm4uYmluZCh0aGlzQXJnKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChmbih2YWwsIGtleSwgdGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBldmVyeShmbiwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgZm4gPSBmbi5iaW5kKHRoaXNBcmcpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKCFmbih2YWwsIGtleSwgdGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIHNpbmdsZSB2YWx1ZS4gSWRlbnRpY2FsIGluIGJlaGF2aW9yIHRvXG4gICAgICogW0FycmF5LnJlZHVjZSgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UpLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHVzZWQgdG8gcmVkdWNlLCB0YWtpbmcgZm91ciBhcmd1bWVudHM7IGBhY2N1bXVsYXRvcmAsIGBjdXJyZW50VmFsdWVgLCBgY3VycmVudEtleWAsXG4gICAgICogYW5kIGBjb2xsZWN0aW9uYFxuICAgICAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gU3RhcnRpbmcgdmFsdWUgZm9yIHRoZSBhY2N1bXVsYXRvclxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBleGFtcGxlIGNvbGxlY3Rpb24ucmVkdWNlKChhY2MsIGd1aWxkKSA9PiBhY2MgKyBndWlsZC5tZW1iZXJDb3VudCwgMCk7XG4gICAgICovXG4gICAgcmVkdWNlKGZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgbGV0IGFjY3VtdWxhdG9yO1xuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMpXG4gICAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBmbihhY2N1bXVsYXRvciwgdmFsLCBrZXksIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IHZhbDtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBmbihhY2N1bXVsYXRvciwgdmFsLCBrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGl0ZW1zIGl0ZXJhdGVkLlxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBjb2xsZWN0aW9uIHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgZWFjaChmbiwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLmZvckVhY2goZm4sIHRoaXNBcmcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGFwKGZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBmbiA9IGZuLmJpbmQodGhpc0FyZyk7XG4gICAgICAgIGZuKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpZGVudGljYWwgc2hhbGxvdyBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cbiAgICAgKiBAZXhhbXBsZSBjb25zdCBuZXdDb2xsID0gc29tZUNvbGwuY2xvbmUoKTtcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdGhpcyBjb2xsZWN0aW9uIHdpdGggb3RoZXJzIGludG8gYSBuZXcgY29sbGVjdGlvbi4gTm9uZSBvZiB0aGUgc291cmNlIGNvbGxlY3Rpb25zIGFyZSBtb2RpZmllZC5cbiAgICAgKiBAcGFyYW0gey4uLkNvbGxlY3Rpb259IGNvbGxlY3Rpb25zIENvbGxlY3Rpb25zIHRvIG1lcmdlXG4gICAgICogQHJldHVybnMge0NvbGxlY3Rpb259XG4gICAgICogQGV4YW1wbGUgY29uc3QgbmV3Q29sbCA9IHNvbWVDb2xsLmNvbmNhdChzb21lT3RoZXJDb2xsLCBhbm90aGVyQ29sbCwgb2hCb3lBQ29sbCk7XG4gICAgICovXG4gICAgY29uY2F0KC4uLmNvbGxlY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbGwgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGZvciAoY29uc3QgY29sbCBvZiBjb2xsZWN0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGNvbGwpXG4gICAgICAgICAgICAgICAgbmV3Q29sbC5zZXQoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdDb2xsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBjb2xsZWN0aW9uIHNoYXJlcyBpZGVudGljYWwgaXRlbXMgd2l0aCBhbm90aGVyLlxuICAgICAqIFRoaXMgaXMgZGlmZmVyZW50IHRvIGNoZWNraW5nIGZvciBlcXVhbGl0eSB1c2luZyBlcXVhbC1zaWducywgYmVjYXVzZVxuICAgICAqIHRoZSBjb2xsZWN0aW9ucyBtYXkgYmUgZGlmZmVyZW50IG9iamVjdHMsIGJ1dCBjb250YWluIHRoZSBzYW1lIGRhdGEuXG4gICAgICogQHBhcmFtIHtDb2xsZWN0aW9ufSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNvbGxlY3Rpb25zIGhhdmUgaWRlbnRpY2FsIGNvbnRlbnRzXG4gICAgICovXG4gICAgZXF1YWxzKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcyA9PT0gY29sbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBjb2xsZWN0aW9uLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvbi5oYXMoa2V5KSB8fCB2YWx1ZSAhPT0gY29sbGVjdGlvbi5nZXQoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNvcnQgbWV0aG9kIHNvcnRzIHRoZSBpdGVtcyBvZiBhIGNvbGxlY3Rpb24gaW4gcGxhY2UgYW5kIHJldHVybnMgaXQuXG4gICAgICogVGhlIHNvcnQgaXMgbm90IG5lY2Vzc2FyaWx5IHN0YWJsZSBpbiBOb2RlIDEwIG9yIG9sZGVyLlxuICAgICAqIFRoZSBkZWZhdWx0IHNvcnQgb3JkZXIgaXMgYWNjb3JkaW5nIHRvIHN0cmluZyBVbmljb2RlIGNvZGUgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlRnVuY3Rpb25dIFNwZWNpZmllcyBhIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyB0aGUgc29ydCBvcmRlci5cbiAgICAgKiBJZiBvbWl0dGVkLCB0aGUgY29sbGVjdGlvbiBpcyBzb3J0ZWQgYWNjb3JkaW5nIHRvIGVhY2ggY2hhcmFjdGVyJ3MgVW5pY29kZSBjb2RlIHBvaW50IHZhbHVlLFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgc3RyaW5nIGNvbnZlcnNpb24gb2YgZWFjaCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuICAgICAqIEBleGFtcGxlIGNvbGxlY3Rpb24uc29ydCgodXNlckEsIHVzZXJCKSA9PiB1c2VyQS5jcmVhdGVkVGltZXN0YW1wIC0gdXNlckIuY3JlYXRlZFRpbWVzdGFtcCk7XG4gICAgICovXG4gICAgc29ydChjb21wYXJlRnVuY3Rpb24gPSAoeCwgeSkgPT4gTnVtYmVyKHggPiB5KSB8fCBOdW1iZXIoeCA9PT0geSkgLSAxKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbLi4udGhpcy5lbnRyaWVzKCldO1xuICAgICAgICBlbnRyaWVzLnNvcnQoKGEsIGIpID0+IGNvbXBhcmVGdW5jdGlvbihhWzFdLCBiWzFdLCBhWzBdLCBiWzBdKSk7XG4gICAgICAgIC8vIFBlcmZvcm0gY2xlYW4tdXBcbiAgICAgICAgc3VwZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fYXJyYXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXlBcnJheSA9IG51bGw7XG4gICAgICAgIC8vIFNldCB0aGUgbmV3IGVudHJpZXNcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZW50cmllcykge1xuICAgICAgICAgICAgc3VwZXIuc2V0KGssIHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJzZWN0IG1ldGhvZCByZXR1cm5zIGEgbmV3IHN0cnVjdHVyZSBjb250YWluaW5nIGl0ZW1zIHdoZXJlIHRoZSBrZXlzIGFyZSBwcmVzZW50IGluIGJvdGggb3JpZ2luYWwgc3RydWN0dXJlcy5cbiAgICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IG90aGVyIFRoZSBvdGhlciBDb2xsZWN0aW9uIHRvIGZpbHRlciBhZ2FpbnN0XG4gICAgICogQHJldHVybnMge0NvbGxlY3Rpb259XG4gICAgICovXG4gICAgaW50ZXJzZWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5maWx0ZXIoKF8sIGspID0+IHRoaXMuaGFzKGspKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRpZmZlcmVuY2UgbWV0aG9kIHJldHVybnMgYSBuZXcgc3RydWN0dXJlIGNvbnRhaW5pbmcgaXRlbXMgd2hlcmUgdGhlIGtleSBpcyBwcmVzZW50IGluIG9uZSBvZiB0aGUgb3JpZ2luYWwgc3RydWN0dXJlcyBidXQgbm90IHRoZSBvdGhlci5cbiAgICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IG90aGVyIFRoZSBvdGhlciBDb2xsZWN0aW9uIHRvIGZpbHRlciBhZ2FpbnN0XG4gICAgICogQHJldHVybnMge0NvbGxlY3Rpb259XG4gICAgICovXG4gICAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIuZmlsdGVyKChfLCBrKSA9PiAhdGhpcy5oYXMoaykpLmNvbmNhdCh0aGlzLmZpbHRlcigoXywgaykgPT4gIW90aGVyLmhhcyhrKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc29ydGVkIG1ldGhvZCBzb3J0cyB0aGUgaXRlbXMgb2YgYSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIGl0LlxuICAgICAqIFRoZSBzb3J0IGlzIG5vdCBuZWNlc3NhcmlseSBzdGFibGUgaW4gTm9kZSAxMCBvciBvbGRlci5cbiAgICAgKiBUaGUgZGVmYXVsdCBzb3J0IG9yZGVyIGlzIGFjY29yZGluZyB0byBzdHJpbmcgVW5pY29kZSBjb2RlIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZUZ1bmN0aW9uXSBTcGVjaWZpZXMgYSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgdGhlIHNvcnQgb3JkZXIuXG4gICAgICogSWYgb21pdHRlZCwgdGhlIGNvbGxlY3Rpb24gaXMgc29ydGVkIGFjY29yZGluZyB0byBlYWNoIGNoYXJhY3RlcidzIFVuaWNvZGUgY29kZSBwb2ludCB2YWx1ZSxcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIHN0cmluZyBjb252ZXJzaW9uIG9mIGVhY2ggZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cbiAgICAgKiBAZXhhbXBsZSBjb2xsZWN0aW9uLnNvcnRlZCgodXNlckEsIHVzZXJCKSA9PiB1c2VyQS5jcmVhdGVkVGltZXN0YW1wIC0gdXNlckIuY3JlYXRlZFRpbWVzdGFtcCk7XG4gICAgICovXG4gICAgc29ydGVkKGNvbXBhcmVGdW5jdGlvbiA9ICh4LCB5KSA9PiBOdW1iZXIoeCA+IHkpIHx8IE51bWJlcih4ID09PSB5KSAtIDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShbLi4udGhpcy5lbnRyaWVzKCldKVxuICAgICAgICAgICAgLnNvcnQoKGF2LCBidiwgYWssIGJrKSA9PiBjb21wYXJlRnVuY3Rpb24oYXYsIGJ2LCBhaywgYmspKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5kZWZhdWx0ID0gQ29sbGVjdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbGxlY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUx5SXNJbk52ZFhKalpYTWlPbHNpYVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlVVRTdPenM3TzBkQlMwYzdRVUZEU0N4TlFVRk5MRlZCUVdsQ0xGTkJRVkVzUjBGQlV6dEpRVTEyUXl4WlFVRnRRaXhQUVVFclF6dFJRVU5xUlN4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRlpqczdPenM3VjBGTFJ6dFJRVU5JTEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hGUVVGRkxGRkJRVkVzUlVGQlJTeEZRVUZGTEV0QlFVc3NSVUZCUlN4SlFVRkpMRVZCUVVVc1VVRkJVU3hGUVVGRkxFbEJRVWtzUlVGQlJTeFpRVUZaTEVWQlFVVXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVVelJqczdPenM3VjBGTFJ6dFJRVU5JTEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hGUVVGRkxGZEJRVmNzUlVGQlJTeEZRVUZGTEV0QlFVc3NSVUZCUlN4SlFVRkpMRVZCUVVVc1VVRkJVU3hGUVVGRkxFbEJRVWtzUlVGQlJTeFpRVUZaTEVWQlFVVXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVNdlJpeERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4SFFVRkhMRU5CUVVNc1IwRkJUVHRSUVVOb1FpeFBRVUZQTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03U1VGRGRrSXNRMEZCUXp0SlFVVkVPenM3T3pzN1QwRk5SenRKUVVOSkxFZEJRVWNzUTBGQlF5eEhRVUZOTEVWQlFVVXNTMEZCVVR0UlFVTXhRaXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVTnVRaXhKUVVGSkxFTkJRVU1zVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVTjBRaXhQUVVGUExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRemxDTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkpMRWRCUVVjc1EwRkJReXhIUVVGTk8xRkJRMmhDTEU5QlFVOHNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dEpRVU4yUWl4RFFVRkRPMGxCUlVRN096czdPMDlCUzBjN1NVRkRTU3hOUVVGTkxFTkJRVU1zUjBGQlRUdFJRVU51UWl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF6dFJRVU51UWl4SlFVRkpMRU5CUVVNc1UwRkJVeXhIUVVGSExFbEJRVWtzUTBGQlF6dFJRVU4wUWl4UFFVRlBMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZETVVJc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hMUVVGTE8xRkJRMWdzVDBGQlR5eExRVUZMTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1NVRkRkRUlzUTBGQlF6dEpRVVZFT3pzN096czdUMEZOUnp0SlFVTkpMRXRCUVVzN1VVRkRXQ3hKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNTVUZCU1N4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUzBGQlN5eEpRVUZKTEVOQlFVTXNTVUZCU1R0WlFVRkZMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRM1pHTEU5QlFVOHNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVOd1FpeERRVUZETzBsQlJVUTdPenM3T3p0UFFVMUhPMGxCUTBrc1VVRkJVVHRSUVVOa0xFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4SlFVRkpMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeExRVUZMTEVsQlFVa3NRMEZCUXl4SlFVRkpPMWxCUVVVc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRE9VWXNUMEZCVHl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRM1pDTEVOQlFVTTdTVUZWVFN4TFFVRkxMRU5CUVVNc1RVRkJaVHRSUVVNelFpeEpRVUZKTEU5QlFVOHNUVUZCVFN4TFFVRkxMRmRCUVZjN1dVRkJSU3hQUVVGUExFbEJRVWtzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRGNrVXNTVUZCU1N4TlFVRk5MRWRCUVVjc1EwRkJRenRaUVVGRkxFOUJRVThzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU01UXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRM0pETEUxQlFVMHNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dFJRVU16UWl4UFFVRlBMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeE5RVUZOTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVc1IwRkJUU3hGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRMjVGTEVOQlFVTTdTVUZWVFN4UlFVRlJMRU5CUVVNc1RVRkJaVHRSUVVNNVFpeEpRVUZKTEU5QlFVOHNUVUZCVFN4TFFVRkxMRmRCUVZjN1dVRkJSU3hQUVVGUExFbEJRVWtzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRGJrVXNTVUZCU1N4TlFVRk5MRWRCUVVjc1EwRkJRenRaUVVGRkxFOUJRVThzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5xUkN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRM0pETEUxQlFVMHNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF6dFJRVU42UWl4UFFVRlBMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeE5RVUZOTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVc1IwRkJUU3hGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRMjVGTEVOQlFVTTdTVUZYVFN4SlFVRkpMRU5CUVVNc1RVRkJaVHRSUVVNeFFpeE5RVUZOTEVkQlFVY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03VVVGRGVrSXNTVUZCU1N4UFFVRlBMRTFCUVUwc1MwRkJTeXhYUVVGWE8xbEJRVVVzVDBGQlR5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU01UkN4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRE8xbEJRVVVzVDBGQlR5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF5OURMRWxCUVVrc1EwRkJReXhOUVVGTk8xbEJRVVVzVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZEZGtJc1QwRkJUeXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRNMElzUTBGQlF6dEpRVmROTEU5QlFVOHNRMEZCUXl4TlFVRmxPMUZCUXpkQ0xFMUJRVTBzUjBGQlJ5eEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVNMVFpeEpRVUZKTEU5QlFVOHNUVUZCVFN4TFFVRkxMRmRCUVZjN1dVRkJSU3hQUVVGUExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemxFTEVsQlFVa3NUVUZCVFN4SFFVRkhMRU5CUVVNN1dVRkJSU3hQUVVGUExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJFUXNTVUZCU1N4RFFVRkRMRTFCUVUwN1dVRkJSU3hQUVVGUExFVkJRVVVzUTBGQlF6dFJRVU4yUWl4UFFVRlBMRWRCUVVjc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wbEJWVTBzVFVGQlRTeERRVUZETEUxQlFXVTdVVUZETlVJc1NVRkJTU3hIUVVGSExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMUZCUTNaQ0xFbEJRVWtzVDBGQlR5eE5RVUZOTEV0QlFVc3NWMEZCVnp0WlFVRkZMRTlCUVU4c1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hIUVVGSExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSR0xFbEJRVWtzUjBGQlJ5eERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTk8xbEJRVVVzVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZETTBNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXp0UlFVTnNRaXhQUVVGUExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4TlFVRk5MRVZCUVVVc1RVRkJUU3hGUVVGRkxFVkJRVVVzUjBGQlRTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1IwRkJSeXhIUVVGSExFTkJRVU1zVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU14Unl4RFFVRkRPMGxCVlUwc1UwRkJVeXhEUVVGRExFMUJRV1U3VVVGREwwSXNTVUZCU1N4SFFVRkhMRWRCUVVjc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFGQlF6RkNMRWxCUVVrc1QwRkJUeXhOUVVGTkxFdEJRVXNzVjBGQlZ6dFpRVUZGTEU5QlFVOHNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4SFFVRkhMRWRCUVVjc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkdMRWxCUVVrc1IwRkJSeXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5PMWxCUVVVc1QwRkJUeXhGUVVGRkxFTkJRVU03VVVGRE0wTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF6dFJRVU5zUWl4UFFVRlBMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeE5RVUZOTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVc1IwRkJUU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVWQlFVVXNSMEZCUnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNeFJ5eERRVUZETzBsQlpVMHNTVUZCU1N4RFFVRkRMRVZCUVcxRUxFVkJRVVVzVDBGQmFVSTdVVUZEYWtZc1NVRkJTU3hQUVVGUExFOUJRVThzUzBGQlN5eFhRVUZYTzFsQlFVVXNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZETVVRc1MwRkJTeXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4SlFVRkpMRWxCUVVrc1JVRkJSVHRaUVVNNVFpeEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFbEJRVWtzUTBGQlF6dG5Ra0ZCUlN4UFFVRlBMRWRCUVVjc1EwRkJRenRUUVVOdVF6dFJRVU5FTEU5QlFVOHNVMEZCVXl4RFFVRkRPMGxCUTJ4Q0xFTkJRVU03U1VGaFRTeFBRVUZQTEVOQlFVTXNSVUZCYlVRc1JVRkJSU3hQUVVGcFFqdFJRVU53Uml4SlFVRkpMRTlCUVU4c1QwRkJUeXhMUVVGTExGZEJRVmM3V1VGQlJTeEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU14UkN4TFFVRkxMRTFCUVUwc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVsQlFVa3NTVUZCU1N4RlFVRkZPMWxCUXpsQ0xFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1NVRkJTU3hEUVVGRE8yZENRVUZGTEU5QlFVOHNSMEZCUnl4RFFVRkRPMU5CUTI1RE8xRkJRMFFzVDBGQlR5eFRRVUZUTEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVZWTkxFdEJRVXNzUTBGQlF5eEZRVUZ0UkN4RlFVRkZMRTlCUVdsQ08xRkJRMnhHTEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1YwRkJWenRaUVVGRkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRekZFTEUxQlFVMHNXVUZCV1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGREwwSXNTMEZCU3l4TlFVRk5MRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eEpRVUZKTEVsQlFVa3NSVUZCUlR0WlFVTTVRaXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWxCUVVrc1EwRkJRenRuUWtGQlJTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xTkJRM3BETzFGQlEwUXNUMEZCVHl4WlFVRlpMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU5xUXl4RFFVRkRPMGxCWVUwc1RVRkJUU3hEUVVGRExFVkJRVzFFTEVWQlFVVXNUMEZCYVVJN1VVRkRia1lzU1VGQlNTeFBRVUZQTEU5QlFVOHNTMEZCU3l4WFFVRlhPMWxCUVVVc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRNVVFzVFVGQlRTeFBRVUZQTEVkQlFVY3NTVUZCU1N4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCWjBJc1EwRkJRenRSUVVOeVJTeExRVUZMTEUxQlFVMHNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFbEJRVWtzU1VGQlNTeEZRVUZGTzFsQlF6bENMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNTVUZCU1N4RFFVRkRPMmRDUVVGRkxFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRE8xTkJRemxETzFGQlEwUXNUMEZCVHl4UFFVRlBMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVmxOTEZOQlFWTXNRMEZCUXl4RlFVRnRSQ3hGUVVGRkxFOUJRV2xDTzFGQlEzUkdMRWxCUVVrc1QwRkJUeXhQUVVGUExFdEJRVXNzVjBGQlZ6dFpRVUZGTEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlF6RkVMSFZIUVVGMVJ6dFJRVU4yUnl4TlFVRk5MRTlCUVU4c1IwRkJhVUlzUTBGQlF5eEpRVUZKTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZuUWl4RlFVRkZMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVdkQ0xFTkJRVU1zUTBGQlF6dFJRVU16U1N4TFFVRkxMRTFCUVUwc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVsQlFVa3NTVUZCU1N4RlFVRkZPMWxCUXpsQ0xFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1NVRkJTU3hEUVVGRExFVkJRVVU3WjBKQlEzWkNMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRE8yRkJRM3BDTzJsQ1FVRk5PMmRDUVVOT0xFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETzJGQlEzcENPMU5CUTBRN1VVRkRSQ3hQUVVGUExFOUJRVThzUTBGQlF6dEpRVU5vUWl4RFFVRkRPMGxCV1Uwc1QwRkJUeXhEUVVGSkxFVkJRVFJFTEVWQlFVVXNUMEZCYVVJN1VVRkRhRWNzVFVGQlRTeFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdVVUZETVVNc1QwRkJVU3hKUVVGSkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVFMlFpeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRmRCUVZjc1EwRkJReXhEUVVGRE8wbEJRMnhITEVOQlFVTTdTVUZaVFN4SFFVRkhMRU5CUVVrc1JVRkJOa01zUlVGQlJTeFBRVUZwUWp0UlFVTTNSU3hKUVVGSkxFOUJRVThzVDBGQlR5eExRVUZMTEZkQlFWYzdXVUZCUlN4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTXhSQ3hOUVVGTkxFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1VVRkROVUlzVDBGQlR5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVWQlFVVXNSVUZCUlN4SFFVRk5MRVZCUVVVN1dVRkRhRVFzVFVGQlRTeERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRPMWxCUTNaRExFOUJRVThzUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4SFFVRkhMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRE4wSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRTaXhEUVVGRE8wbEJXVTBzVTBGQlV5eERRVUZKTEVWQlFUWkRMRVZCUVVVc1QwRkJhVUk3VVVGRGJrWXNTVUZCU1N4UFFVRlBMRTlCUVU4c1MwRkJTeXhYUVVGWE8xbEJRVVVzUlVGQlJTeEhRVUZITEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRE1VUXNUVUZCVFN4SlFVRkpMRWRCUVVjc1NVRkJTU3hKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJORUlzUTBGQlF6dFJRVU01UlN4TFFVRkxMRTFCUVUwc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVsQlFVa3NTVUZCU1R0WlFVRkZMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtVc1QwRkJUeXhKUVVGSkxFTkJRVU03U1VGRFlpeERRVUZETzBsQldVMHNTVUZCU1N4RFFVRkRMRVZCUVcxRUxFVkJRVVVzVDBGQmFVSTdVVUZEYWtZc1NVRkJTU3hQUVVGUExFOUJRVThzUzBGQlN5eFhRVUZYTzFsQlFVVXNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZETVVRc1MwRkJTeXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4SlFVRkpMRWxCUVVrc1JVRkJSVHRaUVVNNVFpeEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFbEJRVWtzUTBGQlF6dG5Ra0ZCUlN4UFFVRlBMRWxCUVVrc1EwRkJRenRUUVVOd1F6dFJRVU5FTEU5QlFVOHNTMEZCU3l4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVZsTkxFdEJRVXNzUTBGQlF5eEZRVUZ0UkN4RlFVRkZMRTlCUVdsQ08xRkJRMnhHTEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1YwRkJWenRaUVVGRkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRekZFTEV0QlFVc3NUVUZCVFN4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFTkJRVU1zU1VGQlNTeEpRVUZKTEVWQlFVVTdXVUZET1VJc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWxCUVVrc1EwRkJRenRuUWtGQlJTeFBRVUZQTEV0QlFVc3NRMEZCUXp0VFFVTjBRenRSUVVORUxFOUJRVThzU1VGQlNTeERRVUZETzBsQlEySXNRMEZCUXp0SlFVVkVPenM3T3pzN096dFBRVkZITzBsQlEwa3NUVUZCVFN4RFFVRkpMRVZCUVRaRUxFVkJRVVVzV1VGQlowSTdVVUZETDBZc1NVRkJTU3hYUVVGbExFTkJRVU03VVVGRmNFSXNTVUZCU1N4UFFVRlBMRmxCUVZrc1MwRkJTeXhYUVVGWExFVkJRVVU3V1VGRGVFTXNWMEZCVnl4SFFVRkhMRmxCUVZrc1EwRkJRenRaUVVNelFpeExRVUZMTEUxQlFVMHNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFbEJRVWtzU1VGQlNUdG5Ra0ZCUlN4WFFVRlhMRWRCUVVjc1JVRkJSU3hEUVVGRExGZEJRVmNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRemRGTEU5QlFVOHNWMEZCVnl4RFFVRkRPMU5CUTI1Q08xRkJRMFFzU1VGQlNTeExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTJwQ0xFdEJRVXNzVFVGQlRTeERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1NVRkJTU3hKUVVGSkxFVkJRVVU3V1VGRE9VSXNTVUZCU1N4TFFVRkxMRVZCUVVVN1owSkJRMVlzVjBGQlZ5eEhRVUZITEVkQlFXMUNMRU5CUVVNN1owSkJRMnhETEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNN1owSkJRMlFzVTBGQlV6dGhRVU5VTzFsQlEwUXNWMEZCVnl4SFFVRkhMRVZCUVVVc1EwRkJReXhYUVVGWExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRUUVVNNVF6dFJRVVZFTEhGQ1FVRnhRanRSUVVOeVFpeEpRVUZKTEV0QlFVc3NSVUZCUlR0WlFVTldMRTFCUVUwc1NVRkJTU3hUUVVGVExFTkJRVU1zYTBSQlFXdEVMRU5CUVVNc1EwRkJRenRUUVVONFJUdFJRVVZFTEU5QlFVOHNWMEZCVnl4RFFVRkRPMGxCUTNCQ0xFTkJRVU03U1VGcFFrMHNTVUZCU1N4RFFVRkRMRVZCUVdkRUxFVkJRVVVzVDBGQmFVSTdVVUZET1VVc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZuUkN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRM2hGTEU5QlFVOHNTVUZCU1N4RFFVRkRPMGxCUTJJc1EwRkJRenRKUVdWTkxFZEJRVWNzUTBGQlF5eEZRVUU0UWl4RlFVRkZMRTlCUVdsQ08xRkJRek5FTEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1YwRkJWenRaUVVGRkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRekZFTEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOVUxFOUJRVThzU1VGQlNTeERRVUZETzBsQlEySXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TFFVRkxPMUZCUTFnc1QwRkJUeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlV5eERRVUZETzBsQlF6TkVMRU5CUVVNN1NVRkZSRHM3T3pzN1QwRkxSenRKUVVOSkxFMUJRVTBzUTBGQlF5eEhRVUZITEZkQlFTdENPMUZCUXk5RExFMUJRVTBzVDBGQlR5eEhRVUZITEVsQlFVa3NRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJRenRSUVVNM1FpeExRVUZMTEUxQlFVMHNTVUZCU1N4SlFVRkpMRmRCUVZjc1JVRkJSVHRaUVVNdlFpeExRVUZMTEUxQlFVMHNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFbEJRVWtzU1VGQlNUdG5Ra0ZCUlN4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0VFFVTnlSRHRSUVVORUxFOUJRVThzVDBGQlR5eERRVUZETzBsQlEyaENMRU5CUVVNN1NVRkZSRHM3T3pzN08wOUJUVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNWVUZCTkVJN1VVRkRla01zU1VGQlNTeERRVUZETEZWQlFWVTdXVUZCUlN4UFFVRlBMRXRCUVVzc1EwRkJRenRSUVVNNVFpeEpRVUZKTEVsQlFVa3NTMEZCU3l4VlFVRlZPMWxCUVVVc1QwRkJUeXhKUVVGSkxFTkJRVU03VVVGRGNrTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1NVRkJTU3hMUVVGTExGVkJRVlVzUTBGQlF5eEpRVUZKTzFsQlFVVXNUMEZCVHl4TFFVRkxMRU5CUVVNN1VVRkRhRVFzUzBGQlN5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc1EwRkJReXhKUVVGSkxFbEJRVWtzUlVGQlJUdFpRVU5vUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4TFFVRkxMRXRCUVVzc1ZVRkJWU3hEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlR0blFrRkRNVVFzVDBGQlR5eExRVUZMTEVOQlFVTTdZVUZEWWp0VFFVTkVPMUZCUTBRc1QwRkJUeXhKUVVGSkxFTkJRVU03U1VGRFlpeERRVUZETzBsQlJVUTdPenM3T3pzN096dFBRVk5ITzBsQlEwa3NTVUZCU1N4RFFVRkRMR3RDUVVGM1JpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVZVc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1RVRkJUU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRPMUZCUTNwS0xFMUJRVTBzVDBGQlR5eEhRVUZITEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU53UXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCVlN4RlFVRkZMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGZUVVc2JVSkJRVzFDTzFGQlEyNUNMRXRCUVVzc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF6dFJRVU5rTEVsQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRMjVDTEVsQlFVa3NRMEZCUXl4VFFVRlRMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJSWFJDTEhOQ1FVRnpRanRSUVVOMFFpeExRVUZMTEUxQlFVMHNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzVDBGQlR5eEZRVUZGTzFsQlF6ZENMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTJoQ08xRkJRMFFzVDBGQlR5eEpRVUZKTEVOQlFVTTdTVUZEWWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRk5CUVZNc1EwRkJReXhMUVVGMVFqdFJRVU4yUXl4UFFVRlBMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkROVU1zUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeFZRVUZWTEVOQlFVTXNTMEZCZFVJN1VVRkRlRU1zVDBGQlR5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRekZHTEVOQlFVTTdTVUZGUkRzN096czdPenM3TzA5QlUwYzdTVUZEU1N4TlFVRk5MRU5CUVVNc2EwSkJRWGRHTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJWU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hOUVVGTkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNN1VVRkRNMG9zVDBGQlVTeEpRVUZKTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zUTBGQlZUdGhRVU40UlN4SlFVRkpMRU5CUVVNc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hEUVVGRExHVkJRV1VzUTBGQlF5eEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlF6ZEVMRU5CUVVNN08wRkJTVThzWjBOQlFWVTdRVUZ3YWtKTExHdENRVUZQTEVkQlFYTkNMRlZCUVZVc1EwRkJRenRCUVcxcVFtaEZMRTFCUVUwc1EwRkJReXhQUVVGUExFZEJRVWNzVlVGQlZTeERRVUZETzBGQlJUVkNMR3RDUVVGbExGVkJRVlVzUTBGQlF5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbVY0Y0c5eWRDQnBiblJsY21aaFkyVWdRMjlzYkdWamRHbHZia052Ym5OMGNuVmpkRzl5SUh0Y2JseDBibVYzS0NrNklFTnZiR3hsWTNScGIyNDhkVzVyYm05M2Jpd2dkVzVyYm05M2JqNDdYRzVjZEc1bGR6eExMQ0JXUGlobGJuUnlhV1Z6UHpvZ1VtVmhaRzl1YkhsQmNuSmhlVHh5WldGa2IyNXNlU0JiU3l3Z1ZsMCtJSHdnYm5Wc2JDazZJRU52Ykd4bFkzUnBiMjQ4U3l3Z1ZqNDdYRzVjZEc1bGR6eExMQ0JXUGlocGRHVnlZV0pzWlRvZ1NYUmxjbUZpYkdVOGNtVmhaRzl1YkhrZ1cwc3NJRlpkUGlrNklFTnZiR3hsWTNScGIyNDhTeXdnVmo0N1hHNWNkSEpsWVdSdmJteDVJSEJ5YjNSdmRIbHdaVG9nUTI5c2JHVmpkR2x2Ymp4MWJtdHViM2R1TENCMWJtdHViM2R1UGp0Y2JseDBjbVZoWkc5dWJIa2dXMU41YldKdmJDNXpjR1ZqYVdWelhUb2dRMjlzYkdWamRHbHZia052Ym5OMGNuVmpkRzl5TzF4dWZWeHVYRzR2S2lwY2JpQXFJRUVnVFdGd0lIZHBkR2dnWVdSa2FYUnBiMjVoYkNCMWRHbHNhWFI1SUcxbGRHaHZaSE11SUZSb2FYTWdhWE1nZFhObFpDQjBhSEp2ZFdkb2IzVjBJR1JwYzJOdmNtUXVhbk1nY21GMGFHVnlJSFJvWVc0Z1FYSnlZWGx6SUdadmNpQmhibmwwYUdsdVp5QjBhR0YwSUdoaGMxeHVJQ29nWVc0Z1NVUXNJR1p2Y2lCemFXZHVhV1pwWTJGdWRHeDVJR2x0Y0hKdmRtVmtJSEJsY21admNtMWhibU5sSUdGdVpDQmxZWE5sTFc5bUxYVnpaUzVjYmlBcUlFQmxlSFJsYm1SeklIdE5ZWEI5WEc0Z0tpQkFjSEp2Y0dWeWRIa2dlMjUxYldKbGNuMGdjMmw2WlNBdElGUm9aU0JoYlc5MWJuUWdiMllnWld4bGJXVnVkSE1nYVc0Z2RHaHBjeUJqYjJ4c1pXTjBhVzl1TGx4dUlDb3ZYRzVqYkdGemN5QkRiMnhzWldOMGFXOXVQRXNzSUZZK0lHVjRkR1Z1WkhNZ1RXRndQRXNzSUZZK0lIdGNibHgwY0hKcGRtRjBaU0JmWVhKeVlYa2hPaUJXVzEwZ2ZDQnVkV3hzTzF4dVhIUndjbWwyWVhSbElGOXJaWGxCY25KaGVTRTZJRXRiWFNCOElHNTFiR3c3WEc1Y2RIQjFZbXhwWXlCemRHRjBhV01nY21WaFpHOXViSGtnWkdWbVlYVnNkRG9nZEhsd1pXOW1JRU52Ykd4bFkzUnBiMjRnUFNCRGIyeHNaV04wYVc5dU8xeHVYSFJ3ZFdKc2FXTWdXeWRqYjI1emRISjFZM1J2Y2lkZE9pQjBlWEJsYjJZZ1EyOXNiR1ZqZEdsdmJqdGNibHh1WEhSd2RXSnNhV01nWTI5dWMzUnlkV04wYjNJb1pXNTBjbWxsY3o4NklGSmxZV1J2Ym14NVFYSnlZWGs4Y21WaFpHOXViSGtnVzBzc0lGWmRQaUI4SUc1MWJHd3BJSHRjYmx4MFhIUnpkWEJsY2lobGJuUnlhV1Z6S1R0Y2JseHVYSFJjZEM4cUtseHVYSFJjZENBcUlFTmhZMmhsWkNCaGNuSmhlU0JtYjNJZ2RHaGxJR0JoY25KaGVTZ3BZQ0J0WlhSb2IyUWdMU0IzYVd4c0lHSmxJSEpsYzJWMElIUnZJR0J1ZFd4c1lDQjNhR1Z1WlhabGNpQmdjMlYwS0NsZ0lHOXlJR0JrWld4bGRHVW9LV0FnWVhKbElHTmhiR3hsWkZ4dVhIUmNkQ0FxSUVCdVlXMWxJRU52Ykd4bFkzUnBiMjRqWDJGeWNtRjVYRzVjZEZ4MElDb2dRSFI1Y0dVZ2V6OUJjbkpoZVgxY2JseDBYSFFnS2lCQWNISnBkbUYwWlZ4dVhIUmNkQ0FxTDF4dVhIUmNkRTlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowZVNoMGFHbHpMQ0FuWDJGeWNtRjVKeXdnZXlCMllXeDFaVG9nYm5Wc2JDd2dkM0pwZEdGaWJHVTZJSFJ5ZFdVc0lHTnZibVpwWjNWeVlXSnNaVG9nZEhKMVpTQjlLVHRjYmx4dVhIUmNkQzhxS2x4dVhIUmNkQ0FxSUVOaFkyaGxaQ0JoY25KaGVTQm1iM0lnZEdobElHQnJaWGxCY25KaGVTZ3BZQ0J0WlhSb2IyUWdMU0IzYVd4c0lHSmxJSEpsYzJWMElIUnZJR0J1ZFd4c1lDQjNhR1Z1WlhabGNpQmdjMlYwS0NsZ0lHOXlJR0JrWld4bGRHVW9LV0FnWVhKbElHTmhiR3hsWkZ4dVhIUmNkQ0FxSUVCdVlXMWxJRU52Ykd4bFkzUnBiMjRqWDJ0bGVVRnljbUY1WEc1Y2RGeDBJQ29nUUhSNWNHVWdlejlCY25KaGVYMWNibHgwWEhRZ0tpQkFjSEpwZG1GMFpWeHVYSFJjZENBcUwxeHVYSFJjZEU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGVTaDBhR2x6TENBblgydGxlVUZ5Y21GNUp5d2dleUIyWVd4MVpUb2diblZzYkN3Z2QzSnBkR0ZpYkdVNklIUnlkV1VzSUdOdmJtWnBaM1Z5WVdKc1pUb2dkSEoxWlNCOUtUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJKWkdWdWRHbGpZV3dnZEc4Z1cwMWhjQzVuWlhRb0tWMG9hSFIwY0hNNkx5OWtaWFpsYkc5d1pYSXViVzk2YVd4c1lTNXZjbWN2Wlc0dFZWTXZaRzlqY3k5WFpXSXZTbUYyWVZOamNtbHdkQzlTWldabGNtVnVZMlV2UjJ4dlltRnNYMDlpYW1WamRITXZUV0Z3TDJkbGRDa3VYRzVjZENBcUlFZGxkSE1nWVc0Z1pXeGxiV1Z1ZENCM2FYUm9JSFJvWlNCemNHVmphV1pwWldRZ2EyVjVMQ0JoYm1RZ2NtVjBkWEp1Y3lCcGRITWdkbUZzZFdVc0lHOXlJR0IxYm1SbFptbHVaV1JnSUdsbUlIUm9aU0JsYkdWdFpXNTBJR1J2WlhNZ2JtOTBJR1Y0YVhOMExseHVYSFFnS2lCQWNHRnlZVzBnZXlwOUlHdGxlU0F0SUZSb1pTQnJaWGtnZEc4Z1oyVjBJR1p5YjIwZ2RHaHBjeUJqYjJ4c1pXTjBhVzl1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHNxSUh3Z2RXNWtaV1pwYm1Wa2ZWeHVYSFFnS2k5Y2JseDBjSFZpYkdsaklHZGxkQ2hyWlhrNklFc3BPaUJXSUh3Z2RXNWtaV1pwYm1Wa0lIdGNibHgwWEhSeVpYUjFjbTRnYzNWd1pYSXVaMlYwS0d0bGVTazdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nU1dSbGJuUnBZMkZzSUhSdklGdE5ZWEF1YzJWMEtDbGRLR2gwZEhCek9pOHZaR1YyWld4dmNHVnlMbTF2ZW1sc2JHRXViM0puTDJWdUxWVlRMMlJ2WTNNdlYyVmlMMHBoZG1GVFkzSnBjSFF2VW1WbVpYSmxibU5sTDBkc2IySmhiRjlQWW1wbFkzUnpMMDFoY0M5elpYUXBMbHh1WEhRZ0tpQlRaWFJ6SUdFZ2JtVjNJR1ZzWlcxbGJuUWdhVzRnZEdobElHTnZiR3hsWTNScGIyNGdkMmwwYUNCMGFHVWdjM0JsWTJsbWFXVmtJR3RsZVNCaGJtUWdkbUZzZFdVdVhHNWNkQ0FxSUVCd1lYSmhiU0I3S24wZ2EyVjVJQzBnVkdobElHdGxlU0J2WmlCMGFHVWdaV3hsYldWdWRDQjBieUJoWkdSY2JseDBJQ29nUUhCaGNtRnRJSHNxZlNCMllXeDFaU0F0SUZSb1pTQjJZV3gxWlNCdlppQjBhR1VnWld4bGJXVnVkQ0IwYnlCaFpHUmNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UwTnZiR3hsWTNScGIyNTlYRzVjZENBcUwxeHVYSFJ3ZFdKc2FXTWdjMlYwS0d0bGVUb2dTeXdnZG1Gc2RXVTZJRllwT2lCMGFHbHpJSHRjYmx4MFhIUjBhR2x6TGw5aGNuSmhlU0E5SUc1MWJHdzdYRzVjZEZ4MGRHaHBjeTVmYTJWNVFYSnlZWGtnUFNCdWRXeHNPMXh1WEhSY2RISmxkSFZ5YmlCemRYQmxjaTV6WlhRb2EyVjVMQ0IyWVd4MVpTazdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nU1dSbGJuUnBZMkZzSUhSdklGdE5ZWEF1YUdGektDbGRLR2gwZEhCek9pOHZaR1YyWld4dmNHVnlMbTF2ZW1sc2JHRXViM0puTDJWdUxWVlRMMlJ2WTNNdlYyVmlMMHBoZG1GVFkzSnBjSFF2VW1WbVpYSmxibU5sTDBkc2IySmhiRjlQWW1wbFkzUnpMMDFoY0M5b1lYTXBMbHh1WEhRZ0tpQkRhR1ZqYTNNZ2FXWWdZVzRnWld4bGJXVnVkQ0JsZUdsemRITWdhVzRnZEdobElHTnZiR3hsWTNScGIyNHVYRzVjZENBcUlFQndZWEpoYlNCN0tuMGdhMlY1SUMwZ1ZHaGxJR3RsZVNCdlppQjBhR1VnWld4bGJXVnVkQ0IwYnlCamFHVmpheUJtYjNKY2JseDBJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUdCMGNuVmxZQ0JwWmlCMGFHVWdaV3hsYldWdWRDQmxlR2x6ZEhNc0lHQm1ZV3h6WldBZ2FXWWdhWFFnWkc5bGN5QnViM1FnWlhocGMzUXVYRzVjZENBcUwxeHVYSFJ3ZFdKc2FXTWdhR0Z6S0d0bGVUb2dTeWs2SUdKdmIyeGxZVzRnZTF4dVhIUmNkSEpsZEhWeWJpQnpkWEJsY2k1b1lYTW9hMlY1S1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkpaR1Z1ZEdsallXd2dkRzhnVzAxaGNDNWtaV3hsZEdVb0tWMG9hSFIwY0hNNkx5OWtaWFpsYkc5d1pYSXViVzk2YVd4c1lTNXZjbWN2Wlc0dFZWTXZaRzlqY3k5WFpXSXZTbUYyWVZOamNtbHdkQzlTWldabGNtVnVZMlV2UjJ4dlltRnNYMDlpYW1WamRITXZUV0Z3TDJSbGJHVjBaU2t1WEc1Y2RDQXFJRVJsYkdWMFpYTWdZVzRnWld4bGJXVnVkQ0JtY205dElIUm9aU0JqYjJ4c1pXTjBhVzl1TGx4dVhIUWdLaUJBY0dGeVlXMGdleXA5SUd0bGVTQXRJRlJvWlNCclpYa2dkRzhnWkdWc1pYUmxJR1p5YjIwZ2RHaGxJR052Ykd4bFkzUnBiMjVjYmx4MElDb2dRSEpsZEhWeWJuTWdlMkp2YjJ4bFlXNTlJR0IwY25WbFlDQnBaaUIwYUdVZ1pXeGxiV1Z1ZENCM1lYTWdjbVZ0YjNabFpDd2dZR1poYkhObFlDQnBaaUIwYUdVZ1pXeGxiV1Z1ZENCa2IyVnpJRzV2ZENCbGVHbHpkQzVjYmx4MElDb3ZYRzVjZEhCMVlteHBZeUJrWld4bGRHVW9hMlY1T2lCTEtUb2dZbTl2YkdWaGJpQjdYRzVjZEZ4MGRHaHBjeTVmWVhKeVlYa2dQU0J1ZFd4c08xeHVYSFJjZEhSb2FYTXVYMnRsZVVGeWNtRjVJRDBnYm5Wc2JEdGNibHgwWEhSeVpYUjFjbTRnYzNWd1pYSXVaR1ZzWlhSbEtHdGxlU2s3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1NXUmxiblJwWTJGc0lIUnZJRnROWVhBdVkyeGxZWElvS1Ywb2FIUjBjSE02THk5a1pYWmxiRzl3WlhJdWJXOTZhV3hzWVM1dmNtY3ZaVzR0VlZNdlpHOWpjeTlYWldJdlNtRjJZVk5qY21sd2RDOVNaV1psY21WdVkyVXZSMnh2WW1Gc1gwOWlhbVZqZEhNdlRXRndMMk5zWldGeUtTNWNibHgwSUNvZ1VtVnRiM1psY3lCaGJHd2daV3hsYldWdWRITWdabkp2YlNCMGFHVWdZMjlzYkdWamRHbHZiaTVjYmx4MElDb2dRSEpsZEhWeWJuTWdlM1Z1WkdWbWFXNWxaSDFjYmx4MElDb3ZYRzVjZEhCMVlteHBZeUJqYkdWaGNpZ3BPaUIyYjJsa0lIdGNibHgwWEhSeVpYUjFjbTRnYzNWd1pYSXVZMnhsWVhJb0tUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJEY21WaGRHVnpJR0Z1SUc5eVpHVnlaV1FnWVhKeVlYa2diMllnZEdobElIWmhiSFZsY3lCdlppQjBhR2x6SUdOdmJHeGxZM1JwYjI0c0lHRnVaQ0JqWVdOb1pYTWdhWFFnYVc1MFpYSnVZV3hzZVM0Z1ZHaGxJR0Z5Y21GNUlIZHBiR3dnYjI1c2VTQmlaVnh1WEhRZ0tpQnlaV052Ym5OMGNuVmpkR1ZrSUdsbUlHRnVJR2wwWlcwZ2FYTWdZV1JrWldRZ2RHOGdiM0lnY21WdGIzWmxaQ0JtY205dElIUm9aU0JqYjJ4c1pXTjBhVzl1TENCdmNpQnBaaUI1YjNVZ1kyaGhibWRsSUhSb1pTQnNaVzVuZEdnZ2IyWWdkR2hsSUdGeWNtRjVYRzVjZENBcUlHbDBjMlZzWmk0Z1NXWWdlVzkxSUdSdmJpZDBJSGRoYm5RZ2RHaHBjeUJqWVdOb2FXNW5JR0psYUdGMmFXOXlMQ0IxYzJVZ1lGc3VMaTVqYjJ4c1pXTjBhVzl1TG5aaGJIVmxjeWdwWFdBZ2IzSmNibHgwSUNvZ1lFRnljbUY1TG1aeWIyMG9ZMjlzYkdWamRHbHZiaTUyWVd4MVpYTW9LU2xnSUdsdWMzUmxZV1F1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHRCY25KaGVYMWNibHgwSUNvdlhHNWNkSEIxWW14cFl5QmhjbkpoZVNncE9pQldXMTBnZTF4dVhIUmNkR2xtSUNnaGRHaHBjeTVmWVhKeVlYa2dmSHdnZEdocGN5NWZZWEp5WVhrdWJHVnVaM1JvSUNFOVBTQjBhR2x6TG5OcGVtVXBJSFJvYVhNdVgyRnljbUY1SUQwZ1d5NHVMblJvYVhNdWRtRnNkV1Z6S0NsZE8xeHVYSFJjZEhKbGRIVnliaUIwYUdsekxsOWhjbkpoZVR0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkRjbVZoZEdWeklHRnVJRzl5WkdWeVpXUWdZWEp5WVhrZ2IyWWdkR2hsSUd0bGVYTWdiMllnZEdocGN5QmpiMnhzWldOMGFXOXVMQ0JoYm1RZ1kyRmphR1Z6SUdsMElHbHVkR1Z5Ym1Gc2JIa3VJRlJvWlNCaGNuSmhlU0IzYVd4c0lHOXViSGtnWW1WY2JseDBJQ29nY21WamIyNXpkSEoxWTNSbFpDQnBaaUJoYmlCcGRHVnRJR2x6SUdGa1pHVmtJSFJ2SUc5eUlISmxiVzkyWldRZ1puSnZiU0IwYUdVZ1kyOXNiR1ZqZEdsdmJpd2diM0lnYVdZZ2VXOTFJR05vWVc1blpTQjBhR1VnYkdWdVozUm9JRzltSUhSb1pTQmhjbkpoZVZ4dVhIUWdLaUJwZEhObGJHWXVJRWxtSUhsdmRTQmtiMjRuZENCM1lXNTBJSFJvYVhNZ1kyRmphR2x1WnlCaVpXaGhkbWx2Y2l3Z2RYTmxJR0JiTGk0dVkyOXNiR1ZqZEdsdmJpNXJaWGx6S0NsZFlDQnZjbHh1WEhRZ0tpQmdRWEp5WVhrdVpuSnZiU2hqYjJ4c1pXTjBhVzl1TG10bGVYTW9LU2xnSUdsdWMzUmxZV1F1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHRCY25KaGVYMWNibHgwSUNvdlhHNWNkSEIxWW14cFl5QnJaWGxCY25KaGVTZ3BPaUJMVzEwZ2UxeHVYSFJjZEdsbUlDZ2hkR2hwY3k1ZmEyVjVRWEp5WVhrZ2ZId2dkR2hwY3k1ZmEyVjVRWEp5WVhrdWJHVnVaM1JvSUNFOVBTQjBhR2x6TG5OcGVtVXBJSFJvYVhNdVgydGxlVUZ5Y21GNUlEMGdXeTR1TG5Sb2FYTXVhMlY1Y3lncFhUdGNibHgwWEhSeVpYUjFjbTRnZEdocGN5NWZhMlY1UVhKeVlYazdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nVDJKMFlXbHVjeUIwYUdVZ1ptbHljM1FnZG1Gc2RXVW9jeWtnYVc0Z2RHaHBjeUJqYjJ4c1pXTjBhVzl1TGx4dVhIUWdLaUJBY0dGeVlXMGdlMjUxYldKbGNuMGdXMkZ0YjNWdWRGMGdRVzF2ZFc1MElHOW1JSFpoYkhWbGN5QjBieUJ2WW5SaGFXNGdabkp2YlNCMGFHVWdZbVZuYVc1dWFXNW5YRzVjZENBcUlFQnlaWFIxY201eklIc3FmRUZ5Y21GNVBDbytmU0JCSUhOcGJtZHNaU0IyWVd4MVpTQnBaaUJ1YnlCaGJXOTFiblFnYVhNZ2NISnZkbWxrWldRZ2IzSWdZVzRnWVhKeVlYa2diMllnZG1Gc2RXVnpMQ0J6ZEdGeWRHbHVaeUJtY205dElIUm9aU0JsYm1RZ2FXWmNibHgwSUNvZ1lXMXZkVzUwSUdseklHNWxaMkYwYVhabFhHNWNkQ0FxTDF4dVhIUndkV0pzYVdNZ1ptbHljM1FvS1RvZ1ZpQjhJSFZ1WkdWbWFXNWxaRHRjYmx4MGNIVmliR2xqSUdacGNuTjBLR0Z0YjNWdWREb2diblZ0WW1WeUtUb2dWbHRkTzF4dVhIUndkV0pzYVdNZ1ptbHljM1FvWVcxdmRXNTBQem9nYm5WdFltVnlLVG9nVmlCOElGWmJYU0I4SUhWdVpHVm1hVzVsWkNCN1hHNWNkRngwYVdZZ0tIUjVjR1Z2WmlCaGJXOTFiblFnUFQwOUlDZDFibVJsWm1sdVpXUW5LU0J5WlhSMWNtNGdkR2hwY3k1MllXeDFaWE1vS1M1dVpYaDBLQ2t1ZG1Gc2RXVTdYRzVjZEZ4MGFXWWdLR0Z0YjNWdWRDQThJREFwSUhKbGRIVnliaUIwYUdsekxteGhjM1FvWVcxdmRXNTBJQ29nTFRFcE8xeHVYSFJjZEdGdGIzVnVkQ0E5SUUxaGRHZ3ViV2x1S0hSb2FYTXVjMmw2WlN3Z1lXMXZkVzUwS1R0Y2JseDBYSFJqYjI1emRDQnBkR1Z5SUQwZ2RHaHBjeTUyWVd4MVpYTW9LVHRjYmx4MFhIUnlaWFIxY200Z1FYSnlZWGt1Wm5KdmJTaDdJR3hsYm1kMGFEb2dZVzF2ZFc1MElIMHNJQ2dwT2lCV0lEMCtJR2wwWlhJdWJtVjRkQ2dwTG5aaGJIVmxLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCUFluUmhhVzV6SUhSb1pTQm1hWEp6ZENCclpYa29jeWtnYVc0Z2RHaHBjeUJqYjJ4c1pXTjBhVzl1TGx4dVhIUWdLaUJBY0dGeVlXMGdlMjUxYldKbGNuMGdXMkZ0YjNWdWRGMGdRVzF2ZFc1MElHOW1JR3RsZVhNZ2RHOGdiMkowWVdsdUlHWnliMjBnZEdobElHSmxaMmx1Ym1sdVoxeHVYSFFnS2lCQWNtVjBkWEp1Y3lCN0tueEJjbkpoZVR3cVBuMGdRU0J6YVc1bmJHVWdhMlY1SUdsbUlHNXZJR0Z0YjNWdWRDQnBjeUJ3Y205MmFXUmxaQ0J2Y2lCaGJpQmhjbkpoZVNCdlppQnJaWGx6TENCemRHRnlkR2x1WnlCbWNtOXRJSFJvWlNCbGJtUWdhV1pjYmx4MElDb2dZVzF2ZFc1MElHbHpJRzVsWjJGMGFYWmxYRzVjZENBcUwxeHVYSFJ3ZFdKc2FXTWdabWx5YzNSTFpYa29LVG9nU3lCOElIVnVaR1ZtYVc1bFpEdGNibHgwY0hWaWJHbGpJR1pwY25OMFMyVjVLR0Z0YjNWdWREb2diblZ0WW1WeUtUb2dTMXRkTzF4dVhIUndkV0pzYVdNZ1ptbHljM1JMWlhrb1lXMXZkVzUwUHpvZ2JuVnRZbVZ5S1RvZ1N5QjhJRXRiWFNCOElIVnVaR1ZtYVc1bFpDQjdYRzVjZEZ4MGFXWWdLSFI1Y0dWdlppQmhiVzkxYm5RZ1BUMDlJQ2QxYm1SbFptbHVaV1FuS1NCeVpYUjFjbTRnZEdocGN5NXJaWGx6S0NrdWJtVjRkQ2dwTG5aaGJIVmxPMXh1WEhSY2RHbG1JQ2hoYlc5MWJuUWdQQ0F3S1NCeVpYUjFjbTRnZEdocGN5NXNZWE4wUzJWNUtHRnRiM1Z1ZENBcUlDMHhLVHRjYmx4MFhIUmhiVzkxYm5RZ1BTQk5ZWFJvTG0xcGJpaDBhR2x6TG5OcGVtVXNJR0Z0YjNWdWRDazdYRzVjZEZ4MFkyOXVjM1FnYVhSbGNpQTlJSFJvYVhNdWEyVjVjeWdwTzF4dVhIUmNkSEpsZEhWeWJpQkJjbkpoZVM1bWNtOXRLSHNnYkdWdVozUm9PaUJoYlc5MWJuUWdmU3dnS0NrNklFc2dQVDRnYVhSbGNpNXVaWGgwS0NrdWRtRnNkV1VwTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFOWlkR0ZwYm5NZ2RHaGxJR3hoYzNRZ2RtRnNkV1VvY3lrZ2FXNGdkR2hwY3lCamIyeHNaV04wYVc5dUxpQlVhR2x6SUhKbGJHbGxjeUJ2YmlCN1FHeHBibXNnUTI5c2JHVmpkR2x2YmlOaGNuSmhlWDBzSUdGdVpDQjBhSFZ6SUhSb1pTQmpZV05vYVc1blhHNWNkQ0FxSUcxbFkyaGhibWx6YlNCaGNIQnNhV1Z6SUdobGNtVWdZWE1nZDJWc2JDNWNibHgwSUNvZ1FIQmhjbUZ0SUh0dWRXMWlaWEo5SUZ0aGJXOTFiblJkSUVGdGIzVnVkQ0J2WmlCMllXeDFaWE1nZEc4Z2IySjBZV2x1SUdaeWIyMGdkR2hsSUdWdVpGeHVYSFFnS2lCQWNtVjBkWEp1Y3lCN0tueEJjbkpoZVR3cVBuMGdRU0J6YVc1bmJHVWdkbUZzZFdVZ2FXWWdibThnWVcxdmRXNTBJR2x6SUhCeWIzWnBaR1ZrSUc5eUlHRnVJR0Z5Y21GNUlHOW1JSFpoYkhWbGN5d2djM1JoY25ScGJtY2dabkp2YlNCMGFHVWdjM1JoY25RZ2FXWmNibHgwSUNvZ1lXMXZkVzUwSUdseklHNWxaMkYwYVhabFhHNWNkQ0FxTDF4dVhIUndkV0pzYVdNZ2JHRnpkQ2dwT2lCV0lId2dkVzVrWldacGJtVmtPMXh1WEhSd2RXSnNhV01nYkdGemRDaGhiVzkxYm5RNklHNTFiV0psY2lrNklGWmJYVHRjYmx4MGNIVmliR2xqSUd4aGMzUW9ZVzF2ZFc1MFB6b2diblZ0WW1WeUtUb2dWaUI4SUZaYlhTQjhJSFZ1WkdWbWFXNWxaQ0I3WEc1Y2RGeDBZMjl1YzNRZ1lYSnlJRDBnZEdocGN5NWhjbkpoZVNncE8xeHVYSFJjZEdsbUlDaDBlWEJsYjJZZ1lXMXZkVzUwSUQwOVBTQW5kVzVrWldacGJtVmtKeWtnY21WMGRYSnVJR0Z5Y2x0aGNuSXViR1Z1WjNSb0lDMGdNVjA3WEc1Y2RGeDBhV1lnS0dGdGIzVnVkQ0E4SURBcElISmxkSFZ5YmlCMGFHbHpMbVpwY25OMEtHRnRiM1Z1ZENBcUlDMHhLVHRjYmx4MFhIUnBaaUFvSVdGdGIzVnVkQ2tnY21WMGRYSnVJRnRkTzF4dVhIUmNkSEpsZEhWeWJpQmhjbkl1YzJ4cFkyVW9MV0Z0YjNWdWRDazdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nVDJKMFlXbHVjeUIwYUdVZ2JHRnpkQ0JyWlhrb2N5a2dhVzRnZEdocGN5QmpiMnhzWldOMGFXOXVMaUJVYUdseklISmxiR2xsY3lCdmJpQjdRR3hwYm1zZ1EyOXNiR1ZqZEdsdmJpTnJaWGxCY25KaGVYMHNJR0Z1WkNCMGFIVnpJSFJvWlNCallXTm9hVzVuWEc1Y2RDQXFJRzFsWTJoaGJtbHpiU0JoY0hCc2FXVnpJR2hsY21VZ1lYTWdkMlZzYkM1Y2JseDBJQ29nUUhCaGNtRnRJSHR1ZFcxaVpYSjlJRnRoYlc5MWJuUmRJRUZ0YjNWdWRDQnZaaUJyWlhseklIUnZJRzlpZEdGcGJpQm1jbTl0SUhSb1pTQmxibVJjYmx4MElDb2dRSEpsZEhWeWJuTWdleXA4UVhKeVlYazhLajU5SUVFZ2MybHVaMnhsSUd0bGVTQnBaaUJ1YnlCaGJXOTFiblFnYVhNZ2NISnZkbWxrWldRZ2IzSWdZVzRnWVhKeVlYa2diMllnYTJWNWN5d2djM1JoY25ScGJtY2dabkp2YlNCMGFHVWdjM1JoY25RZ2FXWmNibHgwSUNvZ1lXMXZkVzUwSUdseklHNWxaMkYwYVhabFhHNWNkQ0FxTDF4dVhIUndkV0pzYVdNZ2JHRnpkRXRsZVNncE9pQkxJSHdnZFc1a1pXWnBibVZrTzF4dVhIUndkV0pzYVdNZ2JHRnpkRXRsZVNoaGJXOTFiblE2SUc1MWJXSmxjaWs2SUV0YlhUdGNibHgwY0hWaWJHbGpJR3hoYzNSTFpYa29ZVzF2ZFc1MFB6b2diblZ0WW1WeUtUb2dTeUI4SUV0YlhTQjhJSFZ1WkdWbWFXNWxaQ0I3WEc1Y2RGeDBZMjl1YzNRZ1lYSnlJRDBnZEdocGN5NXJaWGxCY25KaGVTZ3BPMXh1WEhSY2RHbG1JQ2gwZVhCbGIyWWdZVzF2ZFc1MElEMDlQU0FuZFc1a1pXWnBibVZrSnlrZ2NtVjBkWEp1SUdGeWNsdGhjbkl1YkdWdVozUm9JQzBnTVYwN1hHNWNkRngwYVdZZ0tHRnRiM1Z1ZENBOElEQXBJSEpsZEhWeWJpQjBhR2x6TG1acGNuTjBTMlY1S0dGdGIzVnVkQ0FxSUMweEtUdGNibHgwWEhScFppQW9JV0Z0YjNWdWRDa2djbVYwZFhKdUlGdGRPMXh1WEhSY2RISmxkSFZ5YmlCaGNuSXVjMnhwWTJVb0xXRnRiM1Z1ZENrN1hHNWNkSDFjYmx4dVhIUXZLaXBjYmx4MElDb2dUMkowWVdsdWN5QjFibWx4ZFdVZ2NtRnVaRzl0SUhaaGJIVmxLSE1wSUdaeWIyMGdkR2hwY3lCamIyeHNaV04wYVc5dUxpQlVhR2x6SUhKbGJHbGxjeUJ2YmlCN1FHeHBibXNnUTI5c2JHVmpkR2x2YmlOaGNuSmhlWDBzSUdGdVpDQjBhSFZ6SUhSb1pTQmpZV05vYVc1blhHNWNkQ0FxSUcxbFkyaGhibWx6YlNCaGNIQnNhV1Z6SUdobGNtVWdZWE1nZDJWc2JDNWNibHgwSUNvZ1FIQmhjbUZ0SUh0dWRXMWlaWEo5SUZ0aGJXOTFiblJkSUVGdGIzVnVkQ0J2WmlCMllXeDFaWE1nZEc4Z2IySjBZV2x1SUhKaGJtUnZiV3g1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHNxZkVGeWNtRjVQQ28rZlNCQklITnBibWRzWlNCMllXeDFaU0JwWmlCdWJ5QmhiVzkxYm5RZ2FYTWdjSEp2ZG1sa1pXUWdiM0lnWVc0Z1lYSnlZWGtnYjJZZ2RtRnNkV1Z6WEc1Y2RDQXFMMXh1WEhSd2RXSnNhV01nY21GdVpHOXRLQ2s2SUZZN1hHNWNkSEIxWW14cFl5QnlZVzVrYjIwb1lXMXZkVzUwT2lCdWRXMWlaWElwT2lCV1cxMDdYRzVjZEhCMVlteHBZeUJ5WVc1a2IyMG9ZVzF2ZFc1MFB6b2diblZ0WW1WeUtUb2dWaUI4SUZaYlhTQjdYRzVjZEZ4MGJHVjBJR0Z5Y2lBOUlIUm9hWE11WVhKeVlYa29LVHRjYmx4MFhIUnBaaUFvZEhsd1pXOW1JR0Z0YjNWdWRDQTlQVDBnSjNWdVpHVm1hVzVsWkNjcElISmxkSFZ5YmlCaGNuSmJUV0YwYUM1bWJHOXZjaWhOWVhSb0xuSmhibVJ2YlNncElDb2dZWEp5TG14bGJtZDBhQ2xkTzF4dVhIUmNkR2xtSUNoaGNuSXViR1Z1WjNSb0lEMDlQU0F3SUh4OElDRmhiVzkxYm5RcElISmxkSFZ5YmlCYlhUdGNibHgwWEhSaGNuSWdQU0JoY25JdWMyeHBZMlVvS1R0Y2JseDBYSFJ5WlhSMWNtNGdRWEp5WVhrdVpuSnZiU2g3SUd4bGJtZDBhRG9nWVcxdmRXNTBJSDBzSUNncE9pQldJRDArSUdGeWNpNXpjR3hwWTJVb1RXRjBhQzVtYkc5dmNpaE5ZWFJvTG5KaGJtUnZiU2dwSUNvZ1lYSnlMbXhsYm1kMGFDa3NJREVwV3pCZEtUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJQWW5SaGFXNXpJSFZ1YVhGMVpTQnlZVzVrYjIwZ2EyVjVLSE1wSUdaeWIyMGdkR2hwY3lCamIyeHNaV04wYVc5dUxpQlVhR2x6SUhKbGJHbGxjeUJ2YmlCN1FHeHBibXNnUTI5c2JHVmpkR2x2YmlOclpYbEJjbkpoZVgwc0lHRnVaQ0IwYUhWeklIUm9aU0JqWVdOb2FXNW5YRzVjZENBcUlHMWxZMmhoYm1semJTQmhjSEJzYVdWeklHaGxjbVVnWVhNZ2QyVnNiQzVjYmx4MElDb2dRSEJoY21GdElIdHVkVzFpWlhKOUlGdGhiVzkxYm5SZElFRnRiM1Z1ZENCdlppQnJaWGx6SUhSdklHOWlkR0ZwYmlCeVlXNWtiMjFzZVZ4dVhIUWdLaUJBY21WMGRYSnVjeUI3S254QmNuSmhlVHdxUG4wZ1FTQnphVzVuYkdVZ2EyVjVJR2xtSUc1dklHRnRiM1Z1ZENCcGN5QndjbTkyYVdSbFpDQnZjaUJoYmlCaGNuSmhlVnh1WEhRZ0tpOWNibHgwY0hWaWJHbGpJSEpoYm1SdmJVdGxlU2dwT2lCTE8xeHVYSFJ3ZFdKc2FXTWdjbUZ1Wkc5dFMyVjVLR0Z0YjNWdWREb2diblZ0WW1WeUtUb2dTMXRkTzF4dVhIUndkV0pzYVdNZ2NtRnVaRzl0UzJWNUtHRnRiM1Z1ZEQ4NklHNTFiV0psY2lrNklFc2dmQ0JMVzEwZ2UxeHVYSFJjZEd4bGRDQmhjbklnUFNCMGFHbHpMbXRsZVVGeWNtRjVLQ2s3WEc1Y2RGeDBhV1lnS0hSNWNHVnZaaUJoYlc5MWJuUWdQVDA5SUNkMWJtUmxabWx1WldRbktTQnlaWFIxY200Z1lYSnlXMDFoZEdndVpteHZiM0lvVFdGMGFDNXlZVzVrYjIwb0tTQXFJR0Z5Y2k1c1pXNW5kR2dwWFR0Y2JseDBYSFJwWmlBb1lYSnlMbXhsYm1kMGFDQTlQVDBnTUNCOGZDQWhZVzF2ZFc1MEtTQnlaWFIxY200Z1cxMDdYRzVjZEZ4MFlYSnlJRDBnWVhKeUxuTnNhV05sS0NrN1hHNWNkRngwY21WMGRYSnVJRUZ5Y21GNUxtWnliMjBvZXlCc1pXNW5kR2c2SUdGdGIzVnVkQ0I5TENBb0tUb2dTeUE5UGlCaGNuSXVjM0JzYVdObEtFMWhkR2d1Wm14dmIzSW9UV0YwYUM1eVlXNWtiMjBvS1NBcUlHRnljaTVzWlc1bmRHZ3BMQ0F4S1Zzd1hTazdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nVTJWaGNtTm9aWE1nWm05eUlHRWdjMmx1WjJ4bElHbDBaVzBnZDJobGNtVWdkR2hsSUdkcGRtVnVJR1oxYm1OMGFXOXVJSEpsZEhWeWJuTWdZU0IwY25WMGFIa2dkbUZzZFdVdUlGUm9hWE1nWW1Wb1lYWmxjeUJzYVd0bFhHNWNkQ0FxSUZ0QmNuSmhlUzVtYVc1a0tDbGRLR2gwZEhCek9pOHZaR1YyWld4dmNHVnlMbTF2ZW1sc2JHRXViM0puTDJWdUxWVlRMMlJ2WTNNdlYyVmlMMHBoZG1GVFkzSnBjSFF2VW1WbVpYSmxibU5sTDBkc2IySmhiRjlQWW1wbFkzUnpMMEZ5Y21GNUwyWnBibVFwTGx4dVhIUWdLaUE4ZDJGeWJqNUJiR3dnWTI5c2JHVmpkR2x2Ym5NZ2RYTmxaQ0JwYmlCRWFYTmpiM0prTG1weklHRnlaU0J0WVhCd1pXUWdkWE5wYm1jZ2RHaGxhWElnWUdsa1lDQndjbTl3WlhKMGVTd2dZVzVrSUdsbUlIbHZkU0IzWVc1MElIUnZJR1pwYm1RZ1lua2dhV1FnZVc5MVhHNWNkQ0FxSUhOb2IzVnNaQ0IxYzJVZ2RHaGxJR0JuWlhSZ0lHMWxkR2h2WkM0Z1UyVmxYRzVjZENBcUlGdE5SRTVkS0doMGRIQnpPaTh2WkdWMlpXeHZjR1Z5TG0xdmVtbHNiR0V1YjNKbkwyVnVMVlZUTDJSdlkzTXZWMlZpTDBwaGRtRlRZM0pwY0hRdlVtVm1aWEpsYm1ObEwwZHNiMkpoYkY5UFltcGxZM1J6TDAxaGNDOW5aWFFwSUdadmNpQmtaWFJoYVd4ekxqd3ZkMkZ5Ymo1Y2JseDBJQ29nUUhCaGNtRnRJSHRHZFc1amRHbHZibjBnWm00Z1ZHaGxJR1oxYm1OMGFXOXVJSFJ2SUhSbGMzUWdkMmwwYUNBb2MyaHZkV3hrSUhKbGRIVnliaUJpYjI5c1pXRnVLVnh1WEhRZ0tpQkFjR0Z5WVcwZ2V5cDlJRnQwYUdselFYSm5YU0JXWVd4MVpTQjBieUIxYzJVZ1lYTWdZSFJvYVhOZ0lIZG9aVzRnWlhobFkzVjBhVzVuSUdaMWJtTjBhVzl1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHNxZlZ4dVhIUWdLaUJBWlhoaGJYQnNaU0JqYjJ4c1pXTjBhVzl1TG1acGJtUW9kWE5sY2lBOVBpQjFjMlZ5TG5WelpYSnVZVzFsSUQwOVBTQW5RbTlpSnlrN1hHNWNkQ0FxTDF4dVhIUndkV0pzYVdNZ1ptbHVaQ2htYmpvZ0tIWmhiSFZsT2lCV0xDQnJaWGs2SUVzc0lHTnZiR3hsWTNScGIyNDZJSFJvYVhNcElEMCtJR0p2YjJ4bFlXNHBPaUJXSUh3Z2RXNWtaV1pwYm1Wa08xeHVYSFJ3ZFdKc2FXTWdabWx1WkR4VVBpaG1iam9nS0hSb2FYTTZJRlFzSUhaaGJIVmxPaUJXTENCclpYazZJRXNzSUdOdmJHeGxZM1JwYjI0NklIUm9hWE1wSUQwK0lHSnZiMnhsWVc0c0lIUm9hWE5CY21jNklGUXBPaUJXSUh3Z2RXNWtaV1pwYm1Wa08xeHVYSFJ3ZFdKc2FXTWdabWx1WkNobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRzSUhSb2FYTkJjbWMvT2lCMWJtdHViM2R1S1RvZ1ZpQjhJSFZ1WkdWbWFXNWxaQ0I3WEc1Y2RGeDBhV1lnS0hSNWNHVnZaaUIwYUdselFYSm5JQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5a2dabTRnUFNCbWJpNWlhVzVrS0hSb2FYTkJjbWNwTzF4dVhIUmNkR1p2Y2lBb1kyOXVjM1FnVzJ0bGVTd2dkbUZzWFNCdlppQjBhR2x6S1NCN1hHNWNkRngwWEhScFppQW9abTRvZG1Gc0xDQnJaWGtzSUhSb2FYTXBLU0J5WlhSMWNtNGdkbUZzTzF4dVhIUmNkSDFjYmx4MFhIUnlaWFIxY200Z2RXNWtaV1pwYm1Wa08xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRk5sWVhKamFHVnpJR1p2Y2lCMGFHVWdhMlY1SUc5bUlHRWdjMmx1WjJ4bElHbDBaVzBnZDJobGNtVWdkR2hsSUdkcGRtVnVJR1oxYm1OMGFXOXVJSEpsZEhWeWJuTWdZU0IwY25WMGFIa2dkbUZzZFdVdUlGUm9hWE1nWW1Wb1lYWmxjeUJzYVd0bFhHNWNkQ0FxSUZ0QmNuSmhlUzVtYVc1a1NXNWtaWGdvS1Ywb2FIUjBjSE02THk5a1pYWmxiRzl3WlhJdWJXOTZhV3hzWVM1dmNtY3ZaVzR0VlZNdlpHOWpjeTlYWldJdlNtRjJZVk5qY21sd2RDOVNaV1psY21WdVkyVXZSMnh2WW1Gc1gwOWlhbVZqZEhNdlFYSnlZWGt2Wm1sdVpFbHVaR1Y0S1N4Y2JseDBJQ29nWW5WMElISmxkSFZ5Ym5NZ2RHaGxJR3RsZVNCeVlYUm9aWElnZEdoaGJpQjBhR1VnY0c5emFYUnBiMjVoYkNCcGJtUmxlQzVjYmx4MElDb2dRSEJoY21GdElIdEdkVzVqZEdsdmJuMGdabTRnVkdobElHWjFibU4wYVc5dUlIUnZJSFJsYzNRZ2QybDBhQ0FvYzJodmRXeGtJSEpsZEhWeWJpQmliMjlzWldGdUtWeHVYSFFnS2lCQWNHRnlZVzBnZXlwOUlGdDBhR2x6UVhKblhTQldZV3gxWlNCMGJ5QjFjMlVnWVhNZ1lIUm9hWE5nSUhkb1pXNGdaWGhsWTNWMGFXNW5JR1oxYm1OMGFXOXVYRzVjZENBcUlFQnlaWFIxY201eklIc3FmVnh1WEhRZ0tpQkFaWGhoYlhCc1pTQmpiMnhzWldOMGFXOXVMbVpwYm1STFpYa29kWE5sY2lBOVBpQjFjMlZ5TG5WelpYSnVZVzFsSUQwOVBTQW5RbTlpSnlrN1hHNWNkQ0FxTDF4dVhIUndkV0pzYVdNZ1ptbHVaRXRsZVNobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRwT2lCTElId2dkVzVrWldacGJtVmtPMXh1WEhSd2RXSnNhV01nWm1sdVpFdGxlVHhVUGlobWJqb2dLSFJvYVhNNklGUXNJSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRzSUhSb2FYTkJjbWM2SUZRcE9pQkxJSHdnZFc1a1pXWnBibVZrTzF4dVhIUndkV0pzYVdNZ1ptbHVaRXRsZVNobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRzSUhSb2FYTkJjbWMvT2lCMWJtdHViM2R1S1RvZ1N5QjhJSFZ1WkdWbWFXNWxaQ0I3WEc1Y2RGeDBhV1lnS0hSNWNHVnZaaUIwYUdselFYSm5JQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5a2dabTRnUFNCbWJpNWlhVzVrS0hSb2FYTkJjbWNwTzF4dVhIUmNkR1p2Y2lBb1kyOXVjM1FnVzJ0bGVTd2dkbUZzWFNCdlppQjBhR2x6S1NCN1hHNWNkRngwWEhScFppQW9abTRvZG1Gc0xDQnJaWGtzSUhSb2FYTXBLU0J5WlhSMWNtNGdhMlY1TzF4dVhIUmNkSDFjYmx4MFhIUnlaWFIxY200Z2RXNWtaV1pwYm1Wa08xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRkpsYlc5MlpYTWdhWFJsYlhNZ2RHaGhkQ0J6WVhScGMyWjVJSFJvWlNCd2NtOTJhV1JsWkNCbWFXeDBaWElnWm5WdVkzUnBiMjR1WEc1Y2RDQXFJRUJ3WVhKaGJTQjdSblZ1WTNScGIyNTlJR1p1SUVaMWJtTjBhVzl1SUhWelpXUWdkRzhnZEdWemRDQW9jMmh2ZFd4a0lISmxkSFZ5YmlCaElHSnZiMnhsWVc0cFhHNWNkQ0FxSUVCd1lYSmhiU0I3S24wZ1czUm9hWE5CY21kZElGWmhiSFZsSUhSdklIVnpaU0JoY3lCZ2RHaHBjMkFnZDJobGJpQmxlR1ZqZFhScGJtY2dablZ1WTNScGIyNWNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UyNTFiV0psY24wZ1ZHaGxJRzUxYldKbGNpQnZaaUJ5WlcxdmRtVmtJR1Z1ZEhKcFpYTmNibHgwSUNvdlhHNWNkSEIxWW14cFl5QnpkMlZsY0NobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRwT2lCdWRXMWlaWEk3WEc1Y2RIQjFZbXhwWXlCemQyVmxjRHhVUGlobWJqb2dLSFJvYVhNNklGUXNJSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRzSUhSb2FYTkJjbWM2SUZRcE9pQnVkVzFpWlhJN1hHNWNkSEIxWW14cFl5QnpkMlZsY0NobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRzSUhSb2FYTkJjbWMvT2lCMWJtdHViM2R1S1RvZ2JuVnRZbVZ5SUh0Y2JseDBYSFJwWmlBb2RIbHdaVzltSUhSb2FYTkJjbWNnSVQwOUlDZDFibVJsWm1sdVpXUW5LU0JtYmlBOUlHWnVMbUpwYm1Rb2RHaHBjMEZ5WnlrN1hHNWNkRngwWTI5dWMzUWdjSEpsZG1sdmRYTlRhWHBsSUQwZ2RHaHBjeTV6YVhwbE8xeHVYSFJjZEdadmNpQW9ZMjl1YzNRZ1cydGxlU3dnZG1Gc1hTQnZaaUIwYUdsektTQjdYRzVjZEZ4MFhIUnBaaUFvWm00b2RtRnNMQ0JyWlhrc0lIUm9hWE1wS1NCMGFHbHpMbVJsYkdWMFpTaHJaWGtwTzF4dVhIUmNkSDFjYmx4MFhIUnlaWFIxY200Z2NISmxkbWx2ZFhOVGFYcGxJQzBnZEdocGN5NXphWHBsTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFbGtaVzUwYVdOaGJDQjBiMXh1WEhRZ0tpQmJRWEp5WVhrdVptbHNkR1Z5S0NsZEtHaDBkSEJ6T2k4dlpHVjJaV3h2Y0dWeUxtMXZlbWxzYkdFdWIzSm5MMlZ1TFZWVEwyUnZZM012VjJWaUwwcGhkbUZUWTNKcGNIUXZVbVZtWlhKbGJtTmxMMGRzYjJKaGJGOVBZbXBsWTNSekwwRnljbUY1TDJacGJIUmxjaWtzWEc1Y2RDQXFJR0oxZENCeVpYUjFjbTV6SUdFZ1EyOXNiR1ZqZEdsdmJpQnBibk4wWldGa0lHOW1JR0Z1SUVGeWNtRjVMbHh1WEhRZ0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQm1iaUJVYUdVZ1puVnVZM1JwYjI0Z2RHOGdkR1Z6ZENCM2FYUm9JQ2h6YUc5MWJHUWdjbVYwZFhKdUlHSnZiMnhsWVc0cFhHNWNkQ0FxSUVCd1lYSmhiU0I3S24wZ1czUm9hWE5CY21kZElGWmhiSFZsSUhSdklIVnpaU0JoY3lCZ2RHaHBjMkFnZDJobGJpQmxlR1ZqZFhScGJtY2dablZ1WTNScGIyNWNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UwTnZiR3hsWTNScGIyNTlYRzVjZENBcUlFQmxlR0Z0Y0d4bElHTnZiR3hsWTNScGIyNHVabWxzZEdWeUtIVnpaWElnUFQ0Z2RYTmxjaTUxYzJWeWJtRnRaU0E5UFQwZ0owSnZZaWNwTzF4dVhIUWdLaTljYmx4MGNIVmliR2xqSUdacGJIUmxjaWhtYmpvZ0tIWmhiSFZsT2lCV0xDQnJaWGs2SUVzc0lHTnZiR3hsWTNScGIyNDZJSFJvYVhNcElEMCtJR0p2YjJ4bFlXNHBPaUIwYUdsek8xeHVYSFJ3ZFdKc2FXTWdabWxzZEdWeVBGUStLR1p1T2lBb2RHaHBjem9nVkN3Z2RtRnNkV1U2SUZZc0lHdGxlVG9nU3l3Z1kyOXNiR1ZqZEdsdmJqb2dkR2hwY3lrZ1BUNGdZbTl2YkdWaGJpd2dkR2hwYzBGeVp6b2dWQ2s2SUhSb2FYTTdYRzVjZEhCMVlteHBZeUJtYVd4MFpYSW9abTQ2SUNoMllXeDFaVG9nVml3Z2EyVjVPaUJMTENCamIyeHNaV04wYVc5dU9pQjBhR2x6S1NBOVBpQmliMjlzWldGdUxDQjBhR2x6UVhKblB6b2dkVzVyYm05M2JpazZJSFJvYVhNZ2UxeHVYSFJjZEdsbUlDaDBlWEJsYjJZZ2RHaHBjMEZ5WnlBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUdadUlEMGdabTR1WW1sdVpDaDBhR2x6UVhKbktUdGNibHgwWEhSamIyNXpkQ0J5WlhOMWJIUnpJRDBnYm1WM0lIUm9hWE11WTI5dWMzUnlkV04wYjNKYlUzbHRZbTlzTG5Od1pXTnBaWE5kUEVzc0lGWStLQ2tnWVhNZ2RHaHBjenRjYmx4MFhIUm1iM0lnS0dOdmJuTjBJRnRyWlhrc0lIWmhiRjBnYjJZZ2RHaHBjeWtnZTF4dVhIUmNkRngwYVdZZ0tHWnVLSFpoYkN3Z2EyVjVMQ0IwYUdsektTa2djbVZ6ZFd4MGN5NXpaWFFvYTJWNUxDQjJZV3dwTzF4dVhIUmNkSDFjYmx4MFhIUnlaWFIxY200Z2NtVnpkV3gwY3p0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQlFZWEowYVhScGIyNXpJSFJvWlNCamIyeHNaV04wYVc5dUlHbHVkRzhnZEhkdklHTnZiR3hsWTNScGIyNXpJSGRvWlhKbElIUm9aU0JtYVhKemRDQmpiMnhzWldOMGFXOXVYRzVjZENBcUlHTnZiblJoYVc1eklIUm9aU0JwZEdWdGN5QjBhR0YwSUhCaGMzTmxaQ0JoYm1RZ2RHaGxJSE5sWTI5dVpDQmpiMjUwWVdsdWN5QjBhR1VnYVhSbGJYTWdkR2hoZENCbVlXbHNaV1F1WEc1Y2RDQXFJRUJ3WVhKaGJTQjdSblZ1WTNScGIyNTlJR1p1SUVaMWJtTjBhVzl1SUhWelpXUWdkRzhnZEdWemRDQW9jMmh2ZFd4a0lISmxkSFZ5YmlCaElHSnZiMnhsWVc0cFhHNWNkQ0FxSUVCd1lYSmhiU0I3S24wZ1czUm9hWE5CY21kZElGWmhiSFZsSUhSdklIVnpaU0JoY3lCZ2RHaHBjMkFnZDJobGJpQmxlR1ZqZFhScGJtY2dablZ1WTNScGIyNWNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UwTnZiR3hsWTNScGIyNWJYWDFjYmx4MElDb2dRR1Y0WVcxd2JHVWdZMjl1YzNRZ1cySnBaeXdnYzIxaGJHeGRJRDBnWTI5c2JHVmpkR2x2Ymk1d1lYSjBhWFJwYjI0b1ozVnBiR1FnUFQ0Z1ozVnBiR1F1YldWdFltVnlRMjkxYm5RZ1BpQXlOVEFwTzF4dVhIUWdLaTljYmx4MGNIVmliR2xqSUhCaGNuUnBkR2x2YmlobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRwT2lCYmRHaHBjeXdnZEdocGMxMDdYRzVjZEhCMVlteHBZeUJ3WVhKMGFYUnBiMjQ4VkQ0b1ptNDZJQ2gwYUdsek9pQlVMQ0IyWVd4MVpUb2dWaXdnYTJWNU9pQkxMQ0JqYjJ4c1pXTjBhVzl1T2lCMGFHbHpLU0E5UGlCaWIyOXNaV0Z1TENCMGFHbHpRWEpuT2lCVUtUb2dXM1JvYVhNc0lIUm9hWE5kTzF4dVhIUndkV0pzYVdNZ2NHRnlkR2wwYVc5dUtHWnVPaUFvZG1Gc2RXVTZJRllzSUd0bGVUb2dTeXdnWTI5c2JHVmpkR2x2YmpvZ2RHaHBjeWtnUFQ0Z1ltOXZiR1ZoYml3Z2RHaHBjMEZ5Wno4NklIVnVhMjV2ZDI0cE9pQmJkR2hwY3l3Z2RHaHBjMTBnZTF4dVhIUmNkR2xtSUNoMGVYQmxiMllnZEdocGMwRnlaeUFoUFQwZ0ozVnVaR1ZtYVc1bFpDY3BJR1p1SUQwZ1ptNHVZbWx1WkNoMGFHbHpRWEpuS1R0Y2JseDBYSFF2THlCVVQwUlBPaUJqYjI1emFXUmxjaUJ5WlcxdmRtbHVaeUIwYUdVZ1BFc3NJRlkrSUdaeWIyMGdkR2hsSUdOdmJuTjBjblZqZEc5eWN5QmhablJsY2lCVVV5QXpMamN1TUNCcGN5QnlaV3hsWVhObFpDd2dZWE1nYVhRZ2FXNW1aWEp6SUdsMFhHNWNkRngwWTI5dWMzUWdjbVZ6ZFd4MGN6b2dXM1JvYVhNc0lIUm9hWE5kSUQwZ1cyNWxkeUIwYUdsekxtTnZibk4wY25WamRHOXlXMU41YldKdmJDNXpjR1ZqYVdWelhUeExMQ0JXUGlncElHRnpJSFJvYVhNc0lHNWxkeUIwYUdsekxtTnZibk4wY25WamRHOXlXMU41YldKdmJDNXpjR1ZqYVdWelhUeExMQ0JXUGlncElHRnpJSFJvYVhOZE8xeHVYSFJjZEdadmNpQW9ZMjl1YzNRZ1cydGxlU3dnZG1Gc1hTQnZaaUIwYUdsektTQjdYRzVjZEZ4MFhIUnBaaUFvWm00b2RtRnNMQ0JyWlhrc0lIUm9hWE1wS1NCN1hHNWNkRngwWEhSY2RISmxjM1ZzZEhOYk1GMHVjMlYwS0d0bGVTd2dkbUZzS1R0Y2JseDBYSFJjZEgwZ1pXeHpaU0I3WEc1Y2RGeDBYSFJjZEhKbGMzVnNkSE5iTVYwdWMyVjBLR3RsZVN3Z2RtRnNLVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjZEZ4MGNtVjBkWEp1SUhKbGMzVnNkSE03WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1RXRndjeUJsWVdOb0lHbDBaVzBnYVc1MGJ5QmhJRU52Ykd4bFkzUnBiMjRzSUhSb1pXNGdhbTlwYm5NZ2RHaGxJSEpsYzNWc2RITWdhVzUwYnlCaElITnBibWRzWlNCRGIyeHNaV04wYVc5dUxpQkpaR1Z1ZEdsallXd2dhVzRnWW1Wb1lYWnBiM0lnZEc5Y2JseDBJQ29nVzBGeWNtRjVMbVpzWVhSTllYQW9LVjBvYUhSMGNITTZMeTlrWlhabGJHOXdaWEl1Ylc5NmFXeHNZUzV2Y21jdlpXNHRWVk12Wkc5amN5OVhaV0l2U21GMllWTmpjbWx3ZEM5U1pXWmxjbVZ1WTJVdlIyeHZZbUZzWDA5aWFtVmpkSE12UVhKeVlYa3ZabXhoZEUxaGNDa3VYRzVjZENBcUlFQndZWEpoYlNCN1JuVnVZM1JwYjI1OUlHWnVJRVoxYm1OMGFXOXVJSFJvWVhRZ2NISnZaSFZqWlhNZ1lTQnVaWGNnUTI5c2JHVmpkR2x2Ymx4dVhIUWdLaUJBY0dGeVlXMGdleXA5SUZ0MGFHbHpRWEpuWFNCV1lXeDFaU0IwYnlCMWMyVWdZWE1nWUhSb2FYTmdJSGRvWlc0Z1pYaGxZM1YwYVc1bklHWjFibU4wYVc5dVhHNWNkQ0FxSUVCeVpYUjFjbTV6SUh0RGIyeHNaV04wYVc5dWZWeHVYSFFnS2lCQVpYaGhiWEJzWlNCamIyeHNaV04wYVc5dUxtWnNZWFJOWVhBb1ozVnBiR1FnUFQ0Z1ozVnBiR1F1YldWdFltVnljeTVqWVdOb1pTazdYRzVjZENBcUwxeHVYSFJ3ZFdKc2FXTWdabXhoZEUxaGNEeFVQaWhtYmpvZ0tIWmhiSFZsT2lCV0xDQnJaWGs2SUVzc0lHTnZiR3hsWTNScGIyNDZJSFJvYVhNcElEMCtJRU52Ykd4bFkzUnBiMjQ4U3l3Z1ZENHBPaUJEYjJ4c1pXTjBhVzl1UEVzc0lGUStPMXh1WEhSd2RXSnNhV01nWm14aGRFMWhjRHhVTENCVWFHbHpQaWhtYmpvZ0tIUm9hWE02SUZSb2FYTXNJSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUVOdmJHeGxZM1JwYjI0OFN5d2dWRDRzSUhSb2FYTkJjbWM2SUZSb2FYTXBPaUJEYjJ4c1pXTjBhVzl1UEVzc0lGUStPMXh1WEhSd2RXSnNhV01nWm14aGRFMWhjRHhVUGlobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUVOdmJHeGxZM1JwYjI0OFN5d2dWRDRzSUhSb2FYTkJjbWMvT2lCMWJtdHViM2R1S1RvZ1EyOXNiR1ZqZEdsdmJqeExMQ0JVUGlCN1hHNWNkRngwWTI5dWMzUWdZMjlzYkdWamRHbHZibk1nUFNCMGFHbHpMbTFoY0NobWJpd2dkR2hwYzBGeVp5azdYRzVjZEZ4MGNtVjBkWEp1SUNodVpYY2dkR2hwY3k1amIyNXpkSEoxWTNSdmNsdFRlVzFpYjJ3dWMzQmxZMmxsYzEwOFN5d2dWRDRvS1NCaGN5QkRiMnhzWldOMGFXOXVQRXNzSUZRK0tTNWpiMjVqWVhRb0xpNHVZMjlzYkdWamRHbHZibk1wTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFMWhjSE1nWldGamFDQnBkR1Z0SUhSdklHRnViM1JvWlhJZ2RtRnNkV1VnYVc1MGJ5QmhiaUJoY25KaGVTNGdTV1JsYm5ScFkyRnNJR2x1SUdKbGFHRjJhVzl5SUhSdlhHNWNkQ0FxSUZ0QmNuSmhlUzV0WVhBb0tWMG9hSFIwY0hNNkx5OWtaWFpsYkc5d1pYSXViVzk2YVd4c1lTNXZjbWN2Wlc0dFZWTXZaRzlqY3k5WFpXSXZTbUYyWVZOamNtbHdkQzlTWldabGNtVnVZMlV2UjJ4dlltRnNYMDlpYW1WamRITXZRWEp5WVhrdmJXRndLUzVjYmx4MElDb2dRSEJoY21GdElIdEdkVzVqZEdsdmJuMGdabTRnUm5WdVkzUnBiMjRnZEdoaGRDQndjbTlrZFdObGN5QmhiaUJsYkdWdFpXNTBJRzltSUhSb1pTQnVaWGNnWVhKeVlYa3NJSFJoYTJsdVp5QjBhSEpsWlNCaGNtZDFiV1Z1ZEhOY2JseDBJQ29nUUhCaGNtRnRJSHNxZlNCYmRHaHBjMEZ5WjEwZ1ZtRnNkV1VnZEc4Z2RYTmxJR0Z6SUdCMGFHbHpZQ0IzYUdWdUlHVjRaV04xZEdsdVp5Qm1kVzVqZEdsdmJseHVYSFFnS2lCQWNtVjBkWEp1Y3lCN1FYSnlZWGw5WEc1Y2RDQXFJRUJsZUdGdGNHeGxJR052Ykd4bFkzUnBiMjR1YldGd0tIVnpaWElnUFQ0Z2RYTmxjaTUwWVdjcE8xeHVYSFFnS2k5Y2JseDBjSFZpYkdsaklHMWhjRHhVUGlobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUZRcE9pQlVXMTA3WEc1Y2RIQjFZbXhwWXlCdFlYQThWR2hwY3l3Z1ZENG9abTQ2SUNoMGFHbHpPaUJVYUdsekxDQjJZV3gxWlRvZ1Zpd2dhMlY1T2lCTExDQmpiMnhzWldOMGFXOXVPaUIwYUdsektTQTlQaUJVTENCMGFHbHpRWEpuT2lCVWFHbHpLVG9nVkZ0ZE8xeHVYSFJ3ZFdKc2FXTWdiV0Z3UEZRK0tHWnVPaUFvZG1Gc2RXVTZJRllzSUd0bGVUb2dTeXdnWTI5c2JHVmpkR2x2YmpvZ2RHaHBjeWtnUFQ0Z1ZDd2dkR2hwYzBGeVp6ODZJSFZ1YTI1dmQyNHBPaUJVVzEwZ2UxeHVYSFJjZEdsbUlDaDBlWEJsYjJZZ2RHaHBjMEZ5WnlBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUdadUlEMGdabTR1WW1sdVpDaDBhR2x6UVhKbktUdGNibHgwWEhSamIyNXpkQ0JwZEdWeUlEMGdkR2hwY3k1bGJuUnlhV1Z6S0NrN1hHNWNkRngwY21WMGRYSnVJRUZ5Y21GNUxtWnliMjBvZXlCc1pXNW5kR2c2SUhSb2FYTXVjMmw2WlNCOUxDQW9LVG9nVkNBOVBpQjdYRzVjZEZ4MFhIUmpiMjV6ZENCYmEyVjVMQ0IyWVd4MVpWMGdQU0JwZEdWeUxtNWxlSFFvS1M1MllXeDFaVHRjYmx4MFhIUmNkSEpsZEhWeWJpQm1iaWgyWVd4MVpTd2dhMlY1TENCMGFHbHpLVHRjYmx4MFhIUjlLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCTllYQnpJR1ZoWTJnZ2FYUmxiU0IwYnlCaGJtOTBhR1Z5SUhaaGJIVmxJR2x1ZEc4Z1lTQmpiMnhzWldOMGFXOXVMaUJKWkdWdWRHbGpZV3dnYVc0Z1ltVm9ZWFpwYjNJZ2RHOWNibHgwSUNvZ1cwRnljbUY1TG0xaGNDZ3BYU2hvZEhSd2N6b3ZMMlJsZG1Wc2IzQmxjaTV0YjNwcGJHeGhMbTl5Wnk5bGJpMVZVeTlrYjJOekwxZGxZaTlLWVhaaFUyTnlhWEIwTDFKbFptVnlaVzVqWlM5SGJHOWlZV3hmVDJKcVpXTjBjeTlCY25KaGVTOXRZWEFwTGx4dVhIUWdLaUJBY0dGeVlXMGdlMFoxYm1OMGFXOXVmU0JtYmlCR2RXNWpkR2x2YmlCMGFHRjBJSEJ5YjJSMVkyVnpJR0Z1SUdWc1pXMWxiblFnYjJZZ2RHaGxJRzVsZHlCamIyeHNaV04wYVc5dUxDQjBZV3RwYm1jZ2RHaHlaV1VnWVhKbmRXMWxiblJ6WEc1Y2RDQXFJRUJ3WVhKaGJTQjdLbjBnVzNSb2FYTkJjbWRkSUZaaGJIVmxJSFJ2SUhWelpTQmhjeUJnZEdocGMyQWdkMmhsYmlCbGVHVmpkWFJwYm1jZ1puVnVZM1JwYjI1Y2JseDBJQ29nUUhKbGRIVnlibk1nZTBOdmJHeGxZM1JwYjI1OVhHNWNkQ0FxSUVCbGVHRnRjR3hsSUdOdmJHeGxZM1JwYjI0dWJXRndWbUZzZFdWektIVnpaWElnUFQ0Z2RYTmxjaTUwWVdjcE8xeHVYSFFnS2k5Y2JseDBjSFZpYkdsaklHMWhjRlpoYkhWbGN6eFVQaWhtYmpvZ0tIWmhiSFZsT2lCV0xDQnJaWGs2SUVzc0lHTnZiR3hsWTNScGIyNDZJSFJvYVhNcElEMCtJRlFwT2lCRGIyeHNaV04wYVc5dVBFc3NJRlErTzF4dVhIUndkV0pzYVdNZ2JXRndWbUZzZFdWelBGUm9hWE1zSUZRK0tHWnVPaUFvZEdocGN6b2dWR2hwY3l3Z2RtRnNkV1U2SUZZc0lHdGxlVG9nU3l3Z1kyOXNiR1ZqZEdsdmJqb2dkR2hwY3lrZ1BUNGdWQ3dnZEdocGMwRnlaem9nVkdocGN5azZJRU52Ykd4bFkzUnBiMjQ4U3l3Z1ZENDdYRzVjZEhCMVlteHBZeUJ0WVhCV1lXeDFaWE04VkQ0b1ptNDZJQ2gyWVd4MVpUb2dWaXdnYTJWNU9pQkxMQ0JqYjJ4c1pXTjBhVzl1T2lCMGFHbHpLU0E5UGlCVUxDQjBhR2x6UVhKblB6b2dkVzVyYm05M2JpazZJRU52Ykd4bFkzUnBiMjQ4U3l3Z1ZENGdlMXh1WEhSY2RHbG1JQ2gwZVhCbGIyWWdkR2hwYzBGeVp5QWhQVDBnSjNWdVpHVm1hVzVsWkNjcElHWnVJRDBnWm00dVltbHVaQ2gwYUdselFYSm5LVHRjYmx4MFhIUmpiMjV6ZENCamIyeHNJRDBnYm1WM0lIUm9hWE11WTI5dWMzUnlkV04wYjNKYlUzbHRZbTlzTG5Od1pXTnBaWE5kUEVzc0lGUStLQ2tnWVhNZ1EyOXNiR1ZqZEdsdmJqeExMQ0JVUGp0Y2JseDBYSFJtYjNJZ0tHTnZibk4wSUZ0clpYa3NJSFpoYkYwZ2IyWWdkR2hwY3lrZ1kyOXNiQzV6WlhRb2EyVjVMQ0JtYmloMllXd3NJR3RsZVN3Z2RHaHBjeWtwTzF4dVhIUmNkSEpsZEhWeWJpQmpiMnhzTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFTm9aV05yY3lCcFppQjBhR1Z5WlNCbGVHbHpkSE1nWVc0Z2FYUmxiU0IwYUdGMElIQmhjM05sY3lCaElIUmxjM1F1SUVsa1pXNTBhV05oYkNCcGJpQmlaV2hoZG1sdmNpQjBiMXh1WEhRZ0tpQmJRWEp5WVhrdWMyOXRaU2dwWFNob2RIUndjem92TDJSbGRtVnNiM0JsY2k1dGIzcHBiR3hoTG05eVp5OWxiaTFWVXk5a2IyTnpMMWRsWWk5S1lYWmhVMk55YVhCMEwxSmxabVZ5Wlc1alpTOUhiRzlpWVd4ZlQySnFaV04wY3k5QmNuSmhlUzl6YjIxbEtTNWNibHgwSUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ1ptNGdSblZ1WTNScGIyNGdkWE5sWkNCMGJ5QjBaWE4wSUNoemFHOTFiR1FnY21WMGRYSnVJR0VnWW05dmJHVmhiaWxjYmx4MElDb2dRSEJoY21GdElIc3FmU0JiZEdocGMwRnlaMTBnVm1Gc2RXVWdkRzhnZFhObElHRnpJR0IwYUdsellDQjNhR1Z1SUdWNFpXTjFkR2x1WnlCbWRXNWpkR2x2Ymx4dVhIUWdLaUJBY21WMGRYSnVjeUI3WW05dmJHVmhibjFjYmx4MElDb2dRR1Y0WVcxd2JHVWdZMjlzYkdWamRHbHZiaTV6YjIxbEtIVnpaWElnUFQ0Z2RYTmxjaTVrYVhOamNtbHRhVzVoZEc5eUlEMDlQU0FuTURBd01DY3BPMXh1WEhRZ0tpOWNibHgwY0hWaWJHbGpJSE52YldVb1ptNDZJQ2gyWVd4MVpUb2dWaXdnYTJWNU9pQkxMQ0JqYjJ4c1pXTjBhVzl1T2lCMGFHbHpLU0E5UGlCaWIyOXNaV0Z1S1RvZ1ltOXZiR1ZoYmp0Y2JseDBjSFZpYkdsaklITnZiV1U4VkQ0b1ptNDZJQ2gwYUdsek9pQlVMQ0IyWVd4MVpUb2dWaXdnYTJWNU9pQkxMQ0JqYjJ4c1pXTjBhVzl1T2lCMGFHbHpLU0E5UGlCaWIyOXNaV0Z1TENCMGFHbHpRWEpuT2lCVUtUb2dZbTl2YkdWaGJqdGNibHgwY0hWaWJHbGpJSE52YldVb1ptNDZJQ2gyWVd4MVpUb2dWaXdnYTJWNU9pQkxMQ0JqYjJ4c1pXTjBhVzl1T2lCMGFHbHpLU0E5UGlCaWIyOXNaV0Z1TENCMGFHbHpRWEpuUHpvZ2RXNXJibTkzYmlrNklHSnZiMnhsWVc0Z2UxeHVYSFJjZEdsbUlDaDBlWEJsYjJZZ2RHaHBjMEZ5WnlBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUdadUlEMGdabTR1WW1sdVpDaDBhR2x6UVhKbktUdGNibHgwWEhSbWIzSWdLR052Ym5OMElGdHJaWGtzSUhaaGJGMGdiMllnZEdocGN5a2dlMXh1WEhSY2RGeDBhV1lnS0dadUtIWmhiQ3dnYTJWNUxDQjBhR2x6S1NrZ2NtVjBkWEp1SUhSeWRXVTdYRzVjZEZ4MGZWeHVYSFJjZEhKbGRIVnliaUJtWVd4elpUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJEYUdWamEzTWdhV1lnWVd4c0lHbDBaVzF6SUhCaGMzTmxjeUJoSUhSbGMzUXVJRWxrWlc1MGFXTmhiQ0JwYmlCaVpXaGhkbWx2Y2lCMGIxeHVYSFFnS2lCYlFYSnlZWGt1WlhabGNua29LVjBvYUhSMGNITTZMeTlrWlhabGJHOXdaWEl1Ylc5NmFXeHNZUzV2Y21jdlpXNHRWVk12Wkc5amN5OVhaV0l2U21GMllWTmpjbWx3ZEM5U1pXWmxjbVZ1WTJVdlIyeHZZbUZzWDA5aWFtVmpkSE12UVhKeVlYa3ZaWFpsY25rcExseHVYSFFnS2lCQWNHRnlZVzBnZTBaMWJtTjBhVzl1ZlNCbWJpQkdkVzVqZEdsdmJpQjFjMlZrSUhSdklIUmxjM1FnS0hOb2IzVnNaQ0J5WlhSMWNtNGdZU0JpYjI5c1pXRnVLVnh1WEhRZ0tpQkFjR0Z5WVcwZ2V5cDlJRnQwYUdselFYSm5YU0JXWVd4MVpTQjBieUIxYzJVZ1lYTWdZSFJvYVhOZ0lIZG9aVzRnWlhobFkzVjBhVzVuSUdaMWJtTjBhVzl1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHRpYjI5c1pXRnVmVnh1WEhRZ0tpQkFaWGhoYlhCc1pTQmpiMnhzWldOMGFXOXVMbVYyWlhKNUtIVnpaWElnUFQ0Z0lYVnpaWEl1WW05MEtUdGNibHgwSUNvdlhHNWNkSEIxWW14cFl5QmxkbVZ5ZVNobWJqb2dLSFpoYkhWbE9pQldMQ0JyWlhrNklFc3NJR052Ykd4bFkzUnBiMjQ2SUhSb2FYTXBJRDArSUdKdmIyeGxZVzRwT2lCaWIyOXNaV0Z1TzF4dVhIUndkV0pzYVdNZ1pYWmxjbms4VkQ0b1ptNDZJQ2gwYUdsek9pQlVMQ0IyWVd4MVpUb2dWaXdnYTJWNU9pQkxMQ0JqYjJ4c1pXTjBhVzl1T2lCMGFHbHpLU0E5UGlCaWIyOXNaV0Z1TENCMGFHbHpRWEpuT2lCVUtUb2dZbTl2YkdWaGJqdGNibHgwY0hWaWJHbGpJR1YyWlhKNUtHWnVPaUFvZG1Gc2RXVTZJRllzSUd0bGVUb2dTeXdnWTI5c2JHVmpkR2x2YmpvZ2RHaHBjeWtnUFQ0Z1ltOXZiR1ZoYml3Z2RHaHBjMEZ5Wno4NklIVnVhMjV2ZDI0cE9pQmliMjlzWldGdUlIdGNibHgwWEhScFppQW9kSGx3Wlc5bUlIUm9hWE5CY21jZ0lUMDlJQ2QxYm1SbFptbHVaV1FuS1NCbWJpQTlJR1p1TG1KcGJtUW9kR2hwYzBGeVp5azdYRzVjZEZ4MFptOXlJQ2hqYjI1emRDQmJhMlY1TENCMllXeGRJRzltSUhSb2FYTXBJSHRjYmx4MFhIUmNkR2xtSUNnaFptNG9kbUZzTENCclpYa3NJSFJvYVhNcEtTQnlaWFIxY200Z1ptRnNjMlU3WEc1Y2RGeDBmVnh1WEhSY2RISmxkSFZ5YmlCMGNuVmxPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUVGd2NHeHBaWE1nWVNCbWRXNWpkR2x2YmlCMGJ5QndjbTlrZFdObElHRWdjMmx1WjJ4bElIWmhiSFZsTGlCSlpHVnVkR2xqWVd3Z2FXNGdZbVZvWVhacGIzSWdkRzljYmx4MElDb2dXMEZ5Y21GNUxuSmxaSFZqWlNncFhTaG9kSFJ3Y3pvdkwyUmxkbVZzYjNCbGNpNXRiM3BwYkd4aExtOXlaeTlsYmkxVlV5OWtiMk56TDFkbFlpOUtZWFpoVTJOeWFYQjBMMUpsWm1WeVpXNWpaUzlIYkc5aVlXeGZUMkpxWldOMGN5OUJjbkpoZVM5eVpXUjFZMlVwTGx4dVhIUWdLaUJBY0dGeVlXMGdlMFoxYm1OMGFXOXVmU0JtYmlCR2RXNWpkR2x2YmlCMWMyVmtJSFJ2SUhKbFpIVmpaU3dnZEdGcmFXNW5JR1p2ZFhJZ1lYSm5kVzFsYm5Sek95QmdZV05qZFcxMWJHRjBiM0pnTENCZ1kzVnljbVZ1ZEZaaGJIVmxZQ3dnWUdOMWNuSmxiblJMWlhsZ0xGeHVYSFFnS2lCaGJtUWdZR052Ykd4bFkzUnBiMjVnWEc1Y2RDQXFJRUJ3WVhKaGJTQjdLbjBnVzJsdWFYUnBZV3hXWVd4MVpWMGdVM1JoY25ScGJtY2dkbUZzZFdVZ1ptOXlJSFJvWlNCaFkyTjFiWFZzWVhSdmNseHVYSFFnS2lCQWNtVjBkWEp1Y3lCN0tuMWNibHgwSUNvZ1FHVjRZVzF3YkdVZ1kyOXNiR1ZqZEdsdmJpNXlaV1IxWTJVb0tHRmpZeXdnWjNWcGJHUXBJRDArSUdGall5QXJJR2QxYVd4a0xtMWxiV0psY2tOdmRXNTBMQ0F3S1R0Y2JseDBJQ292WEc1Y2RIQjFZbXhwWXlCeVpXUjFZMlU4VkQ0b1ptNDZJQ2hoWTJOMWJYVnNZWFJ2Y2pvZ1ZDd2dkbUZzZFdVNklGWXNJR3RsZVRvZ1N5d2dZMjlzYkdWamRHbHZiam9nZEdocGN5a2dQVDRnVkN3Z2FXNXBkR2xoYkZaaGJIVmxQem9nVkNrNklGUWdlMXh1WEhSY2RHeGxkQ0JoWTJOMWJYVnNZWFJ2Y2lFNklGUTdYRzVjYmx4MFhIUnBaaUFvZEhsd1pXOW1JR2x1YVhScFlXeFdZV3gxWlNBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JseDBYSFJjZEdGalkzVnRkV3hoZEc5eUlEMGdhVzVwZEdsaGJGWmhiSFZsTzF4dVhIUmNkRngwWm05eUlDaGpiMjV6ZENCYmEyVjVMQ0IyWVd4ZElHOW1JSFJvYVhNcElHRmpZM1Z0ZFd4aGRHOXlJRDBnWm00b1lXTmpkVzExYkdGMGIzSXNJSFpoYkN3Z2EyVjVMQ0IwYUdsektUdGNibHgwWEhSY2RISmxkSFZ5YmlCaFkyTjFiWFZzWVhSdmNqdGNibHgwWEhSOVhHNWNkRngwYkdWMElHWnBjbk4wSUQwZ2RISjFaVHRjYmx4MFhIUm1iM0lnS0dOdmJuTjBJRnRyWlhrc0lIWmhiRjBnYjJZZ2RHaHBjeWtnZTF4dVhIUmNkRngwYVdZZ0tHWnBjbk4wS1NCN1hHNWNkRngwWEhSY2RHRmpZM1Z0ZFd4aGRHOXlJRDBnZG1Gc0lHRnpJSFZ1YTI1dmQyNGdZWE1nVkR0Y2JseDBYSFJjZEZ4MFptbHljM1FnUFNCbVlXeHpaVHRjYmx4MFhIUmNkRngwWTI5dWRHbHVkV1U3WEc1Y2RGeDBYSFI5WEc1Y2RGeDBYSFJoWTJOMWJYVnNZWFJ2Y2lBOUlHWnVLR0ZqWTNWdGRXeGhkRzl5TENCMllXd3NJR3RsZVN3Z2RHaHBjeWs3WEc1Y2RGeDBmVnh1WEc1Y2RGeDBMeThnVG04Z2FYUmxiWE1nYVhSbGNtRjBaV1F1WEc1Y2RGeDBhV1lnS0dacGNuTjBLU0I3WEc1Y2RGeDBYSFIwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkU1pXUjFZMlVnYjJZZ1pXMXdkSGtnWTI5c2JHVmpkR2x2YmlCM2FYUm9JRzV2SUdsdWFYUnBZV3dnZG1Gc2RXVW5LVHRjYmx4MFhIUjlYRzVjYmx4MFhIUnlaWFIxY200Z1lXTmpkVzExYkdGMGIzSTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nU1dSbGJuUnBZMkZzSUhSdlhHNWNkQ0FxSUZ0TllYQXVabTl5UldGamFDZ3BYU2hvZEhSd2N6b3ZMMlJsZG1Wc2IzQmxjaTV0YjNwcGJHeGhMbTl5Wnk5bGJpMVZVeTlrYjJOekwxZGxZaTlLWVhaaFUyTnlhWEIwTDFKbFptVnlaVzVqWlM5SGJHOWlZV3hmVDJKcVpXTjBjeTlOWVhBdlptOXlSV0ZqYUNrc1hHNWNkQ0FxSUdKMWRDQnlaWFIxY201eklIUm9aU0JqYjJ4c1pXTjBhVzl1SUdsdWMzUmxZV1FnYjJZZ2RXNWtaV1pwYm1Wa0xseHVYSFFnS2lCQWNHRnlZVzBnZTBaMWJtTjBhVzl1ZlNCbWJpQkdkVzVqZEdsdmJpQjBieUJsZUdWamRYUmxJR1p2Y2lCbFlXTm9JR1ZzWlcxbGJuUmNibHgwSUNvZ1FIQmhjbUZ0SUhzcWZTQmJkR2hwYzBGeVoxMGdWbUZzZFdVZ2RHOGdkWE5sSUdGeklHQjBhR2x6WUNCM2FHVnVJR1Y0WldOMWRHbHVaeUJtZFc1amRHbHZibHh1WEhRZ0tpQkFjbVYwZFhKdWN5QjdRMjlzYkdWamRHbHZibjFjYmx4MElDb2dRR1Y0WVcxd2JHVmNibHgwSUNvZ1kyOXNiR1ZqZEdsdmJseHVYSFFnS2lBZ0xtVmhZMmdvZFhObGNpQTlQaUJqYjI1emIyeGxMbXh2WnloMWMyVnlMblZ6WlhKdVlXMWxLU2xjYmx4MElDb2dJQzVtYVd4MFpYSW9kWE5sY2lBOVBpQjFjMlZ5TG1KdmRDbGNibHgwSUNvZ0lDNWxZV05vS0hWelpYSWdQVDRnWTI5dWMyOXNaUzVzYjJjb2RYTmxjaTUxYzJWeWJtRnRaU2twTzF4dVhIUWdLaTljYmx4MGNIVmliR2xqSUdWaFkyZ29abTQ2SUNoMllXeDFaVG9nVml3Z2EyVjVPaUJMTENCamIyeHNaV04wYVc5dU9pQjBhR2x6S1NBOVBpQjJiMmxrS1RvZ2RHaHBjenRjYmx4MGNIVmliR2xqSUdWaFkyZzhWRDRvWm00NklDaDBhR2x6T2lCVUxDQjJZV3gxWlRvZ1Zpd2dhMlY1T2lCTExDQmpiMnhzWldOMGFXOXVPaUIwYUdsektTQTlQaUIyYjJsa0xDQjBhR2x6UVhKbk9pQlVLVG9nZEdocGN6dGNibHgwY0hWaWJHbGpJR1ZoWTJnb1ptNDZJQ2gyWVd4MVpUb2dWaXdnYTJWNU9pQkxMQ0JqYjJ4c1pXTjBhVzl1T2lCMGFHbHpLU0E5UGlCMmIybGtMQ0IwYUdselFYSm5Qem9nZFc1cmJtOTNiaWs2SUhSb2FYTWdlMXh1WEhSY2RIUm9hWE11Wm05eVJXRmphQ2htYmlCaGN5QW9kbUZzZFdVNklGWXNJR3RsZVRvZ1N5d2diV0Z3T2lCTllYQThTeXdnVmo0cElEMCtJSFp2YVdRc0lIUm9hWE5CY21jcE8xeHVYSFJjZEhKbGRIVnliaUIwYUdsek8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRkoxYm5NZ1lTQm1kVzVqZEdsdmJpQnZiaUIwYUdVZ1kyOXNiR1ZqZEdsdmJpQmhibVFnY21WMGRYSnVjeUIwYUdVZ1kyOXNiR1ZqZEdsdmJpNWNibHgwSUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ1ptNGdSblZ1WTNScGIyNGdkRzhnWlhobFkzVjBaVnh1WEhRZ0tpQkFjR0Z5WVcwZ2V5cDlJRnQwYUdselFYSm5YU0JXWVd4MVpTQjBieUIxYzJVZ1lYTWdZSFJvYVhOZ0lIZG9aVzRnWlhobFkzVjBhVzVuSUdaMWJtTjBhVzl1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHREYjJ4c1pXTjBhVzl1ZlZ4dVhIUWdLaUJBWlhoaGJYQnNaVnh1WEhRZ0tpQmpiMnhzWldOMGFXOXVYRzVjZENBcUlDQXVkR0Z3S0dOdmJHd2dQVDRnWTI5dWMyOXNaUzVzYjJjb1kyOXNiQzV6YVhwbEtTbGNibHgwSUNvZ0lDNW1hV3gwWlhJb2RYTmxjaUE5UGlCMWMyVnlMbUp2ZENsY2JseDBJQ29nSUM1MFlYQW9ZMjlzYkNBOVBpQmpiMjV6YjJ4bExteHZaeWhqYjJ4c0xuTnBlbVVwS1Z4dVhIUWdLaTljYmx4MGNIVmliR2xqSUhSaGNDaG1iam9nS0dOdmJHeGxZM1JwYjI0NklIUm9hWE1wSUQwK0lIWnZhV1FwT2lCMGFHbHpPMXh1WEhSd2RXSnNhV01nZEdGd1BGUStLR1p1T2lBb2RHaHBjem9nVkN3Z1kyOXNiR1ZqZEdsdmJqb2dkR2hwY3lrZ1BUNGdkbTlwWkN3Z2RHaHBjMEZ5WnpvZ1ZDazZJSFJvYVhNN1hHNWNkSEIxWW14cFl5QjBZWEFvWm00NklDaGpiMnhzWldOMGFXOXVPaUIwYUdsektTQTlQaUIyYjJsa0xDQjBhR2x6UVhKblB6b2dkVzVyYm05M2JpazZJSFJvYVhNZ2UxeHVYSFJjZEdsbUlDaDBlWEJsYjJZZ2RHaHBjMEZ5WnlBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUdadUlEMGdabTR1WW1sdVpDaDBhR2x6UVhKbktUdGNibHgwWEhSbWJpaDBhR2x6S1R0Y2JseDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkRjbVZoZEdWeklHRnVJR2xrWlc1MGFXTmhiQ0J6YUdGc2JHOTNJR052Y0hrZ2IyWWdkR2hwY3lCamIyeHNaV04wYVc5dUxseHVYSFFnS2lCQWNtVjBkWEp1Y3lCN1EyOXNiR1ZqZEdsdmJuMWNibHgwSUNvZ1FHVjRZVzF3YkdVZ1kyOXVjM1FnYm1WM1EyOXNiQ0E5SUhOdmJXVkRiMnhzTG1Oc2IyNWxLQ2s3WEc1Y2RDQXFMMXh1WEhSd2RXSnNhV01nWTJ4dmJtVW9LVG9nZEdocGN5QjdYRzVjZEZ4MGNtVjBkWEp1SUc1bGR5QjBhR2x6TG1OdmJuTjBjblZqZEc5eVcxTjViV0p2YkM1emNHVmphV1Z6WFNoMGFHbHpLU0JoY3lCMGFHbHpPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUVOdmJXSnBibVZ6SUhSb2FYTWdZMjlzYkdWamRHbHZiaUIzYVhSb0lHOTBhR1Z5Y3lCcGJuUnZJR0VnYm1WM0lHTnZiR3hsWTNScGIyNHVJRTV2Ym1VZ2IyWWdkR2hsSUhOdmRYSmpaU0JqYjJ4c1pXTjBhVzl1Y3lCaGNtVWdiVzlrYVdacFpXUXVYRzVjZENBcUlFQndZWEpoYlNCN0xpNHVRMjlzYkdWamRHbHZibjBnWTI5c2JHVmpkR2x2Ym5NZ1EyOXNiR1ZqZEdsdmJuTWdkRzhnYldWeVoyVmNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UwTnZiR3hsWTNScGIyNTlYRzVjZENBcUlFQmxlR0Z0Y0d4bElHTnZibk4wSUc1bGQwTnZiR3dnUFNCemIyMWxRMjlzYkM1amIyNWpZWFFvYzI5dFpVOTBhR1Z5UTI5c2JDd2dZVzV2ZEdobGNrTnZiR3dzSUc5b1FtOTVRVU52Ykd3cE8xeHVYSFFnS2k5Y2JseDBjSFZpYkdsaklHTnZibU5oZENndUxpNWpiMnhzWldOMGFXOXVjem9nUTI5c2JHVmpkR2x2Ymp4TExDQldQbHRkS1RvZ2RHaHBjeUI3WEc1Y2RGeDBZMjl1YzNRZ2JtVjNRMjlzYkNBOUlIUm9hWE11WTJ4dmJtVW9LVHRjYmx4MFhIUm1iM0lnS0dOdmJuTjBJR052Ykd3Z2IyWWdZMjlzYkdWamRHbHZibk1wSUh0Y2JseDBYSFJjZEdadmNpQW9ZMjl1YzNRZ1cydGxlU3dnZG1Gc1hTQnZaaUJqYjJ4c0tTQnVaWGREYjJ4c0xuTmxkQ2hyWlhrc0lIWmhiQ2s3WEc1Y2RGeDBmVnh1WEhSY2RISmxkSFZ5YmlCdVpYZERiMnhzTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFTm9aV05yY3lCcFppQjBhR2x6SUdOdmJHeGxZM1JwYjI0Z2MyaGhjbVZ6SUdsa1pXNTBhV05oYkNCcGRHVnRjeUIzYVhSb0lHRnViM1JvWlhJdVhHNWNkQ0FxSUZSb2FYTWdhWE1nWkdsbVptVnlaVzUwSUhSdklHTm9aV05yYVc1bklHWnZjaUJsY1hWaGJHbDBlU0IxYzJsdVp5QmxjWFZoYkMxemFXZHVjeXdnWW1WallYVnpaVnh1WEhRZ0tpQjBhR1VnWTI5c2JHVmpkR2x2Ym5NZ2JXRjVJR0psSUdScFptWmxjbVZ1ZENCdlltcGxZM1J6TENCaWRYUWdZMjl1ZEdGcGJpQjBhR1VnYzJGdFpTQmtZWFJoTGx4dVhIUWdLaUJBY0dGeVlXMGdlME52Ykd4bFkzUnBiMjU5SUdOdmJHeGxZM1JwYjI0Z1EyOXNiR1ZqZEdsdmJpQjBieUJqYjIxd1lYSmxJSGRwZEdoY2JseDBJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUZkb1pYUm9aWElnZEdobElHTnZiR3hsWTNScGIyNXpJR2hoZG1VZ2FXUmxiblJwWTJGc0lHTnZiblJsYm5SelhHNWNkQ0FxTDF4dVhIUndkV0pzYVdNZ1pYRjFZV3h6S0dOdmJHeGxZM1JwYjI0NklFTnZiR3hsWTNScGIyNDhTeXdnVmo0cE9pQmliMjlzWldGdUlIdGNibHgwWEhScFppQW9JV052Ykd4bFkzUnBiMjRwSUhKbGRIVnliaUJtWVd4elpUdGNibHgwWEhScFppQW9kR2hwY3lBOVBUMGdZMjlzYkdWamRHbHZiaWtnY21WMGRYSnVJSFJ5ZFdVN1hHNWNkRngwYVdZZ0tIUm9hWE11YzJsNlpTQWhQVDBnWTI5c2JHVmpkR2x2Ymk1emFYcGxLU0J5WlhSMWNtNGdabUZzYzJVN1hHNWNkRngwWm05eUlDaGpiMjV6ZENCYmEyVjVMQ0IyWVd4MVpWMGdiMllnZEdocGN5a2dlMXh1WEhSY2RGeDBhV1lnS0NGamIyeHNaV04wYVc5dUxtaGhjeWhyWlhrcElIeDhJSFpoYkhWbElDRTlQU0JqYjJ4c1pXTjBhVzl1TG1kbGRDaHJaWGtwS1NCN1hHNWNkRngwWEhSY2RISmxkSFZ5YmlCbVlXeHpaVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjZEZ4MGNtVjBkWEp1SUhSeWRXVTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nVkdobElITnZjblFnYldWMGFHOWtJSE52Y25SeklIUm9aU0JwZEdWdGN5QnZaaUJoSUdOdmJHeGxZM1JwYjI0Z2FXNGdjR3hoWTJVZ1lXNWtJSEpsZEhWeWJuTWdhWFF1WEc1Y2RDQXFJRlJvWlNCemIzSjBJR2x6SUc1dmRDQnVaV05sYzNOaGNtbHNlU0J6ZEdGaWJHVWdhVzRnVG05a1pTQXhNQ0J2Y2lCdmJHUmxjaTVjYmx4MElDb2dWR2hsSUdSbFptRjFiSFFnYzI5eWRDQnZjbVJsY2lCcGN5QmhZMk52Y21ScGJtY2dkRzhnYzNSeWFXNW5JRlZ1YVdOdlpHVWdZMjlrWlNCd2IybHVkSE11WEc1Y2RDQXFJRUJ3WVhKaGJTQjdSblZ1WTNScGIyNTlJRnRqYjIxd1lYSmxSblZ1WTNScGIyNWRJRk53WldOcFptbGxjeUJoSUdaMWJtTjBhVzl1SUhSb1lYUWdaR1ZtYVc1bGN5QjBhR1VnYzI5eWRDQnZjbVJsY2k1Y2JseDBJQ29nU1dZZ2IyMXBkSFJsWkN3Z2RHaGxJR052Ykd4bFkzUnBiMjRnYVhNZ2MyOXlkR1ZrSUdGalkyOXlaR2x1WnlCMGJ5QmxZV05vSUdOb1lYSmhZM1JsY2lkeklGVnVhV052WkdVZ1kyOWtaU0J3YjJsdWRDQjJZV3gxWlN4Y2JseDBJQ29nWVdOamIzSmthVzVuSUhSdklIUm9aU0J6ZEhKcGJtY2dZMjl1ZG1WeWMybHZiaUJ2WmlCbFlXTm9JR1ZzWlcxbGJuUXVYRzVjZENBcUlFQnlaWFIxY201eklIdERiMnhzWldOMGFXOXVmVnh1WEhRZ0tpQkFaWGhoYlhCc1pTQmpiMnhzWldOMGFXOXVMbk52Y25Rb0tIVnpaWEpCTENCMWMyVnlRaWtnUFQ0Z2RYTmxja0V1WTNKbFlYUmxaRlJwYldWemRHRnRjQ0F0SUhWelpYSkNMbU55WldGMFpXUlVhVzFsYzNSaGJYQXBPMXh1WEhRZ0tpOWNibHgwY0hWaWJHbGpJSE52Y25Rb1kyOXRjR0Z5WlVaMWJtTjBhVzl1T2lBb1ptbHljM1JXWVd4MVpUb2dWaXdnYzJWamIyNWtWbUZzZFdVNklGWXNJR1pwY25OMFMyVjVPaUJMTENCelpXTnZibVJMWlhrNklFc3BJRDArSUc1MWJXSmxjaUE5SUNoNExDQjVLVG9nYm5WdFltVnlJRDArSUU1MWJXSmxjaWg0SUQ0Z2VTa2dmSHdnVG5WdFltVnlLSGdnUFQwOUlIa3BJQzBnTVNrNklIUm9hWE1nZTF4dVhIUmNkR052Ym5OMElHVnVkSEpwWlhNZ1BTQmJMaTR1ZEdocGN5NWxiblJ5YVdWektDbGRPMXh1WEhSY2RHVnVkSEpwWlhNdWMyOXlkQ2dvWVN3Z1lpazZJRzUxYldKbGNpQTlQaUJqYjIxd1lYSmxSblZ1WTNScGIyNG9ZVnN4WFN3Z1lsc3hYU3dnWVZzd1hTd2dZbHN3WFNrcE8xeHVYRzVjZEZ4MEx5OGdVR1Z5Wm05eWJTQmpiR1ZoYmkxMWNGeHVYSFJjZEhOMWNHVnlMbU5zWldGeUtDazdYRzVjZEZ4MGRHaHBjeTVmWVhKeVlYa2dQU0J1ZFd4c08xeHVYSFJjZEhSb2FYTXVYMnRsZVVGeWNtRjVJRDBnYm5Wc2JEdGNibHh1WEhSY2RDOHZJRk5sZENCMGFHVWdibVYzSUdWdWRISnBaWE5jYmx4MFhIUm1iM0lnS0dOdmJuTjBJRnRyTENCMlhTQnZaaUJsYm5SeWFXVnpLU0I3WEc1Y2RGeDBYSFJ6ZFhCbGNpNXpaWFFvYXl3Z2RpazdYRzVjZEZ4MGZWeHVYSFJjZEhKbGRIVnliaUIwYUdsek8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRlJvWlNCcGJuUmxjbk5sWTNRZ2JXVjBhRzlrSUhKbGRIVnlibk1nWVNCdVpYY2djM1J5ZFdOMGRYSmxJR052Ym5SaGFXNXBibWNnYVhSbGJYTWdkMmhsY21VZ2RHaGxJR3RsZVhNZ1lYSmxJSEJ5WlhObGJuUWdhVzRnWW05MGFDQnZjbWxuYVc1aGJDQnpkSEoxWTNSMWNtVnpMbHh1WEhRZ0tpQkFjR0Z5WVcwZ2UwTnZiR3hsWTNScGIyNTlJRzkwYUdWeUlGUm9aU0J2ZEdobGNpQkRiMnhzWldOMGFXOXVJSFJ2SUdacGJIUmxjaUJoWjJGcGJuTjBYRzVjZENBcUlFQnlaWFIxY201eklIdERiMnhzWldOMGFXOXVmVnh1WEhRZ0tpOWNibHgwY0hWaWJHbGpJR2x1ZEdWeWMyVmpkQ2h2ZEdobGNqb2dRMjlzYkdWamRHbHZianhMTENCV1BpazZJRU52Ykd4bFkzUnBiMjQ4U3l3Z1ZqNGdlMXh1WEhSY2RISmxkSFZ5YmlCdmRHaGxjaTVtYVd4MFpYSW9LRjhzSUdzcElEMCtJSFJvYVhNdWFHRnpLR3NwS1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQlVhR1VnWkdsbVptVnlaVzVqWlNCdFpYUm9iMlFnY21WMGRYSnVjeUJoSUc1bGR5QnpkSEoxWTNSMWNtVWdZMjl1ZEdGcGJtbHVaeUJwZEdWdGN5QjNhR1Z5WlNCMGFHVWdhMlY1SUdseklIQnlaWE5sYm5RZ2FXNGdiMjVsSUc5bUlIUm9aU0J2Y21sbmFXNWhiQ0J6ZEhKMVkzUjFjbVZ6SUdKMWRDQnViM1FnZEdobElHOTBhR1Z5TGx4dVhIUWdLaUJBY0dGeVlXMGdlME52Ykd4bFkzUnBiMjU5SUc5MGFHVnlJRlJvWlNCdmRHaGxjaUJEYjJ4c1pXTjBhVzl1SUhSdklHWnBiSFJsY2lCaFoyRnBibk4wWEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHREYjJ4c1pXTjBhVzl1ZlZ4dVhIUWdLaTljYmx4MGNIVmliR2xqSUdScFptWmxjbVZ1WTJVb2IzUm9aWEk2SUVOdmJHeGxZM1JwYjI0OFN5d2dWajRwT2lCRGIyeHNaV04wYVc5dVBFc3NJRlkrSUh0Y2JseDBYSFJ5WlhSMWNtNGdiM1JvWlhJdVptbHNkR1Z5S0NoZkxDQnJLU0E5UGlBaGRHaHBjeTVvWVhNb2F5a3BMbU52Ym1OaGRDaDBhR2x6TG1acGJIUmxjaWdvWHl3Z2F5a2dQVDRnSVc5MGFHVnlMbWhoY3locktTa3BPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUZSb1pTQnpiM0owWldRZ2JXVjBhRzlrSUhOdmNuUnpJSFJvWlNCcGRHVnRjeUJ2WmlCaElHTnZiR3hsWTNScGIyNGdZVzVrSUhKbGRIVnlibk1nYVhRdVhHNWNkQ0FxSUZSb1pTQnpiM0owSUdseklHNXZkQ0J1WldObGMzTmhjbWxzZVNCemRHRmliR1VnYVc0Z1RtOWtaU0F4TUNCdmNpQnZiR1JsY2k1Y2JseDBJQ29nVkdobElHUmxabUYxYkhRZ2MyOXlkQ0J2Y21SbGNpQnBjeUJoWTJOdmNtUnBibWNnZEc4Z2MzUnlhVzVuSUZWdWFXTnZaR1VnWTI5a1pTQndiMmx1ZEhNdVhHNWNkQ0FxSUVCd1lYSmhiU0I3Um5WdVkzUnBiMjU5SUZ0amIyMXdZWEpsUm5WdVkzUnBiMjVkSUZOd1pXTnBabWxsY3lCaElHWjFibU4wYVc5dUlIUm9ZWFFnWkdWbWFXNWxjeUIwYUdVZ2MyOXlkQ0J2Y21SbGNpNWNibHgwSUNvZ1NXWWdiMjFwZEhSbFpDd2dkR2hsSUdOdmJHeGxZM1JwYjI0Z2FYTWdjMjl5ZEdWa0lHRmpZMjl5WkdsdVp5QjBieUJsWVdOb0lHTm9ZWEpoWTNSbGNpZHpJRlZ1YVdOdlpHVWdZMjlrWlNCd2IybHVkQ0IyWVd4MVpTeGNibHgwSUNvZ1lXTmpiM0prYVc1bklIUnZJSFJvWlNCemRISnBibWNnWTI5dWRtVnljMmx2YmlCdlppQmxZV05vSUdWc1pXMWxiblF1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHREYjJ4c1pXTjBhVzl1ZlZ4dVhIUWdLaUJBWlhoaGJYQnNaU0JqYjJ4c1pXTjBhVzl1TG5OdmNuUmxaQ2dvZFhObGNrRXNJSFZ6WlhKQ0tTQTlQaUIxYzJWeVFTNWpjbVZoZEdWa1ZHbHRaWE4wWVcxd0lDMGdkWE5sY2tJdVkzSmxZWFJsWkZScGJXVnpkR0Z0Y0NrN1hHNWNkQ0FxTDF4dVhIUndkV0pzYVdNZ2MyOXlkR1ZrS0dOdmJYQmhjbVZHZFc1amRHbHZiam9nS0dacGNuTjBWbUZzZFdVNklGWXNJSE5sWTI5dVpGWmhiSFZsT2lCV0xDQm1hWEp6ZEV0bGVUb2dTeXdnYzJWamIyNWtTMlY1T2lCTEtTQTlQaUJ1ZFcxaVpYSWdQU0FvZUN3Z2VTazZJRzUxYldKbGNpQTlQaUJPZFcxaVpYSW9lQ0ErSUhrcElIeDhJRTUxYldKbGNpaDRJRDA5UFNCNUtTQXRJREVwT2lCMGFHbHpJSHRjYmx4MFhIUnlaWFIxY200Z0tHNWxkeUIwYUdsekxtTnZibk4wY25WamRHOXlXMU41YldKdmJDNXpjR1ZqYVdWelhTaGJMaTR1ZEdocGN5NWxiblJ5YVdWektDbGRLU0JoY3lCMGFHbHpLVnh1WEhSY2RGeDBMbk52Y25Rb0tHRjJMQ0JpZGl3Z1lXc3NJR0pyS1NBOVBpQmpiMjF3WVhKbFJuVnVZM1JwYjI0b1lYWXNJR0oyTENCaGF5d2dZbXNwS1R0Y2JseDBmVnh1ZlZ4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlFTnZiR3hsWTNScGIyNDdYRzVsZUhCdmNuUWdleUJEYjJ4c1pXTjBhVzl1SUgwN1hHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCRGIyeHNaV04wYVc5dU8xeHVJbDE5IiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnID8gc2VsZi5Gb3JtRGF0YSA6IHdpbmRvdy5Gb3JtRGF0YTtcbiIsIi8qZ2xvYmFscyBzZWxmLCB3aW5kb3cgKi9cblwidXNlIHN0cmljdFwiXG5cbi8qZXNsaW50LWRpc2FibGUgQG15c3RpY2F0ZWEvcHJldHRpZXIgKi9cbmNvbnN0IHsgQWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbCB9ID1cbiAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIC8qIG90aGVyd2lzZSAqLyB1bmRlZmluZWRcbi8qZXNsaW50LWVuYWJsZSBAbXlzdGljYXRlYS9wcmV0dGllciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFib3J0Q29udHJvbGxlclxubW9kdWxlLmV4cG9ydHMuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFib3J0Q29udHJvbGxlclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGJyb3dzZXIgfSA9IHJlcXVpcmUoJy4vdXRpbC9Db25zdGFudHMnKTtcblxubGV0IGVybHBhY2s7XG5cbnRyeSB7XG4gIGVybHBhY2sgPSByZXF1aXJlKCdlcmxwYWNrJyk7XG4gIGlmICghZXJscGFjay5wYWNrKSBlcmxwYWNrID0gbnVsbDtcbn0gY2F0Y2gge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG5sZXQgVGV4dERlY29kZXI7XG5cbmlmIChicm93c2VyKSB7XG4gIFRleHREZWNvZGVyID0gd2luZG93LlRleHREZWNvZGVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIGV4cG9ydHMuV2ViU29ja2V0ID0gd2luZG93LldlYlNvY2tldDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufSBlbHNlIHtcbiAgVGV4dERlY29kZXIgPSByZXF1aXJlKCd1dGlsJykuVGV4dERlY29kZXI7XG4gIGV4cG9ydHMuV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbn1cblxuY29uc3QgYWIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuZXhwb3J0cy5lbmNvZGluZyA9IGVybHBhY2sgPyAnZXRmJyA6ICdqc29uJztcblxuZXhwb3J0cy5wYWNrID0gZXJscGFjayA/IGVybHBhY2sucGFjayA6IEpTT04uc3RyaW5naWZ5O1xuXG5leHBvcnRzLnVucGFjayA9IChkYXRhLCB0eXBlKSA9PiB7XG4gIGlmIChleHBvcnRzLmVuY29kaW5nID09PSAnanNvbicgfHwgdHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IGFiLmRlY29kZShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShkYXRhKSk7XG4gIHJldHVybiBlcmxwYWNrLnVucGFjayhkYXRhKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlID0gKGdhdGV3YXksIHF1ZXJ5ID0ge30sIC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgW2csIHFdID0gZ2F0ZXdheS5zcGxpdCgnPycpO1xuICBxdWVyeS5lbmNvZGluZyA9IGV4cG9ydHMuZW5jb2Rpbmc7XG4gIHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeSk7XG4gIGlmIChxKSBuZXcgVVJMU2VhcmNoUGFyYW1zKHEpLmZvckVhY2goKHYsIGspID0+IHF1ZXJ5LnNldChrLCB2KSk7XG4gIGNvbnN0IHdzID0gbmV3IGV4cG9ydHMuV2ViU29ja2V0KGAke2d9PyR7cXVlcnl9YCwgLi4uYXJncyk7XG4gIGlmIChicm93c2VyKSB3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgcmV0dXJuIHdzO1xufTtcblxuZm9yIChjb25zdCBzdGF0ZSBvZiBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddKSBleHBvcnRzW3N0YXRlXSA9IGV4cG9ydHMuV2ViU29ja2V0W3N0YXRlXTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnc2V0aW1tZWRpYXRlJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IFJFU1RNYW5hZ2VyID0gcmVxdWlyZSgnLi4vcmVzdC9SRVNUTWFuYWdlcicpO1xuY29uc3QgeyBEZWZhdWx0T3B0aW9ucyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIGNsaWVudHMuXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICovXG5jbGFzcyBCYXNlQ2xpZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXRzIHNldCBieSB7QGxpbmsgQmFzZUNsaWVudCNzZXRUaW1lb3V0fSB0aGF0IGFyZSBzdGlsbCBhY3RpdmVcbiAgICAgKiBAdHlwZSB7U2V0PFRpbWVvdXQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGltZW91dHMgPSBuZXcgU2V0KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnZhbHMgc2V0IGJ5IHtAbGluayBCYXNlQ2xpZW50I3NldEludGVydmFsfSB0aGF0IGFyZSBzdGlsbCBhY3RpdmVcbiAgICAgKiBAdHlwZSB7U2V0PFRpbWVvdXQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faW50ZXJ2YWxzID0gbmV3IFNldCgpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJ2YWxzIHNldCBieSB7QGxpbmsgQmFzZUNsaWVudCNzZXRJbW1lZGlhdGV9IHRoYXQgYXJlIHN0aWxsIGFjdGl2ZVxuICAgICAqIEB0eXBlIHtTZXQ8SW1tZWRpYXRlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ltbWVkaWF0ZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyB0aGUgY2xpZW50IHdhcyBpbnN0YW50aWF0ZWQgd2l0aFxuICAgICAqIEB0eXBlIHtDbGllbnRPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IFV0aWwubWVyZ2VEZWZhdWx0KERlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBSRVNUIG1hbmFnZXIgb2YgdGhlIGNsaWVudFxuICAgICAqIEB0eXBlIHtSRVNUTWFuYWdlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVzdCA9IG5ldyBSRVNUTWFuYWdlcih0aGlzLCBvcHRpb25zLl90b2tlblR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFQSSBzaG9ydGN1dFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBhcGkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5hcGk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGFzc2V0cyB1c2VkIGJ5IHRoZSBiYXNlIGNsaWVudC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuX3RpbWVvdXRzKSB0aGlzLmNsZWFyVGltZW91dCh0KTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5faW50ZXJ2YWxzKSB0aGlzLmNsZWFySW50ZXJ2YWwoaSk7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuX2ltbWVkaWF0ZXMpIHRoaXMuY2xlYXJJbW1lZGlhdGUoaSk7XG4gICAgdGhpcy5fdGltZW91dHMuY2xlYXIoKTtcbiAgICB0aGlzLl9pbnRlcnZhbHMuY2xlYXIoKTtcbiAgICB0aGlzLl9pbW1lZGlhdGVzLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHRpbWVvdXQgdGhhdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FuY2VsbGVkIGlmIHRoZSBjbGllbnQgaXMgZGVzdHJveWVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBUaW1lIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyAoaW4gbWlsbGlzZWNvbmRzKVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciB0aGUgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1RpbWVvdXR9XG4gICAqL1xuICBzZXRUaW1lb3V0KGZuLCBkZWxheSwgLi4uYXJncykge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZuKC4uLmFyZ3MpO1xuICAgICAgdGhpcy5fdGltZW91dHMuZGVsZXRlKHRpbWVvdXQpO1xuICAgIH0sIGRlbGF5KTtcbiAgICB0aGlzLl90aW1lb3V0cy5hZGQodGltZW91dCk7XG4gICAgcmV0dXJuIHRpbWVvdXQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGEgdGltZW91dC5cbiAgICogQHBhcmFtIHtUaW1lb3V0fSB0aW1lb3V0IFRpbWVvdXQgdG8gY2FuY2VsXG4gICAqL1xuICBjbGVhclRpbWVvdXQodGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aGlzLl90aW1lb3V0cy5kZWxldGUodGltZW91dCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBpbnRlcnZhbCB0aGF0IHdpbGwgYmUgYXV0b21hdGljYWxseSBjYW5jZWxsZWQgaWYgdGhlIGNsaWVudCBpcyBkZXN0cm95ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRpbWUgdG8gd2FpdCBiZXR3ZWVuIGV4ZWN1dGlvbnMgKGluIG1pbGxpc2Vjb25kcylcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgdGhlIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtUaW1lb3V0fVxuICAgKi9cbiAgc2V0SW50ZXJ2YWwoZm4sIGRlbGF5LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmbiwgZGVsYXksIC4uLmFyZ3MpO1xuICAgIHRoaXMuX2ludGVydmFscy5hZGQoaW50ZXJ2YWwpO1xuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYW4gaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7VGltZW91dH0gaW50ZXJ2YWwgSW50ZXJ2YWwgdG8gY2FuY2VsXG4gICAqL1xuICBjbGVhckludGVydmFsKGludGVydmFsKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgdGhpcy5faW50ZXJ2YWxzLmRlbGV0ZShpbnRlcnZhbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBpbW1lZGlhdGUgdGhhdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FuY2VsbGVkIGlmIHRoZSBjbGllbnQgaXMgZGVzdHJveWVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIHRoZSBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7SW1tZWRpYXRlfVxuICAgKi9cbiAgc2V0SW1tZWRpYXRlKGZuLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgaW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlKGZuLCAuLi5hcmdzKTtcbiAgICB0aGlzLl9pbW1lZGlhdGVzLmFkZChpbW1lZGlhdGUpO1xuICAgIHJldHVybiBpbW1lZGlhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFuIGltbWVkaWF0ZS5cbiAgICogQHBhcmFtIHtJbW1lZGlhdGV9IGltbWVkaWF0ZSBJbW1lZGlhdGUgdG8gY2FuY2VsXG4gICAqL1xuICBjbGVhckltbWVkaWF0ZShpbW1lZGlhdGUpIHtcbiAgICBjbGVhckltbWVkaWF0ZShpbW1lZGlhdGUpO1xuICAgIHRoaXMuX2ltbWVkaWF0ZXMuZGVsZXRlKGltbWVkaWF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50cyBtYXggbGlzdGVuZXJzIGJ5IG9uZSwgaWYgdGhleSBhcmUgbm90IHplcm8uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbmNyZW1lbnRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgbWF4TGlzdGVuZXJzID0gdGhpcy5nZXRNYXhMaXN0ZW5lcnMoKTtcbiAgICBpZiAobWF4TGlzdGVuZXJzICE9PSAwKSB7XG4gICAgICB0aGlzLnNldE1heExpc3RlbmVycyhtYXhMaXN0ZW5lcnMgKyAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVtZW50cyBtYXggbGlzdGVuZXJzIGJ5IG9uZSwgaWYgdGhleSBhcmUgbm90IHplcm8uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNyZW1lbnRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgbWF4TGlzdGVuZXJzID0gdGhpcy5nZXRNYXhMaXN0ZW5lcnMoKTtcbiAgICBpZiAobWF4TGlzdGVuZXJzICE9PSAwKSB7XG4gICAgICB0aGlzLnNldE1heExpc3RlbmVycyhtYXhMaXN0ZW5lcnMgLSAxKTtcbiAgICB9XG4gIH1cblxuICB0b0pTT04oLi4ucHJvcHMpIHtcbiAgICByZXR1cm4gVXRpbC5mbGF0dGVuKHRoaXMsIHsgZG9tYWluOiBmYWxzZSB9LCAuLi5wcm9wcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ2xpZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9CYXNlQ2xpZW50Jyk7XG5jb25zdCBBY3Rpb25zTWFuYWdlciA9IHJlcXVpcmUoJy4vYWN0aW9ucy9BY3Rpb25zTWFuYWdlcicpO1xuY29uc3QgQ2xpZW50Vm9pY2VNYW5hZ2VyID0gcmVxdWlyZSgnLi92b2ljZS9DbGllbnRWb2ljZU1hbmFnZXInKTtcbmNvbnN0IFdlYlNvY2tldE1hbmFnZXIgPSByZXF1aXJlKCcuL3dlYnNvY2tldC9XZWJTb2NrZXRNYW5hZ2VyJyk7XG5jb25zdCB7IEVycm9yLCBUeXBlRXJyb3IsIFJhbmdlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgQ2hhbm5lbE1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9DaGFubmVsTWFuYWdlcicpO1xuY29uc3QgR3VpbGRFbW9qaU1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9HdWlsZEVtb2ppTWFuYWdlcicpO1xuY29uc3QgR3VpbGRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvR3VpbGRNYW5hZ2VyJyk7XG5jb25zdCBVc2VyTWFuYWdlciA9IHJlcXVpcmUoJy4uL21hbmFnZXJzL1VzZXJNYW5hZ2VyJyk7XG5jb25zdCBTaGFyZENsaWVudFV0aWwgPSByZXF1aXJlKCcuLi9zaGFyZGluZy9TaGFyZENsaWVudFV0aWwnKTtcbmNvbnN0IENsaWVudEFwcGxpY2F0aW9uID0gcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9DbGllbnRBcHBsaWNhdGlvbicpO1xuY29uc3QgR3VpbGRQcmV2aWV3ID0gcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9HdWlsZFByZXZpZXcnKTtcbmNvbnN0IEd1aWxkVGVtcGxhdGUgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL0d1aWxkVGVtcGxhdGUnKTtcbmNvbnN0IEludml0ZSA9IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvSW52aXRlJyk7XG5jb25zdCBWb2ljZVJlZ2lvbiA9IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvVm9pY2VSZWdpb24nKTtcbmNvbnN0IFdlYmhvb2sgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL1dlYmhvb2snKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzLCBicm93c2VyLCBEZWZhdWx0T3B0aW9ucyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IERhdGFSZXNvbHZlciA9IHJlcXVpcmUoJy4uL3V0aWwvRGF0YVJlc29sdmVyJyk7XG5jb25zdCBJbnRlbnRzID0gcmVxdWlyZSgnLi4vdXRpbC9JbnRlbnRzJyk7XG5jb25zdCBQZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvUGVybWlzc2lvbnMnKTtcbmNvbnN0IFN0cnVjdHVyZXMgPSByZXF1aXJlKCcuLi91dGlsL1N0cnVjdHVyZXMnKTtcblxuLyoqXG4gKiBUaGUgbWFpbiBodWIgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIERpc2NvcmQgQVBJLCBhbmQgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBhbnkgYm90LlxuICogQGV4dGVuZHMge0Jhc2VDbGllbnR9XG4gKi9cbmNsYXNzIENsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtDbGllbnRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IF90b2tlblR5cGU6ICdCb3QnIH0sIG9wdGlvbnMpKTtcblxuICAgIC8vIE9idGFpbiBzaGFyZCBkZXRhaWxzIGZyb20gZW52aXJvbm1lbnQgb3IgaWYgcHJlc2VudCwgd29ya2VyIHRocmVhZHNcbiAgICBsZXQgZGF0YSA9IHByb2Nlc3MuZW52O1xuICAgIHRyeSB7XG4gICAgICAvLyBUZXN0IGlmIHdvcmtlciB0aHJlYWRzIG1vZHVsZSBpcyBwcmVzZW50IGFuZCB1c2VkXG4gICAgICBkYXRhID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKS53b3JrZXJEYXRhIHx8IGRhdGE7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaGFyZHMgPT09IERlZmF1bHRPcHRpb25zLnNoYXJkcykge1xuICAgICAgaWYgKCdTSEFSRFMnIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNoYXJkcyA9IEpTT04ucGFyc2UoZGF0YS5TSEFSRFMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcmRDb3VudCA9PT0gRGVmYXVsdE9wdGlvbnMuc2hhcmRDb3VudCkge1xuICAgICAgaWYgKCdTSEFSRF9DT1VOVCcgaW4gZGF0YSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcmRDb3VudCA9IE51bWJlcihkYXRhLlNIQVJEX0NPVU5UKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuc2hhcmRzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcmRDb3VudCA9IHRoaXMub3B0aW9ucy5zaGFyZHMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHR5cGVvZlNoYXJkcyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2hhcmRzO1xuXG4gICAgaWYgKHR5cGVvZlNoYXJkcyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5zaGFyZENvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5vcHRpb25zLnNoYXJkcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMub3B0aW9ucy5zaGFyZENvdW50IH0sIChfLCBpKSA9PiBpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mU2hhcmRzID09PSAnbnVtYmVyJykgdGhpcy5vcHRpb25zLnNoYXJkcyA9IFt0aGlzLm9wdGlvbnMuc2hhcmRzXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5zaGFyZHMpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2hhcmRzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFyZHMuZmlsdGVyKGl0ZW0gPT4gIWlzTmFOKGl0ZW0pICYmIGl0ZW0gPj0gMCAmJiBpdGVtIDwgSW5maW5pdHkgJiYgaXRlbSA9PT0gKGl0ZW0gfCAwKSksXG4gICAgICAgICksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbGlkYXRlT3B0aW9ucygpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYlNvY2tldCBtYW5hZ2VyIG9mIHRoZSBjbGllbnRcbiAgICAgKiBAdHlwZSB7V2ViU29ja2V0TWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldE1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWN0aW9uIG1hbmFnZXIgb2YgdGhlIGNsaWVudFxuICAgICAqIEB0eXBlIHtBY3Rpb25zTWFuYWdlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYWN0aW9ucyA9IG5ldyBBY3Rpb25zTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2b2ljZSBtYW5hZ2VyIG9mIHRoZSBjbGllbnQgKGBudWxsYCBpbiBicm93c2VycylcbiAgICAgKiBAdHlwZSB7P0NsaWVudFZvaWNlTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLnZvaWNlID0gIWJyb3dzZXIgPyBuZXcgQ2xpZW50Vm9pY2VNYW5hZ2VyKHRoaXMpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNoYXJkIGhlbHBlcnMgZm9yIHRoZSBjbGllbnQgKG9ubHkgaWYgdGhlIHByb2Nlc3Mgd2FzIHNwYXduZWQgZnJvbSBhIHtAbGluayBTaGFyZGluZ01hbmFnZXJ9KVxuICAgICAqIEB0eXBlIHs/U2hhcmRDbGllbnRVdGlsfVxuICAgICAqL1xuICAgIHRoaXMuc2hhcmQgPVxuICAgICAgIWJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuU0hBUkRJTkdfTUFOQUdFUlxuICAgICAgICA/IFNoYXJkQ2xpZW50VXRpbC5zaW5nbGV0b24odGhpcywgcHJvY2Vzcy5lbnYuU0hBUkRJTkdfTUFOQUdFUl9NT0RFKVxuICAgICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbGwgb2YgdGhlIHtAbGluayBVc2VyfSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCBhdCBhbnkgcG9pbnQsIG1hcHBlZCBieSB0aGVpciBJRHNcbiAgICAgKiBAdHlwZSB7VXNlck1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy51c2VycyA9IG5ldyBVc2VyTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBvZiB0aGUgZ3VpbGRzIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGhhbmRsaW5nLCBtYXBwZWQgYnkgdGhlaXIgSURzIC1cbiAgICAgKiBhcyBsb25nIGFzIHNoYXJkaW5nIGlzbid0IGJlaW5nIHVzZWQsIHRoaXMgd2lsbCBiZSAqZXZlcnkqIGd1aWxkIHRoZSBib3QgaXMgYSBtZW1iZXIgb2ZcbiAgICAgKiBAdHlwZSB7R3VpbGRNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpbGRzID0gbmV3IEd1aWxkTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBvZiB0aGUge0BsaW5rIENoYW5uZWx9cyB0aGF0IHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGhhbmRsaW5nLCBtYXBwZWQgYnkgdGhlaXIgSURzIC1cbiAgICAgKiBhcyBsb25nIGFzIHNoYXJkaW5nIGlzbid0IGJlaW5nIHVzZWQsIHRoaXMgd2lsbCBiZSAqZXZlcnkqIGNoYW5uZWwgaW4gKmV2ZXJ5KiBndWlsZCB0aGUgYm90XG4gICAgICogaXMgYSBtZW1iZXIgb2YuIE5vdGUgdGhhdCBETSBjaGFubmVscyB3aWxsIG5vdCBiZSBpbml0aWFsbHkgY2FjaGVkLCBhbmQgdGh1cyBub3QgYmUgcHJlc2VudFxuICAgICAqIGluIHRoZSBNYW5hZ2VyIHdpdGhvdXQgdGhlaXIgZXhwbGljaXQgZmV0Y2hpbmcgb3IgdXNlLlxuICAgICAqIEB0eXBlIHtDaGFubmVsTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxNYW5hZ2VyKHRoaXMpO1xuXG4gICAgY29uc3QgQ2xpZW50UHJlc2VuY2UgPSBTdHJ1Y3R1cmVzLmdldCgnQ2xpZW50UHJlc2VuY2UnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhlIENsaWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NsaWVudFByZXNlbmNlfVxuICAgICAqL1xuICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgQ2xpZW50UHJlc2VuY2UodGhpcyk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Rva2VuJywgeyB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBpZiAoIWJyb3dzZXIgJiYgIXRoaXMudG9rZW4gJiYgJ0RJU0NPUkRfVE9LRU4nIGluIHByb2Nlc3MuZW52KSB7XG4gICAgICAvKipcbiAgICAgICAqIEF1dGhvcml6YXRpb24gdG9rZW4gZm9yIHRoZSBsb2dnZWQgaW4gYm90LlxuICAgICAgICogSWYgcHJlc2VudCwgdGhpcyBkZWZhdWx0cyB0byBgcHJvY2Vzcy5lbnYuRElTQ09SRF9UT0tFTmAgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnRcbiAgICAgICAqIDx3YXJuPlRoaXMgc2hvdWxkIGJlIGtlcHQgcHJpdmF0ZSBhdCBhbGwgdGltZXMuPC93YXJuPlxuICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudG9rZW4gPSBwcm9jZXNzLmVudi5ESVNDT1JEX1RPS0VOO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VyIHRoYXQgdGhlIGNsaWVudCBpcyBsb2dnZWQgaW4gYXNcbiAgICAgKiBAdHlwZSB7P0NsaWVudFVzZXJ9XG4gICAgICovXG4gICAgdGhpcy51c2VyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRpbWUgYXQgd2hpY2ggdGhlIGNsaWVudCB3YXMgbGFzdCByZWdhcmRlZCBhcyBiZWluZyBpbiB0aGUgYFJFQURZYCBzdGF0ZVxuICAgICAqIChlYWNoIHRpbWUgdGhlIGNsaWVudCBkaXNjb25uZWN0cyBhbmQgc3VjY2Vzc2Z1bGx5IHJlY29ubmVjdHMsIHRoaXMgd2lsbCBiZSBvdmVyd3JpdHRlbilcbiAgICAgKiBAdHlwZSB7P0RhdGV9XG4gICAgICovXG4gICAgdGhpcy5yZWFkeUF0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubWVzc2FnZVN3ZWVwSW50ZXJ2YWwgPiAwKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKHRoaXMuc3dlZXBNZXNzYWdlcy5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnMubWVzc2FnZVN3ZWVwSW50ZXJ2YWwgKiAxMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsIGN1c3RvbSBlbW9qaXMgdGhhdCB0aGUgY2xpZW50IGhhcyBhY2Nlc3MgdG8sIG1hcHBlZCBieSB0aGVpciBJRHNcbiAgICogQHR5cGUge0d1aWxkRW1vamlNYW5hZ2VyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBlbW9qaXMoKSB7XG4gICAgY29uc3QgZW1vamlzID0gbmV3IEd1aWxkRW1vamlNYW5hZ2VyKHsgY2xpZW50OiB0aGlzIH0pO1xuICAgIGZvciAoY29uc3QgZ3VpbGQgb2YgdGhpcy5ndWlsZHMuY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGlmIChndWlsZC5hdmFpbGFibGUpIGZvciAoY29uc3QgZW1vamkgb2YgZ3VpbGQuZW1vamlzLmNhY2hlLnZhbHVlcygpKSBlbW9qaXMuY2FjaGUuc2V0KGVtb2ppLmlkLCBlbW9qaSk7XG4gICAgfVxuICAgIHJldHVybiBlbW9qaXM7XG4gIH1cblxuICAvKipcbiAgICogVGltZXN0YW1wIG9mIHRoZSB0aW1lIHRoZSBjbGllbnQgd2FzIGxhc3QgYFJFQURZYCBhdFxuICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhZHlUaW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHlBdCA/IHRoaXMucmVhZHlBdC5nZXRUaW1lKCkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvdyBsb25nIGl0IGhhcyBiZWVuIHNpbmNlIHRoZSBjbGllbnQgbGFzdCBlbnRlcmVkIHRoZSBgUkVBRFlgIHN0YXRlIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdXB0aW1lKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5QXQgPyBEYXRlLm5vdygpIC0gdGhpcy5yZWFkeUF0IDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBjbGllbnQgaW4sIGVzdGFibGlzaGluZyBhIHdlYnNvY2tldCBjb25uZWN0aW9uIHRvIERpc2NvcmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9rZW49dGhpcy50b2tlbl0gVG9rZW4gb2YgdGhlIGFjY291bnQgdG8gbG9nIGluIHdpdGhcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVG9rZW4gb2YgdGhlIGFjY291bnQgdXNlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGllbnQubG9naW4oJ215IHRva2VuJyk7XG4gICAqL1xuICBhc3luYyBsb2dpbih0b2tlbiA9IHRoaXMudG9rZW4pIHtcbiAgICBpZiAoIXRva2VuIHx8IHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignVE9LRU5fSU5WQUxJRCcpO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbiA9IHRva2VuLnJlcGxhY2UoL14oQm90fEJlYXJlcilcXHMqL2ksICcnKTtcbiAgICB0aGlzLmVtaXQoXG4gICAgICBFdmVudHMuREVCVUcsXG4gICAgICBgUHJvdmlkZWQgdG9rZW46ICR7dG9rZW5cbiAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgLm1hcCgodmFsLCBpKSA9PiAoaSA+IDEgPyB2YWwucmVwbGFjZSgvLi9nLCAnKicpIDogdmFsKSlcbiAgICAgICAgLmpvaW4oJy4nKX1gLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlbmNlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMud3MucHJlc2VuY2UgPSBhd2FpdCB0aGlzLnByZXNlbmNlLl9wYXJzZSh0aGlzLm9wdGlvbnMucHJlc2VuY2UpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdChFdmVudHMuREVCVUcsICdQcmVwYXJpbmcgdG8gY29ubmVjdCB0byB0aGUgZ2F0ZXdheS4uLicpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMud3MuY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZ3Mgb3V0LCB0ZXJtaW5hdGVzIHRoZSBjb25uZWN0aW9uIHRvIERpc2NvcmQsIGFuZCBkZXN0cm95cyB0aGUgY2xpZW50LlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMud3MuZGVzdHJveSgpO1xuICAgIHRoaXMudG9rZW4gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgYW4gaW52aXRlIGZyb20gRGlzY29yZC5cbiAgICogQHBhcmFtIHtJbnZpdGVSZXNvbHZhYmxlfSBpbnZpdGUgSW52aXRlIGNvZGUgb3IgVVJMXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEludml0ZT59XG4gICAqIEBleGFtcGxlXG4gICAqIGNsaWVudC5mZXRjaEludml0ZSgnaHR0cHM6Ly9kaXNjb3JkLmdnL2JSQ3ZGeTknKVxuICAgKiAgIC50aGVuKGludml0ZSA9PiBjb25zb2xlLmxvZyhgT2J0YWluZWQgaW52aXRlIHdpdGggY29kZTogJHtpbnZpdGUuY29kZX1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaEludml0ZShpbnZpdGUpIHtcbiAgICBjb25zdCBjb2RlID0gRGF0YVJlc29sdmVyLnJlc29sdmVJbnZpdGVDb2RlKGludml0ZSk7XG4gICAgcmV0dXJuIHRoaXMuYXBpXG4gICAgICAuaW52aXRlcyhjb2RlKVxuICAgICAgLmdldCh7IHF1ZXJ5OiB7IHdpdGhfY291bnRzOiB0cnVlIH0gfSlcbiAgICAgIC50aGVuKGRhdGEgPT4gbmV3IEludml0ZSh0aGlzLCBkYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogT2J0YWlucyBhIHRlbXBsYXRlIGZyb20gRGlzY29yZC5cbiAgICogQHBhcmFtIHtHdWlsZFRlbXBsYXRlUmVzb2x2YWJsZX0gdGVtcGxhdGUgVGVtcGxhdGUgY29kZSBvciBVUkxcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRUZW1wbGF0ZT59XG4gICAqIEBleGFtcGxlXG4gICAqIGNsaWVudC5mZXRjaEd1aWxkVGVtcGxhdGUoJ2h0dHBzOi8vZGlzY29yZC5uZXcvRkt2bWN6SDJIeVVmJylcbiAgICogICAudGhlbih0ZW1wbGF0ZSA9PiBjb25zb2xlLmxvZyhgT2J0YWluZWQgdGVtcGxhdGUgd2l0aCBjb2RlOiAke3RlbXBsYXRlLmNvZGV9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgZmV0Y2hHdWlsZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgY29uc3QgY29kZSA9IERhdGFSZXNvbHZlci5yZXNvbHZlR3VpbGRUZW1wbGF0ZUNvZGUodGVtcGxhdGUpO1xuICAgIHJldHVybiB0aGlzLmFwaS5ndWlsZHNcbiAgICAgIC50ZW1wbGF0ZXMoY29kZSlcbiAgICAgIC5nZXQoKVxuICAgICAgLnRoZW4oZGF0YSA9PiBuZXcgR3VpbGRUZW1wbGF0ZSh0aGlzLCBkYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogT2J0YWlucyBhIHdlYmhvb2sgZnJvbSBEaXNjb3JkLlxuICAgKiBAcGFyYW0ge1Nub3dmbGFrZX0gaWQgSUQgb2YgdGhlIHdlYmhvb2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0b2tlbl0gVG9rZW4gZm9yIHRoZSB3ZWJob29rXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2s+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGllbnQuZmV0Y2hXZWJob29rKCdpZCcsICd0b2tlbicpXG4gICAqICAgLnRoZW4od2ViaG9vayA9PiBjb25zb2xlLmxvZyhgT2J0YWluZWQgd2ViaG9vayB3aXRoIG5hbWU6ICR7d2ViaG9vay5uYW1lfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGZldGNoV2ViaG9vayhpZCwgdG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5hcGlcbiAgICAgIC53ZWJob29rcyhpZCwgdG9rZW4pXG4gICAgICAuZ2V0KClcbiAgICAgIC50aGVuKGRhdGEgPT4gbmV3IFdlYmhvb2sodGhpcywgZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgdGhlIGF2YWlsYWJsZSB2b2ljZSByZWdpb25zIGZyb20gRGlzY29yZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q29sbGVjdGlvbjxzdHJpbmcsIFZvaWNlUmVnaW9uPj59XG4gICAqIEBleGFtcGxlXG4gICAqIGNsaWVudC5mZXRjaFZvaWNlUmVnaW9ucygpXG4gICAqICAgLnRoZW4ocmVnaW9ucyA9PiBjb25zb2xlLmxvZyhgQXZhaWxhYmxlIHJlZ2lvbnMgYXJlOiAke3JlZ2lvbnMubWFwKHJlZ2lvbiA9PiByZWdpb24ubmFtZSkuam9pbignLCAnKX1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaFZvaWNlUmVnaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hcGkudm9pY2UucmVnaW9ucy5nZXQoKS50aGVuKHJlcyA9PiB7XG4gICAgICBjb25zdCByZWdpb25zID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICAgIGZvciAoY29uc3QgcmVnaW9uIG9mIHJlcykgcmVnaW9ucy5zZXQocmVnaW9uLmlkLCBuZXcgVm9pY2VSZWdpb24ocmVnaW9uKSk7XG4gICAgICByZXR1cm4gcmVnaW9ucztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2VlcHMgYWxsIHRleHQtYmFzZWQgY2hhbm5lbHMnIG1lc3NhZ2VzIGFuZCByZW1vdmVzIHRoZSBvbmVzIG9sZGVyIHRoYW4gdGhlIG1heCBtZXNzYWdlIGxpZmV0aW1lLlxuICAgKiBJZiB0aGUgbWVzc2FnZSBoYXMgYmVlbiBlZGl0ZWQsIHRoZSB0aW1lIG9mIHRoZSBlZGl0IGlzIHVzZWQgcmF0aGVyIHRoYW4gdGhlIHRpbWUgb2YgdGhlIG9yaWdpbmFsIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGlmZXRpbWU9dGhpcy5vcHRpb25zLm1lc3NhZ2VDYWNoZUxpZmV0aW1lXSBNZXNzYWdlcyB0aGF0IGFyZSBvbGRlciB0aGFuIHRoaXMgKGluIHNlY29uZHMpXG4gICAqIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZXMuIFRoZSBkZWZhdWx0IGlzIGJhc2VkIG9uIHtAbGluayBDbGllbnRPcHRpb25zI21lc3NhZ2VDYWNoZUxpZmV0aW1lfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBbW91bnQgb2YgbWVzc2FnZXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgY2FjaGVzLFxuICAgKiBvciAtMSBpZiB0aGUgbWVzc2FnZSBjYWNoZSBsaWZldGltZSBpcyB1bmxpbWl0ZWRcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUmVtb3ZlIGFsbCBtZXNzYWdlcyBvbGRlciB0aGFuIDE4MDAgc2Vjb25kcyBmcm9tIHRoZSBtZXNzYWdlcyBjYWNoZVxuICAgKiBjb25zdCBhbW91bnQgPSBjbGllbnQuc3dlZXBNZXNzYWdlcygxODAwKTtcbiAgICogY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZW1vdmVkICR7YW1vdW50fSBtZXNzYWdlcyBmcm9tIHRoZSBjYWNoZS5gKTtcbiAgICovXG4gIHN3ZWVwTWVzc2FnZXMobGlmZXRpbWUgPSB0aGlzLm9wdGlvbnMubWVzc2FnZUNhY2hlTGlmZXRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGxpZmV0aW1lICE9PSAnbnVtYmVyJyB8fCBpc05hTihsaWZldGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lOVkFMSURfVFlQRScsICdsaWZldGltZScsICdudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKGxpZmV0aW1lIDw9IDApIHtcbiAgICAgIHRoaXMuZW1pdChFdmVudHMuREVCVUcsIFwiRGlkbid0IHN3ZWVwIG1lc3NhZ2VzIC0gbGlmZXRpbWUgaXMgdW5saW1pdGVkXCIpO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGNvbnN0IGxpZmV0aW1lTXMgPSBsaWZldGltZSAqIDEwMDA7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgY2hhbm5lbHMgPSAwO1xuICAgIGxldCBtZXNzYWdlcyA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgdGhpcy5jaGFubmVscy5jYWNoZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFjaGFubmVsLm1lc3NhZ2VzKSBjb250aW51ZTtcbiAgICAgIGNoYW5uZWxzKys7XG5cbiAgICAgIG1lc3NhZ2VzICs9IGNoYW5uZWwubWVzc2FnZXMuY2FjaGUuc3dlZXAoXG4gICAgICAgIG1lc3NhZ2UgPT4gbm93IC0gKG1lc3NhZ2UuZWRpdGVkVGltZXN0YW1wIHx8IG1lc3NhZ2UuY3JlYXRlZFRpbWVzdGFtcCkgPiBsaWZldGltZU1zLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoXG4gICAgICBFdmVudHMuREVCVUcsXG4gICAgICBgU3dlcHQgJHttZXNzYWdlc30gbWVzc2FnZXMgb2xkZXIgdGhhbiAke2xpZmV0aW1lfSBzZWNvbmRzIGluICR7Y2hhbm5lbHN9IHRleHQtYmFzZWQgY2hhbm5lbHNgLFxuICAgICk7XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgdGhlIE9BdXRoIEFwcGxpY2F0aW9uIG9mIHRoaXMgYm90IGZyb20gRGlzY29yZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2xpZW50QXBwbGljYXRpb24+fVxuICAgKi9cbiAgZmV0Y2hBcHBsaWNhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcGkub2F1dGgyXG4gICAgICAuYXBwbGljYXRpb25zKCdAbWUnKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihhcHAgPT4gbmV3IENsaWVudEFwcGxpY2F0aW9uKHRoaXMsIGFwcCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgYSBndWlsZCBwcmV2aWV3IGZyb20gRGlzY29yZCwgYXZhaWxhYmxlIGZvciBhbGwgZ3VpbGRzIHRoZSBib3QgaXMgaW4gYW5kIGFsbCBEaXNjb3ZlcmFibGUgZ3VpbGRzLlxuICAgKiBAcGFyYW0ge0d1aWxkUmVzb2x2YWJsZX0gZ3VpbGQgVGhlIGd1aWxkIHRvIGZldGNoIHRoZSBwcmV2aWV3IGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZFByZXZpZXc+fVxuICAgKi9cbiAgZmV0Y2hHdWlsZFByZXZpZXcoZ3VpbGQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ3VpbGRzLnJlc29sdmVJRChndWlsZCk7XG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSU5WQUxJRF9UWVBFJywgJ2d1aWxkJywgJ0d1aWxkUmVzb2x2YWJsZScpO1xuICAgIHJldHVybiB0aGlzLmFwaVxuICAgICAgLmd1aWxkcyhpZClcbiAgICAgIC5wcmV2aWV3LmdldCgpXG4gICAgICAudGhlbihkYXRhID0+IG5ldyBHdWlsZFByZXZpZXcodGhpcywgZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGxpbmsgdGhhdCBjYW4gYmUgdXNlZCB0byBpbnZpdGUgdGhlIGJvdCB0byBhIGd1aWxkLlxuICAgKiBAcGFyYW0ge0ludml0ZUdlbmVyYXRpb25PcHRpb25zfFBlcm1pc3Npb25SZXNvbHZhYmxlfSBbb3B0aW9uc10gUGVybWlzc2lvbnMgdG8gcmVxdWVzdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGllbnQuZ2VuZXJhdGVJbnZpdGUoe1xuICAgKiAgIHBlcm1pc3Npb25zOiBbJ1NFTkRfTUVTU0FHRVMnLCAnTUFOQUdFX0dVSUxEJywgJ01FTlRJT05fRVZFUllPTkUnXSxcbiAgICogfSlcbiAgICogICAudGhlbihsaW5rID0+IGNvbnNvbGUubG9nKGBHZW5lcmF0ZWQgYm90IGludml0ZSBsaW5rOiAke2xpbmt9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVJbnZpdGUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHwgWydzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIG9wdGlvbnMpIHx8IG9wdGlvbnMgaW5zdGFuY2VvZiBQZXJtaXNzaW9ucykge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICAgJ0NsaWVudCNnZW5lcmF0ZUludml0ZTogR2VuZXJhdGUgaW52aXRlIHdpdGggYW4gb3B0aW9ucyBvYmplY3QgaW5zdGVhZCBvZiBhIFBlcm1pc3Npb25SZXNvbHZhYmxlJyxcbiAgICAgICAgJ0RlcHJlY2F0aW9uV2FybmluZycsXG4gICAgICApO1xuICAgICAgb3B0aW9ucyA9IHsgcGVybWlzc2lvbnM6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgY29uc3QgYXBwbGljYXRpb24gPSBhd2FpdCB0aGlzLmZldGNoQXBwbGljYXRpb24oKTtcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgY2xpZW50X2lkOiBhcHBsaWNhdGlvbi5pZCxcbiAgICAgIHBlcm1pc3Npb25zOiBQZXJtaXNzaW9ucy5yZXNvbHZlKG9wdGlvbnMucGVybWlzc2lvbnMpLFxuICAgICAgc2NvcGU6ICdib3QnLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kaXNhYmxlR3VpbGRTZWxlY3QgPT09ICdib29sZWFuJykge1xuICAgICAgcXVlcnkuc2V0KCdkaXNhYmxlX2d1aWxkX3NlbGVjdCcsIG9wdGlvbnMuZGlzYWJsZUd1aWxkU2VsZWN0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ3VpbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBndWlsZElEID0gdGhpcy5ndWlsZHMucmVzb2x2ZUlEKG9wdGlvbnMuZ3VpbGQpO1xuICAgICAgaWYgKCFndWlsZElEKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAnb3B0aW9ucy5ndWlsZCcsICdHdWlsZFJlc29sdmFibGUnKTtcbiAgICAgIHF1ZXJ5LnNldCgnZ3VpbGRfaWQnLCBndWlsZElEKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5odHRwLmFwaX0ke3RoaXMuYXBpLm9hdXRoMi5hdXRob3JpemV9PyR7cXVlcnl9YDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gc3VwZXIudG9KU09OKHtcbiAgICAgIHJlYWR5QXQ6IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9ldmFsfSBvbiBhIHNjcmlwdFxuICAgKiB3aXRoIHRoZSBjbGllbnQgYXMgYHRoaXNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IFNjcmlwdCB0byBldmFsXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2YWwoc2NyaXB0KSB7XG4gICAgcmV0dXJuIGV2YWwoc2NyaXB0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGNsaWVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NsaWVudE9wdGlvbnN9IFtvcHRpb25zPXRoaXMub3B0aW9uc10gT3B0aW9ucyB0byB2YWxpZGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlT3B0aW9ucyhvcHRpb25zID0gdGhpcy5vcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndzLmludGVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zLndzLmludGVudHMgPSBJbnRlbnRzLnJlc29sdmUob3B0aW9ucy53cy5pbnRlbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNoYXJkQ291bnQgIT09ICdudW1iZXInIHx8IGlzTmFOKG9wdGlvbnMuc2hhcmRDb3VudCkgfHwgb3B0aW9ucy5zaGFyZENvdW50IDwgMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ0xJRU5UX0lOVkFMSURfT1BUSU9OJywgJ3NoYXJkQ291bnQnLCAnYSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2hhcmRzICYmICEob3B0aW9ucy5zaGFyZHMgPT09ICdhdXRvJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2hhcmRzKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NMSUVOVF9JTlZBTElEX09QVElPTicsICdzaGFyZHMnLCBcIidhdXRvJywgYSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2hhcmRzICYmICFvcHRpb25zLnNoYXJkcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdDTElFTlRfSU5WQUxJRF9QUk9WSURFRF9TSEFSRFMnKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWVzc2FnZUNhY2hlTWF4U2l6ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4ob3B0aW9ucy5tZXNzYWdlQ2FjaGVNYXhTaXplKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ0xJRU5UX0lOVkFMSURfT1BUSU9OJywgJ21lc3NhZ2VDYWNoZU1heFNpemUnLCAnYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2VDYWNoZUxpZmV0aW1lICE9PSAnbnVtYmVyJyB8fCBpc05hTihvcHRpb25zLm1lc3NhZ2VDYWNoZUxpZmV0aW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ0xJRU5UX0lOVkFMSURfT1BUSU9OJywgJ1RoZSBtZXNzYWdlQ2FjaGVMaWZldGltZScsICdhIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWVzc2FnZVN3ZWVwSW50ZXJ2YWwgIT09ICdudW1iZXInIHx8IGlzTmFOKG9wdGlvbnMubWVzc2FnZVN3ZWVwSW50ZXJ2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDTElFTlRfSU5WQUxJRF9PUFRJT04nLCAnbWVzc2FnZVN3ZWVwSW50ZXJ2YWwnLCAnYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMubWVzc2FnZUVkaXRIaXN0b3J5TWF4U2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgIGlzTmFOKG9wdGlvbnMubWVzc2FnZUVkaXRIaXN0b3J5TWF4U2l6ZSkgfHxcbiAgICAgIG9wdGlvbnMubWVzc2FnZUVkaXRIaXN0b3J5TWF4U2l6ZSA8IC0xXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDTElFTlRfSU5WQUxJRF9PUFRJT04nLCAnbWVzc2FnZUVkaXRIaXN0b3J5TWF4U2l6ZScsICdhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gLTEnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZldGNoQWxsTWVtYmVycyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDTElFTlRfSU5WQUxJRF9PUFRJT04nLCAnZmV0Y2hBbGxNZW1iZXJzJywgJ2EgYm9vbGVhbicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGlzYWJsZU1lbnRpb25zICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ0xJRU5UX0lOVkFMSURfT1BUSU9OJywgJ2Rpc2FibGVNZW50aW9ucycsICdhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXJ0aWFscykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NMSUVOVF9JTlZBTElEX09QVElPTicsICdwYXJ0aWFscycsICdhbiBBcnJheScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVzdFdzQnJpZGdlVGltZW91dCAhPT0gJ251bWJlcicgfHwgaXNOYU4ob3B0aW9ucy5yZXN0V3NCcmlkZ2VUaW1lb3V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ0xJRU5UX0lOVkFMSURfT1BUSU9OJywgJ3Jlc3RXc0JyaWRnZVRpbWVvdXQnLCAnYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlc3RSZXF1ZXN0VGltZW91dCAhPT0gJ251bWJlcicgfHwgaXNOYU4ob3B0aW9ucy5yZXN0UmVxdWVzdFRpbWVvdXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDTElFTlRfSU5WQUxJRF9PUFRJT04nLCAncmVzdFJlcXVlc3RUaW1lb3V0JywgJ2EgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXN0U3dlZXBJbnRlcnZhbCAhPT0gJ251bWJlcicgfHwgaXNOYU4ob3B0aW9ucy5yZXN0U3dlZXBJbnRlcnZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NMSUVOVF9JTlZBTElEX09QVElPTicsICdyZXN0U3dlZXBJbnRlcnZhbCcsICdhIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmV0cnlMaW1pdCAhPT0gJ251bWJlcicgfHwgaXNOYU4ob3B0aW9ucy5yZXRyeUxpbWl0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ0xJRU5UX0lOVkFMSURfT1BUSU9OJywgJ3JldHJ5TGltaXQnLCAnYSBudW1iZXInKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG5cbi8qKlxuICogT3B0aW9ucyBmb3Ige0BsaW5rIENsaWVudCNnZW5lcmF0ZUludml0ZX0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbnZpdGVHZW5lcmF0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtQZXJtaXNzaW9uUmVzb2x2YWJsZX0gW3Blcm1pc3Npb25zXSBQZXJtaXNzaW9ucyB0byByZXF1ZXN0XG4gKiBAcHJvcGVydHkge0d1aWxkUmVzb2x2YWJsZX0gW2d1aWxkXSBHdWlsZCB0byBwcmVzZWxlY3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVHdWlsZFNlbGVjdF0gV2hldGhlciB0byBkaXNhYmxlIHRoZSBndWlsZCBzZWxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEVtaXR0ZWQgZm9yIGdlbmVyYWwgd2FybmluZ3MuXG4gKiBAZXZlbnQgQ2xpZW50I3dhcm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvIFRoZSB3YXJuaW5nXG4gKi9cblxuLyoqXG4gKiBFbWl0dGVkIGZvciBnZW5lcmFsIGRlYnVnZ2luZyBpbmZvcm1hdGlvbi5cbiAqIEBldmVudCBDbGllbnQjZGVidWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvIFRoZSBkZWJ1ZyBpbmZvcm1hdGlvblxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL0Jhc2VDbGllbnQnKTtcbmNvbnN0IFdlYmhvb2sgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL1dlYmhvb2snKTtcblxuLyoqXG4gKiBUaGUgd2ViaG9vayBjbGllbnQuXG4gKiBAaW1wbGVtZW50cyB7V2ViaG9va31cbiAqIEBleHRlbmRzIHtCYXNlQ2xpZW50fVxuICovXG5jbGFzcyBXZWJob29rQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Nub3dmbGFrZX0gaWQgSUQgb2YgdGhlIHdlYmhvb2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuIG9mIHRoZSB3ZWJob29rXG4gICAqIEBwYXJhbSB7Q2xpZW50T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIGEgbmV3IHdlYmhvb2sgYW5kIHNlbmQgYSBtZXNzYWdlXG4gICAqIGNvbnN0IGhvb2sgPSBuZXcgRGlzY29yZC5XZWJob29rQ2xpZW50KCcxMjM0JywgJ2FiY2RlZicpO1xuICAgKiBob29rLnNlbmQoJ1RoaXMgd2lsbCBzZW5kIGEgbWVzc2FnZScpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgY29uc3RydWN0b3IoaWQsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjbGllbnQnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Rva2VuJywgeyB2YWx1ZTogdG9rZW4sIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn1cblxuV2ViaG9vay5hcHBseVRvQ2xhc3MoV2ViaG9va0NsaWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViaG9va0NsaWVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBQYXJ0aWFsVHlwZXMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbi8qXG5cbkFCT1VUIEFDVElPTlNcblxuQWN0aW9ucyBhcmUgc2ltaWxhciB0byBXZWJTb2NrZXQgUGFja2V0IEhhbmRsZXJzLCBidXQgc2luY2UgaW50cm9kdWNpbmdcbnRoZSBSRVNUIEFQSSBtZXRob2RzLCBpbiBvcmRlciB0byBwcmV2ZW50IHJld3JpdGluZyBjb2RlIHRvIGhhbmRsZSBkYXRhLFxuXCJhY3Rpb25zXCIgaGF2ZSBiZWVuIGludHJvZHVjZWQuIFRoZXkncmUgYmFzaWNhbGx5IHdoYXQgUGFja2V0IEhhbmRsZXJzXG51c2VkIHRvIGJlIGJ1dCB0aGV5J3JlIHN0cmljdGx5IGZvciBtYW5pcHVsYXRpbmcgZGF0YSBhbmQgbWFraW5nIHN1cmVcbnRoYXQgV2ViU29ja2V0IGV2ZW50cyBkb24ndCBjbGFzaCB3aXRoIFJFU1QgbWV0aG9kcy5cblxuKi9cblxuY2xhc3MgR2VuZXJpY0FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG5cbiAgaGFuZGxlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGdldFBheWxvYWQoZGF0YSwgbWFuYWdlciwgaWQsIHBhcnRpYWxUeXBlLCBjYWNoZSkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gbWFuYWdlci5jYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZXhpc3RpbmcgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5wYXJ0aWFscy5pbmNsdWRlcyhwYXJ0aWFsVHlwZSkpIHtcbiAgICAgIHJldHVybiBtYW5hZ2VyLmFkZChkYXRhLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIGdldENoYW5uZWwoZGF0YSkge1xuICAgIGNvbnN0IGlkID0gZGF0YS5jaGFubmVsX2lkIHx8IGRhdGEuaWQ7XG4gICAgcmV0dXJuIChcbiAgICAgIGRhdGEuY2hhbm5lbCB8fFxuICAgICAgdGhpcy5nZXRQYXlsb2FkKFxuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZ3VpbGRfaWQ6IGRhdGEuZ3VpbGRfaWQsXG4gICAgICAgICAgcmVjaXBpZW50czogW2RhdGEuYXV0aG9yIHx8IHsgaWQ6IGRhdGEudXNlcl9pZCB9XSxcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5jbGllbnQuY2hhbm5lbHMsXG4gICAgICAgIGlkLFxuICAgICAgICBQYXJ0aWFsVHlwZXMuQ0hBTk5FTCxcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZ2V0TWVzc2FnZShkYXRhLCBjaGFubmVsLCBjYWNoZSkge1xuICAgIGNvbnN0IGlkID0gZGF0YS5tZXNzYWdlX2lkIHx8IGRhdGEuaWQ7XG4gICAgcmV0dXJuIChcbiAgICAgIGRhdGEubWVzc2FnZSB8fFxuICAgICAgdGhpcy5nZXRQYXlsb2FkKFxuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY2hhbm5lbF9pZDogY2hhbm5lbC5pZCxcbiAgICAgICAgICBndWlsZF9pZDogZGF0YS5ndWlsZF9pZCB8fCAoY2hhbm5lbC5ndWlsZCA/IGNoYW5uZWwuZ3VpbGQuaWQgOiBudWxsKSxcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbC5tZXNzYWdlcyxcbiAgICAgICAgaWQsXG4gICAgICAgIFBhcnRpYWxUeXBlcy5NRVNTQUdFLFxuICAgICAgICBjYWNoZSxcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZ2V0UmVhY3Rpb24oZGF0YSwgbWVzc2FnZSwgdXNlcikge1xuICAgIGNvbnN0IGlkID0gZGF0YS5lbW9qaS5pZCB8fCBkZWNvZGVVUklDb21wb25lbnQoZGF0YS5lbW9qaS5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQYXlsb2FkKFxuICAgICAge1xuICAgICAgICBlbW9qaTogZGF0YS5lbW9qaSxcbiAgICAgICAgY291bnQ6IG1lc3NhZ2UucGFydGlhbCA/IG51bGwgOiAwLFxuICAgICAgICBtZTogdXNlciA/IHVzZXIuaWQgPT09IHRoaXMuY2xpZW50LnVzZXIuaWQgOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlLnJlYWN0aW9ucyxcbiAgICAgIGlkLFxuICAgICAgUGFydGlhbFR5cGVzLlJFQUNUSU9OLFxuICAgICk7XG4gIH1cblxuICBnZXRNZW1iZXIoZGF0YSwgZ3VpbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQYXlsb2FkKGRhdGEsIGd1aWxkLm1lbWJlcnMsIGRhdGEudXNlci5pZCwgUGFydGlhbFR5cGVzLkdVSUxEX01FTUJFUik7XG4gIH1cblxuICBnZXRVc2VyKGRhdGEpIHtcbiAgICBjb25zdCBpZCA9IGRhdGEudXNlcl9pZDtcbiAgICByZXR1cm4gZGF0YS51c2VyIHx8IHRoaXMuZ2V0UGF5bG9hZCh7IGlkIH0sIHRoaXMuY2xpZW50LnVzZXJzLCBpZCwgUGFydGlhbFR5cGVzLlVTRVIpO1xuICB9XG5cbiAgZ2V0VXNlckZyb21NZW1iZXIoZGF0YSkge1xuICAgIGlmIChkYXRhLmd1aWxkX2lkICYmIGRhdGEubWVtYmVyICYmIGRhdGEubWVtYmVyLnVzZXIpIHtcbiAgICAgIGNvbnN0IGd1aWxkID0gdGhpcy5jbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmd1aWxkX2lkKTtcbiAgICAgIGlmIChndWlsZCkge1xuICAgICAgICByZXR1cm4gZ3VpbGQubWVtYmVycy5hZGQoZGF0YS5tZW1iZXIpLnVzZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQudXNlcnMuYWRkKGRhdGEubWVtYmVyLnVzZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRVc2VyKGRhdGEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY0FjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgQWN0aW9uc01hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcblxuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9NZXNzYWdlQ3JlYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9NZXNzYWdlRGVsZXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9NZXNzYWdlRGVsZXRlQnVsaycpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vTWVzc2FnZVVwZGF0ZScpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vTWVzc2FnZVJlYWN0aW9uQWRkJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9NZXNzYWdlUmVhY3Rpb25SZW1vdmUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL01lc3NhZ2VSZWFjdGlvblJlbW92ZUFsbCcpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vTWVzc2FnZVJlYWN0aW9uUmVtb3ZlRW1vamknKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL0NoYW5uZWxDcmVhdGUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL0NoYW5uZWxEZWxldGUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL0NoYW5uZWxVcGRhdGUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL0d1aWxkRGVsZXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZFVwZGF0ZScpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vSW52aXRlQ3JlYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9JbnZpdGVEZWxldGUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL0d1aWxkTWVtYmVyUmVtb3ZlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZE1lbWJlclVwZGF0ZScpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vR3VpbGRCYW5SZW1vdmUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL0d1aWxkUm9sZUNyZWF0ZScpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vR3VpbGRSb2xlRGVsZXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZFJvbGVVcGRhdGUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL1ByZXNlbmNlVXBkYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9Vc2VyVXBkYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9Wb2ljZVN0YXRlVXBkYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZEVtb2ppQ3JlYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZEVtb2ppRGVsZXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZEVtb2ppVXBkYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZEVtb2ppc1VwZGF0ZScpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vR3VpbGRSb2xlc1Bvc2l0aW9uVXBkYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9HdWlsZENoYW5uZWxzUG9zaXRpb25VcGRhdGUnKSk7XG4gICAgdGhpcy5yZWdpc3RlcihyZXF1aXJlKCcuL0d1aWxkSW50ZWdyYXRpb25zVXBkYXRlJykpO1xuICAgIHRoaXMucmVnaXN0ZXIocmVxdWlyZSgnLi9XZWJob29rc1VwZGF0ZScpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKHJlcXVpcmUoJy4vVHlwaW5nU3RhcnQnKSk7XG4gIH1cblxuICByZWdpc3RlcihBY3Rpb24pIHtcbiAgICB0aGlzW0FjdGlvbi5uYW1lLnJlcGxhY2UoL0FjdGlvbiQvLCAnJyldID0gbmV3IEFjdGlvbih0aGlzLmNsaWVudCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY3Rpb25zTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBDaGFubmVsQ3JlYXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBleGlzdGluZyA9IGNsaWVudC5jaGFubmVscy5jYWNoZS5oYXMoZGF0YS5pZCk7XG4gICAgY29uc3QgY2hhbm5lbCA9IGNsaWVudC5jaGFubmVscy5hZGQoZGF0YSk7XG4gICAgaWYgKCFleGlzdGluZyAmJiBjaGFubmVsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBjaGFubmVsIGlzIGNyZWF0ZWQuXG4gICAgICAgKiBAZXZlbnQgQ2xpZW50I2NoYW5uZWxDcmVhdGVcbiAgICAgICAqIEBwYXJhbSB7RE1DaGFubmVsfEd1aWxkQ2hhbm5lbH0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0aGF0IHdhcyBjcmVhdGVkXG4gICAgICAgKi9cbiAgICAgIGNsaWVudC5lbWl0KEV2ZW50cy5DSEFOTkVMX0NSRUFURSwgY2hhbm5lbCk7XG4gICAgfVxuICAgIHJldHVybiB7IGNoYW5uZWwgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5uZWxDcmVhdGVBY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFjdGlvbiA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG5jb25zdCBETUNoYW5uZWwgPSByZXF1aXJlKCcuLi8uLi9zdHJ1Y3R1cmVzL0RNQ2hhbm5lbCcpO1xuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIENoYW5uZWxEZWxldGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICBzdXBlcihjbGllbnQpO1xuICAgIHRoaXMuZGVsZXRlZCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGhhbmRsZShkYXRhKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgbGV0IGNoYW5uZWwgPSBjbGllbnQuY2hhbm5lbHMuY2FjaGUuZ2V0KGRhdGEuaWQpO1xuXG4gICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgIGNsaWVudC5jaGFubmVscy5yZW1vdmUoY2hhbm5lbC5pZCk7XG4gICAgICBjaGFubmVsLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNoYW5uZWwubWVzc2FnZXMgJiYgIShjaGFubmVsIGluc3RhbmNlb2YgRE1DaGFubmVsKSkge1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgY2hhbm5lbC5tZXNzYWdlcy5jYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICAgIG1lc3NhZ2UuZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRW1pdHRlZCB3aGVuZXZlciBhIGNoYW5uZWwgaXMgZGVsZXRlZC5cbiAgICAgICAqIEBldmVudCBDbGllbnQjY2hhbm5lbERlbGV0ZVxuICAgICAgICogQHBhcmFtIHtETUNoYW5uZWx8R3VpbGRDaGFubmVsfSBjaGFubmVsIFRoZSBjaGFubmVsIHRoYXQgd2FzIGRlbGV0ZWRcbiAgICAgICAqL1xuICAgICAgY2xpZW50LmVtaXQoRXZlbnRzLkNIQU5ORUxfREVMRVRFLCBjaGFubmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjaGFubmVsIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsRGVsZXRlQWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuY29uc3QgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uLy4uL3N0cnVjdHVyZXMvQ2hhbm5lbCcpO1xuY29uc3QgeyBDaGFubmVsVHlwZXMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIENoYW5uZWxVcGRhdGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuXG4gICAgbGV0IGNoYW5uZWwgPSBjbGllbnQuY2hhbm5lbHMuY2FjaGUuZ2V0KGRhdGEuaWQpO1xuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICBjb25zdCBvbGQgPSBjaGFubmVsLl91cGRhdGUoZGF0YSk7XG5cbiAgICAgIGlmIChDaGFubmVsVHlwZXNbY2hhbm5lbC50eXBlLnRvVXBwZXJDYXNlKCldICE9PSBkYXRhLnR5cGUpIHtcbiAgICAgICAgY29uc3QgbmV3Q2hhbm5lbCA9IENoYW5uZWwuY3JlYXRlKHRoaXMuY2xpZW50LCBkYXRhLCBjaGFubmVsLmd1aWxkKTtcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIG1lc3NhZ2VdIG9mIGNoYW5uZWwubWVzc2FnZXMuY2FjaGUpIG5ld0NoYW5uZWwubWVzc2FnZXMuY2FjaGUuc2V0KGlkLCBtZXNzYWdlKTtcbiAgICAgICAgbmV3Q2hhbm5lbC5fdHlwaW5nID0gbmV3IE1hcChjaGFubmVsLl90eXBpbmcpO1xuICAgICAgICBjaGFubmVsID0gbmV3Q2hhbm5lbDtcbiAgICAgICAgdGhpcy5jbGllbnQuY2hhbm5lbHMuY2FjaGUuc2V0KGNoYW5uZWwuaWQsIGNoYW5uZWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbGQsXG4gICAgICAgIHVwZGF0ZWQ6IGNoYW5uZWwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5uZWxVcGRhdGVBY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFjdGlvbiA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcblxuY2xhc3MgR3VpbGRCYW5SZW1vdmUgZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5ndWlsZF9pZCk7XG4gICAgY29uc3QgdXNlciA9IGNsaWVudC51c2Vycy5hZGQoZGF0YS51c2VyKTtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgbWVtYmVyIGlzIHVuYmFubmVkIGZyb20gYSBndWlsZC5cbiAgICAgKiBAZXZlbnQgQ2xpZW50I2d1aWxkQmFuUmVtb3ZlXG4gICAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoYXQgdGhlIHVuYmFuIG9jY3VycmVkIGluXG4gICAgICogQHBhcmFtIHtVc2VyfSB1c2VyIFRoZSB1c2VyIHRoYXQgd2FzIHVuYmFubmVkXG4gICAgICovXG4gICAgaWYgKGd1aWxkICYmIHVzZXIpIGNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9CQU5fUkVNT1ZFLCBndWlsZCwgdXNlcik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZEJhblJlbW92ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcblxuY2xhc3MgR3VpbGRDaGFubmVsc1Bvc2l0aW9uVXBkYXRlIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcblxuICAgIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5ndWlsZF9pZCk7XG4gICAgaWYgKGd1aWxkKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnRpYWxDaGFubmVsIG9mIGRhdGEuY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGd1aWxkLmNoYW5uZWxzLmNhY2hlLmdldChwYXJ0aWFsQ2hhbm5lbC5pZCk7XG4gICAgICAgIGlmIChjaGFubmVsKSBjaGFubmVsLnJhd1Bvc2l0aW9uID0gcGFydGlhbENoYW5uZWwucG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZ3VpbGQgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkQ2hhbm5lbHNQb3NpdGlvblVwZGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBHdWlsZERlbGV0ZUFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHN1cGVyKGNsaWVudCk7XG4gICAgdGhpcy5kZWxldGVkID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcblxuICAgIGxldCBndWlsZCA9IGNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KGRhdGEuaWQpO1xuICAgIGlmIChndWlsZCkge1xuICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIGd1aWxkLmNoYW5uZWxzLmNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChjaGFubmVsLnR5cGUgPT09ICd0ZXh0JykgY2hhbm5lbC5zdG9wVHlwaW5nKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS51bmF2YWlsYWJsZSkge1xuICAgICAgICAvLyBHdWlsZCBpcyB1bmF2YWlsYWJsZVxuICAgICAgICBndWlsZC5hdmFpbGFibGUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHRlZCB3aGVuZXZlciBhIGd1aWxkIGJlY29tZXMgdW5hdmFpbGFibGUsIGxpa2VseSBkdWUgdG8gYSBzZXJ2ZXIgb3V0YWdlLlxuICAgICAgICAgKiBAZXZlbnQgQ2xpZW50I2d1aWxkVW5hdmFpbGFibGVcbiAgICAgICAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoYXQgaGFzIGJlY29tZSB1bmF2YWlsYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xpZW50LmVtaXQoRXZlbnRzLkdVSUxEX1VOQVZBSUxBQkxFLCBndWlsZCk7XG5cbiAgICAgICAgLy8gU3RvcHMgdGhlIEd1aWxkRGVsZXRlIHBhY2tldCB0aGlua2luZyBhIGd1aWxkIHdhcyBhY3R1YWxseSBkZWxldGVkLFxuICAgICAgICAvLyBoYW5kbGVzIGVtaXR0aW5nIG9mIGV2ZW50IGl0c2VsZlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGd1aWxkOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgZ3VpbGQuY2hhbm5lbHMuY2FjaGUudmFsdWVzKCkpIHRoaXMuY2xpZW50LmNoYW5uZWxzLnJlbW92ZShjaGFubmVsLmlkKTtcbiAgICAgIGlmIChndWlsZC52b2ljZSAmJiBndWlsZC52b2ljZS5jb25uZWN0aW9uKSBndWlsZC52b2ljZS5jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgLy8gRGVsZXRlIGd1aWxkXG4gICAgICBjbGllbnQuZ3VpbGRzLmNhY2hlLmRlbGV0ZShndWlsZC5pZCk7XG4gICAgICBndWlsZC5kZWxldGVkID0gdHJ1ZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgZ3VpbGQga2lja3MgdGhlIGNsaWVudCBvciB0aGUgZ3VpbGQgaXMgZGVsZXRlZC9sZWZ0LlxuICAgICAgICogQGV2ZW50IENsaWVudCNndWlsZERlbGV0ZVxuICAgICAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoYXQgd2FzIGRlbGV0ZWRcbiAgICAgICAqL1xuICAgICAgY2xpZW50LmVtaXQoRXZlbnRzLkdVSUxEX0RFTEVURSwgZ3VpbGQpO1xuXG4gICAgICB0aGlzLmRlbGV0ZWQuc2V0KGd1aWxkLmlkLCBndWlsZCk7XG4gICAgICB0aGlzLnNjaGVkdWxlRm9yRGVsZXRpb24oZ3VpbGQuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBndWlsZCA9IHRoaXMuZGVsZXRlZC5nZXQoZGF0YS5pZCkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4geyBndWlsZCB9O1xuICB9XG5cbiAgc2NoZWR1bGVGb3JEZWxldGlvbihpZCkge1xuICAgIHRoaXMuY2xpZW50LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZWxldGVkLmRlbGV0ZShpZCksIHRoaXMuY2xpZW50Lm9wdGlvbnMucmVzdFdzQnJpZGdlVGltZW91dCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZERlbGV0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBHdWlsZEVtb2ppQ3JlYXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGd1aWxkLCBjcmVhdGVkRW1vamkpIHtcbiAgICBjb25zdCBhbHJlYWR5ID0gZ3VpbGQuZW1vamlzLmNhY2hlLmhhcyhjcmVhdGVkRW1vamkuaWQpO1xuICAgIGNvbnN0IGVtb2ppID0gZ3VpbGQuZW1vamlzLmFkZChjcmVhdGVkRW1vamkpO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBjdXN0b20gZW1vamkgaXMgY3JlYXRlZCBpbiBhIGd1aWxkLlxuICAgICAqIEBldmVudCBDbGllbnQjZW1vamlDcmVhdGVcbiAgICAgKiBAcGFyYW0ge0d1aWxkRW1vaml9IGVtb2ppIFRoZSBlbW9qaSB0aGF0IHdhcyBjcmVhdGVkXG4gICAgICovXG4gICAgaWYgKCFhbHJlYWR5KSB0aGlzLmNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9FTU9KSV9DUkVBVEUsIGVtb2ppKTtcbiAgICByZXR1cm4geyBlbW9qaSB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRFbW9qaUNyZWF0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBHdWlsZEVtb2ppRGVsZXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGVtb2ppKSB7XG4gICAgZW1vamkuZ3VpbGQuZW1vamlzLmNhY2hlLmRlbGV0ZShlbW9qaS5pZCk7XG4gICAgZW1vamkuZGVsZXRlZCA9IHRydWU7XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuZXZlciBhIGN1c3RvbSBlbW9qaSBpcyBkZWxldGVkIGluIGEgZ3VpbGQuXG4gICAgICogQGV2ZW50IENsaWVudCNlbW9qaURlbGV0ZVxuICAgICAqIEBwYXJhbSB7R3VpbGRFbW9qaX0gZW1vamkgVGhlIGVtb2ppIHRoYXQgd2FzIGRlbGV0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9FTU9KSV9ERUxFVEUsIGVtb2ppKTtcbiAgICByZXR1cm4geyBlbW9qaSB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRFbW9qaURlbGV0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBHdWlsZEVtb2ppVXBkYXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGN1cnJlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBvbGQgPSBjdXJyZW50Ll91cGRhdGUoZGF0YSk7XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuZXZlciBhIGN1c3RvbSBlbW9qaSBpcyB1cGRhdGVkIGluIGEgZ3VpbGQuXG4gICAgICogQGV2ZW50IENsaWVudCNlbW9qaVVwZGF0ZVxuICAgICAqIEBwYXJhbSB7R3VpbGRFbW9qaX0gb2xkRW1vamkgVGhlIG9sZCBlbW9qaVxuICAgICAqIEBwYXJhbSB7R3VpbGRFbW9qaX0gbmV3RW1vamkgVGhlIG5ldyBlbW9qaVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLkdVSUxEX0VNT0pJX1VQREFURSwgb2xkLCBjdXJyZW50KTtcbiAgICByZXR1cm4geyBlbW9qaTogY3VycmVudCB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRFbW9qaVVwZGF0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcblxuY2xhc3MgR3VpbGRFbW9qaXNVcGRhdGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGd1aWxkID0gdGhpcy5jbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmd1aWxkX2lkKTtcbiAgICBpZiAoIWd1aWxkIHx8ICFndWlsZC5lbW9qaXMpIHJldHVybjtcblxuICAgIGNvbnN0IGRlbGV0aW9ucyA9IG5ldyBNYXAoZ3VpbGQuZW1vamlzLmNhY2hlKTtcblxuICAgIGZvciAoY29uc3QgZW1vamkgb2YgZGF0YS5lbW9qaXMpIHtcbiAgICAgIC8vIERldGVybWluZSB0eXBlIG9mIGVtb2ppIGV2ZW50XG4gICAgICBjb25zdCBjYWNoZWRFbW9qaSA9IGd1aWxkLmVtb2ppcy5jYWNoZS5nZXQoZW1vamkuaWQpO1xuICAgICAgaWYgKGNhY2hlZEVtb2ppKSB7XG4gICAgICAgIGRlbGV0aW9ucy5kZWxldGUoZW1vamkuaWQpO1xuICAgICAgICBpZiAoIWNhY2hlZEVtb2ppLmVxdWFscyhlbW9qaSkpIHtcbiAgICAgICAgICAvLyBFbW9qaSB1cGRhdGVkXG4gICAgICAgICAgdGhpcy5jbGllbnQuYWN0aW9ucy5HdWlsZEVtb2ppVXBkYXRlLmhhbmRsZShjYWNoZWRFbW9qaSwgZW1vamkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbW9qaSBhZGRlZFxuICAgICAgICB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkRW1vamlDcmVhdGUuaGFuZGxlKGd1aWxkLCBlbW9qaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBlbW9qaSBvZiBkZWxldGlvbnMudmFsdWVzKCkpIHtcbiAgICAgIC8vIEVtb2ppIGRlbGV0ZWRcbiAgICAgIHRoaXMuY2xpZW50LmFjdGlvbnMuR3VpbGRFbW9qaURlbGV0ZS5oYW5kbGUoZW1vamkpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkRW1vamlzVXBkYXRlQWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIEd1aWxkSW50ZWdyYXRpb25zVXBkYXRlIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBndWlsZCA9IGNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KGRhdGEuZ3VpbGRfaWQpO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBndWlsZCBpbnRlZ3JhdGlvbiBpcyB1cGRhdGVkXG4gICAgICogQGV2ZW50IENsaWVudCNndWlsZEludGVncmF0aW9uc1VwZGF0ZVxuICAgICAqIEBwYXJhbSB7R3VpbGR9IGd1aWxkIFRoZSBndWlsZCB3aG9zZSBpbnRlZ3JhdGlvbnMgd2VyZSB1cGRhdGVkXG4gICAgICovXG4gICAgaWYgKGd1aWxkKSBjbGllbnQuZW1pdChFdmVudHMuR1VJTERfSU5URUdSQVRJT05TX1VQREFURSwgZ3VpbGQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRJbnRlZ3JhdGlvbnNVcGRhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFjdGlvbiA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG5jb25zdCB7IEV2ZW50cywgU3RhdHVzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBHdWlsZE1lbWJlclJlbW92ZUFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gIGhhbmRsZShkYXRhLCBzaGFyZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5ndWlsZF9pZCk7XG4gICAgbGV0IG1lbWJlciA9IG51bGw7XG4gICAgaWYgKGd1aWxkKSB7XG4gICAgICBtZW1iZXIgPSB0aGlzLmdldE1lbWJlcih7IHVzZXI6IGRhdGEudXNlciB9LCBndWlsZCk7XG4gICAgICBndWlsZC5tZW1iZXJDb3VudC0tO1xuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICBtZW1iZXIuZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIGd1aWxkLm1lbWJlcnMuY2FjaGUuZGVsZXRlKG1lbWJlci5pZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgbWVtYmVyIGxlYXZlcyBhIGd1aWxkLCBvciBpcyBraWNrZWQuXG4gICAgICAgICAqIEBldmVudCBDbGllbnQjZ3VpbGRNZW1iZXJSZW1vdmVcbiAgICAgICAgICogQHBhcmFtIHtHdWlsZE1lbWJlcn0gbWVtYmVyIFRoZSBtZW1iZXIgdGhhdCBoYXMgbGVmdC9iZWVuIGtpY2tlZCBmcm9tIHRoZSBndWlsZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHNoYXJkLnN0YXR1cyA9PT0gU3RhdHVzLlJFQURZKSBjbGllbnQuZW1pdChFdmVudHMuR1VJTERfTUVNQkVSX1JFTU9WRSwgbWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGd1aWxkLnZvaWNlU3RhdGVzLmNhY2hlLmRlbGV0ZShkYXRhLnVzZXIuaWQpO1xuICAgIH1cbiAgICByZXR1cm4geyBndWlsZCwgbWVtYmVyIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZE1lbWJlclJlbW92ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgU3RhdHVzLCBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIEd1aWxkTWVtYmVyVXBkYXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEsIHNoYXJkKSB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHRoaXM7XG4gICAgaWYgKGRhdGEudXNlci51c2VybmFtZSkge1xuICAgICAgY29uc3QgdXNlciA9IGNsaWVudC51c2Vycy5jYWNoZS5nZXQoZGF0YS51c2VyLmlkKTtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICBjbGllbnQudXNlcnMuYWRkKGRhdGEudXNlcik7XG4gICAgICB9IGVsc2UgaWYgKCF1c2VyLmVxdWFscyhkYXRhLnVzZXIpKSB7XG4gICAgICAgIGNsaWVudC5hY3Rpb25zLlVzZXJVcGRhdGUuaGFuZGxlKGRhdGEudXNlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZ3VpbGQgPSBjbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmd1aWxkX2lkKTtcbiAgICBpZiAoZ3VpbGQpIHtcbiAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuZ2V0TWVtYmVyKHsgdXNlcjogZGF0YS51c2VyIH0sIGd1aWxkKTtcbiAgICAgIGlmIChtZW1iZXIpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gbWVtYmVyLl91cGRhdGUoZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgZ3VpbGQgbWVtYmVyIGNoYW5nZXMgLSBpLmUuIG5ldyByb2xlLCByZW1vdmVkIHJvbGUsIG5pY2tuYW1lLlxuICAgICAgICAgKiBBbHNvIGVtaXR0ZWQgd2hlbiB0aGUgdXNlcidzIGRldGFpbHMgKGUuZy4gdXNlcm5hbWUpIGNoYW5nZS5cbiAgICAgICAgICogQGV2ZW50IENsaWVudCNndWlsZE1lbWJlclVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0d1aWxkTWVtYmVyfSBvbGRNZW1iZXIgVGhlIG1lbWJlciBiZWZvcmUgdGhlIHVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0d1aWxkTWVtYmVyfSBuZXdNZW1iZXIgVGhlIG1lbWJlciBhZnRlciB0aGUgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoc2hhcmQuc3RhdHVzID09PSBTdGF0dXMuUkVBRFkpIGNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9NRU1CRVJfVVBEQVRFLCBvbGQsIG1lbWJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdNZW1iZXIgPSBndWlsZC5tZW1iZXJzLmFkZChkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBtZW1iZXIgYmVjb21lcyBhdmFpbGFibGUgaW4gYSBsYXJnZSBndWlsZC5cbiAgICAgICAgICogQGV2ZW50IENsaWVudCNndWlsZE1lbWJlckF2YWlsYWJsZVxuICAgICAgICAgKiBAcGFyYW0ge0d1aWxkTWVtYmVyfSBtZW1iZXIgVGhlIG1lbWJlciB0aGF0IGJlY2FtZSBhdmFpbGFibGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLkdVSUxEX01FTUJFUl9BVkFJTEFCTEUsIG5ld01lbWJlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRNZW1iZXJVcGRhdGVBY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFjdGlvbiA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcblxuY2xhc3MgR3VpbGRSb2xlQ3JlYXRlIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBndWlsZCA9IGNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KGRhdGEuZ3VpbGRfaWQpO1xuICAgIGxldCByb2xlO1xuICAgIGlmIChndWlsZCkge1xuICAgICAgY29uc3QgYWxyZWFkeSA9IGd1aWxkLnJvbGVzLmNhY2hlLmhhcyhkYXRhLnJvbGUuaWQpO1xuICAgICAgcm9sZSA9IGd1aWxkLnJvbGVzLmFkZChkYXRhLnJvbGUpO1xuICAgICAgLyoqXG4gICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgcm9sZSBpcyBjcmVhdGVkLlxuICAgICAgICogQGV2ZW50IENsaWVudCNyb2xlQ3JlYXRlXG4gICAgICAgKiBAcGFyYW0ge1JvbGV9IHJvbGUgVGhlIHJvbGUgdGhhdCB3YXMgY3JlYXRlZFxuICAgICAgICovXG4gICAgICBpZiAoIWFscmVhZHkpIGNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9ST0xFX0NSRUFURSwgcm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHJvbGUgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkUm9sZUNyZWF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBHdWlsZFJvbGVEZWxldGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5ndWlsZF9pZCk7XG4gICAgbGV0IHJvbGU7XG5cbiAgICBpZiAoZ3VpbGQpIHtcbiAgICAgIHJvbGUgPSBndWlsZC5yb2xlcy5jYWNoZS5nZXQoZGF0YS5yb2xlX2lkKTtcbiAgICAgIGlmIChyb2xlKSB7XG4gICAgICAgIGd1aWxkLnJvbGVzLmNhY2hlLmRlbGV0ZShkYXRhLnJvbGVfaWQpO1xuICAgICAgICByb2xlLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHRlZCB3aGVuZXZlciBhIGd1aWxkIHJvbGUgaXMgZGVsZXRlZC5cbiAgICAgICAgICogQGV2ZW50IENsaWVudCNyb2xlRGVsZXRlXG4gICAgICAgICAqIEBwYXJhbSB7Um9sZX0gcm9sZSBUaGUgcm9sZSB0aGF0IHdhcyBkZWxldGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGllbnQuZW1pdChFdmVudHMuR1VJTERfUk9MRV9ERUxFVEUsIHJvbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHJvbGUgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkUm9sZURlbGV0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBHdWlsZFJvbGVVcGRhdGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5ndWlsZF9pZCk7XG5cbiAgICBpZiAoZ3VpbGQpIHtcbiAgICAgIGxldCBvbGQgPSBudWxsO1xuXG4gICAgICBjb25zdCByb2xlID0gZ3VpbGQucm9sZXMuY2FjaGUuZ2V0KGRhdGEucm9sZS5pZCk7XG4gICAgICBpZiAocm9sZSkge1xuICAgICAgICBvbGQgPSByb2xlLl91cGRhdGUoZGF0YS5yb2xlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBndWlsZCByb2xlIGlzIHVwZGF0ZWQuXG4gICAgICAgICAqIEBldmVudCBDbGllbnQjcm9sZVVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge1JvbGV9IG9sZFJvbGUgVGhlIHJvbGUgYmVmb3JlIHRoZSB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHtSb2xlfSBuZXdSb2xlIFRoZSByb2xlIGFmdGVyIHRoZSB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9ST0xFX1VQREFURSwgb2xkLCByb2xlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2xkLFxuICAgICAgICB1cGRhdGVkOiByb2xlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb2xkOiBudWxsLFxuICAgICAgdXBkYXRlZDogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRSb2xlVXBkYXRlQWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuXG5jbGFzcyBHdWlsZFJvbGVzUG9zaXRpb25VcGRhdGUgZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuXG4gICAgY29uc3QgZ3VpbGQgPSBjbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmd1aWxkX2lkKTtcbiAgICBpZiAoZ3VpbGQpIHtcbiAgICAgIGZvciAoY29uc3QgcGFydGlhbFJvbGUgb2YgZGF0YS5yb2xlcykge1xuICAgICAgICBjb25zdCByb2xlID0gZ3VpbGQucm9sZXMuY2FjaGUuZ2V0KHBhcnRpYWxSb2xlLmlkKTtcbiAgICAgICAgaWYgKHJvbGUpIHJvbGUucmF3UG9zaXRpb24gPSBwYXJ0aWFsUm9sZS5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBndWlsZCB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRSb2xlc1Bvc2l0aW9uVXBkYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIEd1aWxkVXBkYXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcblxuICAgIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5pZCk7XG4gICAgaWYgKGd1aWxkKSB7XG4gICAgICBjb25zdCBvbGQgPSBndWlsZC5fdXBkYXRlKGRhdGEpO1xuICAgICAgLyoqXG4gICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgZ3VpbGQgaXMgdXBkYXRlZCAtIGUuZy4gbmFtZSBjaGFuZ2UuXG4gICAgICAgKiBAZXZlbnQgQ2xpZW50I2d1aWxkVXBkYXRlXG4gICAgICAgKiBAcGFyYW0ge0d1aWxkfSBvbGRHdWlsZCBUaGUgZ3VpbGQgYmVmb3JlIHRoZSB1cGRhdGVcbiAgICAgICAqIEBwYXJhbSB7R3VpbGR9IG5ld0d1aWxkIFRoZSBndWlsZCBhZnRlciB0aGUgdXBkYXRlXG4gICAgICAgKi9cbiAgICAgIGNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9VUERBVEUsIG9sZCwgZ3VpbGQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2xkLFxuICAgICAgICB1cGRhdGVkOiBndWlsZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9sZDogbnVsbCxcbiAgICAgIHVwZGF0ZWQ6IG51bGwsXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkVXBkYXRlQWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuY29uc3QgSW52aXRlID0gcmVxdWlyZSgnLi4vLi4vc3RydWN0dXJlcy9JbnZpdGUnKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBJbnZpdGVDcmVhdGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGNoYW5uZWwgPSBjbGllbnQuY2hhbm5lbHMuY2FjaGUuZ2V0KGRhdGEuY2hhbm5lbF9pZCk7XG4gICAgY29uc3QgZ3VpbGQgPSBjbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmd1aWxkX2lkKTtcbiAgICBpZiAoIWNoYW5uZWwpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGludml0ZURhdGEgPSBPYmplY3QuYXNzaWduKGRhdGEsIHsgY2hhbm5lbCwgZ3VpbGQgfSk7XG4gICAgY29uc3QgaW52aXRlID0gbmV3IEludml0ZShjbGllbnQsIGludml0ZURhdGEpO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhbiBpbnZpdGUgaXMgY3JlYXRlZC5cbiAgICAgKiA8aW5mbz4gVGhpcyBldmVudCBvbmx5IHRyaWdnZXJzIGlmIHRoZSBjbGllbnQgaGFzIGBNQU5BR0VfR1VJTERgIHBlcm1pc3Npb25zIGZvciB0aGUgZ3VpbGQsXG4gICAgICogb3IgYE1BTkFHRV9DSEFOTkVMYCBwZXJtaXNzaW9ucyBmb3IgdGhlIGNoYW5uZWwuPC9pbmZvPlxuICAgICAqIEBldmVudCBDbGllbnQjaW52aXRlQ3JlYXRlXG4gICAgICogQHBhcmFtIHtJbnZpdGV9IGludml0ZSBUaGUgaW52aXRlIHRoYXQgd2FzIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBjbGllbnQuZW1pdChFdmVudHMuSU5WSVRFX0NSRUFURSwgaW52aXRlKTtcbiAgICByZXR1cm4geyBpbnZpdGUgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludml0ZUNyZWF0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IEludml0ZSA9IHJlcXVpcmUoJy4uLy4uL3N0cnVjdHVyZXMvSW52aXRlJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcblxuY2xhc3MgSW52aXRlRGVsZXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBjaGFubmVsID0gY2xpZW50LmNoYW5uZWxzLmNhY2hlLmdldChkYXRhLmNoYW5uZWxfaWQpO1xuICAgIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5ndWlsZF9pZCk7XG4gICAgaWYgKCFjaGFubmVsICYmICFndWlsZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaW52aXRlRGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSwgeyBjaGFubmVsLCBndWlsZCB9KTtcbiAgICBjb25zdCBpbnZpdGUgPSBuZXcgSW52aXRlKGNsaWVudCwgaW52aXRlRGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYW4gaW52aXRlIGlzIGRlbGV0ZWQuXG4gICAgICogPGluZm8+IFRoaXMgZXZlbnQgb25seSB0cmlnZ2VycyBpZiB0aGUgY2xpZW50IGhhcyBgTUFOQUdFX0dVSUxEYCBwZXJtaXNzaW9ucyBmb3IgdGhlIGd1aWxkLFxuICAgICAqIG9yIGBNQU5BR0VfQ0hBTk5FTGAgcGVybWlzc2lvbnMgZm9yIHRoZSBjaGFubmVsLjwvaW5mbz5cbiAgICAgKiBAZXZlbnQgQ2xpZW50I2ludml0ZURlbGV0ZVxuICAgICAqIEBwYXJhbSB7SW52aXRlfSBpbnZpdGUgVGhlIGludml0ZSB0aGF0IHdhcyBkZWxldGVkXG4gICAgICovXG4gICAgY2xpZW50LmVtaXQoRXZlbnRzLklOVklURV9ERUxFVEUsIGludml0ZSk7XG4gICAgcmV0dXJuIHsgaW52aXRlIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnZpdGVEZWxldGVBY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFjdGlvbiA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcblxuY2xhc3MgTWVzc2FnZUNyZWF0ZUFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gIGhhbmRsZShkYXRhKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgY2hhbm5lbCA9IGNsaWVudC5jaGFubmVscy5jYWNoZS5nZXQoZGF0YS5jaGFubmVsX2lkKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBjaGFubmVsLm1lc3NhZ2VzLmNhY2hlLmdldChkYXRhLmlkKTtcbiAgICAgIGlmIChleGlzdGluZykgcmV0dXJuIHsgbWVzc2FnZTogZXhpc3RpbmcgfTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjaGFubmVsLm1lc3NhZ2VzLmFkZChkYXRhKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLmF1dGhvcjtcbiAgICAgIGxldCBtZW1iZXIgPSBtZXNzYWdlLm1lbWJlcjtcbiAgICAgIGNoYW5uZWwubGFzdE1lc3NhZ2VJRCA9IGRhdGEuaWQ7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICB1c2VyLmxhc3RNZXNzYWdlSUQgPSBkYXRhLmlkO1xuICAgICAgICB1c2VyLmxhc3RNZXNzYWdlQ2hhbm5lbElEID0gY2hhbm5lbC5pZDtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1iZXIpIHtcbiAgICAgICAgbWVtYmVyLmxhc3RNZXNzYWdlSUQgPSBkYXRhLmlkO1xuICAgICAgICBtZW1iZXIubGFzdE1lc3NhZ2VDaGFubmVsSUQgPSBjaGFubmVsLmlkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIGNyZWF0ZWQuXG4gICAgICAgKiBAZXZlbnQgQ2xpZW50I21lc3NhZ2VcbiAgICAgICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSBUaGUgY3JlYXRlZCBtZXNzYWdlXG4gICAgICAgKi9cbiAgICAgIGNsaWVudC5lbWl0KEV2ZW50cy5NRVNTQUdFX0NSRUFURSwgbWVzc2FnZSk7XG4gICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZUNyZWF0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBNZXNzYWdlRGVsZXRlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5nZXRDaGFubmVsKGRhdGEpO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICBtZXNzYWdlID0gdGhpcy5nZXRNZXNzYWdlKGRhdGEsIGNoYW5uZWwpO1xuICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgY2hhbm5lbC5tZXNzYWdlcy5jYWNoZS5kZWxldGUobWVzc2FnZS5pZCk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgbWVzc2FnZSBpcyBkZWxldGVkLlxuICAgICAgICAgKiBAZXZlbnQgQ2xpZW50I21lc3NhZ2VEZWxldGVcbiAgICAgICAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBkZWxldGVkIG1lc3NhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGNsaWVudC5lbWl0KEV2ZW50cy5NRVNTQUdFX0RFTEVURSwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZURlbGV0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBNZXNzYWdlRGVsZXRlQnVsa0FjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gIGhhbmRsZShkYXRhKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgY2hhbm5lbCA9IGNsaWVudC5jaGFubmVscy5jYWNoZS5nZXQoZGF0YS5jaGFubmVsX2lkKTtcblxuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICBjb25zdCBpZHMgPSBkYXRhLmlkcztcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmdldE1lc3NhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBndWlsZF9pZDogZGF0YS5ndWlsZF9pZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoYW5uZWwsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgbWVzc2FnZS5kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICBtZXNzYWdlcy5zZXQobWVzc2FnZS5pZCwgbWVzc2FnZSk7XG4gICAgICAgICAgY2hhbm5lbC5tZXNzYWdlcy5jYWNoZS5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW1pdHRlZCB3aGVuZXZlciBtZXNzYWdlcyBhcmUgZGVsZXRlZCBpbiBidWxrLlxuICAgICAgICogQGV2ZW50IENsaWVudCNtZXNzYWdlRGVsZXRlQnVsa1xuICAgICAgICogQHBhcmFtIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgTWVzc2FnZT59IG1lc3NhZ2VzIFRoZSBkZWxldGVkIG1lc3NhZ2VzLCBtYXBwZWQgYnkgdGhlaXIgSURcbiAgICAgICAqL1xuICAgICAgaWYgKG1lc3NhZ2VzLnNpemUgPiAwKSBjbGllbnQuZW1pdChFdmVudHMuTUVTU0FHRV9CVUxLX0RFTEVURSwgbWVzc2FnZXMpO1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZURlbGV0ZUJ1bGtBY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFjdGlvbiA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IHsgUGFydGlhbFR5cGVzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG4vKlxueyB1c2VyX2lkOiAnaWQnLFxuICAgICBtZXNzYWdlX2lkOiAnaWQnLFxuICAgICBlbW9qaTogeyBuYW1lOiAn77+9JywgaWQ6IG51bGwgfSxcbiAgICAgY2hhbm5lbF9pZDogJ2lkJyxcbiAgICAgLy8gSWYgb3JpZ2luYXRpbmcgZnJvbSBhIGd1aWxkXG4gICAgIGd1aWxkX2lkOiAnaWQnLFxuICAgICBtZW1iZXI6IHsgLi4uLCB1c2VyOiB7IC4uLiB9IH0gfVxuKi9cblxuY2xhc3MgTWVzc2FnZVJlYWN0aW9uQWRkIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuZW1vamkpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXJGcm9tTWVtYmVyKGRhdGEpO1xuICAgIGlmICghdXNlcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVmVyaWZ5IGNoYW5uZWxcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5nZXRDaGFubmVsKGRhdGEpO1xuICAgIGlmICghY2hhbm5lbCB8fCBjaGFubmVsLnR5cGUgPT09ICd2b2ljZScpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFZlcmlmeSBtZXNzYWdlXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0TWVzc2FnZShkYXRhLCBjaGFubmVsKTtcbiAgICBpZiAoIW1lc3NhZ2UpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFZlcmlmeSByZWFjdGlvblxuICAgIGlmIChtZXNzYWdlLnBhcnRpYWwgJiYgIXRoaXMuY2xpZW50Lm9wdGlvbnMucGFydGlhbHMuaW5jbHVkZXMoUGFydGlhbFR5cGVzLlJFQUNUSU9OKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gbWVzc2FnZS5yZWFjdGlvbnMuY2FjaGUuZ2V0KGRhdGEuZW1vamkuaWQgfHwgZGF0YS5lbW9qaS5uYW1lKTtcbiAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcudXNlcnMuY2FjaGUuaGFzKHVzZXIuaWQpKSByZXR1cm4geyBtZXNzYWdlLCByZWFjdGlvbjogZXhpc3RpbmcsIHVzZXIgfTtcbiAgICBjb25zdCByZWFjdGlvbiA9IG1lc3NhZ2UucmVhY3Rpb25zLmFkZCh7XG4gICAgICBlbW9qaTogZGF0YS5lbW9qaSxcbiAgICAgIGNvdW50OiBtZXNzYWdlLnBhcnRpYWwgPyBudWxsIDogMCxcbiAgICAgIG1lOiB1c2VyLmlkID09PSB0aGlzLmNsaWVudC51c2VyLmlkLFxuICAgIH0pO1xuICAgIGlmICghcmVhY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICByZWFjdGlvbi5fYWRkKHVzZXIpO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSByZWFjdGlvbiBpcyBhZGRlZCB0byBhIGNhY2hlZCBtZXNzYWdlLlxuICAgICAqIEBldmVudCBDbGllbnQjbWVzc2FnZVJlYWN0aW9uQWRkXG4gICAgICogQHBhcmFtIHtNZXNzYWdlUmVhY3Rpb259IG1lc3NhZ2VSZWFjdGlvbiBUaGUgcmVhY3Rpb24gb2JqZWN0XG4gICAgICogQHBhcmFtIHtVc2VyfSB1c2VyIFRoZSB1c2VyIHRoYXQgYXBwbGllZCB0aGUgZ3VpbGQgb3IgcmVhY3Rpb24gZW1vamlcbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudC5lbWl0KEV2ZW50cy5NRVNTQUdFX1JFQUNUSU9OX0FERCwgcmVhY3Rpb24sIHVzZXIpO1xuXG4gICAgcmV0dXJuIHsgbWVzc2FnZSwgcmVhY3Rpb24sIHVzZXIgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VSZWFjdGlvbkFkZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG4vKlxueyB1c2VyX2lkOiAnaWQnLFxuICAgICBtZXNzYWdlX2lkOiAnaWQnLFxuICAgICBlbW9qaTogeyBuYW1lOiAn77+9JywgaWQ6IG51bGwgfSxcbiAgICAgY2hhbm5lbF9pZDogJ2lkJyxcbiAgICAgZ3VpbGRfaWQ6ICdpZCcgfVxuKi9cblxuY2xhc3MgTWVzc2FnZVJlYWN0aW9uUmVtb3ZlIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuZW1vamkpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXIoZGF0YSk7XG4gICAgaWYgKCF1c2VyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBWZXJpZnkgY2hhbm5lbFxuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmdldENoYW5uZWwoZGF0YSk7XG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwudHlwZSA9PT0gJ3ZvaWNlJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVmVyaWZ5IG1lc3NhZ2VcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZXRNZXNzYWdlKGRhdGEsIGNoYW5uZWwpO1xuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVmVyaWZ5IHJlYWN0aW9uXG4gICAgY29uc3QgcmVhY3Rpb24gPSB0aGlzLmdldFJlYWN0aW9uKGRhdGEsIG1lc3NhZ2UsIHVzZXIpO1xuICAgIGlmICghcmVhY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICByZWFjdGlvbi5fcmVtb3ZlKHVzZXIpO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSByZWFjdGlvbiBpcyByZW1vdmVkIGZyb20gYSBjYWNoZWQgbWVzc2FnZS5cbiAgICAgKiBAZXZlbnQgQ2xpZW50I21lc3NhZ2VSZWFjdGlvblJlbW92ZVxuICAgICAqIEBwYXJhbSB7TWVzc2FnZVJlYWN0aW9ufSBtZXNzYWdlUmVhY3Rpb24gVGhlIHJlYWN0aW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSB7VXNlcn0gdXNlciBUaGUgdXNlciB3aG9zZSBlbW9qaSBvciByZWFjdGlvbiBlbW9qaSB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLk1FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFLCByZWFjdGlvbiwgdXNlcik7XG5cbiAgICByZXR1cm4geyBtZXNzYWdlLCByZWFjdGlvbiwgdXNlciB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVJlYWN0aW9uUmVtb3ZlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIE1lc3NhZ2VSZWFjdGlvblJlbW92ZUFsbCBleHRlbmRzIEFjdGlvbiB7XG4gIGhhbmRsZShkYXRhKSB7XG4gICAgLy8gVmVyaWZ5IGNoYW5uZWxcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5nZXRDaGFubmVsKGRhdGEpO1xuICAgIGlmICghY2hhbm5lbCB8fCBjaGFubmVsLnR5cGUgPT09ICd2b2ljZScpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFZlcmlmeSBtZXNzYWdlXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0TWVzc2FnZShkYXRhLCBjaGFubmVsKTtcbiAgICBpZiAoIW1lc3NhZ2UpIHJldHVybiBmYWxzZTtcblxuICAgIG1lc3NhZ2UucmVhY3Rpb25zLmNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5jbGllbnQuZW1pdChFdmVudHMuTUVTU0FHRV9SRUFDVElPTl9SRU1PVkVfQUxMLCBtZXNzYWdlKTtcblxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgfVxufVxuXG4vKipcbiAqIEVtaXR0ZWQgd2hlbmV2ZXIgYWxsIHJlYWN0aW9ucyBhcmUgcmVtb3ZlZCBmcm9tIGEgY2FjaGVkIG1lc3NhZ2UuXG4gKiBAZXZlbnQgQ2xpZW50I21lc3NhZ2VSZWFjdGlvblJlbW92ZUFsbFxuICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoZSByZWFjdGlvbnMgd2VyZSByZW1vdmVkIGZyb21cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VSZWFjdGlvblJlbW92ZUFsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBNZXNzYWdlUmVhY3Rpb25SZW1vdmVFbW9qaSBleHRlbmRzIEFjdGlvbiB7XG4gIGhhbmRsZShkYXRhKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuZ2V0Q2hhbm5lbChkYXRhKTtcbiAgICBpZiAoIWNoYW5uZWwgfHwgY2hhbm5lbC50eXBlID09PSAndm9pY2UnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZXRNZXNzYWdlKGRhdGEsIGNoYW5uZWwpO1xuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgcmVhY3Rpb24gPSB0aGlzLmdldFJlYWN0aW9uKGRhdGEsIG1lc3NhZ2UpO1xuICAgIGlmICghcmVhY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIW1lc3NhZ2UucGFydGlhbCkgbWVzc2FnZS5yZWFjdGlvbnMuY2FjaGUuZGVsZXRlKHJlYWN0aW9uLmVtb2ppLmlkIHx8IHJlYWN0aW9uLmVtb2ppLm5hbWUpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgYm90IHJlbW92ZXMgYW4gZW1vamkgcmVhY3Rpb24gZnJvbSBhIGNhY2hlZCBtZXNzYWdlLlxuICAgICAqIEBldmVudCBDbGllbnQjbWVzc2FnZVJlYWN0aW9uUmVtb3ZlRW1vamlcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VSZWFjdGlvbn0gcmVhY3Rpb24gVGhlIHJlYWN0aW9uIHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudC5lbWl0KEV2ZW50cy5NRVNTQUdFX1JFQUNUSU9OX1JFTU9WRV9FTU9KSSwgcmVhY3Rpb24pO1xuICAgIHJldHVybiB7IHJlYWN0aW9uIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlUmVhY3Rpb25SZW1vdmVFbW9qaTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcblxuY2xhc3MgTWVzc2FnZVVwZGF0ZUFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gIGhhbmRsZShkYXRhKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuZ2V0Q2hhbm5lbChkYXRhKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgY29uc3QgeyBpZCwgY2hhbm5lbF9pZCwgZ3VpbGRfaWQsIGF1dGhvciwgdGltZXN0YW1wLCB0eXBlIH0gPSBkYXRhO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0TWVzc2FnZSh7IGlkLCBjaGFubmVsX2lkLCBndWlsZF9pZCwgYXV0aG9yLCB0aW1lc3RhbXAsIHR5cGUgfSwgY2hhbm5lbCk7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvbGQgPSBtZXNzYWdlLnBhdGNoKGRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9sZCxcbiAgICAgICAgICB1cGRhdGVkOiBtZXNzYWdlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VVcGRhdGVBY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFjdGlvbiA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcblxuY2xhc3MgUHJlc2VuY2VVcGRhdGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGxldCB1c2VyID0gdGhpcy5jbGllbnQudXNlcnMuY2FjaGUuZ2V0KGRhdGEudXNlci5pZCk7XG4gICAgaWYgKCF1c2VyICYmIGRhdGEudXNlci51c2VybmFtZSkgdXNlciA9IHRoaXMuY2xpZW50LnVzZXJzLmFkZChkYXRhLnVzZXIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuXG4gICAgaWYgKGRhdGEudXNlciAmJiBkYXRhLnVzZXIudXNlcm5hbWUpIHtcbiAgICAgIGlmICghdXNlci5lcXVhbHMoZGF0YS51c2VyKSkgdGhpcy5jbGllbnQuYWN0aW9ucy5Vc2VyVXBkYXRlLmhhbmRsZShkYXRhLnVzZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGd1aWxkID0gdGhpcy5jbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmd1aWxkX2lkKTtcbiAgICBpZiAoIWd1aWxkKSByZXR1cm47XG5cbiAgICBsZXQgb2xkUHJlc2VuY2UgPSBndWlsZC5wcmVzZW5jZXMuY2FjaGUuZ2V0KHVzZXIuaWQpO1xuICAgIGlmIChvbGRQcmVzZW5jZSkgb2xkUHJlc2VuY2UgPSBvbGRQcmVzZW5jZS5fY2xvbmUoKTtcbiAgICBsZXQgbWVtYmVyID0gZ3VpbGQubWVtYmVycy5jYWNoZS5nZXQodXNlci5pZCk7XG4gICAgaWYgKCFtZW1iZXIgJiYgZGF0YS5zdGF0dXMgIT09ICdvZmZsaW5lJykge1xuICAgICAgbWVtYmVyID0gZ3VpbGQubWVtYmVycy5hZGQoe1xuICAgICAgICB1c2VyLFxuICAgICAgICByb2xlczogZGF0YS5yb2xlcyxcbiAgICAgICAgZGVhZjogZmFsc2UsXG4gICAgICAgIG11dGU6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNsaWVudC5lbWl0KEV2ZW50cy5HVUlMRF9NRU1CRVJfQVZBSUxBQkxFLCBtZW1iZXIpO1xuICAgIH1cbiAgICBndWlsZC5wcmVzZW5jZXMuYWRkKE9iamVjdC5hc3NpZ24oZGF0YSwgeyBndWlsZCB9KSk7XG4gICAgaWYgKG1lbWJlciAmJiB0aGlzLmNsaWVudC5saXN0ZW5lckNvdW50KEV2ZW50cy5QUkVTRU5DRV9VUERBVEUpKSB7XG4gICAgICAvKipcbiAgICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBndWlsZCBtZW1iZXIncyBwcmVzZW5jZSAoZS5nLiBzdGF0dXMsIGFjdGl2aXR5KSBpcyBjaGFuZ2VkLlxuICAgICAgICogQGV2ZW50IENsaWVudCNwcmVzZW5jZVVwZGF0ZVxuICAgICAgICogQHBhcmFtIHs/UHJlc2VuY2V9IG9sZFByZXNlbmNlIFRoZSBwcmVzZW5jZSBiZWZvcmUgdGhlIHVwZGF0ZSwgaWYgb25lIGF0IGFsbFxuICAgICAgICogQHBhcmFtIHtQcmVzZW5jZX0gbmV3UHJlc2VuY2UgVGhlIHByZXNlbmNlIGFmdGVyIHRoZSB1cGRhdGVcbiAgICAgICAqL1xuICAgICAgdGhpcy5jbGllbnQuZW1pdChFdmVudHMuUFJFU0VOQ0VfVVBEQVRFLCBvbGRQcmVzZW5jZSwgbWVtYmVyLnByZXNlbmNlKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmVzZW5jZVVwZGF0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgdGV4dEJhc2VkQ2hhbm5lbFR5cGVzID0gWydkbScsICd0ZXh0JywgJ25ld3MnXTtcblxuY2xhc3MgVHlwaW5nU3RhcnQgZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmdldENoYW5uZWwoZGF0YSk7XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGV4dEJhc2VkQ2hhbm5lbFR5cGVzLmluY2x1ZGVzKGNoYW5uZWwudHlwZSkpIHtcbiAgICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLldBUk4sIGBEaXNjb3JkIHNlbnQgYSB0eXBpbmcgcGFja2V0IHRvIGEgJHtjaGFubmVsLnR5cGV9IGNoYW5uZWwgJHtjaGFubmVsLmlkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXJGcm9tTWVtYmVyKGRhdGEpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKGRhdGEudGltZXN0YW1wICogMTAwMCk7XG5cbiAgICBpZiAoY2hhbm5lbCAmJiB1c2VyKSB7XG4gICAgICBpZiAoY2hhbm5lbC5fdHlwaW5nLmhhcyh1c2VyLmlkKSkge1xuICAgICAgICBjb25zdCB0eXBpbmcgPSBjaGFubmVsLl90eXBpbmcuZ2V0KHVzZXIuaWQpO1xuXG4gICAgICAgIHR5cGluZy5sYXN0VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0eXBpbmcuZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gdHlwaW5nLnNpbmNlO1xuICAgICAgICB0aGlzLmNsaWVudC5jbGVhclRpbWVvdXQodHlwaW5nLnRpbWVvdXQpO1xuICAgICAgICB0eXBpbmcudGltZW91dCA9IHRoaXMudG9vTGF0ZShjaGFubmVsLCB1c2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpbmNlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgbGFzdFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNoYW5uZWwuX3R5cGluZy5zZXQodXNlci5pZCwge1xuICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgc2luY2UsXG4gICAgICAgICAgbGFzdFRpbWVzdGFtcCxcbiAgICAgICAgICBlbGFwc2VkVGltZTogRGF0ZS5ub3coKSAtIHNpbmNlLFxuICAgICAgICAgIHRpbWVvdXQ6IHRoaXMudG9vTGF0ZShjaGFubmVsLCB1c2VyKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSB1c2VyIHN0YXJ0cyB0eXBpbmcgaW4gYSBjaGFubmVsLlxuICAgICAgICAgKiBAZXZlbnQgQ2xpZW50I3R5cGluZ1N0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0aGUgdXNlciBzdGFydGVkIHR5cGluZyBpblxuICAgICAgICAgKiBAcGFyYW0ge1VzZXJ9IHVzZXIgVGhlIHVzZXIgdGhhdCBzdGFydGVkIHR5cGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGllbnQuZW1pdChFdmVudHMuVFlQSU5HX1NUQVJULCBjaGFubmVsLCB1c2VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b29MYXRlKGNoYW5uZWwsIHVzZXIpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5jbGllbnQuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjaGFubmVsLl90eXBpbmcuZGVsZXRlKHVzZXIuaWQpO1xuICAgIH0sIDEwMDAwKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGluZ1N0YXJ0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIFVzZXJVcGRhdGVBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICBoYW5kbGUoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuXG4gICAgY29uc3QgbmV3VXNlciA9IGNsaWVudC51c2Vycy5jYWNoZS5nZXQoZGF0YS5pZCk7XG4gICAgY29uc3Qgb2xkVXNlciA9IG5ld1VzZXIuX3VwZGF0ZShkYXRhKTtcblxuICAgIGlmICghb2xkVXNlci5lcXVhbHMobmV3VXNlcikpIHtcbiAgICAgIC8qKlxuICAgICAgICogRW1pdHRlZCB3aGVuZXZlciBhIHVzZXIncyBkZXRhaWxzIChlLmcuIHVzZXJuYW1lKSBhcmUgY2hhbmdlZC5cbiAgICAgICAqIFRyaWdnZXJlZCBieSB0aGUgRGlzY29yZCBnYXRld2F5IGV2ZW50cyBVU0VSX1VQREFURSwgR1VJTERfTUVNQkVSX1VQREFURSwgYW5kIFBSRVNFTkNFX1VQREFURS5cbiAgICAgICAqIEBldmVudCBDbGllbnQjdXNlclVwZGF0ZVxuICAgICAgICogQHBhcmFtIHtVc2VyfSBvbGRVc2VyIFRoZSB1c2VyIGJlZm9yZSB0aGUgdXBkYXRlXG4gICAgICAgKiBAcGFyYW0ge1VzZXJ9IG5ld1VzZXIgVGhlIHVzZXIgYWZ0ZXIgdGhlIHVwZGF0ZVxuICAgICAgICovXG4gICAgICBjbGllbnQuZW1pdChFdmVudHMuVVNFUl9VUERBVEUsIG9sZFVzZXIsIG5ld1VzZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2xkOiBvbGRVc2VyLFxuICAgICAgICB1cGRhdGVkOiBuZXdVc2VyLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb2xkOiBudWxsLFxuICAgICAgdXBkYXRlZDogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlclVwZGF0ZUFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgU3RydWN0dXJlcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvU3RydWN0dXJlcycpO1xuXG5jbGFzcyBWb2ljZVN0YXRlVXBkYXRlIGV4dGVuZHMgQWN0aW9uIHtcbiAgaGFuZGxlKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCBndWlsZCA9IGNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KGRhdGEuZ3VpbGRfaWQpO1xuICAgIGlmIChndWlsZCkge1xuICAgICAgY29uc3QgVm9pY2VTdGF0ZSA9IFN0cnVjdHVyZXMuZ2V0KCdWb2ljZVN0YXRlJyk7XG4gICAgICAvLyBVcGRhdGUgdGhlIHN0YXRlXG4gICAgICBjb25zdCBvbGRTdGF0ZSA9IGd1aWxkLnZvaWNlU3RhdGVzLmNhY2hlLmhhcyhkYXRhLnVzZXJfaWQpXG4gICAgICAgID8gZ3VpbGQudm9pY2VTdGF0ZXMuY2FjaGUuZ2V0KGRhdGEudXNlcl9pZCkuX2Nsb25lKClcbiAgICAgICAgOiBuZXcgVm9pY2VTdGF0ZShndWlsZCwgeyB1c2VyX2lkOiBkYXRhLnVzZXJfaWQgfSk7XG5cbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gZ3VpbGQudm9pY2VTdGF0ZXMuYWRkKGRhdGEpO1xuXG4gICAgICAvLyBHZXQgdGhlIG1lbWJlclxuICAgICAgbGV0IG1lbWJlciA9IGd1aWxkLm1lbWJlcnMuY2FjaGUuZ2V0KGRhdGEudXNlcl9pZCk7XG4gICAgICBpZiAobWVtYmVyICYmIGRhdGEubWVtYmVyKSB7XG4gICAgICAgIG1lbWJlci5fcGF0Y2goZGF0YS5tZW1iZXIpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLm1lbWJlciAmJiBkYXRhLm1lbWJlci51c2VyICYmIGRhdGEubWVtYmVyLmpvaW5lZF9hdCkge1xuICAgICAgICBtZW1iZXIgPSBndWlsZC5tZW1iZXJzLmFkZChkYXRhLm1lbWJlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEVtaXQgZXZlbnRcbiAgICAgIGlmIChtZW1iZXIgJiYgbWVtYmVyLnVzZXIuaWQgPT09IGNsaWVudC51c2VyLmlkKSB7XG4gICAgICAgIGNsaWVudC5lbWl0KCdkZWJ1ZycsIGBbVk9JQ0VdIHJlY2VpdmVkIHZvaWNlIHN0YXRlIHVwZGF0ZTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICAgICAgY2xpZW50LnZvaWNlLm9uVm9pY2VTdGF0ZVVwZGF0ZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgbWVtYmVyIGNoYW5nZXMgdm9pY2Ugc3RhdGUgLSBlLmcuIGpvaW5zL2xlYXZlcyBhIGNoYW5uZWwsIG11dGVzL3VubXV0ZXMuXG4gICAgICAgKiBAZXZlbnQgQ2xpZW50I3ZvaWNlU3RhdGVVcGRhdGVcbiAgICAgICAqIEBwYXJhbSB7Vm9pY2VTdGF0ZX0gb2xkU3RhdGUgVGhlIHZvaWNlIHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlXG4gICAgICAgKiBAcGFyYW0ge1ZvaWNlU3RhdGV9IG5ld1N0YXRlIFRoZSB2b2ljZSBzdGF0ZSBhZnRlciB0aGUgdXBkYXRlXG4gICAgICAgKi9cbiAgICAgIGNsaWVudC5lbWl0KEV2ZW50cy5WT0lDRV9TVEFURV9VUERBVEUsIG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVm9pY2VTdGF0ZVVwZGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWN0aW9uID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jbGFzcyBXZWJob29rc1VwZGF0ZSBleHRlbmRzIEFjdGlvbiB7XG4gIGhhbmRsZShkYXRhKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgY2hhbm5lbCA9IGNsaWVudC5jaGFubmVscy5jYWNoZS5nZXQoZGF0YS5jaGFubmVsX2lkKTtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgZ3VpbGQgdGV4dCBjaGFubmVsIGhhcyBpdHMgd2ViaG9va3MgY2hhbmdlZC5cbiAgICAgKiBAZXZlbnQgQ2xpZW50I3dlYmhvb2tVcGRhdGVcbiAgICAgKiBAcGFyYW0ge1RleHRDaGFubmVsfSBjaGFubmVsIFRoZSBjaGFubmVsIHRoYXQgaGFkIGEgd2ViaG9vayB1cGRhdGVcbiAgICAgKi9cbiAgICBpZiAoY2hhbm5lbCkgY2xpZW50LmVtaXQoRXZlbnRzLldFQkhPT0tTX1VQREFURSwgY2hhbm5lbCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJob29rc1VwZGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBXZWJTb2NrZXRTaGFyZCA9IHJlcXVpcmUoJy4vV2ViU29ja2V0U2hhcmQnKTtcbmNvbnN0IFBhY2tldEhhbmRsZXJzID0gcmVxdWlyZSgnLi9oYW5kbGVycycpO1xuY29uc3QgeyBFcnJvcjogREpTRXJyb3IgfSA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuY29uc3QgeyBFdmVudHMsIFNoYXJkRXZlbnRzLCBTdGF0dXMsIFdTQ29kZXMsIFdTRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvVXRpbCcpO1xuXG5jb25zdCBCZWZvcmVSZWFkeVdoaXRlbGlzdCA9IFtcbiAgV1NFdmVudHMuUkVBRFksXG4gIFdTRXZlbnRzLlJFU1VNRUQsXG4gIFdTRXZlbnRzLkdVSUxEX0NSRUFURSxcbiAgV1NFdmVudHMuR1VJTERfREVMRVRFLFxuICBXU0V2ZW50cy5HVUlMRF9NRU1CRVJTX0NIVU5LLFxuICBXU0V2ZW50cy5HVUlMRF9NRU1CRVJfQURELFxuICBXU0V2ZW50cy5HVUlMRF9NRU1CRVJfUkVNT1ZFLFxuXTtcblxuY29uc3QgVU5SRUNPVkVSQUJMRV9DTE9TRV9DT0RFUyA9IE9iamVjdC5rZXlzKFdTQ29kZXMpLnNsaWNlKDEpLm1hcChOdW1iZXIpO1xuY29uc3QgVU5SRVNVTUFCTEVfQ0xPU0VfQ09ERVMgPSBbMTAwMCwgNDAwNiwgNDAwN107XG5cbi8qKlxuICogVGhlIFdlYlNvY2tldCBtYW5hZ2VyIGZvciB0aGlzIGNsaWVudC5cbiAqIDxpbmZvPlRoaXMgY2xhc3MgZm9yd2FyZHMgcmF3IGRpc3BhdGNoIGV2ZW50cyxcbiAqIHJlYWQgbW9yZSBhYm91dCBpdCBoZXJlIHtAbGluayBodHRwczovL2Rpc2NvcmQuY29tL2RldmVsb3BlcnMvZG9jcy90b3BpY3MvZ2F0ZXdheX08L2luZm8+XG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRoYXQgaW5zdGFudGlhdGVkIHRoaXMgV2ViU29ja2V0TWFuYWdlclxuICAgICAqIEB0eXBlIHtDbGllbnR9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG5hbWUgV2ViU29ja2V0TWFuYWdlciNjbGllbnRcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NsaWVudCcsIHsgdmFsdWU6IGNsaWVudCB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnYXRld2F5IHRoaXMgbWFuYWdlciB1c2VzXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nYXRld2F5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2Ygc2hhcmRzIHRoaXMgbWFuYWdlciBoYW5kbGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG90YWxTaGFyZHMgPSB0aGlzLmNsaWVudC5vcHRpb25zLnNoYXJkcy5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgYWxsIHNoYXJkcyB0aGlzIG1hbmFnZXIgaGFuZGxlc1xuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPG51bWJlciwgV2ViU29ja2V0U2hhcmQ+fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcmRzID0gbmV3IENvbGxlY3Rpb24oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHNoYXJkcyB0byBiZSBjb25uZWN0ZWQgb3IgdGhhdCBuZWVkIHRvIHJlY29ubmVjdFxuICAgICAqIEB0eXBlIHtTZXQ8V2ViU29ja2V0U2hhcmQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgV2ViU29ja2V0TWFuYWdlciNzaGFyZFF1ZXVlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaGFyZFF1ZXVlJywgeyB2YWx1ZTogbmV3IFNldCgpLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHF1ZXVlZCBldmVudHMgYmVmb3JlIHRoaXMgV2ViU29ja2V0TWFuYWdlciBiZWNhbWUgcmVhZHlcbiAgICAgKiBAdHlwZSB7b2JqZWN0W119XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBXZWJTb2NrZXRNYW5hZ2VyI3BhY2tldFF1ZXVlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYWNrZXRRdWV1ZScsIHsgdmFsdWU6IFtdIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoaXMgV2ViU29ja2V0TWFuYWdlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGF0dXMgPSBTdGF0dXMuSURMRTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgbWFuYWdlciB3YXMgZGVzdHJveWVkLiBJdCB3aWxsIHByZXZlbnQgc2hhcmRzIGZyb20gcmVjb25uZWN0aW5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBtYW5hZ2VyIGlzIGN1cnJlbnRseSByZWNvbm5lY3Rpbmcgb25lIG9yIG11bHRpcGxlIHNoYXJkc1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNlc3Npb24gbGltaXQgb2YgdGhlIGNsaWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRvdGFsIFRvdGFsIG51bWJlciBvZiBpZGVudGlmaWVzIGF2YWlsYWJsZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZW1haW5pbmcgTnVtYmVyIG9mIGlkZW50aWZpZXMgcmVtYWluaW5nXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc2V0X2FmdGVyIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGxpbWl0IHJlc2V0c1xuICAgICAqL1xuICAgIHRoaXMuc2Vzc2lvblN0YXJ0TGltaXQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhdmVyYWdlIHBpbmcgb2YgYWxsIFdlYlNvY2tldFNoYXJkc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwaW5nKCkge1xuICAgIGNvbnN0IHN1bSA9IHRoaXMuc2hhcmRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIucGluZywgMCk7XG4gICAgcmV0dXJuIHN1bSAvIHRoaXMuc2hhcmRzLnNpemU7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSBkZWJ1ZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZGVidWcgbWVzc2FnZVxuICAgKiBAcGFyYW0gez9XZWJTb2NrZXRTaGFyZH0gW3NoYXJkXSBUaGUgc2hhcmQgdGhhdCBlbWl0dGVkIHRoaXMgbWVzc2FnZSwgaWYgYW55XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWJ1ZyhtZXNzYWdlLCBzaGFyZCkge1xuICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLkRFQlVHLCBgW1dTID0+ICR7c2hhcmQgPyBgU2hhcmQgJHtzaGFyZC5pZH1gIDogJ01hbmFnZXInfV0gJHttZXNzYWdlfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoaXMgbWFuYWdlciB0byB0aGUgZ2F0ZXdheS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgY29uc3QgaW52YWxpZFRva2VuID0gbmV3IERKU0Vycm9yKFdTQ29kZXNbNDAwNF0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHVybDogZ2F0ZXdheVVSTCxcbiAgICAgIHNoYXJkczogcmVjb21tZW5kZWRTaGFyZHMsXG4gICAgICBzZXNzaW9uX3N0YXJ0X2xpbWl0OiBzZXNzaW9uU3RhcnRMaW1pdCxcbiAgICB9ID0gYXdhaXQgdGhpcy5jbGllbnQuYXBpLmdhdGV3YXkuYm90LmdldCgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRocm93IGVycm9yLmh0dHBTdGF0dXMgPT09IDQwMSA/IGludmFsaWRUb2tlbiA6IGVycm9yO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXNzaW9uU3RhcnRMaW1pdCA9IHNlc3Npb25TdGFydExpbWl0O1xuXG4gICAgY29uc3QgeyB0b3RhbCwgcmVtYWluaW5nLCByZXNldF9hZnRlciB9ID0gc2Vzc2lvblN0YXJ0TGltaXQ7XG5cbiAgICB0aGlzLmRlYnVnKGBGZXRjaGVkIEdhdGV3YXkgSW5mb3JtYXRpb25cbiAgICBVUkw6ICR7Z2F0ZXdheVVSTH1cbiAgICBSZWNvbW1lbmRlZCBTaGFyZHM6ICR7cmVjb21tZW5kZWRTaGFyZHN9YCk7XG5cbiAgICB0aGlzLmRlYnVnKGBTZXNzaW9uIExpbWl0IEluZm9ybWF0aW9uXG4gICAgVG90YWw6ICR7dG90YWx9XG4gICAgUmVtYWluaW5nOiAke3JlbWFpbmluZ31gKTtcblxuICAgIHRoaXMuZ2F0ZXdheSA9IGAke2dhdGV3YXlVUkx9L2A7XG5cbiAgICBsZXQgeyBzaGFyZHMgfSA9IHRoaXMuY2xpZW50Lm9wdGlvbnM7XG5cbiAgICBpZiAoc2hhcmRzID09PSAnYXV0bycpIHtcbiAgICAgIHRoaXMuZGVidWcoYFVzaW5nIHRoZSByZWNvbW1lbmRlZCBzaGFyZCBjb3VudCBwcm92aWRlZCBieSBEaXNjb3JkOiAke3JlY29tbWVuZGVkU2hhcmRzfWApO1xuICAgICAgdGhpcy50b3RhbFNoYXJkcyA9IHRoaXMuY2xpZW50Lm9wdGlvbnMuc2hhcmRDb3VudCA9IHJlY29tbWVuZGVkU2hhcmRzO1xuICAgICAgc2hhcmRzID0gdGhpcy5jbGllbnQub3B0aW9ucy5zaGFyZHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByZWNvbW1lbmRlZFNoYXJkcyB9LCAoXywgaSkgPT4gaSk7XG4gICAgfVxuXG4gICAgdGhpcy50b3RhbFNoYXJkcyA9IHNoYXJkcy5sZW5ndGg7XG4gICAgdGhpcy5kZWJ1ZyhgU3Bhd25pbmcgc2hhcmRzOiAke3NoYXJkcy5qb2luKCcsICcpfWApO1xuICAgIHRoaXMuc2hhcmRRdWV1ZSA9IG5ldyBTZXQoc2hhcmRzLm1hcChpZCA9PiBuZXcgV2ViU29ja2V0U2hhcmQodGhpcywgaWQpKSk7XG5cbiAgICBhd2FpdCB0aGlzLl9oYW5kbGVTZXNzaW9uTGltaXQocmVtYWluaW5nLCByZXNldF9hZnRlcik7XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVTaGFyZHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjcmVhdGlvbiBvZiBhIHNoYXJkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNoYXJkcygpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBzaGFyZHMgdG8gaGFuZGxlLCByZXR1cm5cbiAgICBpZiAoIXRoaXMuc2hhcmRRdWV1ZS5zaXplKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBbc2hhcmRdID0gdGhpcy5zaGFyZFF1ZXVlO1xuXG4gICAgdGhpcy5zaGFyZFF1ZXVlLmRlbGV0ZShzaGFyZCk7XG5cbiAgICBpZiAoIXNoYXJkLmV2ZW50c0F0dGFjaGVkKSB7XG4gICAgICBzaGFyZC5vbihTaGFyZEV2ZW50cy5BTExfUkVBRFksIHVuYXZhaWxhYmxlR3VpbGRzID0+IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiBhIHNoYXJkIHR1cm5zIHJlYWR5LlxuICAgICAgICAgKiBAZXZlbnQgQ2xpZW50I3NoYXJkUmVhZHlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFRoZSBzaGFyZCBJRCB0aGF0IHR1cm5lZCByZWFkeVxuICAgICAgICAgKiBAcGFyYW0gez9TZXQ8c3RyaW5nPn0gdW5hdmFpbGFibGVHdWlsZHMgU2V0IG9mIHVuYXZhaWxhYmxlIGd1aWxkIElEcywgaWYgYW55XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWVudC5lbWl0KEV2ZW50cy5TSEFSRF9SRUFEWSwgc2hhcmQuaWQsIHVuYXZhaWxhYmxlR3VpbGRzKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2hhcmRRdWV1ZS5zaXplKSB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoZWNrU2hhcmRzUmVhZHkoKTtcbiAgICAgIH0pO1xuXG4gICAgICBzaGFyZC5vbihTaGFyZEV2ZW50cy5DTE9TRSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuY29kZSA9PT0gMTAwMCA/IHRoaXMuZGVzdHJveWVkIDogVU5SRUNPVkVSQUJMRV9DTE9TRV9DT0RFUy5pbmNsdWRlcyhldmVudC5jb2RlKSkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEVtaXR0ZWQgd2hlbiBhIHNoYXJkJ3MgV2ViU29ja2V0IGRpc2Nvbm5lY3RzIGFuZCB3aWxsIG5vIGxvbmdlciByZWNvbm5lY3QuXG4gICAgICAgICAgICogQGV2ZW50IENsaWVudCNzaGFyZERpc2Nvbm5lY3RcbiAgICAgICAgICAgKiBAcGFyYW0ge0Nsb3NlRXZlbnR9IGV2ZW50IFRoZSBXZWJTb2NrZXQgY2xvc2UgZXZlbnRcbiAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIHNoYXJkIElEIHRoYXQgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy5jbGllbnQuZW1pdChFdmVudHMuU0hBUkRfRElTQ09OTkVDVCwgZXZlbnQsIHNoYXJkLmlkKTtcbiAgICAgICAgICB0aGlzLmRlYnVnKFdTQ29kZXNbZXZlbnQuY29kZV0sIHNoYXJkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVU5SRVNVTUFCTEVfQ0xPU0VfQ09ERVMuaW5jbHVkZXMoZXZlbnQuY29kZSkpIHtcbiAgICAgICAgICAvLyBUaGVzZSBldmVudCBjb2RlcyBjYW5ub3QgYmUgcmVzdW1lZFxuICAgICAgICAgIHNoYXJkLnNlc3Npb25JRCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHRlZCB3aGVuIGEgc2hhcmQgaXMgYXR0ZW1wdGluZyB0byByZWNvbm5lY3Qgb3IgcmUtaWRlbnRpZnkuXG4gICAgICAgICAqIEBldmVudCBDbGllbnQjc2hhcmRSZWNvbm5lY3RpbmdcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFRoZSBzaGFyZCBJRCB0aGF0IGlzIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWVudC5lbWl0KEV2ZW50cy5TSEFSRF9SRUNPTk5FQ1RJTkcsIHNoYXJkLmlkKTtcblxuICAgICAgICB0aGlzLnNoYXJkUXVldWUuYWRkKHNoYXJkKTtcblxuICAgICAgICBpZiAoc2hhcmQuc2Vzc2lvbklEKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgU2Vzc2lvbiBJRCBpcyBwcmVzZW50LCBhdHRlbXB0aW5nIGFuIGltbWVkaWF0ZSByZWNvbm5lY3QuLi5gLCBzaGFyZCk7XG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3QodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcmQuZGVzdHJveSh7IHJlc2V0OiB0cnVlLCBlbWl0OiBmYWxzZSwgbG9nOiBmYWxzZSB9KTtcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2hhcmQub24oU2hhcmRFdmVudHMuSU5WQUxJRF9TRVNTSU9OLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLlNIQVJEX1JFQ09OTkVDVElORywgc2hhcmQuaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIHNoYXJkLm9uKFNoYXJkRXZlbnRzLkRFU1RST1lFRCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKCdTaGFyZCB3YXMgZGVzdHJveWVkIGJ1dCBubyBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgcHJlc2VudCEgUmVjb25uZWN0aW5nLi4uJywgc2hhcmQpO1xuXG4gICAgICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLlNIQVJEX1JFQ09OTkVDVElORywgc2hhcmQuaWQpO1xuXG4gICAgICAgIHRoaXMuc2hhcmRRdWV1ZS5hZGQoc2hhcmQpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHNoYXJkLmV2ZW50c0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXJkcy5zZXQoc2hhcmQuaWQsIHNoYXJkKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzaGFyZC5jb25uZWN0KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlICYmIFVOUkVDT1ZFUkFCTEVfQ0xPU0VfQ09ERVMuaW5jbHVkZXMoZXJyb3IuY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERKU0Vycm9yKFdTQ29kZXNbZXJyb3IuY29kZV0pO1xuICAgICAgICAvLyBVbmRlZmluZWQgaWYgc2Vzc2lvbiBpcyBpbnZhbGlkLCBlcnJvciBldmVudCBmb3IgcmVndWxhciBjbG9zZXNcbiAgICAgIH0gZWxzZSBpZiAoIWVycm9yIHx8IGVycm9yLmNvZGUpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnRmFpbGVkIHRvIGNvbm5lY3QgdG8gdGhlIGdhdGV3YXksIHJlcXVldWVpbmcuLi4nLCBzaGFyZCk7XG4gICAgICAgIHRoaXMuc2hhcmRRdWV1ZS5hZGQoc2hhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSBzaGFyZHMsIGFkZCBhIDVzIGRlbGF5XG4gICAgaWYgKHRoaXMuc2hhcmRRdWV1ZS5zaXplKSB7XG4gICAgICB0aGlzLmRlYnVnKGBTaGFyZCBRdWV1ZSBTaXplOiAke3RoaXMuc2hhcmRRdWV1ZS5zaXplfTsgY29udGludWluZyBpbiA1IHNlY29uZHMuLi5gKTtcbiAgICAgIGF3YWl0IFV0aWwuZGVsYXlGb3IoNTAwMCk7XG4gICAgICBhd2FpdCB0aGlzLl9oYW5kbGVTZXNzaW9uTGltaXQoKTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNoYXJkcygpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgcmVjb25uZWN0cyBmb3IgdGhpcyBtYW5hZ2VyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGltaXQ9ZmFsc2VdIElGIHRoaXMgcmVjb25uZWN0IHNob3VsZCBza2lwIGNoZWNraW5nIHRoZSBzZXNzaW9uIGxpbWl0XG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgcmVjb25uZWN0KHNraXBMaW1pdCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc3RhdHVzICE9PSBTdGF0dXMuUkVBRFkpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2tpcExpbWl0KSBhd2FpdCB0aGlzLl9oYW5kbGVTZXNzaW9uTGltaXQoKTtcbiAgICAgIGF3YWl0IHRoaXMuY3JlYXRlU2hhcmRzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVidWcoYENvdWxkbid0IHJlY29ubmVjdCBvciBmZXRjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2F0ZXdheS4gJHtlcnJvcn1gKTtcbiAgICAgIGlmIChlcnJvci5odHRwU3RhdHVzICE9PSA0MDEpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgUG9zc2libGUgbmV0d29yayBlcnJvciBvY2N1cnJlZC4gUmV0cnlpbmcgaW4gNXMuLi5gKTtcbiAgICAgICAgYXdhaXQgVXRpbC5kZWxheUZvcig1MDAwKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgYW4gZXJyb3IgYXQgdGhpcyBwb2ludCwgaXQgbWVhbnMgd2UgY2Fubm90IHJlY29ubmVjdCBhbnltb3JlXG4gICAgICBpZiAodGhpcy5jbGllbnQubGlzdGVuZXJDb3VudChFdmVudHMuSU5WQUxJREFURUQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGNsaWVudCdzIHNlc3Npb24gYmVjb21lcyBpbnZhbGlkYXRlZC5cbiAgICAgICAgICogWW91IGFyZSBleHBlY3RlZCB0byBoYW5kbGUgY2xvc2luZyB0aGUgcHJvY2VzcyBncmFjZWZ1bGx5IGFuZCBwcmV2ZW50aW5nIGEgYm9vdCBsb29wXG4gICAgICAgICAqIGlmIHlvdSBhcmUgbGlzdGVuaW5nIHRvIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBldmVudCBDbGllbnQjaW52YWxpZGF0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLklOVkFMSURBVEVEKTtcbiAgICAgICAgLy8gRGVzdHJveSBqdXN0IHRoZSBzaGFyZHMuIFRoaXMgbWVhbnMgeW91IGhhdmUgdG8gaGFuZGxlIHRoZSBjbGVhbnVwIHlvdXJzZWxmXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbGllbnQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCcm9hZGNhc3RzIGEgcGFja2V0IHRvIGV2ZXJ5IHNoYXJkIHRoaXMgbWFuYWdlciBoYW5kbGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IFRoZSBwYWNrZXQgdG8gc2VuZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnJvYWRjYXN0KHBhY2tldCkge1xuICAgIGZvciAoY29uc3Qgc2hhcmQgb2YgdGhpcy5zaGFyZHMudmFsdWVzKCkpIHNoYXJkLnNlbmQocGFja2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIG1hbmFnZXIgYW5kIGFsbCBpdHMgc2hhcmRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybjtcbiAgICB0aGlzLmRlYnVnKGBNYW5hZ2VyIHdhcyBkZXN0cm95ZWQuIENhbGxlZCBieTpcXG4ke25ldyBFcnJvcignTUFOQUdFUl9ERVNUUk9ZRUQnKS5zdGFja31gKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5zaGFyZFF1ZXVlLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBzaGFyZCBvZiB0aGlzLnNoYXJkcy52YWx1ZXMoKSkgc2hhcmQuZGVzdHJveSh7IGNsb3NlQ29kZTogMTAwMCwgcmVzZXQ6IHRydWUsIGVtaXQ6IGZhbHNlLCBsb2c6IGZhbHNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHRpbWVvdXQgcmVxdWlyZWQgaWYgd2UgY2Fubm90IGlkZW50aWZ5IGFueW1vcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVtYWluaW5nXSBUaGUgYW1vdW50IG9mIHJlbWFpbmluZyBpZGVudGlmeSBzZXNzaW9ucyB0aGF0IGNhbiBiZSBkb25lIHRvZGF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzZXRBZnRlcl0gVGhlIGFtb3VudCBvZiB0aW1lIGluIHdoaWNoIHRoZSBpZGVudGlmeSBjb3VudGVyIHJlc2V0c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2hhbmRsZVNlc3Npb25MaW1pdChyZW1haW5pbmcsIHJlc2V0QWZ0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlbWFpbmluZyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHJlc2V0QWZ0ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IHNlc3Npb25fc3RhcnRfbGltaXQgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmFwaS5nYXRld2F5LmJvdC5nZXQoKTtcbiAgICAgIHRoaXMuc2Vzc2lvblN0YXJ0TGltaXQgPSBzZXNzaW9uX3N0YXJ0X2xpbWl0O1xuICAgICAgcmVtYWluaW5nID0gc2Vzc2lvbl9zdGFydF9saW1pdC5yZW1haW5pbmc7XG4gICAgICByZXNldEFmdGVyID0gc2Vzc2lvbl9zdGFydF9saW1pdC5yZXNldF9hZnRlcjtcbiAgICAgIHRoaXMuZGVidWcoYFNlc3Npb24gTGltaXQgSW5mb3JtYXRpb25cbiAgICBUb3RhbDogJHtzZXNzaW9uX3N0YXJ0X2xpbWl0LnRvdGFsfVxuICAgIFJlbWFpbmluZzogJHtyZW1haW5pbmd9YCk7XG4gICAgfVxuICAgIGlmICghcmVtYWluaW5nKSB7XG4gICAgICB0aGlzLmRlYnVnKGBFeGNlZWRlZCBpZGVudGlmeSB0aHJlc2hvbGQuIFdpbGwgYXR0ZW1wdCBhIGNvbm5lY3Rpb24gaW4gJHtyZXNldEFmdGVyfW1zYCk7XG4gICAgICBhd2FpdCBVdGlsLmRlbGF5Rm9yKHJlc2V0QWZ0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBwYWNrZXQgYW5kIHF1ZXVlcyBpdCBpZiB0aGlzIFdlYlNvY2tldE1hbmFnZXIgaXMgbm90IHJlYWR5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhY2tldF0gVGhlIHBhY2tldCB0byBiZSBoYW5kbGVkXG4gICAqIEBwYXJhbSB7V2ViU29ja2V0U2hhcmR9IFtzaGFyZF0gVGhlIHNoYXJkIHRoYXQgd2lsbCBoYW5kbGUgdGhpcyBwYWNrZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQYWNrZXQocGFja2V0LCBzaGFyZCkge1xuICAgIGlmIChwYWNrZXQgJiYgdGhpcy5zdGF0dXMgIT09IFN0YXR1cy5SRUFEWSkge1xuICAgICAgaWYgKCFCZWZvcmVSZWFkeVdoaXRlbGlzdC5pbmNsdWRlcyhwYWNrZXQudCkpIHtcbiAgICAgICAgdGhpcy5wYWNrZXRRdWV1ZS5wdXNoKHsgcGFja2V0LCBzaGFyZCB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhY2tldFF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMucGFja2V0UXVldWUuc2hpZnQoKTtcbiAgICAgIHRoaXMuY2xpZW50LnNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFja2V0KGl0ZW0ucGFja2V0LCBpdGVtLnNoYXJkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYWNrZXQgJiYgUGFja2V0SGFuZGxlcnNbcGFja2V0LnRdKSB7XG4gICAgICBQYWNrZXRIYW5kbGVyc1twYWNrZXQudF0odGhpcy5jbGllbnQsIHBhY2tldCwgc2hhcmQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjbGllbnQgaXMgcmVhZHkgdG8gYmUgbWFya2VkIGFzIHJlYWR5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgY2hlY2tTaGFyZHNSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IFN0YXR1cy5SRUFEWSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnNoYXJkcy5zaXplICE9PSB0aGlzLnRvdGFsU2hhcmRzIHx8IHRoaXMuc2hhcmRzLnNvbWUocyA9PiBzLnN0YXR1cyAhPT0gU3RhdHVzLlJFQURZKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdHVzID0gU3RhdHVzLk5FQVJMWTtcblxuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmZldGNoQWxsTWVtYmVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLmNsaWVudC5ndWlsZHMuY2FjaGUubWFwKGd1aWxkID0+IHtcbiAgICAgICAgICBpZiAoZ3VpbGQuYXZhaWxhYmxlKSByZXR1cm4gZ3VpbGQubWVtYmVycy5mZXRjaCgpO1xuICAgICAgICAgIC8vIFJldHVybiBlbXB0eSBwcm9taXNlIGlmIGd1aWxkIGlzIHVuYXZhaWxhYmxlXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBmZXRjaCBhbGwgbWVtYmVycyBiZWZvcmUgcmVhZHkhICR7ZXJyfVxcbiR7ZXJyLnN0YWNrfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlckNsaWVudFJlYWR5KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2F1c2VzIHRoZSBjbGllbnQgdG8gYmUgbWFya2VkIGFzIHJlYWR5IGFuZCBlbWl0cyB0aGUgcmVhZHkgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyQ2xpZW50UmVhZHkoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBTdGF0dXMuUkVBRFk7XG5cbiAgICB0aGlzLmNsaWVudC5yZWFkeUF0ID0gbmV3IERhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgY2xpZW50IGJlY29tZXMgcmVhZHkgdG8gc3RhcnQgd29ya2luZy5cbiAgICAgKiBAZXZlbnQgQ2xpZW50I3JlYWR5XG4gICAgICovXG4gICAgdGhpcy5jbGllbnQuZW1pdChFdmVudHMuQ0xJRU5UX1JFQURZKTtcblxuICAgIHRoaXMuaGFuZGxlUGFja2V0KCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4uLy4uL1dlYlNvY2tldCcpO1xuY29uc3QgeyBicm93c2VyLCBTdGF0dXMsIEV2ZW50cywgU2hhcmRFdmVudHMsIE9QQ29kZXMsIFdTRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jb25zdCBTVEFUVVNfS0VZUyA9IE9iamVjdC5rZXlzKFN0YXR1cyk7XG5jb25zdCBDT05ORUNUSU9OX1NUQVRFID0gT2JqZWN0LmtleXMoV2ViU29ja2V0LldlYlNvY2tldCk7XG5cbmxldCB6bGliO1xuXG5pZiAoIWJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB6bGliID0gcmVxdWlyZSgnemxpYi1zeW5jJyk7XG4gIH0gY2F0Y2gge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBTaGFyZCdzIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNoYXJkIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgaWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYlNvY2tldE1hbmFnZXIgb2YgdGhlIHNoYXJkXG4gICAgICogQHR5cGUge1dlYlNvY2tldE1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgc2hhcmRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgc2hhcmRcbiAgICAgKiBAdHlwZSB7U3RhdHVzfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdHVzID0gU3RhdHVzLklETEU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzZXF1ZW5jZSBvZiB0aGUgc2hhcmRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zZXF1ZW5jZSA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIG9mIHRoZSBzaGFyZCBhZnRlciBjbG9zZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNsb3NlU2VxdWVuY2UgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2Vzc2lvbiBJRCBvZiB0aGUgc2hhcmRcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2Vzc2lvbklEID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBoZWFydGJlYXQgcGluZyBvZiB0aGUgc2hhcmRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGluZyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgdGltZSBhIHBpbmcgd2FzIHNlbnQgKGEgdGltZXN0YW1wKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQaW5nVGltZXN0YW1wID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSByZWNlaXZlZCBhIGhlYXJ0YmVhdCBhY2sgYmFjay4gVXNlZCB0byBpZGVudGlmeSB6b21iaWUgY29ubmVjdGlvbnNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFzdEhlYXJ0YmVhdEFja2VkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHRoZSByYXRlIGxpbWl0IHF1ZXVlIGFuZCBtZXRhZGF0YVxuICAgICAqIEBuYW1lIFdlYlNvY2tldFNoYXJkI3JhdGVsaW1pdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JhdGVsaW1pdCcsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHF1ZXVlOiBbXSxcbiAgICAgICAgdG90YWw6IDEyMCxcbiAgICAgICAgcmVtYWluaW5nOiAxMjAsXG4gICAgICAgIHRpbWU6IDYwZTMsXG4gICAgICAgIHRpbWVyOiBudWxsLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdGhlIGN1cnJlbnQgc2hhcmRcbiAgICAgKiBAbmFtZSBXZWJTb2NrZXRTaGFyZCNjb25uZWN0aW9uXG4gICAgICogQHR5cGUgez9XZWJTb2NrZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2Nvbm5lY3Rpb24nLCB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuICAgIC8qKlxuICAgICAqIEBleHRlcm5hbCBJbmZsYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvemxpYi1zeW5jfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXByZXNzaW9uIHRvIHVzZVxuICAgICAqIEBuYW1lIFdlYlNvY2tldFNoYXJkI2luZmxhdGVcbiAgICAgKiBAdHlwZSB7P0luZmxhdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2luZmxhdGUnLCB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBIRUxMTyB0aW1lb3V0XG4gICAgICogQG5hbWUgV2ViU29ja2V0U2hhcmQjaGVsbG9UaW1lb3V0XG4gICAgICogQHR5cGUgez9Ob2RlSlMuVGltZW91dH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGVsbG9UaW1lb3V0JywgeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbWFuYWdlciBhdHRhY2hlZCBpdHMgZXZlbnQgaGFuZGxlcnMgb24gdGhlIHNoYXJkXG4gICAgICogQG5hbWUgV2ViU29ja2V0U2hhcmQjZXZlbnRzQXR0YWNoZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZXZlbnRzQXR0YWNoZWQnLCB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBndWlsZCBJRHMgdGhpcyBzaGFyZCBleHBlY3RzIHRvIHJlY2VpdmVcbiAgICAgKiBAbmFtZSBXZWJTb2NrZXRTaGFyZCNleHBlY3RlZEd1aWxkc1xuICAgICAqIEB0eXBlIHs/U2V0PHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2V4cGVjdGVkR3VpbGRzJywgeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVhZHkgdGltZW91dFxuICAgICAqIEBuYW1lIFdlYlNvY2tldFNoYXJkI3JlYWR5VGltZW91dFxuICAgICAqIEB0eXBlIHs/Tm9kZUpTLlRpbWVvdXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWR5VGltZW91dCcsIHsgdmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGltZSB3aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgb3BlbmVkXG4gICAgICogQG5hbWUgV2ViU29ja2V0U2hhcmQjY29ubmVjdGVkQXRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25uZWN0ZWRBdCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgZGVidWcgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBkZWJ1ZyBtZXNzYWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgdGhpcy5tYW5hZ2VyLmRlYnVnKG1lc3NhZ2UsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBzaGFyZCB0byB0aGUgZ2F0ZXdheS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBpZiB0aGUgc2hhcmQgdHVybnMgcmVhZHkgc3VjY2Vzc2Z1bGx5LFxuICAgKiBvciByZWplY3QgaWYgd2UgY291bGRuJ3QgY29ubmVjdFxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBjb25zdCB7IGdhdGV3YXksIGNsaWVudCB9ID0gdGhpcy5tYW5hZ2VyO1xuXG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4gJiYgdGhpcy5zdGF0dXMgPT09IFN0YXR1cy5SRUFEWSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFNoYXJkRXZlbnRzLkNMT1NFLCBvbkNsb3NlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihTaGFyZEV2ZW50cy5SRUFEWSwgb25SZWFkeSk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoU2hhcmRFdmVudHMuUkVTVU1FRCwgb25SZXN1bWVkKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihTaGFyZEV2ZW50cy5JTlZBTElEX1NFU1NJT04sIG9uSW52YWxpZE9yRGVzdHJveWVkKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihTaGFyZEV2ZW50cy5ERVNUUk9ZRUQsIG9uSW52YWxpZE9yRGVzdHJveWVkKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgb25SZXN1bWVkID0gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9uQ2xvc2UgPSBldmVudCA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KGV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9uSW52YWxpZE9yRGVzdHJveWVkID0gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbmNlKFNoYXJkRXZlbnRzLlJFQURZLCBvblJlYWR5KTtcbiAgICAgIHRoaXMub25jZShTaGFyZEV2ZW50cy5SRVNVTUVELCBvblJlc3VtZWQpO1xuICAgICAgdGhpcy5vbmNlKFNoYXJkRXZlbnRzLkNMT1NFLCBvbkNsb3NlKTtcbiAgICAgIHRoaXMub25jZShTaGFyZEV2ZW50cy5JTlZBTElEX1NFU1NJT04sIG9uSW52YWxpZE9yRGVzdHJveWVkKTtcbiAgICAgIHRoaXMub25jZShTaGFyZEV2ZW50cy5ERVNUUk9ZRUQsIG9uSW52YWxpZE9yRGVzdHJveWVkKTtcblxuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnQW4gb3BlbiBjb25uZWN0aW9uIHdhcyBmb3VuZCwgYXR0ZW1wdGluZyBhbiBpbW1lZGlhdGUgaWRlbnRpZnkuJyk7XG4gICAgICAgIHRoaXMuaWRlbnRpZnkoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZGVidWcoYEEgY29ubmVjdGlvbiBvYmplY3Qgd2FzIGZvdW5kLiBDbGVhbmluZyB1cCBiZWZvcmUgY29udGludWluZy5cbiAgICBTdGF0ZTogJHtDT05ORUNUSU9OX1NUQVRFW3RoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlXX1gKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KHsgZW1pdDogZmFsc2UgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdzUXVlcnkgPSB7IHY6IGNsaWVudC5vcHRpb25zLndzLnZlcnNpb24gfTtcblxuICAgICAgaWYgKHpsaWIpIHtcbiAgICAgICAgdGhpcy5pbmZsYXRlID0gbmV3IHpsaWIuSW5mbGF0ZSh7XG4gICAgICAgICAgY2h1bmtTaXplOiA2NTUzNSxcbiAgICAgICAgICBmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXG4gICAgICAgICAgdG86IFdlYlNvY2tldC5lbmNvZGluZyA9PT0gJ2pzb24nID8gJ3N0cmluZycgOiAnJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHdzUXVlcnkuY29tcHJlc3MgPSAnemxpYi1zdHJlYW0nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlYnVnKFxuICAgICAgICBgW0NPTk5FQ1RdXG4gICAgR2F0ZXdheSAgICA6ICR7Z2F0ZXdheX1cbiAgICBWZXJzaW9uICAgIDogJHtjbGllbnQub3B0aW9ucy53cy52ZXJzaW9ufVxuICAgIEVuY29kaW5nICAgOiAke1dlYlNvY2tldC5lbmNvZGluZ31cbiAgICBDb21wcmVzc2lvbjogJHt6bGliID8gJ3psaWItc3RyZWFtJyA6ICdub25lJ31gLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCA/IFN0YXR1cy5SRUNPTk5FQ1RJTkcgOiBTdGF0dXMuQ09OTkVDVElORztcbiAgICAgIHRoaXMuc2V0SGVsbG9UaW1lb3V0KCk7XG5cbiAgICAgIHRoaXMuY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuXG4gICAgICBjb25zdCB3cyA9ICh0aGlzLmNvbm5lY3Rpb24gPSBXZWJTb2NrZXQuY3JlYXRlKGdhdGV3YXksIHdzUXVlcnkpKTtcbiAgICAgIHdzLm9ub3BlbiA9IHRoaXMub25PcGVuLmJpbmQodGhpcyk7XG4gICAgICB3cy5vbm1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgd3Mub25lcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xuICAgICAgd3Mub25jbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuZXZlciBhIGNvbm5lY3Rpb24gaXMgb3BlbmVkIHRvIHRoZSBnYXRld2F5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25PcGVuKCkge1xuICAgIHRoaXMuZGVidWcoYFtDT05ORUNURURdICR7dGhpcy5jb25uZWN0aW9uLnVybH0gaW4gJHtEYXRlLm5vdygpIC0gdGhpcy5jb25uZWN0ZWRBdH1tc2ApO1xuICAgIHRoaXMuc3RhdHVzID0gU3RhdHVzLk5FQVJMWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnQgRXZlbnQgcmVjZWl2ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTWVzc2FnZSh7IGRhdGEgfSkge1xuICAgIGxldCByYXc7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIGlmICh6bGliKSB7XG4gICAgICBjb25zdCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICBjb25zdCBmbHVzaCA9XG4gICAgICAgIGwgPj0gNCAmJiBkYXRhW2wgLSA0XSA9PT0gMHgwMCAmJiBkYXRhW2wgLSAzXSA9PT0gMHgwMCAmJiBkYXRhW2wgLSAyXSA9PT0gMHhmZiAmJiBkYXRhW2wgLSAxXSA9PT0gMHhmZjtcblxuICAgICAgdGhpcy5pbmZsYXRlLnB1c2goZGF0YSwgZmx1c2ggJiYgemxpYi5aX1NZTkNfRkxVU0gpO1xuICAgICAgaWYgKCFmbHVzaCkgcmV0dXJuO1xuICAgICAgcmF3ID0gdGhpcy5pbmZsYXRlLnJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3ID0gZGF0YTtcbiAgICB9XG4gICAgbGV0IHBhY2tldDtcbiAgICB0cnkge1xuICAgICAgcGFja2V0ID0gV2ViU29ja2V0LnVucGFjayhyYXcpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmNsaWVudC5lbWl0KEV2ZW50cy5SQVcsIHBhY2tldCwgdGhpcy5pZCk7XG4gICAgICBpZiAocGFja2V0Lm9wID09PSBPUENvZGVzLkRJU1BBVENIKSB0aGlzLm1hbmFnZXIuZW1pdChwYWNrZXQudCwgcGFja2V0LmQsIHRoaXMuaWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5tYW5hZ2VyLmNsaWVudC5lbWl0KEV2ZW50cy5TSEFSRF9FUlJPUiwgZXJyLCB0aGlzLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuZXZlciBhbiBlcnJvciBvY2N1cnMgd2l0aCB0aGUgV2ViU29ja2V0LlxuICAgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50IFRoZSBlcnJvciB0aGF0IG9jY3VycmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkVycm9yKGV2ZW50KSB7XG4gICAgY29uc3QgZXJyb3IgPSBldmVudCAmJiBldmVudC5lcnJvciA/IGV2ZW50LmVycm9yIDogZXZlbnQ7XG4gICAgaWYgKCFlcnJvcikgcmV0dXJuO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuZXZlciBhIHNoYXJkJ3MgV2ViU29ja2V0IGVuY291bnRlcnMgYSBjb25uZWN0aW9uIGVycm9yLlxuICAgICAqIEBldmVudCBDbGllbnQjc2hhcmRFcnJvclxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlbmNvdW50ZXJlZCBlcnJvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaGFyZElEIFRoZSBzaGFyZCB0aGF0IGVuY291bnRlcmVkIHRoaXMgZXJyb3JcbiAgICAgKi9cbiAgICB0aGlzLm1hbmFnZXIuY2xpZW50LmVtaXQoRXZlbnRzLlNIQVJEX0VSUk9SLCBlcnJvciwgdGhpcy5pZCk7XG4gIH1cblxuICAvKipcbiAgICogQGV4dGVybmFsIENsb3NlRXZlbnRcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnR9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXh0ZXJuYWwgRXJyb3JFdmVudFxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXJyb3JFdmVudH1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBleHRlcm5hbCBNZXNzYWdlRXZlbnRcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lc3NhZ2VFdmVudH1cbiAgICovXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuZXZlciBhIGNvbm5lY3Rpb24gdG8gdGhlIGdhdGV3YXkgaXMgY2xvc2VkLlxuICAgKiBAcGFyYW0ge0Nsb3NlRXZlbnR9IGV2ZW50IENsb3NlIGV2ZW50IHRoYXQgd2FzIHJlY2VpdmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkNsb3NlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc2VxdWVuY2UgIT09IC0xKSB0aGlzLmNsb3NlU2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlO1xuICAgIHRoaXMuc2VxdWVuY2UgPSAtMTtcblxuICAgIHRoaXMuZGVidWcoYFtDTE9TRV1cbiAgICBFdmVudCBDb2RlOiAke2V2ZW50LmNvZGV9XG4gICAgQ2xlYW4gICAgIDogJHtldmVudC53YXNDbGVhbn1cbiAgICBSZWFzb24gICAgOiAke2V2ZW50LnJlYXNvbiB8fCAnTm8gcmVhc29uIHJlY2VpdmVkJ31gKTtcblxuICAgIHRoaXMuc2V0SGVhcnRiZWF0VGltZXIoLTEpO1xuICAgIHRoaXMuc2V0SGVsbG9UaW1lb3V0KC0xKTtcbiAgICAvLyBJZiB3ZSBzdGlsbCBoYXZlIGEgY29ubmVjdGlvbiBvYmplY3QsIGNsZWFuIHVwIGl0cyBsaXN0ZW5lcnNcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB0aGlzLl9jbGVhbnVwQ29ubmVjdGlvbigpO1xuXG4gICAgdGhpcy5zdGF0dXMgPSBTdGF0dXMuRElTQ09OTkVDVEVEO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgc2hhcmQncyBXZWJTb2NrZXQgY2xvc2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGV2ZW50IFdlYlNvY2tldFNoYXJkI2Nsb3NlXG4gICAgICogQHBhcmFtIHtDbG9zZUV2ZW50fSBldmVudCBUaGUgcmVjZWl2ZWQgZXZlbnRcbiAgICAgKi9cbiAgICB0aGlzLmVtaXQoU2hhcmRFdmVudHMuQ0xPU0UsIGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBwYWNrZXQgaXMgcmVjZWl2ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgVGhlIHJlY2VpdmVkIHBhY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25QYWNrZXQocGFja2V0KSB7XG4gICAgaWYgKCFwYWNrZXQpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlY2VpdmVkIGJyb2tlbiBwYWNrZXQ6ICcke3BhY2tldH0nLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAocGFja2V0LnQpIHtcbiAgICAgIGNhc2UgV1NFdmVudHMuUkVBRFk6XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIHNoYXJkIHJlY2VpdmVzIHRoZSBSRUFEWSBwYXlsb2FkIGFuZCBpcyBub3cgd2FpdGluZyBmb3IgZ3VpbGRzXG4gICAgICAgICAqIEBldmVudCBXZWJTb2NrZXRTaGFyZCNyZWFkeVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KFNoYXJkRXZlbnRzLlJFQURZKTtcblxuICAgICAgICB0aGlzLnNlc3Npb25JRCA9IHBhY2tldC5kLnNlc3Npb25faWQ7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRHdWlsZHMgPSBuZXcgU2V0KHBhY2tldC5kLmd1aWxkcy5tYXAoZCA9PiBkLmlkKSk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gU3RhdHVzLldBSVRJTkdfRk9SX0dVSUxEUztcbiAgICAgICAgdGhpcy5kZWJ1ZyhgW1JFQURZXSBTZXNzaW9uICR7dGhpcy5zZXNzaW9uSUR9LmApO1xuICAgICAgICB0aGlzLmxhc3RIZWFydGJlYXRBY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VuZEhlYXJ0YmVhdCgnUmVhZHlIZWFydGJlYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdTRXZlbnRzLlJFU1VNRUQ6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgc2hhcmQgcmVzdW1lcyBzdWNjZXNzZnVsbHlcbiAgICAgICAgICogQGV2ZW50IFdlYlNvY2tldFNoYXJkI3Jlc3VtZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdChTaGFyZEV2ZW50cy5SRVNVTUVEKTtcblxuICAgICAgICB0aGlzLnN0YXR1cyA9IFN0YXR1cy5SRUFEWTtcbiAgICAgICAgY29uc3QgcmVwbGF5ZWQgPSBwYWNrZXQucyAtIHRoaXMuY2xvc2VTZXF1ZW5jZTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgW1JFU1VNRURdIFNlc3Npb24gJHt0aGlzLnNlc3Npb25JRH0gfCBSZXBsYXllZCAke3JlcGxheWVkfSBldmVudHMuYCk7XG4gICAgICAgIHRoaXMubGFzdEhlYXJ0YmVhdEFja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZW5kSGVhcnRiZWF0KCdSZXN1bWVIZWFydGJlYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhY2tldC5zID4gdGhpcy5zZXF1ZW5jZSkgdGhpcy5zZXF1ZW5jZSA9IHBhY2tldC5zO1xuXG4gICAgc3dpdGNoIChwYWNrZXQub3ApIHtcbiAgICAgIGNhc2UgT1BDb2Rlcy5IRUxMTzpcbiAgICAgICAgdGhpcy5zZXRIZWxsb1RpbWVvdXQoLTEpO1xuICAgICAgICB0aGlzLnNldEhlYXJ0YmVhdFRpbWVyKHBhY2tldC5kLmhlYXJ0YmVhdF9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuaWRlbnRpZnkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE9QQ29kZXMuUkVDT05ORUNUOlxuICAgICAgICB0aGlzLmRlYnVnKCdbUkVDT05ORUNUXSBEaXNjb3JkIGFza2VkIHVzIHRvIHJlY29ubmVjdCcpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koeyBjbG9zZUNvZGU6IDQwMDAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPUENvZGVzLklOVkFMSURfU0VTU0lPTjpcbiAgICAgICAgdGhpcy5kZWJ1ZyhgW0lOVkFMSUQgU0VTU0lPTl0gUmVzdW1hYmxlOiAke3BhY2tldC5kfS5gKTtcbiAgICAgICAgLy8gSWYgd2UgY2FuIHJlc3VtZSB0aGUgc2Vzc2lvbiwgZG8gc28gaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKHBhY2tldC5kKSB7XG4gICAgICAgICAgdGhpcy5pZGVudGlmeVJlc3VtZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgc2VxdWVuY2VcbiAgICAgICAgdGhpcy5zZXF1ZW5jZSA9IC0xO1xuICAgICAgICAvLyBSZXNldCB0aGUgc2Vzc2lvbiBJRCBhcyBpdCdzIGludmFsaWRcbiAgICAgICAgdGhpcy5zZXNzaW9uSUQgPSBudWxsO1xuICAgICAgICAvLyBTZXQgdGhlIHN0YXR1cyB0byByZWNvbm5lY3RpbmdcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBTdGF0dXMuUkVDT05ORUNUSU5HO1xuICAgICAgICAvLyBGaW5hbGx5LCBlbWl0IHRoZSBJTlZBTElEX1NFU1NJT04gZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KFNoYXJkRXZlbnRzLklOVkFMSURfU0VTU0lPTik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPUENvZGVzLkhFQVJUQkVBVF9BQ0s6XG4gICAgICAgIHRoaXMuYWNrSGVhcnRiZWF0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPUENvZGVzLkhFQVJUQkVBVDpcbiAgICAgICAgdGhpcy5zZW5kSGVhcnRiZWF0KCdIZWFydGJlYXRSZXF1ZXN0JywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmhhbmRsZVBhY2tldChwYWNrZXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFN0YXR1cy5XQUlUSU5HX0ZPUl9HVUlMRFMgJiYgcGFja2V0LnQgPT09IFdTRXZlbnRzLkdVSUxEX0NSRUFURSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0ZWRHdWlsZHMuZGVsZXRlKHBhY2tldC5kLmlkKTtcbiAgICAgICAgICB0aGlzLmNoZWNrUmVhZHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHNoYXJkIGNhbiBiZSBtYXJrZWQgYXMgcmVhZHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrUmVhZHkoKSB7XG4gICAgLy8gU3RlcCAwLiBDbGVhciB0aGUgcmVhZHkgdGltZW91dCwgaWYgaXQgZXhpc3RzXG4gICAgaWYgKHRoaXMucmVhZHlUaW1lb3V0KSB7XG4gICAgICB0aGlzLm1hbmFnZXIuY2xpZW50LmNsZWFyVGltZW91dCh0aGlzLnJlYWR5VGltZW91dCk7XG4gICAgICB0aGlzLnJlYWR5VGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIC8vIFN0ZXAgMS4gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgb3RoZXIgZ3VpbGRzIHBlbmRpbmcsIHdlIGFyZSByZWFkeVxuICAgIGlmICghdGhpcy5leHBlY3RlZEd1aWxkcy5zaXplKSB7XG4gICAgICB0aGlzLmRlYnVnKCdTaGFyZCByZWNlaXZlZCBhbGwgaXRzIGd1aWxkcy4gTWFya2luZyBhcyBmdWxseSByZWFkeS4nKTtcbiAgICAgIHRoaXMuc3RhdHVzID0gU3RhdHVzLlJFQURZO1xuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgc2hhcmQgaXMgZnVsbHkgcmVhZHkuXG4gICAgICAgKiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgaWY6XG4gICAgICAgKiAqIGFsbCBndWlsZHMgd2VyZSByZWNlaXZlZCBieSB0aGlzIHNoYXJkXG4gICAgICAgKiAqIHRoZSByZWFkeSB0aW1lb3V0IGV4cGlyZWQsIGFuZCBzb21lIGd1aWxkcyBhcmUgdW5hdmFpbGFibGVcbiAgICAgICAqIEBldmVudCBXZWJTb2NrZXRTaGFyZCNhbGxSZWFkeVxuICAgICAgICogQHBhcmFtIHs/U2V0PHN0cmluZz59IHVuYXZhaWxhYmxlR3VpbGRzIFNldCBvZiB1bmF2YWlsYWJsZSBndWlsZHMsIGlmIGFueVxuICAgICAgICovXG4gICAgICB0aGlzLmVtaXQoU2hhcmRFdmVudHMuQUxMX1JFQURZKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3RlcCAyLiBDcmVhdGUgYSAxNXMgdGltZW91dCB0aGF0IHdpbGwgbWFyayB0aGUgc2hhcmQgYXMgcmVhZHkgaWYgdGhlcmUgYXJlIHN0aWxsIHVuYXZhaWxhYmxlIGd1aWxkc1xuICAgIHRoaXMucmVhZHlUaW1lb3V0ID0gdGhpcy5tYW5hZ2VyLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGVidWcoYFNoYXJkIGRpZCBub3QgcmVjZWl2ZSBhbnkgbW9yZSBndWlsZCBwYWNrZXRzIGluIDE1IHNlY29uZHMuXG4gIFVuYXZhaWxhYmxlIGd1aWxkIGNvdW50OiAke3RoaXMuZXhwZWN0ZWRHdWlsZHMuc2l6ZX1gKTtcblxuICAgICAgdGhpcy5yZWFkeVRpbWVvdXQgPSBudWxsO1xuXG4gICAgICB0aGlzLnN0YXR1cyA9IFN0YXR1cy5SRUFEWTtcblxuICAgICAgdGhpcy5lbWl0KFNoYXJkRXZlbnRzLkFMTF9SRUFEWSwgdGhpcy5leHBlY3RlZEd1aWxkcyk7XG4gICAgfSwgMTUwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIEhFTExPIHBhY2tldCB0aW1lb3V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVdIElmIHNldCB0byAtMSwgaXQgd2lsbCBjbGVhciB0aGUgaGVsbG8gdGltZW91dCB0aW1lb3V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRIZWxsb1RpbWVvdXQodGltZSkge1xuICAgIGlmICh0aW1lID09PSAtMSkge1xuICAgICAgaWYgKHRoaXMuaGVsbG9UaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZGVidWcoJ0NsZWFyaW5nIHRoZSBIRUxMTyB0aW1lb3V0LicpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuY2xpZW50LmNsZWFyVGltZW91dCh0aGlzLmhlbGxvVGltZW91dCk7XG4gICAgICAgIHRoaXMuaGVsbG9UaW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZygnU2V0dGluZyBhIEhFTExPIHRpbWVvdXQgZm9yIDIwcy4nKTtcbiAgICB0aGlzLmhlbGxvVGltZW91dCA9IHRoaXMubWFuYWdlci5jbGllbnQuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKCdEaWQgbm90IHJlY2VpdmUgSEVMTE8gaW4gdGltZS4gRGVzdHJveWluZyBhbmQgY29ubmVjdGluZyBhZ2Fpbi4nKTtcbiAgICAgIHRoaXMuZGVzdHJveSh7IHJlc2V0OiB0cnVlLCBjbG9zZUNvZGU6IDQwMDkgfSk7XG4gICAgfSwgMjAwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhlYXJ0YmVhdCB0aW1lciBmb3IgdGhpcyBzaGFyZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgSWYgLTEsIGNsZWFycyB0aGUgaW50ZXJ2YWwsIGFueSBvdGhlciBudW1iZXIgc2V0cyBhbiBpbnRlcnZhbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0SGVhcnRiZWF0VGltZXIodGltZSkge1xuICAgIGlmICh0aW1lID09PSAtMSkge1xuICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnQ2xlYXJpbmcgdGhlIGhlYXJ0YmVhdCBpbnRlcnZhbC4nKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmNsaWVudC5jbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhgU2V0dGluZyBhIGhlYXJ0YmVhdCBpbnRlcnZhbCBmb3IgJHt0aW1lfW1zLmApO1xuICAgIC8vIFNhbml0eSBjaGVja3NcbiAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbCkgdGhpcy5tYW5hZ2VyLmNsaWVudC5jbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwgPSB0aGlzLm1hbmFnZXIuY2xpZW50LnNldEludGVydmFsKCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGhlYXJ0YmVhdCB0byB0aGUgV2ViU29ja2V0LlxuICAgKiBJZiB0aGlzIHNoYXJkIGRpZG4ndCByZWNlaXZlIGEgaGVhcnRiZWF0IGxhc3QgdGltZSwgaXQgd2lsbCBkZXN0cm95IGl0IGFuZCByZWNvbm5lY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWc9J0hlYXJ0YmVhdFRpbWVyJ10gV2hhdCBjYXVzZWQgdGhpcyBoZWFydGJlYXQgdG8gYmUgc2VudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVIZWFydGJlYXRBY2tdIElmIHdlIHNob3VsZCBzZW5kIHRoZSBoZWFydGJlYXQgZm9yY2VmdWxseS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRIZWFydGJlYXQoXG4gICAgdGFnID0gJ0hlYXJ0YmVhdFRpbWVyJyxcbiAgICBpZ25vcmVIZWFydGJlYXRBY2sgPSBbU3RhdHVzLldBSVRJTkdfRk9SX0dVSUxEUywgU3RhdHVzLklERU5USUZZSU5HLCBTdGF0dXMuUkVTVU1JTkddLmluY2x1ZGVzKHRoaXMuc3RhdHVzKSxcbiAgKSB7XG4gICAgaWYgKGlnbm9yZUhlYXJ0YmVhdEFjayAmJiAhdGhpcy5sYXN0SGVhcnRiZWF0QWNrZWQpIHtcbiAgICAgIHRoaXMuZGVidWcoYFske3RhZ31dIERpZG4ndCBwcm9jZXNzIGhlYXJ0YmVhdCBhY2sgeWV0IGJ1dCB3ZSBhcmUgc3RpbGwgY29ubmVjdGVkLiBTZW5kaW5nIG9uZSBub3cuYCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5sYXN0SGVhcnRiZWF0QWNrZWQpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIGBbJHt0YWd9XSBEaWRuJ3QgcmVjZWl2ZSBhIGhlYXJ0YmVhdCBhY2sgbGFzdCB0aW1lLCBhc3N1bWluZyB6b21iaWUgY29ubmVjdGlvbi4gRGVzdHJveWluZyBhbmQgcmVjb25uZWN0aW5nLlxuICAgIFN0YXR1cyAgICAgICAgICA6ICR7U1RBVFVTX0tFWVNbdGhpcy5zdGF0dXNdfVxuICAgIFNlcXVlbmNlICAgICAgICA6ICR7dGhpcy5zZXF1ZW5jZX1cbiAgICBDb25uZWN0aW9uIFN0YXRlOiAke3RoaXMuY29ubmVjdGlvbiA/IENPTk5FQ1RJT05fU1RBVEVbdGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGVdIDogJ05vIENvbm5lY3Rpb24/Pyd9YCxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuZGVzdHJveSh7IGNsb3NlQ29kZTogNDAwOSwgcmVzZXQ6IHRydWUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZWJ1ZyhgWyR7dGFnfV0gU2VuZGluZyBhIGhlYXJ0YmVhdC5gKTtcbiAgICB0aGlzLmxhc3RIZWFydGJlYXRBY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFBpbmdUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc2VuZCh7IG9wOiBPUENvZGVzLkhFQVJUQkVBVCwgZDogdGhpcy5zZXF1ZW5jZSB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2tub3dsZWRnZXMgYSBoZWFydGJlYXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2tIZWFydGJlYXQoKSB7XG4gICAgdGhpcy5sYXN0SGVhcnRiZWF0QWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGxhdGVuY3kgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0UGluZ1RpbWVzdGFtcDtcbiAgICB0aGlzLmRlYnVnKGBIZWFydGJlYXQgYWNrbm93bGVkZ2VkLCBsYXRlbmN5IG9mICR7bGF0ZW5jeX1tcy5gKTtcbiAgICB0aGlzLnBpbmcgPSBsYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXMgdGhlIGNsaWVudCBvbiB0aGUgY29ubmVjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBpZGVudGlmeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uSUQgPyB0aGlzLmlkZW50aWZ5UmVzdW1lKCkgOiB0aGlzLmlkZW50aWZ5TmV3KCk7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllcyBhcyBhIG5ldyBjb25uZWN0aW9uIG9uIHRoZSBnYXRld2F5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaWRlbnRpZnlOZXcoKSB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHRoaXMubWFuYWdlcjtcbiAgICBpZiAoIWNsaWVudC50b2tlbikge1xuICAgICAgdGhpcy5kZWJ1ZygnW0lERU5USUZZXSBObyB0b2tlbiBhdmFpbGFibGUgdG8gaWRlbnRpZnkgYSBuZXcgc2Vzc2lvbi4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXR1cyA9IFN0YXR1cy5JREVOVElGWUlORztcblxuICAgIC8vIENsb25lIHRoZSBpZGVudGlmeSBwYXlsb2FkIGFuZCBhc3NpZ24gdGhlIHRva2VuIGFuZCBzaGFyZCBpbmZvXG4gICAgY29uc3QgZCA9IHtcbiAgICAgIC4uLmNsaWVudC5vcHRpb25zLndzLFxuICAgICAgdG9rZW46IGNsaWVudC50b2tlbixcbiAgICAgIHNoYXJkOiBbdGhpcy5pZCwgTnVtYmVyKGNsaWVudC5vcHRpb25zLnNoYXJkQ291bnQpXSxcbiAgICB9O1xuXG4gICAgdGhpcy5kZWJ1ZyhgW0lERU5USUZZXSBTaGFyZCAke3RoaXMuaWR9LyR7Y2xpZW50Lm9wdGlvbnMuc2hhcmRDb3VudH1gKTtcbiAgICB0aGlzLnNlbmQoeyBvcDogT1BDb2Rlcy5JREVOVElGWSwgZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIGEgc2Vzc2lvbiBvbiB0aGUgZ2F0ZXdheS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlkZW50aWZ5UmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5zZXNzaW9uSUQpIHtcbiAgICAgIHRoaXMuZGVidWcoJ1tSRVNVTUVdIE5vIHNlc3Npb24gSUQgd2FzIHByZXNlbnQ7IGlkZW50aWZ5aW5nIGFzIGEgbmV3IHNlc3Npb24uJyk7XG4gICAgICB0aGlzLmlkZW50aWZ5TmV3KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0dXMgPSBTdGF0dXMuUkVTVU1JTkc7XG5cbiAgICB0aGlzLmRlYnVnKGBbUkVTVU1FXSBTZXNzaW9uICR7dGhpcy5zZXNzaW9uSUR9LCBzZXF1ZW5jZSAke3RoaXMuY2xvc2VTZXF1ZW5jZX1gKTtcblxuICAgIGNvbnN0IGQgPSB7XG4gICAgICB0b2tlbjogdGhpcy5tYW5hZ2VyLmNsaWVudC50b2tlbixcbiAgICAgIHNlc3Npb25faWQ6IHRoaXMuc2Vzc2lvbklELFxuICAgICAgc2VxOiB0aGlzLmNsb3NlU2VxdWVuY2UsXG4gICAgfTtcblxuICAgIHRoaXMuc2VuZCh7IG9wOiBPUENvZGVzLlJFU1VNRSwgZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGFja2V0IHRvIHRoZSBxdWV1ZSB0byBiZSBzZW50IHRvIHRoZSBnYXRld2F5LlxuICAgKiA8d2Fybj5JZiB5b3UgdXNlIHRoaXMgbWV0aG9kLCBtYWtlIHN1cmUgeW91IHVuZGVyc3RhbmQgdGhhdCB5b3UgbmVlZCB0byBwcm92aWRlXG4gICAqIGEgZnVsbCBbUGF5bG9hZF0oaHR0cHM6Ly9kaXNjb3JkLmNvbS9kZXZlbG9wZXJzL2RvY3MvdG9waWNzL2dhdGV3YXkjY29tbWFuZHMtYW5kLWV2ZW50cy1nYXRld2F5LWNvbW1hbmRzKS5cbiAgICogRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiB5b3UgZG9uJ3Qga25vdyB3aGF0IHlvdSdyZSBkb2luZy48L3dhcm4+XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBmdWxsIHBhY2tldCB0byBzZW5kXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltcG9ydGFudD1mYWxzZV0gSWYgdGhpcyBwYWNrZXQgc2hvdWxkIGJlIGFkZGVkIGZpcnN0IGluIHF1ZXVlXG4gICAqL1xuICBzZW5kKGRhdGEsIGltcG9ydGFudCA9IGZhbHNlKSB7XG4gICAgdGhpcy5yYXRlbGltaXQucXVldWVbaW1wb3J0YW50ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShkYXRhKTtcbiAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGRhdGEsIGJ5cGFzc2luZyB0aGUgcXVldWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBhY2tldCB0byBzZW5kXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbmQoZGF0YSkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uIHx8IHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdGhpcy5kZWJ1ZyhgVHJpZWQgdG8gc2VuZCBwYWNrZXQgJyR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9JyBidXQgbm8gV2ViU29ja2V0IGlzIGF2YWlsYWJsZSFgKTtcbiAgICAgIHRoaXMuZGVzdHJveSh7IGNsb3NlOiA0MDAwIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKFdlYlNvY2tldC5wYWNrKGRhdGEpLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgdGhpcy5tYW5hZ2VyLmNsaWVudC5lbWl0KEV2ZW50cy5TSEFSRF9FUlJPUiwgZXJyLCB0aGlzLmlkKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgdGhlIGN1cnJlbnQgV2ViU29ja2V0IHF1ZXVlLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5yYXRlbGltaXQucmVtYWluaW5nID09PSAwKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmF0ZWxpbWl0LnF1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJhdGVsaW1pdC5yZW1haW5pbmcgPT09IHRoaXMucmF0ZWxpbWl0LnRvdGFsKSB7XG4gICAgICB0aGlzLnJhdGVsaW1pdC50aW1lciA9IHRoaXMubWFuYWdlci5jbGllbnQuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMucmF0ZWxpbWl0LnJlbWFpbmluZyA9IHRoaXMucmF0ZWxpbWl0LnRvdGFsO1xuICAgICAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgICAgfSwgdGhpcy5yYXRlbGltaXQudGltZSk7XG4gICAgfVxuICAgIHdoaWxlICh0aGlzLnJhdGVsaW1pdC5yZW1haW5pbmcgPiAwKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5yYXRlbGltaXQucXVldWUuc2hpZnQoKTtcbiAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgdGhpcy5fc2VuZChpdGVtKTtcbiAgICAgIHRoaXMucmF0ZWxpbWl0LnJlbWFpbmluZy0tO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHNoYXJkIGFuZCBjbG9zZXMgaXRzIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9eyBjbG9zZUNvZGU6IDEwMDAsIHJlc2V0OiBmYWxzZSwgZW1pdDogdHJ1ZSwgbG9nOiB0cnVlIH1dIE9wdGlvbnMgZm9yIGRlc3Ryb3lpbmcgdGhlIHNoYXJkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXN0cm95KHsgY2xvc2VDb2RlID0gMTAwMCwgcmVzZXQgPSBmYWxzZSwgZW1pdCA9IHRydWUsIGxvZyA9IHRydWUgfSA9IHt9KSB7XG4gICAgaWYgKGxvZykge1xuICAgICAgdGhpcy5kZWJ1ZyhgW0RFU1RST1ldXG4gICAgQ2xvc2UgQ29kZSAgICA6ICR7Y2xvc2VDb2RlfVxuICAgIFJlc2V0ICAgICAgICAgOiAke3Jlc2V0fVxuICAgIEVtaXQgREVTVFJPWUVEOiAke2VtaXR9YCk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAwOiBSZW1vdmUgYWxsIHRpbWVyc1xuICAgIHRoaXMuc2V0SGVhcnRiZWF0VGltZXIoLTEpO1xuICAgIHRoaXMuc2V0SGVsbG9UaW1lb3V0KC0xKTtcblxuICAgIC8vIFN0ZXAgMTogQ2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLCBpZiBhbnksIG90aGVyd2lzZSwgZW1pdCBERVNUUk9ZRURcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgb3BlbmVkLCB3ZSB3aWxsIChob3BlZnVsbHkpIHJlY2VpdmUgY2xvc2VcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKGNsb3NlQ29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25uZWN0aW9uIGlzIG5vdCBPUEVOXG4gICAgICAgIHRoaXMuZGVidWcoYFdTIFN0YXRlOiAke0NPTk5FQ1RJT05fU1RBVEVbdGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGVdfWApO1xuICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIGZyb20gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgdGhpcy5fY2xlYW51cENvbm5lY3Rpb24oKTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBjbG9zZSB0aGUgY29ubmVjdGlvbiBqdXN0IGluIGNhc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoY2xvc2VDb2RlKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gTm8tb3BcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IHRoZSBkZXN0cm95ZWQgZXZlbnQgaWYgbmVlZGVkXG4gICAgICAgIGlmIChlbWl0KSB0aGlzLl9lbWl0RGVzdHJveWVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbWl0KSB7XG4gICAgICAvLyBXZSByZXF1ZXN0ZWQgYSBkZXN0cm95LCBidXQgd2UgaGFkIG5vIGNvbm5lY3Rpb24uIEVtaXQgZGVzdHJveWVkXG4gICAgICB0aGlzLl9lbWl0RGVzdHJveWVkKCk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAyOiBOdWxsIHRoZSBjb25uZWN0aW9uIG9iamVjdFxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG5cbiAgICAvLyBTdGVwIDM6IFNldCB0aGUgc2hhcmQgc3RhdHVzIHRvIERJU0NPTk5FQ1RFRFxuICAgIHRoaXMuc3RhdHVzID0gU3RhdHVzLkRJU0NPTk5FQ1RFRDtcblxuICAgIC8vIFN0ZXAgNDogQ2FjaGUgdGhlIG9sZCBzZXF1ZW5jZSAodXNlIHRvIGF0dGVtcHQgYSByZXN1bWUpXG4gICAgaWYgKHRoaXMuc2VxdWVuY2UgIT09IC0xKSB0aGlzLmNsb3NlU2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlO1xuXG4gICAgLy8gU3RlcCA1OiBSZXNldCB0aGUgc2VxdWVuY2UgYW5kIHNlc3Npb24gSUQgaWYgcmVxdWVzdGVkXG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICB0aGlzLnNlcXVlbmNlID0gLTE7XG4gICAgICB0aGlzLnNlc3Npb25JRCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3RlcCA2OiByZXNldCB0aGUgcmF0ZWxpbWl0IGRhdGFcbiAgICB0aGlzLnJhdGVsaW1pdC5yZW1haW5pbmcgPSB0aGlzLnJhdGVsaW1pdC50b3RhbDtcbiAgICB0aGlzLnJhdGVsaW1pdC5xdWV1ZS5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLnJhdGVsaW1pdC50aW1lcikge1xuICAgICAgdGhpcy5tYW5hZ2VyLmNsaWVudC5jbGVhclRpbWVvdXQodGhpcy5yYXRlbGltaXQudGltZXIpO1xuICAgICAgdGhpcy5yYXRlbGltaXQudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGxpc3RlbmVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhbnVwQ29ubmVjdGlvbigpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24ub25vcGVuID0gdGhpcy5jb25uZWN0aW9uLm9uY2xvc2UgPSB0aGlzLmNvbm5lY3Rpb24ub25lcnJvciA9IHRoaXMuY29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBERVNUUk9ZRUQgZXZlbnQgb24gdGhlIHNoYXJkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZW1pdERlc3Ryb3llZCgpIHtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYSBzaGFyZCBpcyBkZXN0cm95ZWQsIGJ1dCBubyBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgcHJlc2VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBldmVudCBXZWJTb2NrZXRTaGFyZCNkZXN0cm95ZWRcbiAgICAgKi9cbiAgICB0aGlzLmVtaXQoU2hhcmRFdmVudHMuREVTVFJPWUVEKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNoYXJkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5DaGFubmVsQ3JlYXRlLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5DaGFubmVsRGVsZXRlLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCB7IGQ6IGRhdGEgfSkgPT4ge1xuICBjb25zdCBjaGFubmVsID0gY2xpZW50LmNoYW5uZWxzLmNhY2hlLmdldChkYXRhLmNoYW5uZWxfaWQpO1xuICBjb25zdCB0aW1lID0gbmV3IERhdGUoZGF0YS5sYXN0X3Bpbl90aW1lc3RhbXApO1xuXG4gIGlmIChjaGFubmVsICYmICFOdW1iZXIuaXNOYU4odGltZS5nZXRUaW1lKCkpKSB7XG4gICAgLy8gRGlzY29yZCBzZW5kcyBudWxsIGZvciBsYXN0X3Bpbl90aW1lc3RhbXAgaWYgdGhlIGxhc3QgcGlubmVkIG1lc3NhZ2Ugd2FzIHJlbW92ZWRcbiAgICBjaGFubmVsLmxhc3RQaW5UaW1lc3RhbXAgPSB0aW1lLmdldFRpbWUoKSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuZXZlciB0aGUgcGlucyBvZiBhIGNoYW5uZWwgYXJlIHVwZGF0ZWQuIER1ZSB0byB0aGUgbmF0dXJlIG9mIHRoZSBXZWJTb2NrZXQgZXZlbnQsXG4gICAgICogbm90IG11Y2ggaW5mb3JtYXRpb24gY2FuIGJlIHByb3ZpZGVkIGVhc2lseSBoZXJlIC0geW91IG5lZWQgdG8gbWFudWFsbHkgY2hlY2sgdGhlIHBpbnMgeW91cnNlbGYuXG4gICAgICogQGV2ZW50IENsaWVudCNjaGFubmVsUGluc1VwZGF0ZVxuICAgICAqIEBwYXJhbSB7RE1DaGFubmVsfFRleHRDaGFubmVsfSBjaGFubmVsIFRoZSBjaGFubmVsIHRoYXQgdGhlIHBpbnMgdXBkYXRlIG9jY3VycmVkIGluXG4gICAgICogQHBhcmFtIHtEYXRlfSB0aW1lIFRoZSB0aW1lIG9mIHRoZSBwaW5zIHVwZGF0ZVxuICAgICAqL1xuICAgIGNsaWVudC5lbWl0KEV2ZW50cy5DSEFOTkVMX1BJTlNfVVBEQVRFLCBjaGFubmVsLCB0aW1lKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNvbnN0IHsgb2xkLCB1cGRhdGVkIH0gPSBjbGllbnQuYWN0aW9ucy5DaGFubmVsVXBkYXRlLmhhbmRsZShwYWNrZXQuZCk7XG4gIGlmIChvbGQgJiYgdXBkYXRlZCkge1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBjaGFubmVsIGlzIHVwZGF0ZWQgLSBlLmcuIG5hbWUgY2hhbmdlLCB0b3BpYyBjaGFuZ2UsIGNoYW5uZWwgdHlwZSBjaGFuZ2UuXG4gICAgICogQGV2ZW50IENsaWVudCNjaGFubmVsVXBkYXRlXG4gICAgICogQHBhcmFtIHtETUNoYW5uZWx8R3VpbGRDaGFubmVsfSBvbGRDaGFubmVsIFRoZSBjaGFubmVsIGJlZm9yZSB0aGUgdXBkYXRlXG4gICAgICogQHBhcmFtIHtETUNoYW5uZWx8R3VpbGRDaGFubmVsfSBuZXdDaGFubmVsIFRoZSBjaGFubmVsIGFmdGVyIHRoZSB1cGRhdGVcbiAgICAgKi9cbiAgICBjbGllbnQuZW1pdChFdmVudHMuQ0hBTk5FTF9VUERBVEUsIG9sZCwgdXBkYXRlZCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHsgZDogZGF0YSB9KSA9PiB7XG4gIGNvbnN0IGd1aWxkID0gY2xpZW50Lmd1aWxkcy5jYWNoZS5nZXQoZGF0YS5ndWlsZF9pZCk7XG4gIGNvbnN0IHVzZXIgPSBjbGllbnQudXNlcnMuYWRkKGRhdGEudXNlcik7XG5cbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBtZW1iZXIgaXMgYmFubmVkIGZyb20gYSBndWlsZC5cbiAgICogQGV2ZW50IENsaWVudCNndWlsZEJhbkFkZFxuICAgKiBAcGFyYW0ge0d1aWxkfSBndWlsZCBUaGUgZ3VpbGQgdGhhdCB0aGUgYmFuIG9jY3VycmVkIGluXG4gICAqIEBwYXJhbSB7VXNlcn0gdXNlciBUaGUgdXNlciB0aGF0IHdhcyBiYW5uZWRcbiAgICovXG4gIGlmIChndWlsZCAmJiB1c2VyKSBjbGllbnQuZW1pdChFdmVudHMuR1VJTERfQkFOX0FERCwgZ3VpbGQsIHVzZXIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCBwYWNrZXQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuR3VpbGRCYW5SZW1vdmUuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRXZlbnRzLCBTdGF0dXMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKGNsaWVudCwgeyBkOiBkYXRhIH0sIHNoYXJkKSA9PiB7XG4gIGxldCBndWlsZCA9IGNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KGRhdGEuaWQpO1xuICBpZiAoZ3VpbGQpIHtcbiAgICBpZiAoIWd1aWxkLmF2YWlsYWJsZSAmJiAhZGF0YS51bmF2YWlsYWJsZSkge1xuICAgICAgLy8gQSBuZXdseSBhdmFpbGFibGUgZ3VpbGRcbiAgICAgIGd1aWxkLl9wYXRjaChkYXRhKTtcbiAgICAgIC8vIElmIHRoZSBjbGllbnQgd2FzIHJlYWR5IGJlZm9yZSBhbmQgd2UgaGFkIHVuYXZhaWxhYmxlIGd1aWxkcywgZmV0Y2ggdGhlbVxuICAgICAgaWYgKGNsaWVudC53cy5zdGF0dXMgPT09IFN0YXR1cy5SRUFEWSAmJiBjbGllbnQub3B0aW9ucy5mZXRjaEFsbE1lbWJlcnMpIHtcbiAgICAgICAgYXdhaXQgZ3VpbGQubWVtYmVyc1xuICAgICAgICAgIC5mZXRjaCgpXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiBjbGllbnQuZW1pdChFdmVudHMuREVCVUcsIGBGYWlsZWQgdG8gZmV0Y2ggYWxsIG1lbWJlcnM6ICR7ZXJyfVxcbiR7ZXJyLnN0YWNrfWApKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQSBuZXcgZ3VpbGRcbiAgICBkYXRhLnNoYXJkSUQgPSBzaGFyZC5pZDtcbiAgICBndWlsZCA9IGNsaWVudC5ndWlsZHMuYWRkKGRhdGEpO1xuICAgIGlmIChjbGllbnQud3Muc3RhdHVzID09PSBTdGF0dXMuUkVBRFkpIHtcbiAgICAgIC8qKlxuICAgICAgICogRW1pdHRlZCB3aGVuZXZlciB0aGUgY2xpZW50IGpvaW5zIGEgZ3VpbGQuXG4gICAgICAgKiBAZXZlbnQgQ2xpZW50I2d1aWxkQ3JlYXRlXG4gICAgICAgKiBAcGFyYW0ge0d1aWxkfSBndWlsZCBUaGUgY3JlYXRlZCBndWlsZFxuICAgICAgICovXG4gICAgICBpZiAoY2xpZW50Lm9wdGlvbnMuZmV0Y2hBbGxNZW1iZXJzKSB7XG4gICAgICAgIGF3YWl0IGd1aWxkLm1lbWJlcnNcbiAgICAgICAgICAuZmV0Y2goKVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4gY2xpZW50LmVtaXQoRXZlbnRzLkRFQlVHLCBgRmFpbGVkIHRvIGZldGNoIGFsbCBtZW1iZXJzOiAke2Vycn1cXG4ke2Vyci5zdGFja31gKSk7XG4gICAgICB9XG4gICAgICBjbGllbnQuZW1pdChFdmVudHMuR1VJTERfQ1JFQVRFLCBndWlsZCk7XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5HdWlsZERlbGV0ZS5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCBwYWNrZXQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuR3VpbGRFbW9qaXNVcGRhdGUuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLkd1aWxkSW50ZWdyYXRpb25zVXBkYXRlLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9Db2xsZWN0aW9uJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCB7IGQ6IGRhdGEgfSkgPT4ge1xuICBjb25zdCBndWlsZCA9IGNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KGRhdGEuZ3VpbGRfaWQpO1xuICBpZiAoIWd1aWxkKSByZXR1cm47XG4gIGNvbnN0IG1lbWJlcnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIGRhdGEubWVtYmVycykgbWVtYmVycy5zZXQobWVtYmVyLnVzZXIuaWQsIGd1aWxkLm1lbWJlcnMuYWRkKG1lbWJlcikpO1xuICBpZiAoZGF0YS5wcmVzZW5jZXMpIHtcbiAgICBmb3IgKGNvbnN0IHByZXNlbmNlIG9mIGRhdGEucHJlc2VuY2VzKSBndWlsZC5wcmVzZW5jZXMuYWRkKE9iamVjdC5hc3NpZ24ocHJlc2VuY2UsIHsgZ3VpbGQgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgY2h1bmsgb2YgZ3VpbGQgbWVtYmVycyBpcyByZWNlaXZlZCAoYWxsIG1lbWJlcnMgY29tZSBmcm9tIHRoZSBzYW1lIGd1aWxkKS5cbiAgICogQGV2ZW50IENsaWVudCNndWlsZE1lbWJlcnNDaHVua1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBHdWlsZE1lbWJlcj59IG1lbWJlcnMgVGhlIG1lbWJlcnMgaW4gdGhlIGNodW5rXG4gICAqIEBwYXJhbSB7R3VpbGR9IGd1aWxkIFRoZSBndWlsZCByZWxhdGVkIHRvIHRoZSBtZW1iZXIgY2h1bmtcbiAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIFByb3BlcnRpZXMgb2YgdGhlIHJlY2VpdmVkIGNodW5rXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVuay5pbmRleCBJbmRleCBvZiB0aGUgcmVjZWl2ZWQgY2h1bmtcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNodW5rLmNvdW50IE51bWJlciBvZiBjaHVua3MgdGhlIGNsaWVudCBzaG91bGQgcmVjZWl2ZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNodW5rLm5vbmNlIE5vbmNlIGZvciB0aGlzIGNodW5rXG4gICAqL1xuICBjbGllbnQuZW1pdChFdmVudHMuR1VJTERfTUVNQkVSU19DSFVOSywgbWVtYmVycywgZ3VpbGQsIHtcbiAgICBjb3VudDogZGF0YS5jaHVua19jb3VudCxcbiAgICBpbmRleDogZGF0YS5jaHVua19pbmRleCxcbiAgICBub25jZTogZGF0YS5ub25jZSxcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEV2ZW50cywgU3RhdHVzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHsgZDogZGF0YSB9LCBzaGFyZCkgPT4ge1xuICBjb25zdCBndWlsZCA9IGNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KGRhdGEuZ3VpbGRfaWQpO1xuICBpZiAoZ3VpbGQpIHtcbiAgICBndWlsZC5tZW1iZXJDb3VudCsrO1xuICAgIGNvbnN0IG1lbWJlciA9IGd1aWxkLm1lbWJlcnMuYWRkKGRhdGEpO1xuICAgIGlmIChzaGFyZC5zdGF0dXMgPT09IFN0YXR1cy5SRUFEWSkge1xuICAgICAgLyoqXG4gICAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgdXNlciBqb2lucyBhIGd1aWxkLlxuICAgICAgICogQGV2ZW50IENsaWVudCNndWlsZE1lbWJlckFkZFxuICAgICAgICogQHBhcmFtIHtHdWlsZE1lbWJlcn0gbWVtYmVyIFRoZSBtZW1iZXIgdGhhdCBoYXMgam9pbmVkIGEgZ3VpbGRcbiAgICAgICAqL1xuICAgICAgY2xpZW50LmVtaXQoRXZlbnRzLkdVSUxEX01FTUJFUl9BREQsIG1lbWJlcik7XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCwgc2hhcmQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuR3VpbGRNZW1iZXJSZW1vdmUuaGFuZGxlKHBhY2tldC5kLCBzaGFyZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCwgc2hhcmQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuR3VpbGRNZW1iZXJVcGRhdGUuaGFuZGxlKHBhY2tldC5kLCBzaGFyZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5HdWlsZFJvbGVDcmVhdGUuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLkd1aWxkUm9sZURlbGV0ZS5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCBwYWNrZXQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuR3VpbGRSb2xlVXBkYXRlLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5HdWlsZFVwZGF0ZS5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCBwYWNrZXQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuSW52aXRlQ3JlYXRlLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5JbnZpdGVEZWxldGUuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLk1lc3NhZ2VDcmVhdGUuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLk1lc3NhZ2VEZWxldGUuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLk1lc3NhZ2VEZWxldGVCdWxrLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5NZXNzYWdlUmVhY3Rpb25BZGQuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLk1lc3NhZ2VSZWFjdGlvblJlbW92ZS5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCBwYWNrZXQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuTWVzc2FnZVJlYWN0aW9uUmVtb3ZlQWxsLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5NZXNzYWdlUmVhY3Rpb25SZW1vdmVFbW9qaS5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNvbnN0IHsgb2xkLCB1cGRhdGVkIH0gPSBjbGllbnQuYWN0aW9ucy5NZXNzYWdlVXBkYXRlLmhhbmRsZShwYWNrZXQuZCk7XG4gIGlmIChvbGQgJiYgdXBkYXRlZCkge1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHVwZGF0ZWQgLSBlLmcuIGVtYmVkIG9yIGNvbnRlbnQgY2hhbmdlLlxuICAgICAqIEBldmVudCBDbGllbnQjbWVzc2FnZVVwZGF0ZVxuICAgICAqIEBwYXJhbSB7TWVzc2FnZX0gb2xkTWVzc2FnZSBUaGUgbWVzc2FnZSBiZWZvcmUgdGhlIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7TWVzc2FnZX0gbmV3TWVzc2FnZSBUaGUgbWVzc2FnZSBhZnRlciB0aGUgdXBkYXRlXG4gICAgICovXG4gICAgY2xpZW50LmVtaXQoRXZlbnRzLk1FU1NBR0VfVVBEQVRFLCBvbGQsIHVwZGF0ZWQpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5QcmVzZW5jZVVwZGF0ZS5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubGV0IENsaWVudFVzZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgeyBkOiBkYXRhIH0sIHNoYXJkKSA9PiB7XG4gIGlmIChjbGllbnQudXNlcikge1xuICAgIGNsaWVudC51c2VyLl9wYXRjaChkYXRhLnVzZXIpO1xuICB9IGVsc2Uge1xuICAgIGlmICghQ2xpZW50VXNlcikgQ2xpZW50VXNlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3N0cnVjdHVyZXMvQ2xpZW50VXNlcicpO1xuICAgIGNvbnN0IGNsaWVudFVzZXIgPSBuZXcgQ2xpZW50VXNlcihjbGllbnQsIGRhdGEudXNlcik7XG4gICAgY2xpZW50LnVzZXIgPSBjbGllbnRVc2VyO1xuICAgIGNsaWVudC51c2Vycy5jYWNoZS5zZXQoY2xpZW50VXNlci5pZCwgY2xpZW50VXNlcik7XG4gIH1cblxuICBmb3IgKGNvbnN0IGd1aWxkIG9mIGRhdGEuZ3VpbGRzKSB7XG4gICAgZ3VpbGQuc2hhcmRJRCA9IHNoYXJkLmlkO1xuICAgIGNsaWVudC5ndWlsZHMuYWRkKGd1aWxkKTtcbiAgfVxuXG4gIHNoYXJkLmNoZWNrUmVhZHkoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCwgc2hhcmQpID0+IHtcbiAgY29uc3QgcmVwbGF5ZWQgPSBzaGFyZC5zZXF1ZW5jZSAtIHNoYXJkLmNsb3NlU2VxdWVuY2U7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gYSBzaGFyZCByZXN1bWVzIHN1Y2Nlc3NmdWxseS5cbiAgICogQGV2ZW50IENsaWVudCNzaGFyZFJlc3VtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIHNoYXJkIElEIHRoYXQgcmVzdW1lZFxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVwbGF5ZWRFdmVudHMgVGhlIGFtb3VudCBvZiByZXBsYXllZCBldmVudHNcbiAgICovXG4gIGNsaWVudC5lbWl0KEV2ZW50cy5TSEFSRF9SRVNVTUUsIHNoYXJkLmlkLCByZXBsYXllZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjbGllbnQsIHBhY2tldCkgPT4ge1xuICBjbGllbnQuYWN0aW9ucy5UeXBpbmdTdGFydC5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCBwYWNrZXQpID0+IHtcbiAgY2xpZW50LmFjdGlvbnMuVXNlclVwZGF0ZS5oYW5kbGUocGFja2V0LmQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoY2xpZW50LCBwYWNrZXQpID0+IHtcbiAgY2xpZW50LmVtaXQoJ2RlYnVnJywgYFtWT0lDRV0gcmVjZWl2ZWQgdm9pY2Ugc2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHBhY2tldCl9YCk7XG4gIGNsaWVudC52b2ljZS5vblZvaWNlU2VydmVyKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLlZvaWNlU3RhdGVVcGRhdGUuaGFuZGxlKHBhY2tldC5kKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGNsaWVudCwgcGFja2V0KSA9PiB7XG4gIGNsaWVudC5hY3Rpb25zLldlYmhvb2tzVXBkYXRlLmhhbmRsZShwYWNrZXQuZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdTRXZlbnRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL0NvbnN0YW50cycpO1xuXG5jb25zdCBoYW5kbGVycyA9IHt9O1xuXG5mb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoV1NFdmVudHMpKSB7XG4gIHRyeSB7XG4gICAgaGFuZGxlcnNbbmFtZV0gPSByZXF1aXJlKGAuLyR7bmFtZX0uanNgKTtcbiAgfSBjYXRjaCB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlcnM7XG4iLCJ2YXIgbWFwID0ge1xuXHRcIi4vQ0hBTk5FTF9DUkVBVEUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0NIQU5ORUxfQ1JFQVRFLmpzXCIsXG5cdFwiLi9DSEFOTkVMX0RFTEVURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvQ0hBTk5FTF9ERUxFVEUuanNcIixcblx0XCIuL0NIQU5ORUxfUElOU19VUERBVEUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0NIQU5ORUxfUElOU19VUERBVEUuanNcIixcblx0XCIuL0NIQU5ORUxfVVBEQVRFLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9DSEFOTkVMX1VQREFURS5qc1wiLFxuXHRcIi4vR1VJTERfQkFOX0FERC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfQkFOX0FERC5qc1wiLFxuXHRcIi4vR1VJTERfQkFOX1JFTU9WRS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfQkFOX1JFTU9WRS5qc1wiLFxuXHRcIi4vR1VJTERfQ1JFQVRFLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9DUkVBVEUuanNcIixcblx0XCIuL0dVSUxEX0RFTEVURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfREVMRVRFLmpzXCIsXG5cdFwiLi9HVUlMRF9FTU9KSVNfVVBEQVRFLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9FTU9KSVNfVVBEQVRFLmpzXCIsXG5cdFwiLi9HVUlMRF9JTlRFR1JBVElPTlNfVVBEQVRFLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9JTlRFR1JBVElPTlNfVVBEQVRFLmpzXCIsXG5cdFwiLi9HVUlMRF9NRU1CRVJTX0NIVU5LLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9NRU1CRVJTX0NIVU5LLmpzXCIsXG5cdFwiLi9HVUlMRF9NRU1CRVJfQURELmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9NRU1CRVJfQURELmpzXCIsXG5cdFwiLi9HVUlMRF9NRU1CRVJfUkVNT1ZFLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9NRU1CRVJfUkVNT1ZFLmpzXCIsXG5cdFwiLi9HVUlMRF9NRU1CRVJfVVBEQVRFLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9NRU1CRVJfVVBEQVRFLmpzXCIsXG5cdFwiLi9HVUlMRF9ST0xFX0NSRUFURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvR1VJTERfUk9MRV9DUkVBVEUuanNcIixcblx0XCIuL0dVSUxEX1JPTEVfREVMRVRFLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9HVUlMRF9ST0xFX0RFTEVURS5qc1wiLFxuXHRcIi4vR1VJTERfUk9MRV9VUERBVEUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0dVSUxEX1JPTEVfVVBEQVRFLmpzXCIsXG5cdFwiLi9HVUlMRF9VUERBVEUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL0dVSUxEX1VQREFURS5qc1wiLFxuXHRcIi4vSU5WSVRFX0NSRUFURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvSU5WSVRFX0NSRUFURS5qc1wiLFxuXHRcIi4vSU5WSVRFX0RFTEVURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvSU5WSVRFX0RFTEVURS5qc1wiLFxuXHRcIi4vTUVTU0FHRV9DUkVBVEUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfQ1JFQVRFLmpzXCIsXG5cdFwiLi9NRVNTQUdFX0RFTEVURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvTUVTU0FHRV9ERUxFVEUuanNcIixcblx0XCIuL01FU1NBR0VfREVMRVRFX0JVTEsuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfREVMRVRFX0JVTEsuanNcIixcblx0XCIuL01FU1NBR0VfUkVBQ1RJT05fQURELmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvZGlzY29yZC5qcy9zcmMvY2xpZW50L3dlYnNvY2tldC9oYW5kbGVycy9NRVNTQUdFX1JFQUNUSU9OX0FERC5qc1wiLFxuXHRcIi4vTUVTU0FHRV9SRUFDVElPTl9SRU1PVkUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFLmpzXCIsXG5cdFwiLi9NRVNTQUdFX1JFQUNUSU9OX1JFTU9WRV9BTEwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFX0FMTC5qc1wiLFxuXHRcIi4vTUVTU0FHRV9SRUFDVElPTl9SRU1PVkVfRU1PSkkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL01FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFX0VNT0pJLmpzXCIsXG5cdFwiLi9NRVNTQUdFX1VQREFURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvTUVTU0FHRV9VUERBVEUuanNcIixcblx0XCIuL1BSRVNFTkNFX1VQREFURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvUFJFU0VOQ0VfVVBEQVRFLmpzXCIsXG5cdFwiLi9SRUFEWS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvUkVBRFkuanNcIixcblx0XCIuL1JFU1VNRUQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL1JFU1VNRUQuanNcIixcblx0XCIuL1RZUElOR19TVEFSVC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvVFlQSU5HX1NUQVJULmpzXCIsXG5cdFwiLi9VU0VSX1VQREFURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvVVNFUl9VUERBVEUuanNcIixcblx0XCIuL1ZPSUNFX1NFUlZFUl9VUERBVEUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL1ZPSUNFX1NFUlZFUl9VUERBVEUuanNcIixcblx0XCIuL1ZPSUNFX1NUQVRFX1VQREFURS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMvVk9JQ0VfU1RBVEVfVVBEQVRFLmpzXCIsXG5cdFwiLi9XRUJIT09LU19VUERBVEUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL1dFQkhPT0tTX1VQREFURS5qc1wiLFxuXHRcIi4vaW5kZXguanNcIjogXCIuL25vZGVfbW9kdWxlcy9kaXNjb3JkLmpzL3NyYy9jbGllbnQvd2Vic29ja2V0L2hhbmRsZXJzL2luZGV4LmpzXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL2Rpc2NvcmQuanMvc3JjL2NsaWVudC93ZWJzb2NrZXQvaGFuZGxlcnMgc3luYyByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKlxcXFwuanMkXCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBIZWF2aWx5IGluc3BpcmVkIGJ5IG5vZGUncyBgaW50ZXJuYWwvZXJyb3JzYCBtb2R1bGVcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2NvZGUnKTtcbmNvbnN0IG1lc3NhZ2VzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEV4dGVuZCBhbiBlcnJvciBvZiBzb21lIHNvcnQgaW50byBhIERpc2NvcmRqc0Vycm9yLlxuICogQHBhcmFtIHtFcnJvcn0gQmFzZSBCYXNlIGVycm9yIHRvIGV4dGVuZFxuICogQHJldHVybnMge0Rpc2NvcmRqc0Vycm9yfVxuICovXG5mdW5jdGlvbiBtYWtlRGlzY29yZGpzRXJyb3IoQmFzZSkge1xuICByZXR1cm4gY2xhc3MgRGlzY29yZGpzRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIC4uLmFyZ3MpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2Uoa2V5LCBhcmdzKSk7XG4gICAgICB0aGlzW2tDb2RlXSA9IGtleTtcbiAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRGlzY29yZGpzRXJyb3IpO1xuICAgIH1cblxuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIGAke3N1cGVyLm5hbWV9IFske3RoaXNba0NvZGVdfV1gO1xuICAgIH1cblxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXNba0NvZGVdO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdGhlIG1lc3NhZ2UgZm9yIGFuIGVycm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBFcnJvciBrZXlcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyZ3MgQXJndW1lbnRzIHRvIHBhc3MgZm9yIHV0aWwgZm9ybWF0IG9yIGFzIGZ1bmN0aW9uIGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gbWVzc2FnZShrZXksIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIG1lc3NhZ2Uga2V5IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgY29uc3QgbXNnID0gbWVzc2FnZXMuZ2V0KGtleSk7XG4gIGlmICghbXNnKSB0aHJvdyBuZXcgRXJyb3IoYEFuIGludmFsaWQgZXJyb3IgbWVzc2FnZSBrZXkgd2FzIHVzZWQ6ICR7a2V5fS5gKTtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHJldHVybiBtc2coLi4uYXJncyk7XG4gIGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncy5sZW5ndGggPT09IDApIHJldHVybiBtc2c7XG4gIGFyZ3MudW5zaGlmdChtc2cpO1xuICByZXR1cm4gU3RyaW5nKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGFuIGVycm9yIGNvZGUgYW5kIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ltIFVuaXF1ZSBuYW1lIGZvciB0aGUgZXJyb3JcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIG9mIHRoZSBlcnJvclxuICovXG5mdW5jdGlvbiByZWdpc3RlcihzeW0sIHZhbCkge1xuICBtZXNzYWdlcy5zZXQoc3ltLCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsIDogU3RyaW5nKHZhbCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVnaXN0ZXIsXG4gIEVycm9yOiBtYWtlRGlzY29yZGpzRXJyb3IoRXJyb3IpLFxuICBUeXBlRXJyb3I6IG1ha2VEaXNjb3JkanNFcnJvcihUeXBlRXJyb3IpLFxuICBSYW5nZUVycm9yOiBtYWtlRGlzY29yZGpzRXJyb3IoUmFuZ2VFcnJvciksXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHJlZ2lzdGVyIH0gPSByZXF1aXJlKCcuL0RKU0Vycm9yJyk7XG5cbmNvbnN0IE1lc3NhZ2VzID0ge1xuICBDTElFTlRfSU5WQUxJRF9PUFRJT046IChwcm9wLCBtdXN0KSA9PiBgVGhlICR7cHJvcH0gb3B0aW9uIG11c3QgYmUgJHttdXN0fWAsXG4gIENMSUVOVF9JTlZBTElEX1BST1ZJREVEX1NIQVJEUzogJ05vbmUgb2YgdGhlIHByb3ZpZGVkIHNoYXJkcyB3ZXJlIHZhbGlkLicsXG5cbiAgVE9LRU5fSU5WQUxJRDogJ0FuIGludmFsaWQgdG9rZW4gd2FzIHByb3ZpZGVkLicsXG4gIFRPS0VOX01JU1NJTkc6ICdSZXF1ZXN0IHRvIHVzZSB0b2tlbiwgYnV0IHRva2VuIHdhcyB1bmF2YWlsYWJsZSB0byB0aGUgY2xpZW50LicsXG5cbiAgV1NfQ0xPU0VfUkVRVUVTVEVEOiAnV2ViU29ja2V0IGNsb3NlZCBkdWUgdG8gdXNlciByZXF1ZXN0LicsXG4gIFdTX0NPTk5FQ1RJT05fRVhJU1RTOiAnVGhlcmUgaXMgYWxyZWFkeSBhbiBleGlzdGluZyBXZWJTb2NrZXQgY29ubmVjdGlvbi4nLFxuICBXU19OT1RfT1BFTjogKGRhdGEgPSAnZGF0YScpID0+IGBXZWJzb2NrZXQgbm90IG9wZW4gdG8gc2VuZCAke2RhdGF9YCxcblxuICBCSVRGSUVMRF9JTlZBTElEOiAnSW52YWxpZCBiaXRmaWVsZCBmbGFnIG9yIG51bWJlci4nLFxuXG4gIFNIQVJESU5HX0lOVkFMSUQ6ICdJbnZhbGlkIHNoYXJkIHNldHRpbmdzIHdlcmUgcHJvdmlkZWQuJyxcbiAgU0hBUkRJTkdfUkVRVUlSRUQ6ICdUaGlzIHNlc3Npb24gd291bGQgaGF2ZSBoYW5kbGVkIHRvbyBtYW55IGd1aWxkcyAtIFNoYXJkaW5nIGlzIHJlcXVpcmVkLicsXG4gIElOVkFMSURfSU5URU5UUzogJ0ludmFsaWQgaW50ZW50IHByb3ZpZGVkIGZvciBXZWJTb2NrZXQgaW50ZW50cy4nLFxuICBESVNBTExPV0VEX0lOVEVOVFM6ICdQcml2aWxlZ2VkIGludGVudCBwcm92aWRlZCBpcyBub3QgZW5hYmxlZCBvciB3aGl0ZWxpc3RlZC4nLFxuICBTSEFSRElOR19OT19TSEFSRFM6ICdObyBzaGFyZHMgaGF2ZSBiZWVuIHNwYXduZWQuJyxcbiAgU0hBUkRJTkdfSU5fUFJPQ0VTUzogJ1NoYXJkcyBhcmUgc3RpbGwgYmVpbmcgc3Bhd25lZC4nLFxuICBTSEFSRElOR19TSEFSRF9OT1RfRk9VTkQ6IGlkID0+IGBTaGFyZCAke2lkfSBjb3VsZCBub3QgYmUgZm91bmQuYCxcbiAgU0hBUkRJTkdfQUxSRUFEWV9TUEFXTkVEOiBjb3VudCA9PiBgQWxyZWFkeSBzcGF3bmVkICR7Y291bnR9IHNoYXJkcy5gLFxuICBTSEFSRElOR19QUk9DRVNTX0VYSVNUUzogaWQgPT4gYFNoYXJkICR7aWR9IGFscmVhZHkgaGFzIGFuIGFjdGl2ZSBwcm9jZXNzLmAsXG4gIFNIQVJESU5HX1dPUktFUl9FWElTVFM6IGlkID0+IGBTaGFyZCAke2lkfSBhbHJlYWR5IGhhcyBhbiBhY3RpdmUgd29ya2VyLmAsXG4gIFNIQVJESU5HX1JFQURZX1RJTUVPVVQ6IGlkID0+IGBTaGFyZCAke2lkfSdzIENsaWVudCB0b29rIHRvbyBsb25nIHRvIGJlY29tZSByZWFkeS5gLFxuICBTSEFSRElOR19SRUFEWV9ESVNDT05ORUNURUQ6IGlkID0+IGBTaGFyZCAke2lkfSdzIENsaWVudCBkaXNjb25uZWN0ZWQgYmVmb3JlIGJlY29taW5nIHJlYWR5LmAsXG4gIFNIQVJESU5HX1JFQURZX0RJRUQ6IGlkID0+IGBTaGFyZCAke2lkfSdzIHByb2Nlc3MgZXhpdGVkIGJlZm9yZSBpdHMgQ2xpZW50IGJlY2FtZSByZWFkeS5gLFxuICBTSEFSRElOR19OT19DSElMRF9FWElTVFM6IGlkID0+IGBTaGFyZCAke2lkfSBoYXMgbm8gYWN0aXZlIHByb2Nlc3Mgb3Igd29ya2VyLmAsXG4gIFNIQVJESU5HX1NIQVJEX01JU0NBTENVTEFUSU9OOiAoc2hhcmQsIGd1aWxkLCBjb3VudCkgPT5cbiAgICBgQ2FsY3VsYXRlZCBpbnZhbGlkIHNoYXJkICR7c2hhcmR9IGZvciBndWlsZCAke2d1aWxkfSB3aXRoICR7Y291bnR9IHNoYXJkcy5gLFxuXG4gIENPTE9SX1JBTkdFOiAnQ29sb3IgbXVzdCBiZSB3aXRoaW4gdGhlIHJhbmdlIDAgLSAxNjc3NzIxNSAoMHhGRkZGRkYpLicsXG4gIENPTE9SX0NPTlZFUlQ6ICdVbmFibGUgdG8gY29udmVydCBjb2xvciB0byBhIG51bWJlci4nLFxuXG4gIEVNQkVEX0ZJRUxEX05BTUU6ICdNZXNzYWdlRW1iZWQgZmllbGQgbmFtZXMgbWF5IG5vdCBiZSBlbXB0eS4nLFxuICBFTUJFRF9GSUVMRF9WQUxVRTogJ01lc3NhZ2VFbWJlZCBmaWVsZCB2YWx1ZXMgbWF5IG5vdCBiZSBlbXB0eS4nLFxuXG4gIEZJTEVfTk9UX0ZPVU5EOiBmaWxlID0+IGBGaWxlIGNvdWxkIG5vdCBiZSBmb3VuZDogJHtmaWxlfWAsXG5cbiAgVVNFUl9OT19ETUNIQU5ORUw6ICdObyBETSBDaGFubmVsIGV4aXN0cyEnLFxuXG4gIFZPSUNFX0lOVkFMSURfSEVBUlRCRUFUOiAnVHJpZWQgdG8gc2V0IHZvaWNlIGhlYXJ0YmVhdCBidXQgbm8gdmFsaWQgaW50ZXJ2YWwgd2FzIHNwZWNpZmllZC4nLFxuICBWT0lDRV9VU0VSX01JU1NJTkc6IFwiQ291bGRuJ3QgcmVzb2x2ZSB0aGUgdXNlciB0byBjcmVhdGUgc3RyZWFtLlwiLFxuICBWT0lDRV9KT0lOX0NIQU5ORUw6IChmdWxsID0gZmFsc2UpID0+XG4gICAgYFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGpvaW4gdGhpcyB2b2ljZSBjaGFubmVsJHtmdWxsID8gJzsgaXQgaXMgZnVsbC4nIDogJy4nfWAsXG4gIFZPSUNFX0NPTk5FQ1RJT05fVElNRU9VVDogJ0Nvbm5lY3Rpb24gbm90IGVzdGFibGlzaGVkIHdpdGhpbiAxNSBzZWNvbmRzLicsXG4gIFZPSUNFX1RPS0VOX0FCU0VOVDogJ1Rva2VuIG5vdCBwcm92aWRlZCBmcm9tIHZvaWNlIHNlcnZlciBwYWNrZXQuJyxcbiAgVk9JQ0VfU0VTU0lPTl9BQlNFTlQ6ICdTZXNzaW9uIElEIG5vdCBzdXBwbGllZC4nLFxuICBWT0lDRV9JTlZBTElEX0VORFBPSU5UOiAnSW52YWxpZCBlbmRwb2ludCByZWNlaXZlZC4nLFxuICBWT0lDRV9OT19CUk9XU0VSOiAnVm9pY2UgY29ubmVjdGlvbnMgYXJlIG5vdCBhdmFpbGFibGUgaW4gYnJvd3NlcnMuJyxcbiAgVk9JQ0VfQ09OTkVDVElPTl9BVFRFTVBUU19FWENFRURFRDogYXR0ZW1wdHMgPT4gYFRvbyBtYW55IGNvbm5lY3Rpb24gYXR0ZW1wdHMgKCR7YXR0ZW1wdHN9KS5gLFxuICBWT0lDRV9KT0lOX1NPQ0tFVF9DTE9TRUQ6ICdUcmllZCB0byBzZW5kIGpvaW4gcGFja2V0LCBidXQgdGhlIFdlYlNvY2tldCBpcyBub3Qgb3Blbi4nLFxuICBWT0lDRV9QTEFZX0lOVEVSRkFDRV9OT19CUk9BRENBU1Q6ICdBIGJyb2FkY2FzdCBjYW5ub3QgYmUgcGxheWVkIGluIHRoaXMgY29udGV4dC4nLFxuICBWT0lDRV9QTEFZX0lOVEVSRkFDRV9CQURfVFlQRTogJ1Vua25vd24gc3RyZWFtIHR5cGUnLFxuICBWT0lDRV9QUklTTV9ERU1VWEVSU19ORUVEX1NUUkVBTTogJ1RvIHBsYXkgYSB3ZWJtL29nZyBzdHJlYW0sIHlvdSBuZWVkIHRvIHBhc3MgYSBSZWFkYWJsZVN0cmVhbS4nLFxuXG4gIFZPSUNFX1NUQVRFX1VOQ0FDSEVEX01FTUJFUjogJ1RoZSBtZW1iZXIgb2YgdGhpcyB2b2ljZSBzdGF0ZSBpcyB1bmNhY2hlZC4nLFxuICBWT0lDRV9TVEFURV9OT1RfT1dOOiAnWW91IGNhbm5vdCBzZWxmLWRlYWZlbi9tdXRlIG9uIFZvaWNlU3RhdGVzIHRoYXQgZG8gbm90IGJlbG9uZyB0byB0aGUgQ2xpZW50VXNlci4nLFxuICBWT0lDRV9TVEFURV9JTlZBTElEX1RZUEU6IG5hbWUgPT4gYCR7bmFtZX0gbXVzdCBiZSBhIGJvb2xlYW4uYCxcblxuICBVRFBfU0VORF9GQUlMOiAnVHJpZWQgdG8gc2VuZCBhIFVEUCBwYWNrZXQsIGJ1dCB0aGVyZSBpcyBubyBzb2NrZXQgYXZhaWxhYmxlLicsXG4gIFVEUF9BRERSRVNTX01BTEZPUk1FRDogJ01hbGZvcm1lZCBVRFAgYWRkcmVzcyBvciBwb3J0LicsXG4gIFVEUF9DT05ORUNUSU9OX0VYSVNUUzogJ1RoZXJlIGlzIGFscmVhZHkgYW4gZXhpc3RpbmcgVURQIGNvbm5lY3Rpb24uJyxcblxuICBSRVFfUkVTT1VSQ0VfVFlQRTogJ1RoZSByZXNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIgb3IgYSB2YWxpZCBmaWxlIHN0cmVhbS4nLFxuXG4gIElNQUdFX0ZPUk1BVDogZm9ybWF0ID0+IGBJbnZhbGlkIGltYWdlIGZvcm1hdDogJHtmb3JtYXR9YCxcbiAgSU1BR0VfU0laRTogc2l6ZSA9PiBgSW52YWxpZCBpbWFnZSBzaXplOiAke3NpemV9YCxcblxuICBNRVNTQUdFX0JVTEtfREVMRVRFX1RZUEU6ICdUaGUgbWVzc2FnZXMgbXVzdCBiZSBhbiBBcnJheSwgQ29sbGVjdGlvbiwgb3IgbnVtYmVyLicsXG4gIE1FU1NBR0VfTk9OQ0VfVFlQRTogJ01lc3NhZ2Ugbm9uY2UgbXVzdCBmaXQgaW4gYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIuJyxcblxuICBUWVBJTkdfQ09VTlQ6ICdDb3VudCBtdXN0IGJlIGF0IGxlYXN0IDEnLFxuXG4gIFNQTElUX01BWF9MRU46ICdDaHVuayBleGNlZWRzIHRoZSBtYXggbGVuZ3RoIGFuZCBjb250YWlucyBubyBzcGxpdCBjaGFyYWN0ZXJzLicsXG5cbiAgQkFOX1JFU09MVkVfSUQ6IChiYW4gPSBmYWxzZSkgPT4gYENvdWxkbid0IHJlc29sdmUgdGhlIHVzZXIgSUQgdG8gJHtiYW4gPyAnYmFuJyA6ICd1bmJhbid9LmAsXG4gIEZFVENIX0JBTl9SRVNPTFZFX0lEOiBcIkNvdWxkbid0IHJlc29sdmUgdGhlIHVzZXIgSUQgdG8gZmV0Y2ggdGhlIGJhbi5cIixcblxuICBQUlVORV9EQVlTX1RZUEU6ICdEYXlzIG11c3QgYmUgYSBudW1iZXInLFxuXG4gIEdVSUxEX0NIQU5ORUxfUkVTT0xWRTogJ0NvdWxkIG5vdCByZXNvbHZlIGNoYW5uZWwgdG8gYSBndWlsZCBjaGFubmVsLicsXG4gIEdVSUxEX1ZPSUNFX0NIQU5ORUxfUkVTT0xWRTogJ0NvdWxkIG5vdCByZXNvbHZlIGNoYW5uZWwgdG8gYSBndWlsZCB2b2ljZSBjaGFubmVsLicsXG4gIEdVSUxEX0NIQU5ORUxfT1JQSEFOOiAnQ291bGQgbm90IGZpbmQgYSBwYXJlbnQgdG8gdGhpcyBndWlsZCBjaGFubmVsLicsXG4gIEdVSUxEX09XTkVEOiAnR3VpbGQgaXMgb3duZWQgYnkgdGhlIGNsaWVudC4nLFxuICBHVUlMRF9NRU1CRVJTX1RJTUVPVVQ6IFwiTWVtYmVycyBkaWRuJ3QgYXJyaXZlIGluIHRpbWUuXCIsXG4gIEdVSUxEX1VOQ0FDSEVEX01FOiAnVGhlIGNsaWVudCB1c2VyIGFzIGEgbWVtYmVyIG9mIHRoaXMgZ3VpbGQgaXMgdW5jYWNoZWQuJyxcblxuICBJTlZBTElEX1RZUEU6IChuYW1lLCBleHBlY3RlZCwgYW4gPSBmYWxzZSkgPT4gYFN1cHBsaWVkICR7bmFtZX0gaXMgbm90IGEke2FuID8gJ24nIDogJyd9ICR7ZXhwZWN0ZWR9LmAsXG5cbiAgV0VCSE9PS19NRVNTQUdFOiAnVGhlIG1lc3NhZ2Ugd2FzIG5vdCBzZW50IGJ5IGEgd2ViaG9vay4nLFxuXG4gIEVNT0pJX1RZUEU6ICdFbW9qaSBtdXN0IGJlIGEgc3RyaW5nIG9yIEd1aWxkRW1vamkvUmVhY3Rpb25FbW9qaScsXG4gIEVNT0pJX01BTkFHRUQ6ICdFbW9qaSBpcyBtYW5hZ2VkIGFuZCBoYXMgbm8gQXV0aG9yLicsXG4gIE1JU1NJTkdfTUFOQUdFX0VNT0pJU19QRVJNSVNTSU9OOiBndWlsZCA9PlxuICAgIGBDbGllbnQgbXVzdCBoYXZlIE1hbmFnZSBFbW9qaSBwZXJtaXNzaW9uIGluIGd1aWxkICR7Z3VpbGR9IHRvIHNlZSBlbW9qaSBhdXRob3JzLmAsXG5cbiAgUkVBQ1RJT05fUkVTT0xWRV9VU0VSOiBcIkNvdWxkbid0IHJlc29sdmUgdGhlIHVzZXIgSUQgdG8gcmVtb3ZlIGZyb20gdGhlIHJlYWN0aW9uLlwiLFxuXG4gIFZBTklUWV9VUkw6ICdUaGlzIGd1aWxkIGRvZXMgbm90IGhhdmUgdGhlIFZBTklUWV9VUkwgZmVhdHVyZSBlbmFibGVkLicsXG5cbiAgREVMRVRFX0dST1VQX0RNX0NIQU5ORUw6IFwiQm90cyBkb24ndCBoYXZlIGFjY2VzcyB0byBHcm91cCBETSBDaGFubmVscyBhbmQgY2Fubm90IGRlbGV0ZSB0aGVtXCIsXG4gIEZFVENIX0dST1VQX0RNX0NIQU5ORUw6IFwiQm90cyBkb24ndCBoYXZlIGFjY2VzcyB0byBHcm91cCBETSBDaGFubmVscyBhbmQgY2Fubm90IGZldGNoIHRoZW1cIixcblxuICBNRU1CRVJfRkVUQ0hfTk9OQ0VfTEVOR1RIOiAnTm9uY2UgbGVuZ3RoIG11c3Qgbm90IGV4Y2VlZCAzMiBjaGFyYWN0ZXJzLicsXG59O1xuXG5mb3IgKGNvbnN0IFtuYW1lLCBtZXNzYWdlXSBvZiBPYmplY3QuZW50cmllcyhNZXNzYWdlcykpIHJlZ2lzdGVyKG5hbWUsIG1lc3NhZ2UpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vREpTRXJyb3InKTtcbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VzID0gcmVxdWlyZSgnLi9NZXNzYWdlcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi91dGlsL1V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFwiUm9vdFwiIGNsYXNzZXMgKHN0YXJ0aW5nIHBvaW50cylcbiAgQmFzZUNsaWVudDogcmVxdWlyZSgnLi9jbGllbnQvQmFzZUNsaWVudCcpLFxuICBDbGllbnQ6IHJlcXVpcmUoJy4vY2xpZW50L0NsaWVudCcpLFxuICBTaGFyZDogcmVxdWlyZSgnLi9zaGFyZGluZy9TaGFyZCcpLFxuICBTaGFyZENsaWVudFV0aWw6IHJlcXVpcmUoJy4vc2hhcmRpbmcvU2hhcmRDbGllbnRVdGlsJyksXG4gIFNoYXJkaW5nTWFuYWdlcjogcmVxdWlyZSgnLi9zaGFyZGluZy9TaGFyZGluZ01hbmFnZXInKSxcbiAgV2ViaG9va0NsaWVudDogcmVxdWlyZSgnLi9jbGllbnQvV2ViaG9va0NsaWVudCcpLFxuXG4gIC8vIFV0aWxpdGllc1xuICBBY3Rpdml0eUZsYWdzOiByZXF1aXJlKCcuL3V0aWwvQWN0aXZpdHlGbGFncycpLFxuICBCaXRGaWVsZDogcmVxdWlyZSgnLi91dGlsL0JpdEZpZWxkJyksXG4gIENvbGxlY3Rpb246IHJlcXVpcmUoJy4vdXRpbC9Db2xsZWN0aW9uJyksXG4gIENvbnN0YW50czogcmVxdWlyZSgnLi91dGlsL0NvbnN0YW50cycpLFxuICBEYXRhUmVzb2x2ZXI6IHJlcXVpcmUoJy4vdXRpbC9EYXRhUmVzb2x2ZXInKSxcbiAgQmFzZU1hbmFnZXI6IHJlcXVpcmUoJy4vbWFuYWdlcnMvQmFzZU1hbmFnZXInKSxcbiAgRGlzY29yZEFQSUVycm9yOiByZXF1aXJlKCcuL3Jlc3QvRGlzY29yZEFQSUVycm9yJyksXG4gIEhUVFBFcnJvcjogcmVxdWlyZSgnLi9yZXN0L0hUVFBFcnJvcicpLFxuICBNZXNzYWdlRmxhZ3M6IHJlcXVpcmUoJy4vdXRpbC9NZXNzYWdlRmxhZ3MnKSxcbiAgSW50ZW50czogcmVxdWlyZSgnLi91dGlsL0ludGVudHMnKSxcbiAgUGVybWlzc2lvbnM6IHJlcXVpcmUoJy4vdXRpbC9QZXJtaXNzaW9ucycpLFxuICBTcGVha2luZzogcmVxdWlyZSgnLi91dGlsL1NwZWFraW5nJyksXG4gIFNub3dmbGFrZTogcmVxdWlyZSgnLi91dGlsL1Nub3dmbGFrZScpLFxuICBTbm93Zmxha2VVdGlsOiByZXF1aXJlKCcuL3V0aWwvU25vd2ZsYWtlJyksXG4gIFN0cnVjdHVyZXM6IHJlcXVpcmUoJy4vdXRpbC9TdHJ1Y3R1cmVzJyksXG4gIFN5c3RlbUNoYW5uZWxGbGFnczogcmVxdWlyZSgnLi91dGlsL1N5c3RlbUNoYW5uZWxGbGFncycpLFxuICBVc2VyRmxhZ3M6IHJlcXVpcmUoJy4vdXRpbC9Vc2VyRmxhZ3MnKSxcbiAgVXRpbDogVXRpbCxcbiAgdmVyc2lvbjogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcblxuICAvLyBNYW5hZ2Vyc1xuICBDaGFubmVsTWFuYWdlcjogcmVxdWlyZSgnLi9tYW5hZ2Vycy9DaGFubmVsTWFuYWdlcicpLFxuICBHdWlsZENoYW5uZWxNYW5hZ2VyOiByZXF1aXJlKCcuL21hbmFnZXJzL0d1aWxkQ2hhbm5lbE1hbmFnZXInKSxcbiAgR3VpbGRFbW9qaU1hbmFnZXI6IHJlcXVpcmUoJy4vbWFuYWdlcnMvR3VpbGRFbW9qaU1hbmFnZXInKSxcbiAgR3VpbGRFbW9qaVJvbGVNYW5hZ2VyOiByZXF1aXJlKCcuL21hbmFnZXJzL0d1aWxkRW1vamlSb2xlTWFuYWdlcicpLFxuICBHdWlsZE1lbWJlck1hbmFnZXI6IHJlcXVpcmUoJy4vbWFuYWdlcnMvR3VpbGRNZW1iZXJNYW5hZ2VyJyksXG4gIEd1aWxkTWVtYmVyUm9sZU1hbmFnZXI6IHJlcXVpcmUoJy4vbWFuYWdlcnMvR3VpbGRNZW1iZXJSb2xlTWFuYWdlcicpLFxuICBHdWlsZE1hbmFnZXI6IHJlcXVpcmUoJy4vbWFuYWdlcnMvR3VpbGRNYW5hZ2VyJyksXG4gIFJlYWN0aW9uTWFuYWdlcjogcmVxdWlyZSgnLi9tYW5hZ2Vycy9SZWFjdGlvbk1hbmFnZXInKSxcbiAgUmVhY3Rpb25Vc2VyTWFuYWdlcjogcmVxdWlyZSgnLi9tYW5hZ2Vycy9SZWFjdGlvblVzZXJNYW5hZ2VyJyksXG4gIE1lc3NhZ2VNYW5hZ2VyOiByZXF1aXJlKCcuL21hbmFnZXJzL01lc3NhZ2VNYW5hZ2VyJyksXG4gIFByZXNlbmNlTWFuYWdlcjogcmVxdWlyZSgnLi9tYW5hZ2Vycy9QcmVzZW5jZU1hbmFnZXInKSxcbiAgUm9sZU1hbmFnZXI6IHJlcXVpcmUoJy4vbWFuYWdlcnMvUm9sZU1hbmFnZXInKSxcbiAgVXNlck1hbmFnZXI6IHJlcXVpcmUoJy4vbWFuYWdlcnMvVXNlck1hbmFnZXInKSxcblxuICAvLyBTaG9ydGN1dHMgdG8gVXRpbCBtZXRob2RzXG4gIGRpc2NvcmRTb3J0OiBVdGlsLmRpc2NvcmRTb3J0LFxuICBlc2NhcGVNYXJrZG93bjogVXRpbC5lc2NhcGVNYXJrZG93bixcbiAgZmV0Y2hSZWNvbW1lbmRlZFNoYXJkczogVXRpbC5mZXRjaFJlY29tbWVuZGVkU2hhcmRzLFxuICByZXNvbHZlQ29sb3I6IFV0aWwucmVzb2x2ZUNvbG9yLFxuICByZXNvbHZlU3RyaW5nOiBVdGlsLnJlc29sdmVTdHJpbmcsXG4gIHNwbGl0TWVzc2FnZTogVXRpbC5zcGxpdE1lc3NhZ2UsXG5cbiAgLy8gU3RydWN0dXJlc1xuICBBcHBsaWNhdGlvbjogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL2ludGVyZmFjZXMvQXBwbGljYXRpb24nKSxcbiAgQmFzZTogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL0Jhc2UnKSxcbiAgQWN0aXZpdHk6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9QcmVzZW5jZScpLkFjdGl2aXR5LFxuICBBUElNZXNzYWdlOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvQVBJTWVzc2FnZScpLFxuICBCYXNlR3VpbGRFbW9qaTogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL0Jhc2VHdWlsZEVtb2ppJyksXG4gIENhdGVnb3J5Q2hhbm5lbDogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL0NhdGVnb3J5Q2hhbm5lbCcpLFxuICBDaGFubmVsOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvQ2hhbm5lbCcpLFxuICBDbGllbnRBcHBsaWNhdGlvbjogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL0NsaWVudEFwcGxpY2F0aW9uJyksXG4gIGdldCBDbGllbnRVc2VyKCkge1xuICAgIC8vIFRoaXMgaXMgYSBnZXR0ZXIgc28gdGhhdCBpdCBwcm9wZXJseSBleHRlbmRzIGFueSBjdXN0b20gVXNlciBjbGFzc1xuICAgIHJldHVybiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvQ2xpZW50VXNlcicpO1xuICB9LFxuICBDb2xsZWN0b3I6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9pbnRlcmZhY2VzL0NvbGxlY3RvcicpLFxuICBETUNoYW5uZWw6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9ETUNoYW5uZWwnKSxcbiAgRW1vamk6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9FbW9qaScpLFxuICBHdWlsZDogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL0d1aWxkJyksXG4gIEd1aWxkQXVkaXRMb2dzOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvR3VpbGRBdWRpdExvZ3MnKSxcbiAgR3VpbGRDaGFubmVsOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvR3VpbGRDaGFubmVsJyksXG4gIEd1aWxkRW1vamk6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9HdWlsZEVtb2ppJyksXG4gIEd1aWxkTWVtYmVyOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvR3VpbGRNZW1iZXInKSxcbiAgR3VpbGRQcmV2aWV3OiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvR3VpbGRQcmV2aWV3JyksXG4gIEd1aWxkVGVtcGxhdGU6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9HdWlsZFRlbXBsYXRlJyksXG4gIEludGVncmF0aW9uOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvSW50ZWdyYXRpb24nKSxcbiAgSW52aXRlOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvSW52aXRlJyksXG4gIE1lc3NhZ2U6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9NZXNzYWdlJyksXG4gIE1lc3NhZ2VBdHRhY2htZW50OiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvTWVzc2FnZUF0dGFjaG1lbnQnKSxcbiAgTWVzc2FnZUNvbGxlY3RvcjogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL01lc3NhZ2VDb2xsZWN0b3InKSxcbiAgTWVzc2FnZUVtYmVkOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvTWVzc2FnZUVtYmVkJyksXG4gIE1lc3NhZ2VNZW50aW9uczogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL01lc3NhZ2VNZW50aW9ucycpLFxuICBNZXNzYWdlUmVhY3Rpb246IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9NZXNzYWdlUmVhY3Rpb24nKSxcbiAgTmV3c0NoYW5uZWw6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9OZXdzQ2hhbm5lbCcpLFxuICBQZXJtaXNzaW9uT3ZlcndyaXRlczogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL1Blcm1pc3Npb25PdmVyd3JpdGVzJyksXG4gIFByZXNlbmNlOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvUHJlc2VuY2UnKS5QcmVzZW5jZSxcbiAgQ2xpZW50UHJlc2VuY2U6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9DbGllbnRQcmVzZW5jZScpLFxuICBSZWFjdGlvbkNvbGxlY3RvcjogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL1JlYWN0aW9uQ29sbGVjdG9yJyksXG4gIFJlYWN0aW9uRW1vamk6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9SZWFjdGlvbkVtb2ppJyksXG4gIFJpY2hQcmVzZW5jZUFzc2V0czogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL1ByZXNlbmNlJykuUmljaFByZXNlbmNlQXNzZXRzLFxuICBSb2xlOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvUm9sZScpLFxuICBTdG9yZUNoYW5uZWw6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9TdG9yZUNoYW5uZWwnKSxcbiAgVGVhbTogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL1RlYW0nKSxcbiAgVGVhbU1lbWJlcjogcmVxdWlyZSgnLi9zdHJ1Y3R1cmVzL1RlYW1NZW1iZXInKSxcbiAgVGV4dENoYW5uZWw6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9UZXh0Q2hhbm5lbCcpLFxuICBVc2VyOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvVXNlcicpLFxuICBWb2ljZUNoYW5uZWw6IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9Wb2ljZUNoYW5uZWwnKSxcbiAgVm9pY2VSZWdpb246IHJlcXVpcmUoJy4vc3RydWN0dXJlcy9Wb2ljZVJlZ2lvbicpLFxuICBWb2ljZVN0YXRlOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvVm9pY2VTdGF0ZScpLFxuICBXZWJob29rOiByZXF1aXJlKCcuL3N0cnVjdHVyZXMvV2ViaG9vaycpLFxuXG4gIFdlYlNvY2tldDogcmVxdWlyZSgnLi9XZWJTb2NrZXQnKSxcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmxldCBTdHJ1Y3R1cmVzO1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIEFQSSBtZXRob2RzIG9mIGEgZGF0YSBtb2RlbCBhbmQgaG9sZHMgaXRzIGNhY2hlLlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBpdGVyYWJsZSwgaG9sZHMsIGNhY2hlVHlwZSA9IENvbGxlY3Rpb24sIC4uLmNhY2hlT3B0aW9ucykge1xuICAgIGlmICghU3RydWN0dXJlcykgU3RydWN0dXJlcyA9IHJlcXVpcmUoJy4uL3V0aWwvU3RydWN0dXJlcycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBiZWxvbmdpbmcgdG8gdGhpcyBtYW5hZ2VyXG4gICAgICogQG5hbWUgQmFzZU1hbmFnZXIjaG9sZHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2hvbGRzJywgeyB2YWx1ZTogU3RydWN0dXJlcy5nZXQoaG9sZHMubmFtZSkgfHwgaG9sZHMgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRoYXQgaW5zdGFudGlhdGVkIHRoaXMgTWFuYWdlclxuICAgICAqIEBuYW1lIEJhc2VNYW5hZ2VyI2NsaWVudFxuICAgICAqIEB0eXBlIHtDbGllbnR9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjbGllbnQnLCB7IHZhbHVlOiBjbGllbnQgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBDb2xsZWN0aW9uIG9mIHRoZSBNYW5hZ2VyXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5jYWNoZVR5cGUgPSBjYWNoZVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgY2FjaGUgZm9yIHRoZSBkYXRhIG1vZGVsXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5jYWNoZSA9IG5ldyBjYWNoZVR5cGUoLi4uY2FjaGVPcHRpb25zKTtcbiAgICBpZiAoaXRlcmFibGUpIGZvciAoY29uc3QgaSBvZiBpdGVyYWJsZSkgdGhpcy5hZGQoaSk7XG4gIH1cblxuICBhZGQoZGF0YSwgY2FjaGUgPSB0cnVlLCB7IGlkLCBleHRyYXMgPSBbXSB9ID0ge30pIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuZ2V0KGlkIHx8IGRhdGEuaWQpO1xuICAgIGlmIChleGlzdGluZyAmJiBleGlzdGluZy5fcGF0Y2ggJiYgY2FjaGUpIGV4aXN0aW5nLl9wYXRjaChkYXRhKTtcbiAgICBpZiAoZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcblxuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5ob2xkcyA/IG5ldyB0aGlzLmhvbGRzKHRoaXMuY2xpZW50LCBkYXRhLCAuLi5leHRyYXMpIDogZGF0YTtcbiAgICBpZiAoY2FjaGUpIHRoaXMuY2FjaGUuc2V0KGlkIHx8IGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgZGF0YSBlbnRyeSB0byBhIGRhdGEgT2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGlkT3JJbnN0YW5jZSBUaGUgaWQgb3IgaW5zdGFuY2Ugb2Ygc29tZXRoaW5nIGluIHRoaXMgTWFuYWdlclxuICAgKiBAcmV0dXJucyB7P09iamVjdH0gQW4gaW5zdGFuY2UgZnJvbSB0aGlzIE1hbmFnZXJcbiAgICovXG4gIHJlc29sdmUoaWRPckluc3RhbmNlKSB7XG4gICAgaWYgKGlkT3JJbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMuaG9sZHMpIHJldHVybiBpZE9ySW5zdGFuY2U7XG4gICAgaWYgKHR5cGVvZiBpZE9ySW5zdGFuY2UgPT09ICdzdHJpbmcnKSByZXR1cm4gdGhpcy5jYWNoZS5nZXQoaWRPckluc3RhbmNlKSB8fCBudWxsO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgZGF0YSBlbnRyeSB0byBhIGluc3RhbmNlIElELlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGlkT3JJbnN0YW5jZSBUaGUgaWQgb3IgaW5zdGFuY2Ugb2Ygc29tZXRoaW5nIGluIHRoaXMgTWFuYWdlclxuICAgKiBAcmV0dXJucyB7P1Nub3dmbGFrZX1cbiAgICovXG4gIHJlc29sdmVJRChpZE9ySW5zdGFuY2UpIHtcbiAgICBpZiAoaWRPckluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy5ob2xkcykgcmV0dXJuIGlkT3JJbnN0YW5jZS5pZDtcbiAgICBpZiAodHlwZW9mIGlkT3JJbnN0YW5jZSA9PT0gJ3N0cmluZycpIHJldHVybiBpZE9ySW5zdGFuY2U7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9CYXNlTWFuYWdlcicpO1xuY29uc3QgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvQ2hhbm5lbCcpO1xuY29uc3QgeyBFdmVudHMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGNoYW5uZWxzIGJlbG9uZ2luZyB0byBhIGNsaWVudFxuICogQGV4dGVuZHMge0Jhc2VNYW5hZ2VyfVxuICovXG5jbGFzcyBDaGFubmVsTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBpdGVyYWJsZSkge1xuICAgIHN1cGVyKGNsaWVudCwgaXRlcmFibGUsIENoYW5uZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBvZiBDaGFubmVsc1xuICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIENoYW5uZWw+fVxuICAgKiBAbmFtZSBDaGFubmVsTWFuYWdlciNjYWNoZVxuICAgKi9cblxuICBhZGQoZGF0YSwgZ3VpbGQsIGNhY2hlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5jYWNoZS5nZXQoZGF0YS5pZCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICBpZiAoZXhpc3RpbmcuX3BhdGNoICYmIGNhY2hlKSBleGlzdGluZy5fcGF0Y2goZGF0YSk7XG4gICAgICBpZiAoZ3VpbGQpIGd1aWxkLmNoYW5uZWxzLmFkZChleGlzdGluZyk7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbm5lbCA9IENoYW5uZWwuY3JlYXRlKHRoaXMuY2xpZW50LCBkYXRhLCBndWlsZCk7XG5cbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHRoaXMuY2xpZW50LmVtaXQoRXZlbnRzLkRFQlVHLCBgRmFpbGVkIHRvIGZpbmQgZ3VpbGQsIG9yIHVua25vd24gdHlwZSBmb3IgY2hhbm5lbCAke2RhdGEuaWR9ICR7ZGF0YS50eXBlfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlKSB0aGlzLmNhY2hlLnNldChjaGFubmVsLmlkLCBjaGFubmVsKTtcblxuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG5cbiAgcmVtb3ZlKGlkKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoY2hhbm5lbC5ndWlsZCkgY2hhbm5lbC5ndWlsZC5jaGFubmVscy5jYWNoZS5kZWxldGUoaWQpO1xuICAgIHRoaXMuY2FjaGUuZGVsZXRlKGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIHRoYXQgY2FuIGJlIHJlc29sdmVkIHRvIGdpdmUgYSBDaGFubmVsIG9iamVjdC4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBDaGFubmVsIG9iamVjdFxuICAgKiAqIEEgU25vd2ZsYWtlXG4gICAqIEB0eXBlZGVmIHtDaGFubmVsfFNub3dmbGFrZX0gQ2hhbm5lbFJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgQ2hhbm5lbFJlc29sdmFibGUgdG8gYSBDaGFubmVsIG9iamVjdC5cbiAgICogQG1ldGhvZCByZXNvbHZlXG4gICAqIEBtZW1iZXJvZiBDaGFubmVsTWFuYWdlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtDaGFubmVsUmVzb2x2YWJsZX0gY2hhbm5lbCBUaGUgY2hhbm5lbCByZXNvbHZhYmxlIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgez9DaGFubmVsfVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBDaGFubmVsUmVzb2x2YWJsZSB0byBhIGNoYW5uZWwgSUQgc3RyaW5nLlxuICAgKiBAbWV0aG9kIHJlc29sdmVJRFxuICAgKiBAbWVtYmVyb2YgQ2hhbm5lbE1hbmFnZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Q2hhbm5lbFJlc29sdmFibGV9IGNoYW5uZWwgVGhlIGNoYW5uZWwgcmVzb2x2YWJsZSB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIHs/U25vd2ZsYWtlfVxuICAgKi9cblxuICAvKipcbiAgICogT2J0YWlucyBhIGNoYW5uZWwgZnJvbSBEaXNjb3JkLCBvciB0aGUgY2hhbm5lbCBjYWNoZSBpZiBpdCdzIGFscmVhZHkgYXZhaWxhYmxlLlxuICAgKiBAcGFyYW0ge1Nub3dmbGFrZX0gaWQgSUQgb2YgdGhlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2FjaGU9dHJ1ZV0gV2hldGhlciB0byBjYWNoZSB0aGUgbmV3IGNoYW5uZWwgb2JqZWN0IGlmIGl0IGlzbid0IGFscmVhZHlcbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgY2hlY2sgYW5kIHJlcXVlc3QgdGhlIEFQSVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmV0Y2ggYSBjaGFubmVsIGJ5IGl0cyBpZFxuICAgKiBjbGllbnQuY2hhbm5lbHMuZmV0Y2goJzIyMjEwOTkzMDU0NTYxMDc1NCcpXG4gICAqICAgLnRoZW4oY2hhbm5lbCA9PiBjb25zb2xlLmxvZyhjaGFubmVsLm5hbWUpKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGFzeW5jIGZldGNoKGlkLCBjYWNoZSA9IHRydWUsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuZ2V0KGlkKTtcbiAgICAgIGlmIChleGlzdGluZyAmJiAhZXhpc3RpbmcucGFydGlhbCkgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkuY2hhbm5lbHMoaWQpLmdldCgpO1xuICAgIHJldHVybiB0aGlzLmFkZChkYXRhLCBudWxsLCBjYWNoZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZU1hbmFnZXIgPSByZXF1aXJlKCcuL0Jhc2VNYW5hZ2VyJyk7XG5jb25zdCBHdWlsZENoYW5uZWwgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL0d1aWxkQ2hhbm5lbCcpO1xuY29uc3QgUGVybWlzc2lvbk92ZXJ3cml0ZXMgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL1Blcm1pc3Npb25PdmVyd3JpdGVzJyk7XG5jb25zdCB7IENoYW5uZWxUeXBlcyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcblxuLyoqXG4gKiBNYW5hZ2VzIEFQSSBtZXRob2RzIGZvciBHdWlsZENoYW5uZWxzIGFuZCBzdG9yZXMgdGhlaXIgY2FjaGUuXG4gKiBAZXh0ZW5kcyB7QmFzZU1hbmFnZXJ9XG4gKi9cbmNsYXNzIEd1aWxkQ2hhbm5lbE1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGd1aWxkLCBpdGVyYWJsZSkge1xuICAgIHN1cGVyKGd1aWxkLmNsaWVudCwgaXRlcmFibGUsIEd1aWxkQ2hhbm5lbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3VpbGQgdGhpcyBNYW5hZ2VyIGJlbG9uZ3MgdG9cbiAgICAgKiBAdHlwZSB7R3VpbGR9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZCA9IGd1aWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBvZiB0aGlzIE1hbmFnZXJcbiAgICogQHR5cGUge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBHdWlsZENoYW5uZWw+fVxuICAgKiBAbmFtZSBHdWlsZENoYW5uZWxNYW5hZ2VyI2NhY2hlXG4gICAqL1xuXG4gIGFkZChjaGFubmVsKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmNhY2hlLmdldChjaGFubmVsLmlkKTtcbiAgICBpZiAoZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICB0aGlzLmNhY2hlLnNldChjaGFubmVsLmlkLCBjaGFubmVsKTtcbiAgICByZXR1cm4gY2hhbm5lbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIHRoYXQgY2FuIGJlIHJlc29sdmVkIHRvIGdpdmUgYSBHdWlsZCBDaGFubmVsIG9iamVjdC4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBHdWlsZENoYW5uZWwgb2JqZWN0XG4gICAqICogQSBTbm93Zmxha2VcbiAgICogQHR5cGVkZWYge0d1aWxkQ2hhbm5lbHxTbm93Zmxha2V9IEd1aWxkQ2hhbm5lbFJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgR3VpbGRDaGFubmVsUmVzb2x2YWJsZSB0byBhIENoYW5uZWwgb2JqZWN0LlxuICAgKiBAbWV0aG9kIHJlc29sdmVcbiAgICogQG1lbWJlcm9mIEd1aWxkQ2hhbm5lbE1hbmFnZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7R3VpbGRDaGFubmVsUmVzb2x2YWJsZX0gY2hhbm5lbCBUaGUgR3VpbGRDaGFubmVsIHJlc29sdmFibGUgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7P0d1aWxkQ2hhbm5lbH1cbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgR3VpbGRDaGFubmVsUmVzb2x2YWJsZSB0byBhIGNoYW5uZWwgSUQgc3RyaW5nLlxuICAgKiBAbWV0aG9kIHJlc29sdmVJRFxuICAgKiBAbWVtYmVyb2YgR3VpbGRDaGFubmVsTWFuYWdlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtHdWlsZENoYW5uZWxSZXNvbHZhYmxlfSBjaGFubmVsIFRoZSBHdWlsZENoYW5uZWwgcmVzb2x2YWJsZSB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIHs/U25vd2ZsYWtlfVxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjaGFubmVsIGluIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBjaGFubmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZT0ndGV4dCddIFRoZSB0eXBlIG9mIHRoZSBuZXcgY2hhbm5lbCwgZWl0aGVyIGB0ZXh0YCwgYHZvaWNlYCwgb3IgYGNhdGVnb3J5YFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9waWNdIFRoZSB0b3BpYyBmb3IgdGhlIG5ldyBjaGFubmVsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubnNmd10gV2hldGhlciB0aGUgbmV3IGNoYW5uZWwgaXMgbnNmd1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYml0cmF0ZV0gQml0cmF0ZSBvZiB0aGUgbmV3IGNoYW5uZWwgaW4gYml0cyAob25seSB2b2ljZSlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnVzZXJMaW1pdF0gTWF4aW11bSBhbW91bnQgb2YgdXNlcnMgYWxsb3dlZCBpbiB0aGUgbmV3IGNoYW5uZWwgKG9ubHkgdm9pY2UpXG4gICAqIEBwYXJhbSB7Q2hhbm5lbFJlc29sdmFibGV9IFtvcHRpb25zLnBhcmVudF0gUGFyZW50IG9mIHRoZSBuZXcgY2hhbm5lbFxuICAgKiBAcGFyYW0ge092ZXJ3cml0ZVJlc29sdmFibGVbXXxDb2xsZWN0aW9uPFNub3dmbGFrZSwgT3ZlcndyaXRlUmVzb2x2YWJsZT59IFtvcHRpb25zLnBlcm1pc3Npb25PdmVyd3JpdGVzXVxuICAgKiBQZXJtaXNzaW9uIG92ZXJ3cml0ZXMgb2YgdGhlIG5ldyBjaGFubmVsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvbl0gUG9zaXRpb24gb2YgdGhlIG5ldyBjaGFubmVsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yYXRlTGltaXRQZXJVc2VyXSBUaGUgcmF0ZWxpbWl0IHBlciB1c2VyIGZvciB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVhc29uXSBSZWFzb24gZm9yIGNyZWF0aW5nIHRoZSBjaGFubmVsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkQ2hhbm5lbD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBhIG5ldyB0ZXh0IGNoYW5uZWxcbiAgICogZ3VpbGQuY2hhbm5lbHMuY3JlYXRlKCduZXctZ2VuZXJhbCcsIHsgcmVhc29uOiAnTmVlZGVkIGEgY29vbCBuZXcgY2hhbm5lbCcgfSlcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBhIG5ldyBjaGFubmVsIHdpdGggcGVybWlzc2lvbiBvdmVyd3JpdGVzXG4gICAqIGd1aWxkLmNoYW5uZWxzLmNyZWF0ZSgnbmV3LXZvaWNlJywge1xuICAgKiAgIHR5cGU6ICd2b2ljZScsXG4gICAqICAgcGVybWlzc2lvbk92ZXJ3cml0ZXM6IFtcbiAgICogICAgICB7XG4gICAqICAgICAgICBpZDogbWVzc2FnZS5hdXRob3IuaWQsXG4gICAqICAgICAgICBkZW55OiBbJ1ZJRVdfQ0hBTk5FTCddLFxuICAgKiAgICAgfSxcbiAgICogICBdLFxuICAgKiB9KVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB7XG4gICAgICB0eXBlLFxuICAgICAgdG9waWMsXG4gICAgICBuc2Z3LFxuICAgICAgYml0cmF0ZSxcbiAgICAgIHVzZXJMaW1pdCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBlcm1pc3Npb25PdmVyd3JpdGVzLFxuICAgICAgcG9zaXRpb24sXG4gICAgICByYXRlTGltaXRQZXJVc2VyLFxuICAgICAgcmVhc29uLFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudCA9IHRoaXMuY2xpZW50LmNoYW5uZWxzLnJlc29sdmVJRChwYXJlbnQpO1xuICAgIGlmIChwZXJtaXNzaW9uT3ZlcndyaXRlcykge1xuICAgICAgcGVybWlzc2lvbk92ZXJ3cml0ZXMgPSBwZXJtaXNzaW9uT3ZlcndyaXRlcy5tYXAobyA9PiBQZXJtaXNzaW9uT3ZlcndyaXRlcy5yZXNvbHZlKG8sIHRoaXMuZ3VpbGQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuYXBpLmd1aWxkcyh0aGlzLmd1aWxkLmlkKS5jaGFubmVscy5wb3N0KHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdG9waWMsXG4gICAgICAgIHR5cGU6IHR5cGUgPyBDaGFubmVsVHlwZXNbdHlwZS50b1VwcGVyQ2FzZSgpXSA6IENoYW5uZWxUeXBlcy5URVhULFxuICAgICAgICBuc2Z3LFxuICAgICAgICBiaXRyYXRlLFxuICAgICAgICB1c2VyX2xpbWl0OiB1c2VyTGltaXQsXG4gICAgICAgIHBhcmVudF9pZDogcGFyZW50LFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgcGVybWlzc2lvbl9vdmVyd3JpdGVzOiBwZXJtaXNzaW9uT3ZlcndyaXRlcyxcbiAgICAgICAgcmF0ZV9saW1pdF9wZXJfdXNlcjogcmF0ZUxpbWl0UGVyVXNlcixcbiAgICAgIH0sXG4gICAgICByZWFzb24sXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFjdGlvbnMuQ2hhbm5lbENyZWF0ZS5oYW5kbGUoZGF0YSkuY2hhbm5lbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkQ2hhbm5lbE1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9CYXNlTWFuYWdlcicpO1xuY29uc3QgeyBUeXBlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgR3VpbGRFbW9qaSA9IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvR3VpbGRFbW9qaScpO1xuY29uc3QgUmVhY3Rpb25FbW9qaSA9IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvUmVhY3Rpb25FbW9qaScpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuY29uc3QgRGF0YVJlc29sdmVyID0gcmVxdWlyZSgnLi4vdXRpbC9EYXRhUmVzb2x2ZXInKTtcbmNvbnN0IHsgcGFyc2VFbW9qaSB9ID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbi8qKlxuICogTWFuYWdlcyBBUEkgbWV0aG9kcyBmb3IgR3VpbGRFbW9qaXMgYW5kIHN0b3JlcyB0aGVpciBjYWNoZS5cbiAqIEBleHRlbmRzIHtCYXNlTWFuYWdlcn1cbiAqL1xuY2xhc3MgR3VpbGRFbW9qaU1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGd1aWxkLCBpdGVyYWJsZSkge1xuICAgIHN1cGVyKGd1aWxkLmNsaWVudCwgaXRlcmFibGUsIEd1aWxkRW1vamkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBndWlsZCB0aGlzIG1hbmFnZXIgYmVsb25ncyB0b1xuICAgICAqIEB0eXBlIHtHdWlsZH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWxkID0gZ3VpbGQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhY2hlIG9mIEd1aWxkRW1vamlzXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRFbW9qaT59XG4gICAqIEBuYW1lIEd1aWxkRW1vamlNYW5hZ2VyI2NhY2hlXG4gICAqL1xuXG4gIGFkZChkYXRhLCBjYWNoZSkge1xuICAgIHJldHVybiBzdXBlci5hZGQoZGF0YSwgY2FjaGUsIHsgZXh0cmFzOiBbdGhpcy5ndWlsZF0gfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjdXN0b20gZW1vamkgaW4gdGhlIGd1aWxkLlxuICAgKiBAcGFyYW0ge0J1ZmZlclJlc29sdmFibGV8QmFzZTY0UmVzb2x2YWJsZX0gYXR0YWNobWVudCBUaGUgaW1hZ2UgZm9yIHRoZSBlbW9qaVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBmb3IgdGhlIGVtb2ppXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBSb2xlPnxSb2xlUmVzb2x2YWJsZVtdfSBbb3B0aW9ucy5yb2xlc10gUm9sZXMgdG8gbGltaXQgdGhlIGVtb2ppIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3IgY3JlYXRpbmcgdGhlIGVtb2ppXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVtb2ppPn0gVGhlIGNyZWF0ZWQgZW1vamlcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIGEgbmV3IGVtb2ppIGZyb20gYSB1cmxcbiAgICogZ3VpbGQuZW1vamlzLmNyZWF0ZSgnaHR0cHM6Ly9pLmltZ3VyLmNvbS93M2R1UjA3LnBuZycsICdyaXAnKVxuICAgKiAgIC50aGVuKGVtb2ppID0+IGNvbnNvbGUubG9nKGBDcmVhdGVkIG5ldyBlbW9qaSB3aXRoIG5hbWUgJHtlbW9qaS5uYW1lfSFgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBhIG5ldyBlbW9qaSBmcm9tIGEgZmlsZSBvbiB5b3VyIGNvbXB1dGVyXG4gICAqIGd1aWxkLmVtb2ppcy5jcmVhdGUoJy4vbWVtZXMvYmFuYW5hLnBuZycsICdiYW5hbmEnKVxuICAgKiAgIC50aGVuKGVtb2ppID0+IGNvbnNvbGUubG9nKGBDcmVhdGVkIG5ldyBlbW9qaSB3aXRoIG5hbWUgJHtlbW9qaS5uYW1lfSFgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBhc3luYyBjcmVhdGUoYXR0YWNobWVudCwgbmFtZSwgeyByb2xlcywgcmVhc29uIH0gPSB7fSkge1xuICAgIGF0dGFjaG1lbnQgPSBhd2FpdCBEYXRhUmVzb2x2ZXIucmVzb2x2ZUltYWdlKGF0dGFjaG1lbnQpO1xuICAgIGlmICghYXR0YWNobWVudCkgdGhyb3cgbmV3IFR5cGVFcnJvcignUkVRX1JFU09VUkNFX1RZUEUnKTtcblxuICAgIGNvbnN0IGRhdGEgPSB7IGltYWdlOiBhdHRhY2htZW50LCBuYW1lIH07XG4gICAgaWYgKHJvbGVzKSB7XG4gICAgICBkYXRhLnJvbGVzID0gW107XG4gICAgICBmb3IgKGxldCByb2xlIG9mIHJvbGVzIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IHJvbGVzLnZhbHVlcygpIDogcm9sZXMpIHtcbiAgICAgICAgcm9sZSA9IHRoaXMuZ3VpbGQucm9sZXMucmVzb2x2ZShyb2xlKTtcbiAgICAgICAgaWYgKCFyb2xlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgbmV3IFR5cGVFcnJvcignSU5WQUxJRF9UWVBFJywgJ29wdGlvbnMucm9sZXMnLCAnQXJyYXkgb3IgQ29sbGVjdGlvbiBvZiBSb2xlcyBvciBTbm93Zmxha2VzJywgdHJ1ZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnJvbGVzLnB1c2gocm9sZS5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmd1aWxkLmlkKVxuICAgICAgLmVtb2ppcy5wb3N0KHsgZGF0YSwgcmVhc29uIH0pXG4gICAgICAudGhlbihlbW9qaSA9PiB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkRW1vamlDcmVhdGUuaGFuZGxlKHRoaXMuZ3VpbGQsIGVtb2ppKS5lbW9qaSk7XG4gIH1cblxuICAvKipcbiAgICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCBpbnRvIGFuIEd1aWxkRW1vamkgb2JqZWN0LiBUaGlzIGNhbiBiZTpcbiAgICogKiBBIGN1c3RvbSBlbW9qaSBJRFxuICAgKiAqIEEgR3VpbGRFbW9qaSBvYmplY3RcbiAgICogKiBBIFJlYWN0aW9uRW1vamkgb2JqZWN0XG4gICAqIEB0eXBlZGVmIHtTbm93Zmxha2V8R3VpbGRFbW9qaXxSZWFjdGlvbkVtb2ppfSBFbW9qaVJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFuIEVtb2ppUmVzb2x2YWJsZSB0byBhbiBFbW9qaSBvYmplY3QuXG4gICAqIEBwYXJhbSB7RW1vamlSZXNvbHZhYmxlfSBlbW9qaSBUaGUgRW1vamkgcmVzb2x2YWJsZSB0byBpZGVudGlmeVxuICAgKiBAcmV0dXJucyB7P0d1aWxkRW1vaml9XG4gICAqL1xuICByZXNvbHZlKGVtb2ppKSB7XG4gICAgaWYgKGVtb2ppIGluc3RhbmNlb2YgUmVhY3Rpb25FbW9qaSkgcmV0dXJuIHN1cGVyLnJlc29sdmUoZW1vamkuaWQpO1xuICAgIHJldHVybiBzdXBlci5yZXNvbHZlKGVtb2ppKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhbiBFbW9qaVJlc29sdmFibGUgdG8gYW4gRW1vamkgSUQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Vtb2ppUmVzb2x2YWJsZX0gZW1vamkgVGhlIEVtb2ppIHJlc29sdmFibGUgdG8gaWRlbnRpZnlcbiAgICogQHJldHVybnMgez9Tbm93Zmxha2V9XG4gICAqL1xuICByZXNvbHZlSUQoZW1vamkpIHtcbiAgICBpZiAoZW1vamkgaW5zdGFuY2VvZiBSZWFjdGlvbkVtb2ppKSByZXR1cm4gZW1vamkuaWQ7XG4gICAgcmV0dXJuIHN1cGVyLnJlc29sdmVJRChlbW9qaSk7XG4gIH1cblxuICAvKipcbiAgICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBnaXZlIGFuIGVtb2ppIGlkZW50aWZpZXIuIFRoaXMgY2FuIGJlOlxuICAgKiAqIFRoZSB1bmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIGFuIGVtb2ppXG4gICAqICogVGhlIGA8YTpuYW1lOmlkPmAsIGA8Om5hbWU6aWQ+YCwgYDpuYW1lOmlkYCBvciBgYTpuYW1lOmlkYCBlbW9qaSBpZGVudGlmaWVyIHN0cmluZyBvZiBhbiBlbW9qaVxuICAgKiAqIEFuIEVtb2ppUmVzb2x2YWJsZVxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfEVtb2ppUmVzb2x2YWJsZX0gRW1vamlJZGVudGlmaWVyUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYW4gRW1vamlSZXNvbHZhYmxlIHRvIGFuIGVtb2ppIGlkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7RW1vamlJZGVudGlmaWVyUmVzb2x2YWJsZX0gZW1vamkgVGhlIGVtb2ppIHJlc29sdmFibGUgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7P3N0cmluZ31cbiAgICovXG4gIHJlc29sdmVJZGVudGlmaWVyKGVtb2ppKSB7XG4gICAgY29uc3QgZW1vamlSZXNvbHZhYmxlID0gdGhpcy5yZXNvbHZlKGVtb2ppKTtcbiAgICBpZiAoZW1vamlSZXNvbHZhYmxlKSByZXR1cm4gZW1vamlSZXNvbHZhYmxlLmlkZW50aWZpZXI7XG4gICAgaWYgKGVtb2ppIGluc3RhbmNlb2YgUmVhY3Rpb25FbW9qaSkgcmV0dXJuIGVtb2ppLmlkZW50aWZpZXI7XG4gICAgaWYgKHR5cGVvZiBlbW9qaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHJlcyA9IHBhcnNlRW1vamkoZW1vamkpO1xuICAgICAgaWYgKHJlcyAmJiByZXMubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgZW1vamkgPSBgJHtyZXMuYW5pbWF0ZWQgPyAnYTonIDogJyd9JHtyZXMubmFtZX0ke3Jlcy5pZCA/IGA6JHtyZXMuaWR9YCA6ICcnfWA7XG4gICAgICB9XG4gICAgICBpZiAoIWVtb2ppLmluY2x1ZGVzKCclJykpIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZW1vamkpO1xuICAgICAgZWxzZSByZXR1cm4gZW1vamk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRFbW9qaU1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgVHlwZUVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiBNYW5hZ2VzIEFQSSBtZXRob2RzIGZvciByb2xlcyBiZWxvbmdpbmcgdG8gZW1vamlzIGFuZCBzdG9yZXMgdGhlaXIgY2FjaGUuXG4gKi9cbmNsYXNzIEd1aWxkRW1vamlSb2xlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVtb2ppKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGVtb2ppIGJlbG9uZ2luZyB0byB0aGlzIG1hbmFnZXJcbiAgICAgKiBAdHlwZSB7R3VpbGRFbW9qaX1cbiAgICAgKi9cbiAgICB0aGlzLmVtb2ppID0gZW1vamk7XG4gICAgLyoqXG4gICAgICogVGhlIGd1aWxkIGJlbG9uZ2luZyB0byB0aGlzIG1hbmFnZXJcbiAgICAgKiBAdHlwZSB7R3VpbGR9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZCA9IGVtb2ppLmd1aWxkO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgYmVsb25naW5nIHRvIHRoaXMgbWFuYWdlclxuICAgICAqIEB0eXBlIHtDbGllbnR9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjbGllbnQnLCB7IHZhbHVlOiBlbW9qaS5jbGllbnQgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZpbHRlcmVkIGNvbGxlY3Rpb24gb2Ygcm9sZXMgb2YgdGhlIGd1aWxkIGVtb2ppXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgUm9sZT59XG4gICAqIEBwcml2YXRlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IF9yb2xlcygpIHtcbiAgICByZXR1cm4gdGhpcy5ndWlsZC5yb2xlcy5jYWNoZS5maWx0ZXIocm9sZSA9PiB0aGlzLmVtb2ppLl9yb2xlcy5pbmNsdWRlcyhyb2xlLmlkKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhY2hlIG9mIHJvbGVzIGJlbG9uZ2luZyB0byB0aGlzIGVtb2ppXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgUm9sZT59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLl9yb2xlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcm9sZSAob3IgbXVsdGlwbGUgcm9sZXMpIHRvIHRoZSBsaXN0IG9mIHJvbGVzIHRoYXQgY2FuIHVzZSB0aGlzIGVtb2ppLlxuICAgKiBAcGFyYW0ge1JvbGVSZXNvbHZhYmxlfFJvbGVSZXNvbHZhYmxlW118Q29sbGVjdGlvbjxTbm93Zmxha2UsIFJvbGU+fSByb2xlT3JSb2xlcyBUaGUgcm9sZSBvciByb2xlcyB0byBhZGRcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRFbW9qaT59XG4gICAqL1xuICBhZGQocm9sZU9yUm9sZXMpIHtcbiAgICBpZiAocm9sZU9yUm9sZXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSByZXR1cm4gdGhpcy5hZGQocm9sZU9yUm9sZXMua2V5QXJyYXkoKSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJvbGVPclJvbGVzKSkgcmV0dXJuIHRoaXMuYWRkKFtyb2xlT3JSb2xlc10pO1xuICAgIHJvbGVPclJvbGVzID0gcm9sZU9yUm9sZXMubWFwKHIgPT4gdGhpcy5ndWlsZC5yb2xlcy5yZXNvbHZlKHIpKTtcblxuICAgIGlmIChyb2xlT3JSb2xlcy5pbmNsdWRlcyhudWxsKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0lOVkFMSURfVFlQRScsICdyb2xlcycsICdBcnJheSBvciBDb2xsZWN0aW9uIG9mIFJvbGVzIG9yIFNub3dmbGFrZXMnLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3Um9sZXMgPSBbLi4ubmV3IFNldChyb2xlT3JSb2xlcy5jb25jYXQoLi4udGhpcy5fcm9sZXMudmFsdWVzKCkpKV07XG4gICAgcmV0dXJuIHRoaXMuc2V0KG5ld1JvbGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcm9sZSAob3IgbXVsdGlwbGUgcm9sZXMpIGZyb20gdGhlIGxpc3Qgb2Ygcm9sZXMgdGhhdCBjYW4gdXNlIHRoaXMgZW1vamkuXG4gICAqIEBwYXJhbSB7Um9sZVJlc29sdmFibGV8Um9sZVJlc29sdmFibGVbXXxDb2xsZWN0aW9uPFNub3dmbGFrZSwgUm9sZT59IHJvbGVPclJvbGVzIFRoZSByb2xlIG9yIHJvbGVzIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZEVtb2ppPn1cbiAgICovXG4gIHJlbW92ZShyb2xlT3JSb2xlcykge1xuICAgIGlmIChyb2xlT3JSb2xlcyBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHJldHVybiB0aGlzLnJlbW92ZShyb2xlT3JSb2xlcy5rZXlBcnJheSgpKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocm9sZU9yUm9sZXMpKSByZXR1cm4gdGhpcy5yZW1vdmUoW3JvbGVPclJvbGVzXSk7XG4gICAgcm9sZU9yUm9sZXMgPSByb2xlT3JSb2xlcy5tYXAociA9PiB0aGlzLmd1aWxkLnJvbGVzLnJlc29sdmVJRChyKSk7XG5cbiAgICBpZiAocm9sZU9yUm9sZXMuaW5jbHVkZXMobnVsbCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAncm9sZXMnLCAnQXJyYXkgb3IgQ29sbGVjdGlvbiBvZiBSb2xlcyBvciBTbm93Zmxha2VzJywgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1JvbGVzID0gdGhpcy5fcm9sZXMua2V5QXJyYXkoKS5maWx0ZXIocm9sZSA9PiAhcm9sZU9yUm9sZXMuaW5jbHVkZXMocm9sZSkpO1xuICAgIHJldHVybiB0aGlzLnNldChuZXdSb2xlcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcm9sZShzKSB0aGF0IGNhbiB1c2UgdGhpcyBlbW9qaS5cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgUm9sZT58Um9sZVJlc29sdmFibGVbXX0gcm9sZXMgVGhlIHJvbGVzIG9yIHJvbGUgSURzIHRvIGFwcGx5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkRW1vamk+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIGVtb2ppJ3Mgcm9sZXMgdG8gYSBzaW5nbGUgcm9sZVxuICAgKiBndWlsZEVtb2ppLnJvbGVzLnNldChbJzM5MTE1NjU3MDQwODYxNTkzNiddKVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUmVtb3ZlIGFsbCByb2xlcyBmcm9tIGFuIGVtb2ppXG4gICAqIGd1aWxkRW1vamkucm9sZXMuc2V0KFtdKVxuICAgKiAgICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgc2V0KHJvbGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1vamkuZWRpdCh7IHJvbGVzIH0pO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmVtb2ppKTtcbiAgICBjbG9uZS5fcGF0Y2godGhpcy5fcm9sZXMua2V5QXJyYXkoKS5zbGljZSgpKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcm9sZXMgZm9yIHRoaXMgbWFuYWdlcidzIGNhY2hlXG4gICAqIEBwYXJhbSB7U25vd2ZsYWtlW119IHJvbGVzIFRoZSBuZXcgcm9sZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXRjaChyb2xlcykge1xuICAgIHRoaXMuZW1vamkuX3JvbGVzID0gcm9sZXM7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZEVtb2ppUm9sZU1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9CYXNlTWFuYWdlcicpO1xuY29uc3QgR3VpbGQgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL0d1aWxkJyk7XG5jb25zdCBHdWlsZENoYW5uZWwgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL0d1aWxkQ2hhbm5lbCcpO1xuY29uc3QgR3VpbGRFbW9qaSA9IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvR3VpbGRFbW9qaScpO1xuY29uc3QgR3VpbGRNZW1iZXIgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL0d1aWxkTWVtYmVyJyk7XG5jb25zdCBJbnZpdGUgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL0ludml0ZScpO1xuY29uc3QgUm9sZSA9IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvUm9sZScpO1xuY29uc3Qge1xuICBDaGFubmVsVHlwZXMsXG4gIEV2ZW50cyxcbiAgVmVyaWZpY2F0aW9uTGV2ZWxzLFxuICBEZWZhdWx0TWVzc2FnZU5vdGlmaWNhdGlvbnMsXG4gIEV4cGxpY2l0Q29udGVudEZpbHRlckxldmVscyxcbn0gPSByZXF1aXJlKCcuLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgRGF0YVJlc29sdmVyID0gcmVxdWlyZSgnLi4vdXRpbC9EYXRhUmVzb2x2ZXInKTtcbmNvbnN0IFBlcm1pc3Npb25zID0gcmVxdWlyZSgnLi4vdXRpbC9QZXJtaXNzaW9ucycpO1xuY29uc3QgeyByZXNvbHZlQ29sb3IgfSA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xuXG4vKipcbiAqIE1hbmFnZXMgQVBJIG1ldGhvZHMgZm9yIEd1aWxkcyBhbmQgc3RvcmVzIHRoZWlyIGNhY2hlLlxuICogQGV4dGVuZHMge0Jhc2VNYW5hZ2VyfVxuICovXG5jbGFzcyBHdWlsZE1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaXRlcmFibGUpIHtcbiAgICBzdXBlcihjbGllbnQsIGl0ZXJhYmxlLCBHdWlsZCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhY2hlIG9mIHRoaXMgTWFuYWdlclxuICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIEd1aWxkPn1cbiAgICogQG5hbWUgR3VpbGRNYW5hZ2VyI2NhY2hlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEYXRhIHRoYXQgcmVzb2x2ZXMgdG8gZ2l2ZSBhIEd1aWxkIG9iamVjdC4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBHdWlsZCBvYmplY3RcbiAgICogKiBBIEd1aWxkQ2hhbm5lbCBvYmplY3RcbiAgICogKiBBIEd1aWxkRW1vamkgb2JqZWN0XG4gICAqICogQSBSb2xlIG9iamVjdFxuICAgKiAqIEEgU25vd2ZsYWtlXG4gICAqICogQW4gSW52aXRlIG9iamVjdFxuICAgKiBAdHlwZWRlZiB7R3VpbGR8R3VpbGRDaGFubmVsfEd1aWxkTWVtYmVyfEd1aWxkRW1vaml8Um9sZXxTbm93Zmxha2V8SW52aXRlfSBHdWlsZFJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFBhcnRpYWwgZGF0YSBmb3IgYSBSb2xlLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJ0aWFsUm9sZURhdGFcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtpZF0gVGhlIElEIGZvciB0aGlzIHJvbGUsIHVzZWQgdG8gc2V0IGNoYW5uZWwgb3ZlcnJpZGVzLFxuICAgKiB0aGlzIGlzIGEgcGxhY2Vob2xkZXIgYW5kIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIEFQSSBhZnRlciBjb25zdW1wdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIFRoZSBuYW1lIG9mIHRoZSByb2xlXG4gICAqIEBwcm9wZXJ0eSB7Q29sb3JSZXNvbHZhYmxlfSBbY29sb3JdIFRoZSBjb2xvciBvZiB0aGUgcm9sZSwgZWl0aGVyIGEgaGV4IHN0cmluZyBvciBhIGJhc2UgMTAgbnVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hvaXN0XSBXaGV0aGVyIG9yIG5vdCB0aGUgcm9sZSBzaG91bGQgYmUgaG9pc3RlZFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3Bvc2l0aW9uXSBUaGUgcG9zaXRpb24gb2YgdGhlIHJvbGVcbiAgICogQHByb3BlcnR5IHtQZXJtaXNzaW9uUmVzb2x2YWJsZXxudW1iZXJ9IFtwZXJtaXNzaW9uc10gVGhlIHBlcm1pc3Npb25zIG9mIHRoZSByb2xlXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21lbnRpb25hYmxlXSBXaGV0aGVyIG9yIG5vdCB0aGUgcm9sZSBzaG91bGQgYmUgbWVudGlvbmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFBhcnRpYWwgb3ZlcndyaXRlIGRhdGEuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnRpYWxPdmVyd3JpdGVEYXRhXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfFNub3dmbGFrZX0gaWQgVGhlIFJvbGUgb3IgVXNlciBJRCBmb3IgdGhpcyBvdmVyd3JpdGVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXSBUaGUgdHlwZSBvZiB0aGlzIG92ZXJ3cml0ZVxuICAgKiBAcHJvcGVydHkge1Blcm1pc3Npb25SZXNvbHZhYmxlfSBbYWxsb3ddIFRoZSBwZXJtaXNzaW9ucyB0byBhbGxvd1xuICAgKiBAcHJvcGVydHkge1Blcm1pc3Npb25SZXNvbHZhYmxlfSBbZGVueV0gVGhlIHBlcm1pc3Npb25zIHRvIGRlbnlcbiAgICovXG5cbiAgLyoqXG4gICAqIFBhcnRpYWwgZGF0YSBmb3IgYSBDaGFubmVsLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJ0aWFsQ2hhbm5lbERhdGFcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtpZF0gVGhlIElEIGZvciB0aGlzIGNoYW5uZWwsIHVzZWQgdG8gc2V0IGl0cyBwYXJlbnQsXG4gICAqIHRoaXMgaXMgYSBwbGFjZWhvbGRlciBhbmQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgQVBJIGFmdGVyIGNvbnN1bXB0aW9uXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFyZW50SURdIFRoZSBwYXJlbnQgSUQgZm9yIHRoaXMgY2hhbm5lbFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVdIFRoZSB0eXBlIG9mIHRoZSBjaGFubmVsXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGFubmVsXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdG9waWNdIFRoZSB0b3BpYyBvZiB0aGUgdGV4dCBjaGFubmVsXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25zZnddIFdoZXRoZXIgdGhlIGNoYW5uZWwgaXMgTlNGV1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2JpdHJhdGVdIFRoZSBiaXRyYXRlIG9mIHRoZSB2b2ljZSBjaGFubmVsXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdXNlckxpbWl0XSBUaGUgdXNlciBsaW1pdCBvZiB0aGUgY2hhbm5lbFxuICAgKiBAcHJvcGVydHkge1BhcnRpYWxPdmVyd3JpdGVEYXRhfSBbcGVybWlzc2lvbk92ZXJ3cml0ZXNdXG4gICAqIE92ZXJ3cml0ZXMgb2YgdGhlIGNoYW5uZWxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYXRlTGltaXRQZXJVc2VyXSBUaGUgcmF0ZSBsaW1pdCBwZXIgdXNlciBvZiB0aGUgY2hhbm5lbCBpbiBzZWNvbmRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIEd1aWxkUmVzb2x2YWJsZSB0byBhIEd1aWxkIG9iamVjdC5cbiAgICogQG1ldGhvZCByZXNvbHZlXG4gICAqIEBtZW1iZXJvZiBHdWlsZE1hbmFnZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7R3VpbGRSZXNvbHZhYmxlfSBndWlsZCBUaGUgZ3VpbGQgcmVzb2x2YWJsZSB0byBpZGVudGlmeVxuICAgKiBAcmV0dXJucyB7P0d1aWxkfVxuICAgKi9cbiAgcmVzb2x2ZShndWlsZCkge1xuICAgIGlmIChcbiAgICAgIGd1aWxkIGluc3RhbmNlb2YgR3VpbGRDaGFubmVsIHx8XG4gICAgICBndWlsZCBpbnN0YW5jZW9mIEd1aWxkTWVtYmVyIHx8XG4gICAgICBndWlsZCBpbnN0YW5jZW9mIEd1aWxkRW1vamkgfHxcbiAgICAgIGd1aWxkIGluc3RhbmNlb2YgUm9sZSB8fFxuICAgICAgKGd1aWxkIGluc3RhbmNlb2YgSW52aXRlICYmIGd1aWxkLmd1aWxkKVxuICAgICkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlc29sdmUoZ3VpbGQuZ3VpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucmVzb2x2ZShndWlsZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBHdWlsZFJlc29sdmFibGUgdG8gYSBHdWlsZCBJRCBzdHJpbmcuXG4gICAqIEBtZXRob2QgcmVzb2x2ZUlEXG4gICAqIEBtZW1iZXJvZiBHdWlsZE1hbmFnZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7R3VpbGRSZXNvbHZhYmxlfSBndWlsZCBUaGUgZ3VpbGQgcmVzb2x2YWJsZSB0byBpZGVudGlmeVxuICAgKiBAcmV0dXJucyB7P1Nub3dmbGFrZX1cbiAgICovXG4gIHJlc29sdmVJRChndWlsZCkge1xuICAgIGlmIChcbiAgICAgIGd1aWxkIGluc3RhbmNlb2YgR3VpbGRDaGFubmVsIHx8XG4gICAgICBndWlsZCBpbnN0YW5jZW9mIEd1aWxkTWVtYmVyIHx8XG4gICAgICBndWlsZCBpbnN0YW5jZW9mIEd1aWxkRW1vamkgfHxcbiAgICAgIGd1aWxkIGluc3RhbmNlb2YgUm9sZSB8fFxuICAgICAgKGd1aWxkIGluc3RhbmNlb2YgSW52aXRlICYmIGd1aWxkLmd1aWxkKVxuICAgICkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlc29sdmVJRChndWlsZC5ndWlsZC5pZCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5yZXNvbHZlSUQoZ3VpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBndWlsZC5cbiAgICogPHdhcm4+VGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB0byBib3RzIGluIGZld2VyIHRoYW4gMTAgZ3VpbGRzLjwvd2Fybj5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGd1aWxkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGNyZWF0aW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hZmtDaGFubmVsSURdIFRoZSBJRCBvZiB0aGUgQUZLIGNoYW5uZWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFma1RpbWVvdXRdIFRoZSBBRksgdGltZW91dCBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7UGFydGlhbENoYW5uZWxEYXRhW119IFtvcHRpb25zLmNoYW5uZWxzXSBUaGUgY2hhbm5lbHMgZm9yIHRoaXMgZ3VpbGRcbiAgICogQHBhcmFtIHtEZWZhdWx0TWVzc2FnZU5vdGlmaWNhdGlvbnN9IFtvcHRpb25zLmRlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9uc10gVGhlIGRlZmF1bHQgbWVzc2FnZSBub3RpZmljYXRpb25zXG4gICAqIGZvciB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtFeHBsaWNpdENvbnRlbnRGaWx0ZXJMZXZlbH0gW29wdGlvbnMuZXhwbGljaXRDb250ZW50RmlsdGVyXSBUaGUgZXhwbGljaXQgY29udGVudCBmaWx0ZXIgbGV2ZWwgZm9yIHRoZSBndWlsZFxuICAgKiBAcGFyYW0ge0J1ZmZlclJlc29sdmFibGV8QmFzZTY0UmVzb2x2YWJsZX0gW29wdGlvbnMuaWNvbj1udWxsXSBUaGUgaWNvbiBmb3IgdGhlIGd1aWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWdpb25dIFRoZSByZWdpb24gZm9yIHRoZSBzZXJ2ZXIsIGRlZmF1bHRzIHRvIHRoZSBjbG9zZXN0IG9uZSBhdmFpbGFibGVcbiAgICogQHBhcmFtIHtQYXJ0aWFsUm9sZURhdGFbXX0gW29wdGlvbnMucm9sZXNdIFRoZSByb2xlcyBmb3IgdGhpcyBndWlsZCxcbiAgICogdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhpcyBhcnJheSBpcyB1c2VkIHRvIGNoYW5nZSBwcm9wZXJ0aWVzIG9mIHRoZSBndWlsZCdzIGV2ZXJ5b25lIHJvbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zeXN0ZW1DaGFubmVsSURdIFRoZSBJRCBvZiB0aGUgc3lzdGVtIGNoYW5uZWxcbiAgICogQHBhcmFtIHtWZXJpZmljYXRpb25MZXZlbH0gW29wdGlvbnMudmVyaWZpY2F0aW9uTGV2ZWxdIFRoZSB2ZXJpZmljYXRpb24gbGV2ZWwgZm9yIHRoZSBndWlsZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59IFRoZSBndWlsZCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqL1xuICBhc3luYyBjcmVhdGUoXG4gICAgbmFtZSxcbiAgICB7XG4gICAgICBhZmtDaGFubmVsSUQsXG4gICAgICBhZmtUaW1lb3V0LFxuICAgICAgY2hhbm5lbHMgPSBbXSxcbiAgICAgIGRlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9ucyxcbiAgICAgIGV4cGxpY2l0Q29udGVudEZpbHRlcixcbiAgICAgIGljb24gPSBudWxsLFxuICAgICAgcmVnaW9uLFxuICAgICAgcm9sZXMgPSBbXSxcbiAgICAgIHN5c3RlbUNoYW5uZWxJRCxcbiAgICAgIHZlcmlmaWNhdGlvbkxldmVsLFxuICAgIH0gPSB7fSxcbiAgKSB7XG4gICAgaWNvbiA9IGF3YWl0IERhdGFSZXNvbHZlci5yZXNvbHZlSW1hZ2UoaWNvbik7XG4gICAgaWYgKHR5cGVvZiB2ZXJpZmljYXRpb25MZXZlbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZlcmlmaWNhdGlvbkxldmVsICE9PSAnbnVtYmVyJykge1xuICAgICAgdmVyaWZpY2F0aW9uTGV2ZWwgPSBWZXJpZmljYXRpb25MZXZlbHMuaW5kZXhPZih2ZXJpZmljYXRpb25MZXZlbCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zICE9PSAnbnVtYmVyJykge1xuICAgICAgZGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zID0gRGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zLmluZGV4T2YoZGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHBsaWNpdENvbnRlbnRGaWx0ZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBsaWNpdENvbnRlbnRGaWx0ZXIgIT09ICdudW1iZXInKSB7XG4gICAgICBleHBsaWNpdENvbnRlbnRGaWx0ZXIgPSBFeHBsaWNpdENvbnRlbnRGaWx0ZXJMZXZlbHMuaW5kZXhPZihleHBsaWNpdENvbnRlbnRGaWx0ZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgY2hhbm5lbHMpIHtcbiAgICAgIGlmIChjaGFubmVsLnR5cGUpIGNoYW5uZWwudHlwZSA9IENoYW5uZWxUeXBlc1tjaGFubmVsLnR5cGUudG9VcHBlckNhc2UoKV07XG4gICAgICBjaGFubmVsLnBhcmVudF9pZCA9IGNoYW5uZWwucGFyZW50SUQ7XG4gICAgICBkZWxldGUgY2hhbm5lbC5wYXJlbnRJRDtcbiAgICAgIGlmICghY2hhbm5lbC5wZXJtaXNzaW9uT3ZlcndyaXRlcykgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IG92ZXJ3cml0ZSBvZiBjaGFubmVsLnBlcm1pc3Npb25PdmVyd3JpdGVzKSB7XG4gICAgICAgIGlmIChvdmVyd3JpdGUuYWxsb3cpIG92ZXJ3cml0ZS5hbGxvdyA9IFBlcm1pc3Npb25zLnJlc29sdmUob3ZlcndyaXRlLmFsbG93KTtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZS5kZW55KSBvdmVyd3JpdGUuZGVueSA9IFBlcm1pc3Npb25zLnJlc29sdmUob3ZlcndyaXRlLmRlbnkpO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5wZXJtaXNzaW9uX292ZXJ3cml0ZXMgPSBjaGFubmVsLnBlcm1pc3Npb25PdmVyd3JpdGVzO1xuICAgICAgZGVsZXRlIGNoYW5uZWwucGVybWlzc2lvbk92ZXJ3cml0ZXM7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgcm9sZSBvZiByb2xlcykge1xuICAgICAgaWYgKHJvbGUuY29sb3IpIHJvbGUuY29sb3IgPSByZXNvbHZlQ29sb3Iocm9sZS5jb2xvcik7XG4gICAgICBpZiAocm9sZS5wZXJtaXNzaW9ucykgcm9sZS5wZXJtaXNzaW9ucyA9IFBlcm1pc3Npb25zLnJlc29sdmUocm9sZS5wZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgdGhpcy5jbGllbnQuYXBpLmd1aWxkc1xuICAgICAgICAucG9zdCh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHJlZ2lvbixcbiAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25fbGV2ZWw6IHZlcmlmaWNhdGlvbkxldmVsLFxuICAgICAgICAgICAgZGVmYXVsdF9tZXNzYWdlX25vdGlmaWNhdGlvbnM6IGRlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgIGV4cGxpY2l0X2NvbnRlbnRfZmlsdGVyOiBleHBsaWNpdENvbnRlbnRGaWx0ZXIsXG4gICAgICAgICAgICByb2xlcyxcbiAgICAgICAgICAgIGNoYW5uZWxzLFxuICAgICAgICAgICAgYWZrX2NoYW5uZWxfaWQ6IGFma0NoYW5uZWxJRCxcbiAgICAgICAgICAgIGFma190aW1lb3V0OiBhZmtUaW1lb3V0LFxuICAgICAgICAgICAgc3lzdGVtX2NoYW5uZWxfaWQ6IHN5c3RlbUNoYW5uZWxJRCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5jbGllbnQuZ3VpbGRzLmNhY2hlLmhhcyhkYXRhLmlkKSkgcmV0dXJuIHJlc29sdmUodGhpcy5jbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmlkKSk7XG5cbiAgICAgICAgICBjb25zdCBoYW5kbGVHdWlsZCA9IGd1aWxkID0+IHtcbiAgICAgICAgICAgIGlmIChndWlsZC5pZCA9PT0gZGF0YS5pZCkge1xuICAgICAgICAgICAgICB0aGlzLmNsaWVudC5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHRoaXMuY2xpZW50LnJlbW92ZUxpc3RlbmVyKEV2ZW50cy5HVUlMRF9DUkVBVEUsIGhhbmRsZUd1aWxkKTtcbiAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGVjcmVtZW50TWF4TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZ3VpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5jbGllbnQuaW5jcmVtZW50TWF4TGlzdGVuZXJzKCk7XG4gICAgICAgICAgdGhpcy5jbGllbnQub24oRXZlbnRzLkdVSUxEX0NSRUFURSwgaGFuZGxlR3VpbGQpO1xuXG4gICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuY2xpZW50LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQucmVtb3ZlTGlzdGVuZXIoRXZlbnRzLkdVSUxEX0NSRUFURSwgaGFuZGxlR3VpbGQpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuZGVjcmVtZW50TWF4TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuY2xpZW50Lmd1aWxkcy5hZGQoZGF0YSkpO1xuICAgICAgICAgIH0sIDEwMDAwKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LCByZWplY3QpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogT2J0YWlucyBhIGd1aWxkIGZyb20gRGlzY29yZCwgb3IgdGhlIGd1aWxkIGNhY2hlIGlmIGl0J3MgYWxyZWFkeSBhdmFpbGFibGUuXG4gICAqIEBwYXJhbSB7U25vd2ZsYWtlfSBpZCBJRCBvZiB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2FjaGU9dHJ1ZV0gV2hldGhlciB0byBjYWNoZSB0aGUgbmV3IGd1aWxkIG9iamVjdCBpZiBpdCBpc24ndCBhbHJlYWR5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIGNoZWNrIGFuZCByZXF1ZXN0IHRoZSBBUElcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGZXRjaCBhIGd1aWxkIGJ5IGl0cyBpZFxuICAgKiBjbGllbnQuZ3VpbGRzLmZldGNoKCcyMjIwNzgxMDg5Nzc1OTQzNjgnKVxuICAgKiAgIC50aGVuKGd1aWxkID0+IGNvbnNvbGUubG9nKGd1aWxkLm5hbWUpKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGFzeW5jIGZldGNoKGlkLCBjYWNoZSA9IHRydWUsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuZ2V0KGlkKTtcbiAgICAgIGlmIChleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkuZ3VpbGRzKGlkKS5nZXQoeyBxdWVyeTogeyB3aXRoX2NvdW50czogdHJ1ZSB9IH0pO1xuICAgIHJldHVybiB0aGlzLmFkZChkYXRhLCBjYWNoZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZE1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9CYXNlTWFuYWdlcicpO1xuY29uc3QgeyBFcnJvciwgVHlwZUVycm9yLCBSYW5nZUVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEd1aWxkTWVtYmVyID0gcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9HdWlsZE1lbWJlcicpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuY29uc3QgeyBFdmVudHMsIE9QQ29kZXMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5jb25zdCBTbm93Zmxha2VVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9Tbm93Zmxha2UnKTtcblxuLyoqXG4gKiBNYW5hZ2VzIEFQSSBtZXRob2RzIGZvciBHdWlsZE1lbWJlcnMgYW5kIHN0b3JlcyB0aGVpciBjYWNoZS5cbiAqIEBleHRlbmRzIHtCYXNlTWFuYWdlcn1cbiAqL1xuY2xhc3MgR3VpbGRNZW1iZXJNYW5hZ2VyIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihndWlsZCwgaXRlcmFibGUpIHtcbiAgICBzdXBlcihndWlsZC5jbGllbnQsIGl0ZXJhYmxlLCBHdWlsZE1lbWJlcik7XG4gICAgLyoqXG4gICAgICogVGhlIGd1aWxkIHRoaXMgbWFuYWdlciBiZWxvbmdzIHRvXG4gICAgICogQHR5cGUge0d1aWxkfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpbGQgPSBndWlsZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FjaGUgb2YgdGhpcyBNYW5hZ2VyXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRNZW1iZXI+fVxuICAgKiBAbmFtZSBHdWlsZE1lbWJlck1hbmFnZXIjY2FjaGVcbiAgICovXG5cbiAgYWRkKGRhdGEsIGNhY2hlID0gdHJ1ZSkge1xuICAgIHJldHVybiBzdXBlci5hZGQoZGF0YSwgY2FjaGUsIHsgaWQ6IGRhdGEudXNlci5pZCwgZXh0cmFzOiBbdGhpcy5ndWlsZF0gfSk7XG4gIH1cblxuICAvKipcbiAgICogRGF0YSB0aGF0IHJlc29sdmVzIHRvIGdpdmUgYSBHdWlsZE1lbWJlciBvYmplY3QuIFRoaXMgY2FuIGJlOlxuICAgKiAqIEEgR3VpbGRNZW1iZXIgb2JqZWN0XG4gICAqICogQSBVc2VyIHJlc29sdmFibGVcbiAgICogQHR5cGVkZWYge0d1aWxkTWVtYmVyfFVzZXJSZXNvbHZhYmxlfSBHdWlsZE1lbWJlclJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgR3VpbGRNZW1iZXJSZXNvbHZhYmxlIHRvIGEgR3VpbGRNZW1iZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge0d1aWxkTWVtYmVyUmVzb2x2YWJsZX0gbWVtYmVyIFRoZSB1c2VyIHRoYXQgaXMgcGFydCBvZiB0aGUgZ3VpbGRcbiAgICogQHJldHVybnMgez9HdWlsZE1lbWJlcn1cbiAgICovXG4gIHJlc29sdmUobWVtYmVyKSB7XG4gICAgY29uc3QgbWVtYmVyUmVzb2x2YWJsZSA9IHN1cGVyLnJlc29sdmUobWVtYmVyKTtcbiAgICBpZiAobWVtYmVyUmVzb2x2YWJsZSkgcmV0dXJuIG1lbWJlclJlc29sdmFibGU7XG4gICAgY29uc3QgdXNlclJlc29sdmFibGUgPSB0aGlzLmNsaWVudC51c2Vycy5yZXNvbHZlSUQobWVtYmVyKTtcbiAgICBpZiAodXNlclJlc29sdmFibGUpIHJldHVybiBzdXBlci5yZXNvbHZlKHVzZXJSZXNvbHZhYmxlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIEd1aWxkTWVtYmVyUmVzb2x2YWJsZSB0byBhIG1lbWJlciBJRCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7R3VpbGRNZW1iZXJSZXNvbHZhYmxlfSBtZW1iZXIgVGhlIHVzZXIgdGhhdCBpcyBwYXJ0IG9mIHRoZSBndWlsZFxuICAgKiBAcmV0dXJucyB7P1Nub3dmbGFrZX1cbiAgICovXG4gIHJlc29sdmVJRChtZW1iZXIpIHtcbiAgICBjb25zdCBtZW1iZXJSZXNvbHZhYmxlID0gc3VwZXIucmVzb2x2ZUlEKG1lbWJlcik7XG4gICAgaWYgKG1lbWJlclJlc29sdmFibGUpIHJldHVybiBtZW1iZXJSZXNvbHZhYmxlO1xuICAgIGNvbnN0IHVzZXJSZXNvbHZhYmxlID0gdGhpcy5jbGllbnQudXNlcnMucmVzb2x2ZUlEKG1lbWJlcik7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKHVzZXJSZXNvbHZhYmxlKSA/IHVzZXJSZXNvbHZhYmxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25zIHVzZWQgdG8gZmV0Y2ggYSBzaW5nbGUgbWVtYmVyIGZyb20gYSBndWlsZC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gRmV0Y2hNZW1iZXJPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7VXNlclJlc29sdmFibGV9IHVzZXIgVGhlIHVzZXIgdG8gZmV0Y2hcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2FjaGU9dHJ1ZV0gV2hldGhlciBvciBub3QgdG8gY2FjaGUgdGhlIGZldGNoZWQgbWVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIGNoZWNrIGFuZCByZXF1ZXN0IHRoZSBBUElcbiAgICovXG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgdXNlZCB0byBmZXRjaCBtdWx0aXBsZSBtZW1iZXJzIGZyb20gYSBndWlsZC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gRmV0Y2hNZW1iZXJzT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1VzZXJSZXNvbHZhYmxlfFVzZXJSZXNvbHZhYmxlW119IHVzZXIgVGhlIHVzZXIocykgdG8gZmV0Y2hcbiAgICogQHByb3BlcnR5IHs/c3RyaW5nfSBxdWVyeSBMaW1pdCBmZXRjaCB0byBtZW1iZXJzIHdpdGggc2ltaWxhciB1c2VybmFtZXNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtsaW1pdD0wXSBNYXhpbXVtIG51bWJlciBvZiBtZW1iZXJzIHRvIHJlcXVlc3RcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbd2l0aFByZXNlbmNlcz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0aGUgcHJlc2VuY2VzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZT0xMjBlM10gVGltZW91dCBmb3IgcmVjZWlwdCBvZiBtZW1iZXJzXG4gICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbm9uY2UgTm9uY2UgZm9yIHRoaXMgcmVxdWVzdCAoMzIgY2hhcmFjdGVycyBtYXggLSBkZWZhdWx0IHRvIGJhc2UgMTYgbm93IHRpbWVzdGFtcClcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgY2hlY2sgYW5kIHJlcXVlc3QgdGhlIEFQSVxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2hlcyBtZW1iZXIocykgZnJvbSBEaXNjb3JkLCBldmVuIGlmIHRoZXkncmUgb2ZmbGluZS5cbiAgICogQHBhcmFtIHtVc2VyUmVzb2x2YWJsZXxGZXRjaE1lbWJlck9wdGlvbnN8RmV0Y2hNZW1iZXJzT3B0aW9uc30gW29wdGlvbnNdIElmIGEgVXNlclJlc29sdmFibGUsIHRoZSB1c2VyIHRvIGZldGNoLlxuICAgKiBJZiB1bmRlZmluZWQsIGZldGNoZXMgYWxsIG1lbWJlcnMuXG4gICAqIElmIGEgcXVlcnksIGl0IGxpbWl0cyB0aGUgcmVzdWx0cyB0byB1c2VycyB3aXRoIHNpbWlsYXIgdXNlcm5hbWVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZE1lbWJlcj58UHJvbWlzZTxDb2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRNZW1iZXI+Pn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmV0Y2ggYWxsIG1lbWJlcnMgZnJvbSBhIGd1aWxkXG4gICAqIGd1aWxkLm1lbWJlcnMuZmV0Y2goKVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmV0Y2ggYSBzaW5nbGUgbWVtYmVyXG4gICAqIGd1aWxkLm1lbWJlcnMuZmV0Y2goJzY2NTY0NTk3NDgxNDgwMTkyJylcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZldGNoIGEgc2luZ2xlIG1lbWJlciB3aXRob3V0IGNoZWNraW5nIGNhY2hlXG4gICAqIGd1aWxkLm1lbWJlcnMuZmV0Y2goeyB1c2VyLCBmb3JjZTogdHJ1ZSB9KVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGZXRjaCBhIHNpbmdsZSBtZW1iZXIgd2l0aG91dCBjYWNoaW5nXG4gICAqIGd1aWxkLm1lbWJlcnMuZmV0Y2goeyB1c2VyLCBjYWNoZTogZmFsc2UgfSlcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZldGNoIGJ5IGFuIGFycmF5IG9mIHVzZXJzIGluY2x1ZGluZyB0aGVpciBwcmVzZW5jZXNcbiAgICogZ3VpbGQubWVtYmVycy5mZXRjaCh7IHVzZXI6IFsnNjY1NjQ1OTc0ODE0ODAxOTInLCAnMTkxNjE1OTI1MzM2NjcwMjA4J10sIHdpdGhQcmVzZW5jZXM6IHRydWUgfSlcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZldGNoIGJ5IHF1ZXJ5XG4gICAqIGd1aWxkLm1lbWJlcnMuZmV0Y2goeyBxdWVyeTogJ2h5ZHJhJywgbGltaXQ6IDEgfSlcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm4gdGhpcy5fZmV0Y2hNYW55KCk7XG4gICAgY29uc3QgdXNlciA9IHRoaXMuY2xpZW50LnVzZXJzLnJlc29sdmVJRChvcHRpb25zKTtcbiAgICBpZiAodXNlcikgcmV0dXJuIHRoaXMuX2ZldGNoU2luZ2xlKHsgdXNlciwgY2FjaGU6IHRydWUgfSk7XG4gICAgaWYgKG9wdGlvbnMudXNlcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51c2VyKSkge1xuICAgICAgICBvcHRpb25zLnVzZXIgPSBvcHRpb25zLnVzZXIubWFwKHUgPT4gdGhpcy5jbGllbnQudXNlcnMucmVzb2x2ZUlEKHUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoTWFueShvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMudXNlciA9IHRoaXMuY2xpZW50LnVzZXJzLnJlc29sdmVJRChvcHRpb25zLnVzZXIpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLmxpbWl0ICYmICFvcHRpb25zLndpdGhQcmVzZW5jZXMpIHJldHVybiB0aGlzLl9mZXRjaFNpbmdsZShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoTWFueShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcnVuZXMgbWVtYmVycyBmcm9tIHRoZSBndWlsZCBiYXNlZCBvbiBob3cgbG9uZyB0aGV5IGhhdmUgYmVlbiBpbmFjdGl2ZS5cbiAgICogPGluZm8+SXQncyByZWNvbW1lbmRlZCB0byBzZXQgb3B0aW9ucy5jb3VudCB0byBgZmFsc2VgIGZvciBsYXJnZSBndWlsZHMuPC9pbmZvPlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFBydW5lIG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRheXM9N10gTnVtYmVyIG9mIGRheXMgb2YgaW5hY3Rpdml0eSByZXF1aXJlZCB0byBraWNrXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZHJ5PWZhbHNlXSBHZXQgbnVtYmVyIG9mIHVzZXJzIHRoYXQgd2lsbCBiZSBraWNrZWQsIHdpdGhvdXQgYWN0dWFsbHkga2lja2luZyB0aGVtXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY291bnQ9dHJ1ZV0gV2hldGhlciBvciBub3QgdG8gcmV0dXJuIHRoZSBudW1iZXIgb2YgdXNlcnMgdGhhdCBoYXZlIGJlZW4ga2lja2VkLlxuICAgKiBAcGFyYW0ge1JvbGVSZXNvbHZhYmxlW119IFtvcHRpb25zLnJvbGVzPVtdXSBBcnJheSBvZiByb2xlcyB0byBieXBhc3MgdGhlIFwiLi4uYW5kIG5vIHJvbGVzXCIgY29uc3RyYWludCB3aGVuIHBydW5pbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciB0aGlzIHBydW5lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcnxudWxsPn0gVGhlIG51bWJlciBvZiBtZW1iZXJzIHRoYXQgd2VyZS93aWxsIGJlIGtpY2tlZFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZWUgaG93IG1hbnkgbWVtYmVycyB3aWxsIGJlIHBydW5lZFxuICAgKiBndWlsZC5tZW1iZXJzLnBydW5lKHsgZHJ5OiB0cnVlIH0pXG4gICAqICAgLnRoZW4ocHJ1bmVkID0+IGNvbnNvbGUubG9nKGBUaGlzIHdpbGwgcHJ1bmUgJHtwcnVuZWR9IHBlb3BsZSFgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEFjdHVhbGx5IHBydW5lIHRoZSBtZW1iZXJzXG4gICAqIGd1aWxkLm1lbWJlcnMucHJ1bmUoeyBkYXlzOiAxLCByZWFzb246ICd0b28gbWFueSBwZW9wbGUhJyB9KVxuICAgKiAgIC50aGVuKHBydW5lZCA9PiBjb25zb2xlLmxvZyhgSSBqdXN0IHBydW5lZCAke3BydW5lZH0gcGVvcGxlIWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gSW5jbHVkZSBtZW1iZXJzIHdpdGggYSBzcGVjaWZpZWQgcm9sZVxuICAgKiBndWlsZC5tZW1iZXJzLnBydW5lKHsgZGF5czogNywgcm9sZXM6IFsnNjU3MjU5MzkxNjUyODU1ODA4J10gfSlcbiAgICogICAgLnRoZW4ocHJ1bmVkID0+IGNvbnNvbGUubG9nKGBJIGp1c3QgcHJ1bmVkICR7cHJ1bmVkfSBwZW9wbGUhYCkpXG4gICAqICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHBydW5lKHsgZGF5cyA9IDcsIGRyeSA9IGZhbHNlLCBjb3VudDogY29tcHV0ZV9wcnVuZV9jb3VudCA9IHRydWUsIHJvbGVzID0gW10sIHJlYXNvbiB9ID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGRheXMgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQUlVORV9EQVlTX1RZUEUnKTtcblxuICAgIGNvbnN0IHF1ZXJ5ID0geyBkYXlzIH07XG4gICAgY29uc3QgcmVzb2x2ZWRSb2xlcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCByb2xlIG9mIHJvbGVzKSB7XG4gICAgICBjb25zdCByZXNvbHZlZFJvbGUgPSB0aGlzLmd1aWxkLnJvbGVzLnJlc29sdmVJRChyb2xlKTtcbiAgICAgIGlmICghcmVzb2x2ZWRSb2xlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAncm9sZXMnLCAnQXJyYXkgb2YgUm9sZXMgb3IgU25vd2ZsYWtlcycsIHRydWUpKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkUm9sZXMucHVzaChyZXNvbHZlZFJvbGUpO1xuICAgIH1cblxuICAgIGlmIChyZXNvbHZlZFJvbGVzLmxlbmd0aCkge1xuICAgICAgcXVlcnkuaW5jbHVkZV9yb2xlcyA9IGRyeSA/IHJlc29sdmVkUm9sZXMuam9pbignLCcpIDogcmVzb2x2ZWRSb2xlcztcbiAgICB9XG5cbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuY2xpZW50LmFwaS5ndWlsZHModGhpcy5ndWlsZC5pZCkucHJ1bmU7XG5cbiAgICBpZiAoZHJ5KSB7XG4gICAgICByZXR1cm4gZW5kcG9pbnQuZ2V0KHsgcXVlcnksIHJlYXNvbiB9KS50aGVuKGRhdGEgPT4gZGF0YS5wcnVuZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmRwb2ludFxuICAgICAgLnBvc3Qoe1xuICAgICAgICBkYXRhOiB7IC4uLnF1ZXJ5LCBjb21wdXRlX3BydW5lX2NvdW50IH0sXG4gICAgICAgIHJlYXNvbixcbiAgICAgIH0pXG4gICAgICAudGhlbihkYXRhID0+IGRhdGEucHJ1bmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYW5zIGEgdXNlciBmcm9tIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtVc2VyUmVzb2x2YWJsZX0gdXNlciBUaGUgdXNlciB0byBiYW5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgYmFuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYXlzPTBdIE51bWJlciBvZiBkYXlzIG9mIG1lc3NhZ2VzIHRvIGRlbGV0ZSwgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciBiYW5uaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkTWVtYmVyfFVzZXJ8U25vd2ZsYWtlPn0gUmVzdWx0IG9iamVjdCB3aWxsIGJlIHJlc29sdmVkIGFzIHNwZWNpZmljYWxseSBhcyBwb3NzaWJsZS5cbiAgICogSWYgdGhlIEd1aWxkTWVtYmVyIGNhbm5vdCBiZSByZXNvbHZlZCwgdGhlIFVzZXIgd2lsbCBpbnN0ZWFkIGJlIGF0dGVtcHRlZCB0byBiZSByZXNvbHZlZC4gSWYgdGhhdCBhbHNvIGNhbm5vdFxuICAgKiBiZSByZXNvbHZlZCwgdGhlIHVzZXIgSUQgd2lsbCBiZSB0aGUgcmVzdWx0LlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBCYW4gYSB1c2VyIGJ5IElEIChvciB3aXRoIGEgdXNlci9ndWlsZCBtZW1iZXIgb2JqZWN0KVxuICAgKiBndWlsZC5tZW1iZXJzLmJhbignODQ0ODQ2NTM2ODcyNjczMjgnKVxuICAgKiAgIC50aGVuKHVzZXIgPT4gY29uc29sZS5sb2coYEJhbm5lZCAke3VzZXIudXNlcm5hbWUgfHwgdXNlci5pZCB8fCB1c2VyfSBmcm9tICR7Z3VpbGQubmFtZX1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBiYW4odXNlciwgb3B0aW9ucyA9IHsgZGF5czogMCB9KSB7XG4gICAgaWYgKG9wdGlvbnMuZGF5cykgb3B0aW9ucy5kZWxldGVfbWVzc2FnZV9kYXlzID0gb3B0aW9ucy5kYXlzO1xuICAgIGNvbnN0IGlkID0gdGhpcy5jbGllbnQudXNlcnMucmVzb2x2ZUlEKHVzZXIpO1xuICAgIGlmICghaWQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0JBTl9SRVNPTFZFX0lEJywgdHJ1ZSkpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5ndWlsZC5pZClcbiAgICAgIC5iYW5zW2lkXS5wdXQoeyBkYXRhOiBvcHRpb25zIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh1c2VyIGluc3RhbmNlb2YgR3VpbGRNZW1iZXIpIHJldHVybiB1c2VyO1xuICAgICAgICBjb25zdCBfdXNlciA9IHRoaXMuY2xpZW50LnVzZXJzLnJlc29sdmUoaWQpO1xuICAgICAgICBpZiAoX3VzZXIpIHtcbiAgICAgICAgICBjb25zdCBtZW1iZXIgPSB0aGlzLnJlc29sdmUoX3VzZXIpO1xuICAgICAgICAgIHJldHVybiBtZW1iZXIgfHwgX3VzZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5iYW5zIGEgdXNlciBmcm9tIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtVc2VyUmVzb2x2YWJsZX0gdXNlciBUaGUgdXNlciB0byB1bmJhblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciB1bmJhbm5pbmcgdXNlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gVW5iYW4gYSB1c2VyIGJ5IElEIChvciB3aXRoIGEgdXNlci9ndWlsZCBtZW1iZXIgb2JqZWN0KVxuICAgKiBndWlsZC5tZW1iZXJzLnVuYmFuKCc4NDQ4NDY1MzY4NzI2NzMyOCcpXG4gICAqICAgLnRoZW4odXNlciA9PiBjb25zb2xlLmxvZyhgVW5iYW5uZWQgJHt1c2VyLnVzZXJuYW1lfSBmcm9tICR7Z3VpbGQubmFtZX1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICB1bmJhbih1c2VyLCByZWFzb24pIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuY2xpZW50LnVzZXJzLnJlc29sdmVJRCh1c2VyKTtcbiAgICBpZiAoIWlkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdCQU5fUkVTT0xWRV9JRCcpKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuZ3VpbGQuaWQpXG4gICAgICAuYmFuc1tpZF0uZGVsZXRlKHsgcmVhc29uIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNsaWVudC51c2Vycy5yZXNvbHZlKHVzZXIpKTtcbiAgfVxuXG4gIF9mZXRjaFNpbmdsZSh7IHVzZXIsIGNhY2hlLCBmb3JjZSA9IGZhbHNlIH0pIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuZ2V0KHVzZXIpO1xuICAgICAgaWYgKGV4aXN0aW5nICYmICFleGlzdGluZy5wYXJ0aWFsKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV4aXN0aW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuZ3VpbGQuaWQpXG4gICAgICAubWVtYmVycyh1c2VyKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihkYXRhID0+IHRoaXMuYWRkKGRhdGEsIGNhY2hlKSk7XG4gIH1cblxuICBfZmV0Y2hNYW55KHtcbiAgICBsaW1pdCA9IDAsXG4gICAgd2l0aFByZXNlbmNlczogcHJlc2VuY2VzID0gZmFsc2UsXG4gICAgdXNlcjogdXNlcl9pZHMsXG4gICAgcXVlcnksXG4gICAgdGltZSA9IDEyMGUzLFxuICAgIG5vbmNlID0gU25vd2ZsYWtlVXRpbC5nZW5lcmF0ZSgpLFxuICAgIGZvcmNlID0gZmFsc2UsXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5ndWlsZC5tZW1iZXJDb3VudCA9PT0gdGhpcy5jYWNoZS5zaXplICYmICFxdWVyeSAmJiAhbGltaXQgJiYgIXByZXNlbmNlcyAmJiAhdXNlcl9pZHMgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5jYWNoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcXVlcnkgJiYgIXVzZXJfaWRzKSBxdWVyeSA9ICcnO1xuICAgICAgaWYgKG5vbmNlLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTUVNQkVSX0ZFVENIX05PTkNFX0xFTkdUSCcpO1xuICAgICAgdGhpcy5ndWlsZC5zaGFyZC5zZW5kKHtcbiAgICAgICAgb3A6IE9QQ29kZXMuUkVRVUVTVF9HVUlMRF9NRU1CRVJTLFxuICAgICAgICBkOiB7XG4gICAgICAgICAgZ3VpbGRfaWQ6IHRoaXMuZ3VpbGQuaWQsXG4gICAgICAgICAgcHJlc2VuY2VzLFxuICAgICAgICAgIHVzZXJfaWRzLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgIGxpbWl0LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBmZXRjaGVkTWVtYmVycyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgICBjb25zdCBvcHRpb24gPSBxdWVyeSB8fCBsaW1pdCB8fCBwcmVzZW5jZXMgfHwgdXNlcl9pZHM7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCBoYW5kbGVyID0gKG1lbWJlcnMsIF8sIGNodW5rKSA9PiB7XG4gICAgICAgIHRpbWVvdXQucmVmcmVzaCgpO1xuICAgICAgICBpZiAoY2h1bmsubm9uY2UgIT09IG5vbmNlKSByZXR1cm47XG4gICAgICAgIGkrKztcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgIGlmIChvcHRpb24pIGZldGNoZWRNZW1iZXJzLnNldChtZW1iZXIuaWQsIG1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuZ3VpbGQubWVtYmVyQ291bnQgPD0gdGhpcy5jYWNoZS5zaXplIHx8XG4gICAgICAgICAgKG9wdGlvbiAmJiBtZW1iZXJzLnNpemUgPCAxMDAwKSB8fFxuICAgICAgICAgIChsaW1pdCAmJiBmZXRjaGVkTWVtYmVycy5zaXplID49IGxpbWl0KSB8fFxuICAgICAgICAgIGkgPT09IGNodW5rLmNvdW50XG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aGlzLmNsaWVudC5yZW1vdmVMaXN0ZW5lcihFdmVudHMuR1VJTERfTUVNQkVSU19DSFVOSywgaGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5jbGllbnQuZGVjcmVtZW50TWF4TGlzdGVuZXJzKCk7XG4gICAgICAgICAgbGV0IGZldGNoZWQgPSBvcHRpb24gPyBmZXRjaGVkTWVtYmVycyA6IHRoaXMuY2FjaGU7XG4gICAgICAgICAgaWYgKHVzZXJfaWRzICYmICFBcnJheS5pc0FycmF5KHVzZXJfaWRzKSAmJiBmZXRjaGVkLnNpemUpIGZldGNoZWQgPSBmZXRjaGVkLmZpcnN0KCk7XG4gICAgICAgICAgcmVzb2x2ZShmZXRjaGVkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQucmVtb3ZlTGlzdGVuZXIoRXZlbnRzLkdVSUxEX01FTUJFUlNfQ0hVTkssIGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmNsaWVudC5kZWNyZW1lbnRNYXhMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignR1VJTERfTUVNQkVSU19USU1FT1VUJykpO1xuICAgICAgfSwgdGltZSk7XG4gICAgICB0aGlzLmNsaWVudC5pbmNyZW1lbnRNYXhMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuY2xpZW50Lm9uKEV2ZW50cy5HVUlMRF9NRU1CRVJTX0NIVU5LLCBoYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkTWVtYmVyTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBUeXBlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuXG4vKipcbiAqIE1hbmFnZXMgQVBJIG1ldGhvZHMgZm9yIHJvbGVzIG9mIGEgR3VpbGRNZW1iZXIgYW5kIHN0b3JlcyB0aGVpciBjYWNoZS5cbiAqL1xuY2xhc3MgR3VpbGRNZW1iZXJSb2xlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG1lbWJlcikge1xuICAgIC8qKlxuICAgICAqIFRoZSBHdWlsZE1lbWJlciB0aGlzIG1hbmFnZXIgYmVsb25ncyB0b1xuICAgICAqIEB0eXBlIHtHdWlsZE1lbWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1lbWJlciA9IG1lbWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgR3VpbGQgdGhpcyBtYW5hZ2VyIGJlbG9uZ3MgdG9cbiAgICAgKiBAdHlwZSB7R3VpbGR9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZCA9IG1lbWJlci5ndWlsZDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NsaWVudCcsIHsgdmFsdWU6IG1lbWJlci5jbGllbnQgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZpbHRlcmVkIGNvbGxlY3Rpb24gb2Ygcm9sZXMgb2YgdGhlIG1lbWJlclxuICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIFJvbGU+fVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBfcm9sZXMoKSB7XG4gICAgY29uc3QgZXZlcnlvbmUgPSB0aGlzLmd1aWxkLnJvbGVzLmV2ZXJ5b25lO1xuICAgIHJldHVybiB0aGlzLmd1aWxkLnJvbGVzLmNhY2hlLmZpbHRlcihyb2xlID0+IHRoaXMubWVtYmVyLl9yb2xlcy5pbmNsdWRlcyhyb2xlLmlkKSkuc2V0KGV2ZXJ5b25lLmlkLCBldmVyeW9uZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJvbGVzIG9mIHRoaXMgbWVtYmVyXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgUm9sZT59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLl9yb2xlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVtYmVyIHVzZWQgdG8gaG9pc3QgdGhlbSBpbiBhIHNlcGFyYXRlIGNhdGVnb3J5IGluIHRoZSB1c2VycyBsaXN0XG4gICAqIEB0eXBlIHs/Um9sZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaG9pc3QoKSB7XG4gICAgY29uc3QgaG9pc3RlZFJvbGVzID0gdGhpcy5fcm9sZXMuZmlsdGVyKHJvbGUgPT4gcm9sZS5ob2lzdCk7XG4gICAgaWYgKCFob2lzdGVkUm9sZXMuc2l6ZSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGhvaXN0ZWRSb2xlcy5yZWR1Y2UoKHByZXYsIHJvbGUpID0+ICghcHJldiB8fCByb2xlLmNvbXBhcmVQb3NpdGlvblRvKHByZXYpID4gMCA/IHJvbGUgOiBwcmV2KSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lbWJlciB1c2VkIHRvIHNldCB0aGVpciBjb2xvclxuICAgKiBAdHlwZSB7P1JvbGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIGNvbnN0IGNvbG9yZWRSb2xlcyA9IHRoaXMuX3JvbGVzLmZpbHRlcihyb2xlID0+IHJvbGUuY29sb3IpO1xuICAgIGlmICghY29sb3JlZFJvbGVzLnNpemUpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBjb2xvcmVkUm9sZXMucmVkdWNlKChwcmV2LCByb2xlKSA9PiAoIXByZXYgfHwgcm9sZS5jb21wYXJlUG9zaXRpb25UbyhwcmV2KSA+IDAgPyByb2xlIDogcHJldikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZW1iZXIgd2l0aCB0aGUgaGlnaGVzdCBwb3NpdGlvblxuICAgKiBAdHlwZSB7Um9sZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaGlnaGVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9sZXMucmVkdWNlKChwcmV2LCByb2xlKSA9PiAocm9sZS5jb21wYXJlUG9zaXRpb25UbyhwcmV2KSA+IDAgPyByb2xlIDogcHJldiksIHRoaXMuX3JvbGVzLmZpcnN0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSByb2xlIChvciBtdWx0aXBsZSByb2xlcykgdG8gdGhlIG1lbWJlci5cbiAgICogQHBhcmFtIHtSb2xlUmVzb2x2YWJsZXxSb2xlUmVzb2x2YWJsZVtdfENvbGxlY3Rpb248U25vd2ZsYWtlLCBSb2xlPn0gcm9sZU9yUm9sZXMgVGhlIHJvbGUgb3Igcm9sZXMgdG8gYWRkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGFkZGluZyB0aGUgcm9sZShzKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZE1lbWJlcj59XG4gICAqL1xuICBhc3luYyBhZGQocm9sZU9yUm9sZXMsIHJlYXNvbikge1xuICAgIGlmIChyb2xlT3JSb2xlcyBpbnN0YW5jZW9mIENvbGxlY3Rpb24gfHwgQXJyYXkuaXNBcnJheShyb2xlT3JSb2xlcykpIHtcbiAgICAgIHJvbGVPclJvbGVzID0gcm9sZU9yUm9sZXMubWFwKHIgPT4gdGhpcy5ndWlsZC5yb2xlcy5yZXNvbHZlKHIpKTtcbiAgICAgIGlmIChyb2xlT3JSb2xlcy5pbmNsdWRlcyhudWxsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAncm9sZXMnLCAnQXJyYXkgb3IgQ29sbGVjdGlvbiBvZiBSb2xlcyBvciBTbm93Zmxha2VzJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1JvbGVzID0gWy4uLm5ldyBTZXQocm9sZU9yUm9sZXMuY29uY2F0KC4uLnRoaXMuX3JvbGVzLnZhbHVlcygpKSldO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG5ld1JvbGVzLCByZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByb2xlT3JSb2xlcyA9IHRoaXMuZ3VpbGQucm9sZXMucmVzb2x2ZShyb2xlT3JSb2xlcyk7XG4gICAgICBpZiAocm9sZU9yUm9sZXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSU5WQUxJRF9UWVBFJywgJ3JvbGVzJywgJ1JvbGUsIFNub3dmbGFrZSBvciBBcnJheSBvciBDb2xsZWN0aW9uIG9mIFJvbGVzIG9yIFNub3dmbGFrZXMnKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5jbGllbnQuYXBpLmd1aWxkc1t0aGlzLmd1aWxkLmlkXS5tZW1iZXJzW3RoaXMubWVtYmVyLmlkXS5yb2xlc1tyb2xlT3JSb2xlcy5pZF0ucHV0KHsgcmVhc29uIH0pO1xuXG4gICAgICBjb25zdCBjbG9uZSA9IHRoaXMubWVtYmVyLl9jbG9uZSgpO1xuICAgICAgY2xvbmUuX3JvbGVzID0gWy4uLnRoaXMuX3JvbGVzLmtleXMoKSwgcm9sZU9yUm9sZXMuaWRdO1xuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcm9sZSAob3IgbXVsdGlwbGUgcm9sZXMpIGZyb20gdGhlIG1lbWJlci5cbiAgICogQHBhcmFtIHtSb2xlUmVzb2x2YWJsZXxSb2xlUmVzb2x2YWJsZVtdfENvbGxlY3Rpb248U25vd2ZsYWtlLCBSb2xlPn0gcm9sZU9yUm9sZXMgVGhlIHJvbGUgb3Igcm9sZXMgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIHJlbW92aW5nIHRoZSByb2xlKHMpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkTWVtYmVyPn1cbiAgICovXG4gIGFzeW5jIHJlbW92ZShyb2xlT3JSb2xlcywgcmVhc29uKSB7XG4gICAgaWYgKHJvbGVPclJvbGVzIGluc3RhbmNlb2YgQ29sbGVjdGlvbiB8fCBBcnJheS5pc0FycmF5KHJvbGVPclJvbGVzKSkge1xuICAgICAgcm9sZU9yUm9sZXMgPSByb2xlT3JSb2xlcy5tYXAociA9PiB0aGlzLmd1aWxkLnJvbGVzLnJlc29sdmUocikpO1xuICAgICAgaWYgKHJvbGVPclJvbGVzLmluY2x1ZGVzKG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lOVkFMSURfVFlQRScsICdyb2xlcycsICdBcnJheSBvciBDb2xsZWN0aW9uIG9mIFJvbGVzIG9yIFNub3dmbGFrZXMnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3Um9sZXMgPSB0aGlzLl9yb2xlcy5maWx0ZXIocm9sZSA9PiAhcm9sZU9yUm9sZXMuaW5jbHVkZXMocm9sZSkpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG5ld1JvbGVzLCByZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByb2xlT3JSb2xlcyA9IHRoaXMuZ3VpbGQucm9sZXMucmVzb2x2ZShyb2xlT3JSb2xlcyk7XG4gICAgICBpZiAocm9sZU9yUm9sZXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSU5WQUxJRF9UWVBFJywgJ3JvbGVzJywgJ0FycmF5IG9yIENvbGxlY3Rpb24gb2YgUm9sZXMgb3IgU25vd2ZsYWtlcycsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5hcGkuZ3VpbGRzW3RoaXMuZ3VpbGQuaWRdLm1lbWJlcnNbdGhpcy5tZW1iZXIuaWRdLnJvbGVzW3JvbGVPclJvbGVzLmlkXS5kZWxldGUoeyByZWFzb24gfSk7XG5cbiAgICAgIGNvbnN0IGNsb25lID0gdGhpcy5tZW1iZXIuX2Nsb25lKCk7XG4gICAgICBjb25zdCBuZXdSb2xlcyA9IHRoaXMuX3JvbGVzLmZpbHRlcihyb2xlID0+IHJvbGUuaWQgIT09IHJvbGVPclJvbGVzLmlkKTtcbiAgICAgIGNsb25lLl9yb2xlcyA9IFsuLi5uZXdSb2xlcy5rZXlzKCldO1xuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByb2xlcyBhcHBsaWVkIHRvIHRoZSBtZW1iZXIuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIFJvbGU+fFJvbGVSZXNvbHZhYmxlW119IHJvbGVzIFRoZSByb2xlcyBvciByb2xlIElEcyB0byBhcHBseVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBhcHBseWluZyB0aGUgcm9sZXNcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRNZW1iZXI+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIG1lbWJlcidzIHJvbGVzIHRvIGEgc2luZ2xlIHJvbGVcbiAgICogZ3VpbGRNZW1iZXIucm9sZXMuc2V0KFsnMzkxMTU2NTcwNDA4NjE1OTM2J10pXG4gICAqICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZW1vdmUgYWxsIHRoZSByb2xlcyBmcm9tIGEgbWVtYmVyXG4gICAqIGd1aWxkTWVtYmVyLnJvbGVzLnNldChbXSlcbiAgICogICAudGhlbihtZW1iZXIgPT4gY29uc29sZS5sb2coYE1lbWJlciByb2xlcyBpcyBub3cgb2YgJHttZW1iZXIucm9sZXMuY2FjaGUuc2l6ZX0gc2l6ZWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldChyb2xlcywgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtYmVyLmVkaXQoeyByb2xlcyB9LCByZWFzb24pO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1lbWJlcik7XG4gICAgY2xvbmUubWVtYmVyLl9yb2xlcyA9IFsuLi50aGlzLl9yb2xlcy5rZXlBcnJheSgpXTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZE1lbWJlclJvbGVNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlTWFuYWdlciA9IHJlcXVpcmUoJy4vQmFzZU1hbmFnZXInKTtcbmNvbnN0IHsgVHlwZUVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL01lc3NhZ2UnKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IExpbWl0ZWRDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9MaW1pdGVkQ29sbGVjdGlvbicpO1xuXG4vKipcbiAqIE1hbmFnZXMgQVBJIG1ldGhvZHMgZm9yIE1lc3NhZ2VzIGFuZCBob2xkcyB0aGVpciBjYWNoZS5cbiAqIEBleHRlbmRzIHtCYXNlTWFuYWdlcn1cbiAqL1xuY2xhc3MgTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGl0ZXJhYmxlKSB7XG4gICAgc3VwZXIoY2hhbm5lbC5jbGllbnQsIGl0ZXJhYmxlLCBNZXNzYWdlLCBMaW1pdGVkQ29sbGVjdGlvbiwgY2hhbm5lbC5jbGllbnQub3B0aW9ucy5tZXNzYWdlQ2FjaGVNYXhTaXplKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhbm5lbCB0aGF0IHRoZSBtZXNzYWdlcyBiZWxvbmcgdG9cbiAgICAgKiBAdHlwZSB7VGV4dEJhc2VkQ2hhbm5lbH1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBvZiBNZXNzYWdlc1xuICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIE1lc3NhZ2U+fVxuICAgKiBAbmFtZSBNZXNzYWdlTWFuYWdlciNjYWNoZVxuICAgKi9cblxuICBhZGQoZGF0YSwgY2FjaGUpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkKGRhdGEsIGNhY2hlLCB7IGV4dHJhczogW3RoaXMuY2hhbm5lbF0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiB3aGVuIHJlcXVlc3RpbmcgcHJldmlvdXMgbWVzc2FnZXMgZnJvbSBhIGNoYW5uZWwuIGBhcm91bmRgLCBgYmVmb3JlYCBhbmRcbiAgICogYGFmdGVyYCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiBBbGwgdGhlIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBDaGFubmVsTG9nc1F1ZXJ5T3B0aW9uc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2xpbWl0PTUwXSBOdW1iZXIgb2YgbWVzc2FnZXMgdG8gYWNxdWlyZVxuICAgKiBAcHJvcGVydHkge1Nub3dmbGFrZX0gW2JlZm9yZV0gSUQgb2YgYSBtZXNzYWdlIHRvIGdldCB0aGUgbWVzc2FnZXMgdGhhdCB3ZXJlIHBvc3RlZCBiZWZvcmUgaXRcbiAgICogQHByb3BlcnR5IHtTbm93Zmxha2V9IFthZnRlcl0gSUQgb2YgYSBtZXNzYWdlIHRvIGdldCB0aGUgbWVzc2FnZXMgdGhhdCB3ZXJlIHBvc3RlZCBhZnRlciBpdFxuICAgKiBAcHJvcGVydHkge1Nub3dmbGFrZX0gW2Fyb3VuZF0gSUQgb2YgYSBtZXNzYWdlIHRvIGdldCB0aGUgbWVzc2FnZXMgdGhhdCB3ZXJlIHBvc3RlZCBhcm91bmQgaXRcbiAgICovXG5cbiAgLyoqXG4gICAqIEdldHMgYSBtZXNzYWdlLCBvciBtZXNzYWdlcywgZnJvbSB0aGlzIGNoYW5uZWwuXG4gICAqIDxpbmZvPlRoZSByZXR1cm5lZCBDb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gcmVhY3Rpb24gdXNlcnMgb2YgdGhlIG1lc3NhZ2VzIGlmIHRoZXkgd2VyZSBub3QgY2FjaGVkLlxuICAgKiBUaG9zZSBuZWVkIHRvIGJlIGZldGNoZWQgc2VwYXJhdGVseSBpbiBzdWNoIGEgY2FzZS48L2luZm8+XG4gICAqIEBwYXJhbSB7U25vd2ZsYWtlfENoYW5uZWxMb2dzUXVlcnlPcHRpb25zfSBbbWVzc2FnZV0gVGhlIElEIG9mIHRoZSBtZXNzYWdlIHRvIGZldGNoLCBvciBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYWNoZT10cnVlXSBXaGV0aGVyIHRvIGNhY2hlIHRoZSBtZXNzYWdlKHMpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIGNoZWNrIGFuZCByZXF1ZXN0IHRoZSBBUElcbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZT58UHJvbWlzZTxDb2xsZWN0aW9uPFNub3dmbGFrZSwgTWVzc2FnZT4+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBHZXQgbWVzc2FnZVxuICAgKiBjaGFubmVsLm1lc3NhZ2VzLmZldGNoKCc5OTUzOTQ0NjQ0OTMxNTg0MCcpXG4gICAqICAgLnRoZW4obWVzc2FnZSA9PiBjb25zb2xlLmxvZyhtZXNzYWdlLmNvbnRlbnQpKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gR2V0IG1lc3NhZ2VzXG4gICAqIGNoYW5uZWwubWVzc2FnZXMuZmV0Y2goeyBsaW1pdDogMTAgfSlcbiAgICogICAudGhlbihtZXNzYWdlcyA9PiBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgJHttZXNzYWdlcy5zaXplfSBtZXNzYWdlc2ApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gR2V0IG1lc3NhZ2VzIGFuZCBmaWx0ZXIgYnkgdXNlciBJRFxuICAgKiBjaGFubmVsLm1lc3NhZ2VzLmZldGNoKClcbiAgICogICAudGhlbihtZXNzYWdlcyA9PiBjb25zb2xlLmxvZyhgJHttZXNzYWdlcy5maWx0ZXIobSA9PiBtLmF1dGhvci5pZCA9PT0gJzg0NDg0NjUzNjg3MjY3MzI4Jykuc2l6ZX0gbWVzc2FnZXNgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaChtZXNzYWdlLCBjYWNoZSA9IHRydWUsIGZvcmNlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gdGhpcy5fZmV0Y2hJZChtZXNzYWdlLCBjYWNoZSwgZm9yY2UpIDogdGhpcy5fZmV0Y2hNYW55KG1lc3NhZ2UsIGNhY2hlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBwaW5uZWQgbWVzc2FnZXMgb2YgdGhpcyBjaGFubmVsIGFuZCByZXR1cm5zIGEgY29sbGVjdGlvbiBvZiB0aGVtLlxuICAgKiA8aW5mbz5UaGUgcmV0dXJuZWQgQ29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIGFueSByZWFjdGlvbiBkYXRhIG9mIHRoZSBtZXNzYWdlcy5cbiAgICogVGhvc2UgbmVlZCB0byBiZSBmZXRjaGVkIHNlcGFyYXRlbHkuPC9pbmZvPlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYWNoZT10cnVlXSBXaGV0aGVyIHRvIGNhY2hlIHRoZSBtZXNzYWdlKHMpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbGxlY3Rpb248U25vd2ZsYWtlLCBNZXNzYWdlPj59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCBwaW5uZWQgbWVzc2FnZXNcbiAgICogY2hhbm5lbC5tZXNzYWdlcy5mZXRjaFBpbm5lZCgpXG4gICAqICAgLnRoZW4obWVzc2FnZXMgPT4gY29uc29sZS5sb2coYFJlY2VpdmVkICR7bWVzc2FnZXMuc2l6ZX0gbWVzc2FnZXNgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaFBpbm5lZChjYWNoZSA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpLmNoYW5uZWxzW3RoaXMuY2hhbm5lbC5pZF0ucGlucy5nZXQoKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIGRhdGEpIG1lc3NhZ2VzLnNldChtZXNzYWdlLmlkLCB0aGlzLmFkZChtZXNzYWdlLCBjYWNoZSkpO1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgdG8gYSBNZXNzYWdlIG9iamVjdC4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBNZXNzYWdlXG4gICAqICogQSBTbm93Zmxha2VcbiAgICogQHR5cGVkZWYge01lc3NhZ2V8U25vd2ZsYWtlfSBNZXNzYWdlUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBNZXNzYWdlUmVzb2x2YWJsZSB0byBhIE1lc3NhZ2Ugb2JqZWN0LlxuICAgKiBAbWV0aG9kIHJlc29sdmVcbiAgICogQG1lbWJlcm9mIE1lc3NhZ2VNYW5hZ2VyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge01lc3NhZ2VSZXNvbHZhYmxlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHJlc29sdmFibGUgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7P01lc3NhZ2V9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIE1lc3NhZ2VSZXNvbHZhYmxlIHRvIGEgTWVzc2FnZSBJRCBzdHJpbmcuXG4gICAqIEBtZXRob2QgcmVzb2x2ZUlEXG4gICAqIEBtZW1iZXJvZiBNZXNzYWdlTWFuYWdlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNZXNzYWdlUmVzb2x2YWJsZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSByZXNvbHZhYmxlIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgez9Tbm93Zmxha2V9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbWVzc2FnZSwgZXZlbiBpZiBpdCdzIG5vdCBjYWNoZWQuXG4gICAqIEBwYXJhbSB7TWVzc2FnZVJlc29sdmFibGV9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGVsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGRlbGV0aW5nIHRoaXMgbWVzc2FnZSwgaWYgaXQgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBjbGllbnQgdXNlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZShtZXNzYWdlLCByZWFzb24pIHtcbiAgICBtZXNzYWdlID0gdGhpcy5yZXNvbHZlSUQobWVzc2FnZSk7XG4gICAgaWYgKCFtZXNzYWdlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAnbWVzc2FnZScsICdNZXNzYWdlUmVzb2x2YWJsZScpO1xuXG4gICAgYXdhaXQgdGhpcy5jbGllbnQuYXBpLmNoYW5uZWxzKHRoaXMuY2hhbm5lbC5pZCkubWVzc2FnZXMobWVzc2FnZSkuZGVsZXRlKHsgcmVhc29uIH0pO1xuICB9XG5cbiAgYXN5bmMgX2ZldGNoSWQobWVzc2FnZUlELCBjYWNoZSwgZm9yY2UpIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuZ2V0KG1lc3NhZ2VJRCk7XG4gICAgICBpZiAoZXhpc3RpbmcgJiYgIWV4aXN0aW5nLnBhcnRpYWwpIHJldHVybiBleGlzdGluZztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuYXBpLmNoYW5uZWxzW3RoaXMuY2hhbm5lbC5pZF0ubWVzc2FnZXNbbWVzc2FnZUlEXS5nZXQoKTtcbiAgICByZXR1cm4gdGhpcy5hZGQoZGF0YSwgY2FjaGUpO1xuICB9XG5cbiAgYXN5bmMgX2ZldGNoTWFueShvcHRpb25zID0ge30sIGNhY2hlKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LmFwaS5jaGFubmVsc1t0aGlzLmNoYW5uZWwuaWRdLm1lc3NhZ2VzLmdldCh7IHF1ZXJ5OiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgZGF0YSkgbWVzc2FnZXMuc2V0KG1lc3NhZ2UuaWQsIHRoaXMuYWRkKG1lc3NhZ2UsIGNhY2hlKSk7XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZU1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9CYXNlTWFuYWdlcicpO1xuY29uc3QgeyBQcmVzZW5jZSB9ID0gcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9QcmVzZW5jZScpO1xuXG4vKipcbiAqIE1hbmFnZXMgQVBJIG1ldGhvZHMgZm9yIFByZXNlbmNlcyBhbmQgaG9sZHMgdGhlaXIgY2FjaGUuXG4gKiBAZXh0ZW5kcyB7QmFzZU1hbmFnZXJ9XG4gKi9cbmNsYXNzIFByZXNlbmNlTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBpdGVyYWJsZSkge1xuICAgIHN1cGVyKGNsaWVudCwgaXRlcmFibGUsIFByZXNlbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FjaGUgb2YgUHJlc2VuY2VzXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgUHJlc2VuY2U+fVxuICAgKiBAbmFtZSBQcmVzZW5jZU1hbmFnZXIjY2FjaGVcbiAgICovXG5cbiAgYWRkKGRhdGEsIGNhY2hlKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmNhY2hlLmdldChkYXRhLnVzZXIuaWQpO1xuICAgIHJldHVybiBleGlzdGluZyA/IGV4aXN0aW5nLnBhdGNoKGRhdGEpIDogc3VwZXIuYWRkKGRhdGEsIGNhY2hlLCB7IGlkOiBkYXRhLnVzZXIuaWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBhIFByZXNlbmNlIG9iamVjdC4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBQcmVzZW5jZVxuICAgKiAqIEEgVXNlclJlc29sdmFibGVcbiAgICogKiBBIFNub3dmbGFrZVxuICAgKiBAdHlwZWRlZiB7UHJlc2VuY2V8VXNlclJlc29sdmFibGV8U25vd2ZsYWtlfSBQcmVzZW5jZVJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgUHJlc2VuY2VSZXNvbHZhYmxlIHRvIGEgUHJlc2VuY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge1ByZXNlbmNlUmVzb2x2YWJsZX0gcHJlc2VuY2UgVGhlIHByZXNlbmNlIHJlc29sdmFibGUgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7P1ByZXNlbmNlfVxuICAgKi9cbiAgcmVzb2x2ZShwcmVzZW5jZSkge1xuICAgIGNvbnN0IHByZXNlbmNlUmVzb2x2YWJsZSA9IHN1cGVyLnJlc29sdmUocHJlc2VuY2UpO1xuICAgIGlmIChwcmVzZW5jZVJlc29sdmFibGUpIHJldHVybiBwcmVzZW5jZVJlc29sdmFibGU7XG4gICAgY29uc3QgVXNlclJlc29sdmFibGUgPSB0aGlzLmNsaWVudC51c2Vycy5yZXNvbHZlSUQocHJlc2VuY2UpO1xuICAgIHJldHVybiBzdXBlci5yZXNvbHZlKFVzZXJSZXNvbHZhYmxlKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgUHJlc2VuY2VSZXNvbHZhYmxlIHRvIGEgUHJlc2VuY2UgSUQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge1ByZXNlbmNlUmVzb2x2YWJsZX0gcHJlc2VuY2UgVGhlIHByZXNlbmNlIHJlc29sdmFibGUgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7P1Nub3dmbGFrZX1cbiAgICovXG4gIHJlc29sdmVJRChwcmVzZW5jZSkge1xuICAgIGNvbnN0IHByZXNlbmNlUmVzb2x2YWJsZSA9IHN1cGVyLnJlc29sdmVJRChwcmVzZW5jZSk7XG4gICAgaWYgKHByZXNlbmNlUmVzb2x2YWJsZSkgcmV0dXJuIHByZXNlbmNlUmVzb2x2YWJsZTtcbiAgICBjb25zdCB1c2VyUmVzb2x2YWJsZSA9IHRoaXMuY2xpZW50LnVzZXJzLnJlc29sdmVJRChwcmVzZW5jZSk7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKHVzZXJSZXNvbHZhYmxlKSA/IHVzZXJSZXNvbHZhYmxlIDogbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNlbmNlTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZU1hbmFnZXIgPSByZXF1aXJlKCcuL0Jhc2VNYW5hZ2VyJyk7XG5jb25zdCBNZXNzYWdlUmVhY3Rpb24gPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL01lc3NhZ2VSZWFjdGlvbicpO1xuXG4vKipcbiAqIE1hbmFnZXMgQVBJIG1ldGhvZHMgZm9yIHJlYWN0aW9ucyBhbmQgaG9sZHMgdGhlaXIgY2FjaGUuXG4gKiBAZXh0ZW5kcyB7QmFzZU1hbmFnZXJ9XG4gKi9cbmNsYXNzIFJlYWN0aW9uTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgaXRlcmFibGUpIHtcbiAgICBzdXBlcihtZXNzYWdlLmNsaWVudCwgaXRlcmFibGUsIE1lc3NhZ2VSZWFjdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWVzc2FnZSB0aGF0IHRoaXMgbWFuYWdlciBiZWxvbmdzIHRvXG4gICAgICogQHR5cGUge01lc3NhZ2V9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIGFkZChkYXRhLCBjYWNoZSkge1xuICAgIHJldHVybiBzdXBlci5hZGQoZGF0YSwgY2FjaGUsIHsgaWQ6IGRhdGEuZW1vamkuaWQgfHwgZGF0YS5lbW9qaS5uYW1lLCBleHRyYXM6IFt0aGlzLm1lc3NhZ2VdIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZWFjdGlvbiBjYWNoZSBvZiB0aGlzIG1hbmFnZXJcbiAgICogQHR5cGUge0NvbGxlY3Rpb248c3RyaW5nfFNub3dmbGFrZSwgTWVzc2FnZVJlYWN0aW9uPn1cbiAgICogQG5hbWUgUmVhY3Rpb25NYW5hZ2VyI2NhY2hlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEYXRhIHRoYXQgY2FuIGJlIHJlc29sdmVkIHRvIGEgTWVzc2FnZVJlYWN0aW9uIG9iamVjdC4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBNZXNzYWdlUmVhY3Rpb25cbiAgICogKiBBIFNub3dmbGFrZVxuICAgKiBAdHlwZWRlZiB7TWVzc2FnZVJlYWN0aW9ufFNub3dmbGFrZX0gTWVzc2FnZVJlYWN0aW9uUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBNZXNzYWdlUmVhY3Rpb25SZXNvbHZhYmxlIHRvIGEgTWVzc2FnZVJlYWN0aW9uIG9iamVjdC5cbiAgICogQG1ldGhvZCByZXNvbHZlXG4gICAqIEBtZW1iZXJvZiBSZWFjdGlvbk1hbmFnZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TWVzc2FnZVJlYWN0aW9uUmVzb2x2YWJsZX0gcmVhY3Rpb24gVGhlIE1lc3NhZ2VSZWFjdGlvbiB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIHs/TWVzc2FnZVJlYWN0aW9ufVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBNZXNzYWdlUmVhY3Rpb25SZXNvbHZhYmxlIHRvIGEgTWVzc2FnZVJlYWN0aW9uIElEIHN0cmluZy5cbiAgICogQG1ldGhvZCByZXNvbHZlSURcbiAgICogQG1lbWJlcm9mIFJlYWN0aW9uTWFuYWdlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNZXNzYWdlUmVhY3Rpb25SZXNvbHZhYmxlfSByZWFjdGlvbiBUaGUgTWVzc2FnZVJlYWN0aW9uIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgez9Tbm93Zmxha2V9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCByZWFjdGlvbnMgZnJvbSBhIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U+fVxuICAgKi9cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5jaGFubmVscyh0aGlzLm1lc3NhZ2UuY2hhbm5lbC5pZClcbiAgICAgIC5tZXNzYWdlcyh0aGlzLm1lc3NhZ2UuaWQpXG4gICAgICAucmVhY3Rpb25zLmRlbGV0ZSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLm1lc3NhZ2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Rpb25NYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlTWFuYWdlciA9IHJlcXVpcmUoJy4vQmFzZU1hbmFnZXInKTtcbmNvbnN0IHsgRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuXG4vKipcbiAqIE1hbmFnZXMgQVBJIG1ldGhvZHMgZm9yIHVzZXJzIHdobyByZWFjdGVkIHRvIGEgcmVhY3Rpb24gYW5kIHN0b3JlcyB0aGVpciBjYWNoZS5cbiAqIEBleHRlbmRzIHtCYXNlTWFuYWdlcn1cbiAqL1xuY2xhc3MgUmVhY3Rpb25Vc2VyTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBpdGVyYWJsZSwgcmVhY3Rpb24pIHtcbiAgICBzdXBlcihjbGllbnQsIGl0ZXJhYmxlLCB7IG5hbWU6ICdVc2VyJyB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVhY3Rpb24gdGhhdCB0aGlzIG1hbmFnZXIgYmVsb25ncyB0b1xuICAgICAqIEB0eXBlIHtNZXNzYWdlUmVhY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5yZWFjdGlvbiA9IHJlYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBvZiB0aGlzIG1hbmFnZXJcbiAgICogQHR5cGUge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBVc2VyPn1cbiAgICogQG5hbWUgUmVhY3Rpb25Vc2VyTWFuYWdlciNjYWNoZVxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgdGhlIHVzZXJzIHRoYXQgZ2F2ZSB0aGlzIHJlYWN0aW9uLiBSZXNvbHZlcyB3aXRoIGEgY29sbGVjdGlvbiBvZiB1c2VycywgbWFwcGVkIGJ5IHRoZWlyIElEcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciBmZXRjaGluZyB0aGUgdXNlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbWl0PTEwMF0gVGhlIG1heGltdW0gYW1vdW50IG9mIHVzZXJzIHRvIGZldGNoLCBkZWZhdWx0cyB0byAxMDBcbiAgICogQHBhcmFtIHtTbm93Zmxha2V9IFtvcHRpb25zLmJlZm9yZV0gTGltaXQgZmV0Y2hpbmcgdXNlcnMgdG8gdGhvc2Ugd2l0aCBhbiBpZCBsb3dlciB0aGFuIHRoZSBzdXBwbGllZCBpZFxuICAgKiBAcGFyYW0ge1Nub3dmbGFrZX0gW29wdGlvbnMuYWZ0ZXJdIExpbWl0IGZldGNoaW5nIHVzZXJzIHRvIHRob3NlIHdpdGggYW4gaWQgZ3JlYXRlciB0aGFuIHRoZSBzdXBwbGllZCBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uPFNub3dmbGFrZSwgVXNlcj4+fVxuICAgKi9cbiAgYXN5bmMgZmV0Y2goeyBsaW1pdCA9IDEwMCwgYWZ0ZXIsIGJlZm9yZSB9ID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5yZWFjdGlvbi5tZXNzYWdlO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkuY2hhbm5lbHNbbWVzc2FnZS5jaGFubmVsLmlkXS5tZXNzYWdlc1ttZXNzYWdlLmlkXS5yZWFjdGlvbnNbXG4gICAgICB0aGlzLnJlYWN0aW9uLmVtb2ppLmlkZW50aWZpZXJcbiAgICBdLmdldCh7IHF1ZXJ5OiB7IGxpbWl0LCBiZWZvcmUsIGFmdGVyIH0gfSk7XG4gICAgY29uc3QgdXNlcnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIGZvciAoY29uc3QgcmF3VXNlciBvZiBkYXRhKSB7XG4gICAgICBjb25zdCB1c2VyID0gdGhpcy5jbGllbnQudXNlcnMuYWRkKHJhd1VzZXIpO1xuICAgICAgdGhpcy5jYWNoZS5zZXQodXNlci5pZCwgdXNlcik7XG4gICAgICB1c2Vycy5zZXQodXNlci5pZCwgdXNlcik7XG4gICAgfVxuICAgIHJldHVybiB1c2VycztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdXNlciBmcm9tIHRoaXMgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSB7VXNlclJlc29sdmFibGV9IFt1c2VyPXRoaXMuY2xpZW50LnVzZXJdIFRoZSB1c2VyIHRvIHJlbW92ZSB0aGUgcmVhY3Rpb24gb2ZcbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZVJlYWN0aW9uPn1cbiAgICovXG4gIHJlbW92ZSh1c2VyID0gdGhpcy5jbGllbnQudXNlcikge1xuICAgIGNvbnN0IHVzZXJJRCA9IHRoaXMuY2xpZW50LnVzZXJzLnJlc29sdmVJRCh1c2VyKTtcbiAgICBpZiAoIXVzZXJJRCkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUkVBQ1RJT05fUkVTT0xWRV9VU0VSJykpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnJlYWN0aW9uLm1lc3NhZ2U7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaS5jaGFubmVsc1ttZXNzYWdlLmNoYW5uZWwuaWRdLm1lc3NhZ2VzW21lc3NhZ2UuaWRdLnJlYWN0aW9uc1t0aGlzLnJlYWN0aW9uLmVtb2ppLmlkZW50aWZpZXJdW1xuICAgICAgdXNlcklEID09PSB0aGlzLmNsaWVudC51c2VyLmlkID8gJ0BtZScgOiB1c2VySURcbiAgICBdXG4gICAgICAuZGVsZXRlKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMucmVhY3Rpb24pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Rpb25Vc2VyTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZU1hbmFnZXIgPSByZXF1aXJlKCcuL0Jhc2VNYW5hZ2VyJyk7XG5jb25zdCBSb2xlID0gcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9Sb2xlJyk7XG5jb25zdCBQZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvUGVybWlzc2lvbnMnKTtcbmNvbnN0IHsgcmVzb2x2ZUNvbG9yIH0gPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBNYW5hZ2VzIEFQSSBtZXRob2RzIGZvciByb2xlcyBhbmQgc3RvcmVzIHRoZWlyIGNhY2hlLlxuICogQGV4dGVuZHMge0Jhc2VNYW5hZ2VyfVxuICovXG5jbGFzcyBSb2xlTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZ3VpbGQsIGl0ZXJhYmxlKSB7XG4gICAgc3VwZXIoZ3VpbGQuY2xpZW50LCBpdGVyYWJsZSwgUm9sZSk7XG4gICAgLyoqXG4gICAgICogVGhlIGd1aWxkIGJlbG9uZ2luZyB0byB0aGlzIG1hbmFnZXJcbiAgICAgKiBAdHlwZSB7R3VpbGR9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZCA9IGd1aWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIGNhY2hlIG9mIHRoaXMgbWFuYWdlclxuICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIFJvbGU+fVxuICAgKiBAbmFtZSBSb2xlTWFuYWdlciNjYWNoZVxuICAgKi9cblxuICBhZGQoZGF0YSwgY2FjaGUpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkKGRhdGEsIGNhY2hlLCB7IGV4dHJhczogW3RoaXMuZ3VpbGRdIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgb25lIG9yIG1vcmUgcm9sZXMgZnJvbSBEaXNjb3JkLCBvciB0aGUgcm9sZSBjYWNoZSBpZiB0aGV5J3JlIGFscmVhZHkgYXZhaWxhYmxlLlxuICAgKiBAcGFyYW0ge1Nub3dmbGFrZX0gW2lkXSBJRCBvciBJRHMgb2YgdGhlIHJvbGUocylcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2FjaGU9dHJ1ZV0gV2hldGhlciB0byBjYWNoZSB0aGUgbmV3IHJvbGVzIG9iamVjdHMgaWYgaXQgd2VyZW4ndCBhbHJlYWR5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIGNoZWNrIGFuZCByZXF1ZXN0IHRoZSBBUElcbiAgICogQHJldHVybnMge1Byb21pc2U8Um9sZXxSb2xlTWFuYWdlcj59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZldGNoIGFsbCByb2xlcyBmcm9tIHRoZSBndWlsZFxuICAgKiBtZXNzYWdlLmd1aWxkLnJvbGVzLmZldGNoKClcbiAgICogICAudGhlbihyb2xlcyA9PiBjb25zb2xlLmxvZyhgVGhlcmUgYXJlICR7cm9sZXMuY2FjaGUuc2l6ZX0gcm9sZXMuYCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGZXRjaCBhIHNpbmdsZSByb2xlXG4gICAqIG1lc3NhZ2UuZ3VpbGQucm9sZXMuZmV0Y2goJzIyMjA3ODEwODk3NzU5NDM2OCcpXG4gICAqICAgLnRoZW4ocm9sZSA9PiBjb25zb2xlLmxvZyhgVGhlIHJvbGUgY29sb3IgaXM6ICR7cm9sZS5jb2xvcn1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBhc3luYyBmZXRjaChpZCwgY2FjaGUgPSB0cnVlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKGlkICYmICFmb3JjZSkge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmNhY2hlLmdldChpZCk7XG4gICAgICBpZiAoZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICB9XG5cbiAgICAvLyBXZSBjYW5ub3QgZmV0Y2ggYSBzaW5nbGUgcm9sZSwgYXMgb2YgdGhpcyBjb21taXQncyBkYXRlLCBEaXNjb3JkIEFQSSB0aHJvd3Mgd2l0aCA0MDVcbiAgICBjb25zdCByb2xlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmFwaS5ndWlsZHModGhpcy5ndWlsZC5pZCkucm9sZXMuZ2V0KCk7XG4gICAgZm9yIChjb25zdCByb2xlIG9mIHJvbGVzKSB0aGlzLmFkZChyb2xlLCBjYWNoZSk7XG4gICAgcmV0dXJuIGlkID8gdGhpcy5jYWNoZS5nZXQoaWQpIHx8IG51bGwgOiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgdG8gYSBSb2xlIG9iamVjdC4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBSb2xlXG4gICAqICogQSBTbm93Zmxha2VcbiAgICogQHR5cGVkZWYge1JvbGV8U25vd2ZsYWtlfSBSb2xlUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBSb2xlUmVzb2x2YWJsZSB0byBhIFJvbGUgb2JqZWN0LlxuICAgKiBAbWV0aG9kIHJlc29sdmVcbiAgICogQG1lbWJlcm9mIFJvbGVNYW5hZ2VyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JvbGVSZXNvbHZhYmxlfSByb2xlIFRoZSByb2xlIHJlc29sdmFibGUgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7P1JvbGV9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIFJvbGVSZXNvbHZhYmxlIHRvIGEgcm9sZSBJRCBzdHJpbmcuXG4gICAqIEBtZXRob2QgcmVzb2x2ZUlEXG4gICAqIEBtZW1iZXJvZiBSb2xlTWFuYWdlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtSb2xlUmVzb2x2YWJsZX0gcm9sZSBUaGUgcm9sZSByZXNvbHZhYmxlIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgez9Tbm93Zmxha2V9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJvbGUgaW4gdGhlIGd1aWxkIHdpdGggZ2l2ZW4gaW5mb3JtYXRpb24uXG4gICAqIDx3YXJuPlRoZSBwb3NpdGlvbiB3aWxsIHNpbGVudGx5IHJlc2V0IHRvIDEgaWYgYW4gaW52YWxpZCBvbmUgaXMgcHJvdmlkZWQsIG9yIG5vbmUuPC93YXJuPlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICogQHBhcmFtIHtSb2xlRGF0YX0gW29wdGlvbnMuZGF0YV0gVGhlIGRhdGEgdG8gY3JlYXRlIHRoZSByb2xlIHdpdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciBjcmVhdGluZyB0aGlzIHJvbGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Um9sZT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBhIG5ldyByb2xlXG4gICAqIGd1aWxkLnJvbGVzLmNyZWF0ZSgpXG4gICAqICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBDcmVhdGUgYSBuZXcgcm9sZSB3aXRoIGRhdGEgYW5kIGEgcmVhc29uXG4gICAqIGd1aWxkLnJvbGVzLmNyZWF0ZSh7XG4gICAqICAgZGF0YToge1xuICAgKiAgICAgbmFtZTogJ1N1cGVyIENvb2wgUGVvcGxlJyxcbiAgICogICAgIGNvbG9yOiAnQkxVRScsXG4gICAqICAgfSxcbiAgICogICByZWFzb246ICd3ZSBuZWVkZWQgYSByb2xlIGZvciBTdXBlciBDb29sIFBlb3BsZScsXG4gICAqIH0pXG4gICAqICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgY3JlYXRlKHsgZGF0YSA9IHt9LCByZWFzb24gfSA9IHt9KSB7XG4gICAgaWYgKGRhdGEuY29sb3IpIGRhdGEuY29sb3IgPSByZXNvbHZlQ29sb3IoZGF0YS5jb2xvcik7XG4gICAgaWYgKGRhdGEucGVybWlzc2lvbnMpIGRhdGEucGVybWlzc2lvbnMgPSBQZXJtaXNzaW9ucy5yZXNvbHZlKGRhdGEucGVybWlzc2lvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMuZ3VpbGQuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmd1aWxkLmlkKVxuICAgICAgLnJvbGVzLnBvc3QoeyBkYXRhLCByZWFzb24gfSlcbiAgICAgIC50aGVuKHIgPT4ge1xuICAgICAgICBjb25zdCB7IHJvbGUgfSA9IHRoaXMuY2xpZW50LmFjdGlvbnMuR3VpbGRSb2xlQ3JlYXRlLmhhbmRsZSh7XG4gICAgICAgICAgZ3VpbGRfaWQ6IHRoaXMuZ3VpbGQuaWQsXG4gICAgICAgICAgcm9sZTogcixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhLnBvc2l0aW9uKSByZXR1cm4gcm9sZS5zZXRQb3NpdGlvbihkYXRhLnBvc2l0aW9uLCByZWFzb24pO1xuICAgICAgICByZXR1cm4gcm9sZTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBgQGV2ZXJ5b25lYCByb2xlIG9mIHRoZSBndWlsZFxuICAgKiBAdHlwZSB7Um9sZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZXZlcnlvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KHRoaXMuZ3VpbGQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIHdpdGggdGhlIGhpZ2hlc3QgcG9zaXRpb24gaW4gdGhlIGNhY2hlXG4gICAqIEB0eXBlIHtSb2xlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBoaWdoZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlLnJlZHVjZSgocHJldiwgcm9sZSkgPT4gKHJvbGUuY29tcGFyZVBvc2l0aW9uVG8ocHJldikgPiAwID8gcm9sZSA6IHByZXYpLCB0aGlzLmNhY2hlLmZpcnN0KCkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUm9sZU1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9CYXNlTWFuYWdlcicpO1xuY29uc3QgR3VpbGRNZW1iZXIgPSByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL0d1aWxkTWVtYmVyJyk7XG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9NZXNzYWdlJyk7XG5jb25zdCBVc2VyID0gcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9Vc2VyJyk7XG5cbi8qKlxuICogTWFuYWdlcyBBUEkgbWV0aG9kcyBmb3IgdXNlcnMgYW5kIHN0b3JlcyB0aGVpciBjYWNoZS5cbiAqIEBleHRlbmRzIHtCYXNlTWFuYWdlcn1cbiAqL1xuY2xhc3MgVXNlck1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaXRlcmFibGUpIHtcbiAgICBzdXBlcihjbGllbnQsIGl0ZXJhYmxlLCBVc2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FjaGUgb2YgdGhpcyBtYW5hZ2VyXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgVXNlcj59XG4gICAqIEBuYW1lIFVzZXJNYW5hZ2VyI2NhY2hlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEYXRhIHRoYXQgcmVzb2x2ZXMgdG8gZ2l2ZSBhIFVzZXIgb2JqZWN0LiBUaGlzIGNhbiBiZTpcbiAgICogKiBBIFVzZXIgb2JqZWN0XG4gICAqICogQSBTbm93Zmxha2VcbiAgICogKiBBIE1lc3NhZ2Ugb2JqZWN0IChyZXNvbHZlcyB0byB0aGUgbWVzc2FnZSBhdXRob3IpXG4gICAqICogQSBHdWlsZE1lbWJlciBvYmplY3RcbiAgICogQHR5cGVkZWYge1VzZXJ8U25vd2ZsYWtlfE1lc3NhZ2V8R3VpbGRNZW1iZXJ9IFVzZXJSZXNvbHZhYmxlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIFVzZXJSZXNvbHZhYmxlIHRvIGEgVXNlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7VXNlclJlc29sdmFibGV9IHVzZXIgVGhlIFVzZXJSZXNvbHZhYmxlIHRvIGlkZW50aWZ5XG4gICAqIEByZXR1cm5zIHs/VXNlcn1cbiAgICovXG4gIHJlc29sdmUodXNlcikge1xuICAgIGlmICh1c2VyIGluc3RhbmNlb2YgR3VpbGRNZW1iZXIpIHJldHVybiB1c2VyLnVzZXI7XG4gICAgaWYgKHVzZXIgaW5zdGFuY2VvZiBNZXNzYWdlKSByZXR1cm4gdXNlci5hdXRob3I7XG4gICAgcmV0dXJuIHN1cGVyLnJlc29sdmUodXNlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBVc2VyUmVzb2x2YWJsZSB0byBhIHVzZXIgSUQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge1VzZXJSZXNvbHZhYmxlfSB1c2VyIFRoZSBVc2VyUmVzb2x2YWJsZSB0byBpZGVudGlmeVxuICAgKiBAcmV0dXJucyB7P1Nub3dmbGFrZX1cbiAgICovXG4gIHJlc29sdmVJRCh1c2VyKSB7XG4gICAgaWYgKHVzZXIgaW5zdGFuY2VvZiBHdWlsZE1lbWJlcikgcmV0dXJuIHVzZXIudXNlci5pZDtcbiAgICBpZiAodXNlciBpbnN0YW5jZW9mIE1lc3NhZ2UpIHJldHVybiB1c2VyLmF1dGhvci5pZDtcbiAgICByZXR1cm4gc3VwZXIucmVzb2x2ZUlEKHVzZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgYSB1c2VyIGZyb20gRGlzY29yZCwgb3IgdGhlIHVzZXIgY2FjaGUgaWYgaXQncyBhbHJlYWR5IGF2YWlsYWJsZS5cbiAgICogQHBhcmFtIHtTbm93Zmxha2V9IGlkIElEIG9mIHRoZSB1c2VyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhY2hlPXRydWVdIFdoZXRoZXIgdG8gY2FjaGUgdGhlIG5ldyB1c2VyIG9iamVjdCBpZiBpdCBpc24ndCBhbHJlYWR5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIGNoZWNrIGFuZCByZXF1ZXN0IHRoZSBBUElcbiAgICogQHJldHVybnMge1Byb21pc2U8VXNlcj59XG4gICAqL1xuICBhc3luYyBmZXRjaChpZCwgY2FjaGUgPSB0cnVlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmNhY2hlLmdldChpZCk7XG4gICAgICBpZiAoZXhpc3RpbmcgJiYgIWV4aXN0aW5nLnBhcnRpYWwpIHJldHVybiBleGlzdGluZztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuYXBpLnVzZXJzKGlkKS5nZXQoKTtcbiAgICByZXR1cm4gdGhpcy5hZGQoZGF0YSwgY2FjaGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9CYXNlTWFuYWdlcicpO1xuXG4vKipcbiAqIE1hbmFnZXMgQVBJIG1ldGhvZHMgZm9yIFZvaWNlU3RhdGVzIGFuZCBzdG9yZXMgdGhlaXIgY2FjaGUuXG4gKiBAZXh0ZW5kcyB7QmFzZU1hbmFnZXJ9XG4gKi9cbmNsYXNzIFZvaWNlU3RhdGVNYW5hZ2VyIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihndWlsZCwgaXRlcmFibGUpIHtcbiAgICBzdXBlcihndWlsZC5jbGllbnQsIGl0ZXJhYmxlLCB7IG5hbWU6ICdWb2ljZVN0YXRlJyB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgZ3VpbGQgdGhpcyBtYW5hZ2VyIGJlbG9uZ3MgdG9cbiAgICAgKiBAdHlwZSB7R3VpbGR9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZCA9IGd1aWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBvZiB0aGlzIG1hbmFnZXJcbiAgICogQHR5cGUge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBWb2ljZVN0YXRlPn1cbiAgICogQG5hbWUgVm9pY2VTdGF0ZU1hbmFnZXIjY2FjaGVcbiAgICovXG5cbiAgYWRkKGRhdGEsIGNhY2hlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5jYWNoZS5nZXQoZGF0YS51c2VyX2lkKTtcbiAgICBpZiAoZXhpc3RpbmcpIHJldHVybiBleGlzdGluZy5fcGF0Y2goZGF0YSk7XG5cbiAgICBjb25zdCBlbnRyeSA9IG5ldyB0aGlzLmhvbGRzKHRoaXMuZ3VpbGQsIGRhdGEpO1xuICAgIGlmIChjYWNoZSkgdGhpcy5jYWNoZS5zZXQoZGF0YS51c2VyX2lkLCBlbnRyeSk7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVm9pY2VTdGF0ZU1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IEZvcm1EYXRhID0gcmVxdWlyZSgnQGRpc2NvcmRqcy9mb3JtLWRhdGEnKTtcbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKTtcbmNvbnN0IGZldGNoID0gcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xuY29uc3QgeyBicm93c2VyLCBVc2VyQWdlbnQgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmlmIChodHRwcy5BZ2VudCkgdmFyIGFnZW50ID0gbmV3IGh0dHBzLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuXG5jbGFzcyBBUElSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IocmVzdCwgbWV0aG9kLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICB0aGlzLmNsaWVudCA9IHJlc3QuY2xpZW50O1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMucm91dGUgPSBvcHRpb25zLnJvdXRlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5yZXRyaWVzID0gMDtcblxuICAgIGxldCBxdWVyeVN0cmluZyA9ICcnO1xuICAgIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMucXVlcnkpXG4gICAgICAgIC5maWx0ZXIoKFssIHZhbHVlXSkgPT4gIVtudWxsLCAnbnVsbCcsICd1bmRlZmluZWQnXS5pbmNsdWRlcyh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgLmZsYXRNYXAoKFtrZXksIHZhbHVlXSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV0pKTtcbiAgICAgIHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeSkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoID0gYCR7cGF0aH0ke3F1ZXJ5U3RyaW5nICYmIGA/JHtxdWVyeVN0cmluZ31gfWA7XG4gIH1cblxuICBtYWtlKCkge1xuICAgIGNvbnN0IEFQSSA9XG4gICAgICB0aGlzLm9wdGlvbnMudmVyc2lvbmVkID09PSBmYWxzZVxuICAgICAgICA/IHRoaXMuY2xpZW50Lm9wdGlvbnMuaHR0cC5hcGlcbiAgICAgICAgOiBgJHt0aGlzLmNsaWVudC5vcHRpb25zLmh0dHAuYXBpfS92JHt0aGlzLmNsaWVudC5vcHRpb25zLmh0dHAudmVyc2lvbn1gO1xuICAgIGNvbnN0IHVybCA9IEFQSSArIHRoaXMucGF0aDtcbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRoICE9PSBmYWxzZSkgaGVhZGVycy5BdXRob3JpemF0aW9uID0gdGhpcy5yZXN0LmdldEF1dGgoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlYXNvbikgaGVhZGVyc1snWC1BdWRpdC1Mb2ctUmVhc29uJ10gPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5vcHRpb25zLnJlYXNvbik7XG4gICAgaWYgKCFicm93c2VyKSBoZWFkZXJzWydVc2VyLUFnZW50J10gPSBVc2VyQWdlbnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJzKSBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG5cbiAgICBsZXQgYm9keTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbGVzICYmIHRoaXMub3B0aW9ucy5maWxlcy5sZW5ndGgpIHtcbiAgICAgIGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiB0aGlzLm9wdGlvbnMuZmlsZXMpIGlmIChmaWxlICYmIGZpbGUuZmlsZSkgYm9keS5hcHBlbmQoZmlsZS5uYW1lLCBmaWxlLmZpbGUsIGZpbGUubmFtZSk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5kYXRhICE9PSAndW5kZWZpbmVkJykgYm9keS5hcHBlbmQoJ3BheWxvYWRfanNvbicsIEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucy5kYXRhKSk7XG4gICAgICBpZiAoIWJyb3dzZXIpIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKGhlYWRlcnMsIGJvZHkuZ2V0SGVhZGVycygpKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kYXRhICE9IG51bGwpIHtcbiAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMuZGF0YSk7XG4gICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGhpcy5jbGllbnQub3B0aW9ucy5yZXN0UmVxdWVzdFRpbWVvdXQpO1xuICAgIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYWdlbnQsXG4gICAgICBib2R5LFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuY2xpZW50LmNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBUElSZXF1ZXN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cbmNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdwb3N0JywgJ2RlbGV0ZScsICdwYXRjaCcsICdwdXQnXTtcbmNvbnN0IHJlZmxlY3RvcnMgPSBbXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJyxcbiAgJ2luc3BlY3QnLFxuICAnY29uc3RydWN0b3InLFxuICBTeW1ib2wudG9QcmltaXRpdmUsXG4gIFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyksXG5dO1xuXG5mdW5jdGlvbiBidWlsZFJvdXRlKG1hbmFnZXIpIHtcbiAgY29uc3Qgcm91dGUgPSBbJyddO1xuICBjb25zdCBoYW5kbGVyID0ge1xuICAgIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICAgIGlmIChyZWZsZWN0b3JzLmluY2x1ZGVzKG5hbWUpKSByZXR1cm4gKCkgPT4gcm91dGUuam9pbignLycpO1xuICAgICAgaWYgKG1ldGhvZHMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgY29uc3Qgcm91dGVCdWNrZXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIFJlYWN0aW9ucyByb3V0ZXMgYW5kIHN1Yi1yb3V0ZXMgYWxsIHNoYXJlIHRoZSBzYW1lIGJ1Y2tldFxuICAgICAgICAgIGlmIChyb3V0ZVtpIC0gMV0gPT09ICdyZWFjdGlvbnMnKSBicmVhaztcbiAgICAgICAgICAvLyBMaXRlcmFsIElEcyBzaG91bGQgb25seSBiZSB0YWtlbiBhY2NvdW50IGlmIHRoZXkgYXJlIHRoZSBNYWpvciBJRCAodGhlIENoYW5uZWwvR3VpbGQgSUQpXG4gICAgICAgICAgaWYgKC9cXGR7MTYsMTl9L2cudGVzdChyb3V0ZVtpXSkgJiYgIS9jaGFubmVsc3xndWlsZHMvLnRlc3Qocm91dGVbaSAtIDFdKSkgcm91dGVCdWNrZXQucHVzaCgnOmlkJyk7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIHBhcnRzIG9mIHRoZSByb3V0ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBwYXJ0IG9mIHRoZSBidWNrZXQgaWRlbnRpZmllclxuICAgICAgICAgIGVsc2Ugcm91dGVCdWNrZXQucHVzaChyb3V0ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgPT5cbiAgICAgICAgICBtYW5hZ2VyLnJlcXVlc3QoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcm91dGUuam9pbignLycpLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZlcnNpb25lZDogbWFuYWdlci52ZXJzaW9uZWQsXG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlQnVja2V0LmpvaW4oJy8nKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJvdXRlLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm4gbmV3IFByb3h5KG5vb3AsIGhhbmRsZXIpO1xuICAgIH0sXG4gICAgYXBwbHkodGFyZ2V0LCBfLCBhcmdzKSB7XG4gICAgICByb3V0ZS5wdXNoKC4uLmFyZ3MuZmlsdGVyKHggPT4geCAhPSBudWxsKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICByZXR1cm4gbmV3IFByb3h5KG5vb3AsIGhhbmRsZXIpO1xuICAgIH0sXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkobm9vcCwgaGFuZGxlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRSb3V0ZTtcbiIsIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAga3lyYW5ldCwgZGlzY29yZC5qc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPKGt5cmFuZXQsIHZsYWRmcmFuZ3UpOiByZXBsYWNlIHRoaXMgd2l0aCBkaXNjb3JkLmpzIHYxMydzIGNvcmUgQXN5bmNRdWV1ZS5cblxuLyoqXG4gKiBBbiBhc3luYyBxdWV1ZSB0aGF0IHByZXNlcnZlcyB0aGUgc3RhY2sgYW5kIHByZXZlbnRzIGxvY2stdXBzLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQXN5bmNRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9taXNlcyBhcnJheS5cbiAgICAgKiBAdHlwZSB7QXJyYXk8e3Byb21pc2U6IFByb21pc2U8dm9pZD4sIHJlc29sdmU6IEZ1bmN0aW9ufT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnByb21pc2VzID0gW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlbWFpbmluZyBhbW91bnQgb2YgcXVldWVkIHByb21pc2VzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcmVtYWluaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnByb21pc2VzLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgbGFzdCBwcm9taXNlIGFuZCBxdWV1ZXMgYSBuZXcgb25lLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcXVldWUgPSBuZXcgQXN5bmNRdWV1ZSgpO1xuICAgKiBhc3luYyBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICAgKiAgICAgYXdhaXQgcXVldWUud2FpdCgpO1xuICAgKiAgICAgdHJ5IHtcbiAgICogICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgKiAgICAgICAgIC8vIERvIHNvbWUgb3BlcmF0aW9ucyB3aXRoICdyZXN1bHQnXG4gICAqICAgICB9IGZpbmFsbHkge1xuICAgKiAgICAgICAgIC8vIFJlbW92ZSBmaXJzdCBlbnRyeSBmcm9tIHRoZSBxdWV1ZSBhbmQgcmVzb2x2ZSBmb3IgdGhlIG5leHQgZW50cnlcbiAgICogICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgKiAgICAgfVxuICAgKiB9XG4gICAqXG4gICAqIHJlcXVlc3Qoc29tZVVybDEsIHNvbWVPcHRpb25zMSk7IC8vIFdpbGwgY2FsbCBmZXRjaCgpIGltbWVkaWF0ZWx5XG4gICAqIHJlcXVlc3Qoc29tZVVybDIsIHNvbWVPcHRpb25zMik7IC8vIFdpbGwgY2FsbCBmZXRjaCgpIGFmdGVyIHRoZSBmaXJzdCBmaW5pc2hlZFxuICAgKiByZXF1ZXN0KHNvbWVVcmwzLCBzb21lT3B0aW9uczMpOyAvLyBXaWxsIGNhbGwgZmV0Y2goKSBhZnRlciB0aGUgc2Vjb25kIGZpbmlzaGVkXG4gICAqL1xuICB3YWl0KCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLnByb21pc2VzLmxlbmd0aCA/IHRoaXMucHJvbWlzZXNbdGhpcy5wcm9taXNlcy5sZW5ndGggLSAxXS5wcm9taXNlIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlcyA9PiB7XG4gICAgICByZXNvbHZlID0gcmVzO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wcm9taXNlcy5wdXNoKHtcbiAgICAgIHJlc29sdmUsXG4gICAgICBwcm9taXNlLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKipcbiAgICogRnJlZXMgdGhlIHF1ZXVlJ3MgbG9jayBmb3IgdGhlIG5leHQgaXRlbSB0byBwcm9jZXNzLlxuICAgKi9cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLnByb21pc2VzLnNoaWZ0KCk7XG4gICAgaWYgKHR5cGVvZiBkZWZlcnJlZCAhPT0gJ3VuZGVmaW5lZCcpIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jUXVldWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciBmcm9tIHRoZSBEaXNjb3JkIEFQSS5cbiAqIEBleHRlbmRzIEVycm9yXG4gKi9cbmNsYXNzIERpc2NvcmRBUElFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGF0aCwgZXJyb3IsIG1ldGhvZCwgc3RhdHVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSB0aGlzLmNvbnN0cnVjdG9yLmZsYXR0ZW5FcnJvcnMoZXJyb3IuZXJyb3JzIHx8IGVycm9yKS5qb2luKCdcXG4nKTtcbiAgICB0aGlzLm5hbWUgPSAnRGlzY29yZEFQSUVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlICYmIGZsYXR0ZW5lZCA/IGAke2Vycm9yLm1lc3NhZ2V9XFxuJHtmbGF0dGVuZWR9YCA6IGVycm9yLm1lc3NhZ2UgfHwgZmxhdHRlbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEhUVFAgbWV0aG9kIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIG9mIHRoZSByZXF1ZXN0IHJlbGF0aXZlIHRvIHRoZSBIVFRQIGVuZHBvaW50XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuXG4gICAgLyoqXG4gICAgICogSFRUUCBlcnJvciBjb2RlIHJldHVybmVkIGJ5IERpc2NvcmRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY29kZSA9IGVycm9yLmNvZGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSFRUUCBzdGF0dXMgY29kZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5odHRwU3RhdHVzID0gc3RhdHVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYXR0ZW5zIGFuIGVycm9ycyBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgQVBJIGludG8gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogRGlzY29yZCBlcnJvcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBVc2VkIGludGVybmFsbHkgdG8gZGV0ZXJtaW5lIGtleSBuYW1lcyBvZiBuZXN0ZWQgZmllbGRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBmbGF0dGVuRXJyb3JzKG9iaiwga2V5ID0gJycpIHtcbiAgICBsZXQgbWVzc2FnZXMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgIGlmIChrID09PSAnbWVzc2FnZScpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbmV3S2V5ID0ga2V5ID8gKGlzTmFOKGspID8gYCR7a2V5fS4ke2t9YCA6IGAke2tleX1bJHtrfV1gKSA6IGs7XG5cbiAgICAgIGlmICh2Ll9lcnJvcnMpIHtcbiAgICAgICAgbWVzc2FnZXMucHVzaChgJHtuZXdLZXl9OiAke3YuX2Vycm9ycy5tYXAoZSA9PiBlLm1lc3NhZ2UpLmpvaW4oJyAnKX1gKTtcbiAgICAgIH0gZWxzZSBpZiAodi5jb2RlIHx8IHYubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKGAke3YuY29kZSA/IGAke3YuY29kZX06IGAgOiAnJ30ke3YubWVzc2FnZX1gLnRyaW0oKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5jb25jYXQodGhpcy5mbGF0dGVuRXJyb3JzKHYsIG5ld0tleSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc2NvcmRBUElFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgSFRUUCBlcnJvciBmcm9tIGEgcmVxdWVzdC5cbiAqIEBleHRlbmRzIEVycm9yXG4gKi9cbmNsYXNzIEhUVFBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSwgY29kZSwgbWV0aG9kLCBwYXRoKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZXJyb3JcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBIVFRQIGVycm9yIGNvZGUgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb2RlID0gY29kZSB8fCA1MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSFRUUCBtZXRob2QgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhdGggb2YgdGhlIHJlcXVlc3QgcmVsYXRpdmUgdG8gdGhlIEhUVFAgZW5kcG9pbnRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIVFRQRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFQSVJlcXVlc3QgPSByZXF1aXJlKCcuL0FQSVJlcXVlc3QnKTtcbmNvbnN0IHJvdXRlQnVpbGRlciA9IHJlcXVpcmUoJy4vQVBJUm91dGVyJyk7XG5jb25zdCBSZXF1ZXN0SGFuZGxlciA9IHJlcXVpcmUoJy4vUmVxdWVzdEhhbmRsZXInKTtcbmNvbnN0IHsgRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuY29uc3QgeyBFbmRwb2ludHMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIFJFU1RNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCB0b2tlblByZWZpeCA9ICdCb3QnKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgdGhpcy50b2tlblByZWZpeCA9IHRva2VuUHJlZml4O1xuICAgIHRoaXMudmVyc2lvbmVkID0gdHJ1ZTtcbiAgICB0aGlzLmdsb2JhbFRpbWVvdXQgPSBudWxsO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5yZXN0U3dlZXBJbnRlcnZhbCA+IDApIHtcbiAgICAgIGNsaWVudC5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuc3dlZXAoaGFuZGxlciA9PiBoYW5kbGVyLl9pbmFjdGl2ZSk7XG4gICAgICB9LCBjbGllbnQub3B0aW9ucy5yZXN0U3dlZXBJbnRlcnZhbCAqIDEwMDApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhcGkoKSB7XG4gICAgcmV0dXJuIHJvdXRlQnVpbGRlcih0aGlzKTtcbiAgfVxuXG4gIGdldEF1dGgoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmNsaWVudC50b2tlbiB8fCB0aGlzLmNsaWVudC5hY2Nlc3NUb2tlbjtcbiAgICBpZiAodG9rZW4pIHJldHVybiBgJHt0aGlzLnRva2VuUHJlZml4fSAke3Rva2VufWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0tFTl9NSVNTSU5HJyk7XG4gIH1cblxuICBnZXQgY2RuKCkge1xuICAgIHJldHVybiBFbmRwb2ludHMuQ0ROKHRoaXMuY2xpZW50Lm9wdGlvbnMuaHR0cC5jZG4pO1xuICB9XG5cbiAgcmVxdWVzdChtZXRob2QsIHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYXBpUmVxdWVzdCA9IG5ldyBBUElSZXF1ZXN0KHRoaXMsIG1ldGhvZCwgdXJsLCBvcHRpb25zKTtcbiAgICBsZXQgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnMuZ2V0KGFwaVJlcXVlc3Qucm91dGUpO1xuXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyID0gbmV3IFJlcXVlc3RIYW5kbGVyKHRoaXMpO1xuICAgICAgdGhpcy5oYW5kbGVycy5zZXQoYXBpUmVxdWVzdC5yb3V0ZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXIucHVzaChhcGlSZXF1ZXN0KTtcbiAgfVxuXG4gIGdldCBlbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQub3B0aW9ucy5odHRwLmFwaTtcbiAgfVxuXG4gIHNldCBlbmRwb2ludChlbmRwb2ludCkge1xuICAgIHRoaXMuY2xpZW50Lm9wdGlvbnMuaHR0cC5hcGkgPSBlbmRwb2ludDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJFU1RNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3luY1F1ZXVlID0gcmVxdWlyZSgnLi9Bc3luY1F1ZXVlJyk7XG5jb25zdCBEaXNjb3JkQVBJRXJyb3IgPSByZXF1aXJlKCcuL0Rpc2NvcmRBUElFcnJvcicpO1xuY29uc3QgSFRUUEVycm9yID0gcmVxdWlyZSgnLi9IVFRQRXJyb3InKTtcbmNvbnN0IHtcbiAgRXZlbnRzOiB7IFJBVEVfTElNSVQgfSxcbiAgYnJvd3Nlcixcbn0gPSByZXF1aXJlKCcuLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xuXG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKHJlcykge1xuICBpZiAocmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKS5zdGFydHNXaXRoKCdhcHBsaWNhdGlvbi9qc29uJykpIHJldHVybiByZXMuanNvbigpO1xuICBpZiAoYnJvd3NlcikgcmV0dXJuIHJlcy5ibG9iKCk7XG4gIHJldHVybiByZXMuYnVmZmVyKCk7XG59XG5cbmZ1bmN0aW9uIGdldEFQSU9mZnNldChzZXJ2ZXJEYXRlKSB7XG4gIHJldHVybiBuZXcgRGF0ZShzZXJ2ZXJEYXRlKS5nZXRUaW1lKCkgLSBEYXRlLm5vdygpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZXNldChyZXNldCwgc2VydmVyRGF0ZSkge1xuICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHJlc2V0KSAqIDEwMDApLmdldFRpbWUoKSAtIGdldEFQSU9mZnNldChzZXJ2ZXJEYXRlKTtcbn1cblxuY2xhc3MgUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcbiAgICB0aGlzLnJlc2V0ID0gLTE7XG4gICAgdGhpcy5yZW1haW5pbmcgPSAtMTtcbiAgICB0aGlzLmxpbWl0ID0gLTE7XG4gICAgdGhpcy5yZXRyeUFmdGVyID0gLTE7XG4gIH1cblxuICBhc3luYyBwdXNoKHJlcXVlc3QpIHtcbiAgICBhd2FpdCB0aGlzLnF1ZXVlLndhaXQoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsaW1pdGVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMubWFuYWdlci5nbG9iYWxUaW1lb3V0KSB8fCAodGhpcy5yZW1haW5pbmcgPD0gMCAmJiBEYXRlLm5vdygpIDwgdGhpcy5yZXNldCk7XG4gIH1cblxuICBnZXQgX2luYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLnJlbWFpbmluZyA9PT0gMCAmJiAhdGhpcy5saW1pdGVkO1xuICB9XG5cbiAgYXN5bmMgZXhlY3V0ZShyZXF1ZXN0KSB7XG4gICAgLy8gQWZ0ZXIgY2FsY3VsYXRpb25zIGFuZCByZXF1ZXN0cyBoYXZlIGJlZW4gZG9uZSwgcHJlLWVtcHRpdmVseSBzdG9wIGZ1cnRoZXIgcmVxdWVzdHNcbiAgICBpZiAodGhpcy5saW1pdGVkKSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5yZXNldCArIHRoaXMubWFuYWdlci5jbGllbnQub3B0aW9ucy5yZXN0VGltZU9mZnNldCAtIERhdGUubm93KCk7XG5cbiAgICAgIGlmICh0aGlzLm1hbmFnZXIuY2xpZW50Lmxpc3RlbmVyQ291bnQoUkFURV9MSU1JVCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgY2xpZW50IGhpdHMgYSByYXRlIGxpbWl0IHdoaWxlIG1ha2luZyBhIHJlcXVlc3RcbiAgICAgICAgICogQGV2ZW50IENsaWVudCNyYXRlTGltaXRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJhdGVMaW1pdEluZm8gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJhdGUgbGltaXQgaW5mb1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0ZUxpbWl0SW5mby50aW1lb3V0IFRpbWVvdXQgaW4gbXNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGVMaW1pdEluZm8ubGltaXQgTnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgY2FuIGJlIG1hZGUgdG8gdGhpcyBlbmRwb2ludFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmF0ZUxpbWl0SW5mby5tZXRob2QgSFRUUCBtZXRob2QgdXNlZCBmb3IgcmVxdWVzdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByYXRlTGltaXRJbmZvLnBhdGggUGF0aCB1c2VkIGZvciByZXF1ZXN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJhdGVMaW1pdEluZm8ucm91dGUgUm91dGUgdXNlZCBmb3IgcmVxdWVzdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hbmFnZXIuY2xpZW50LmVtaXQoUkFURV9MSU1JVCwge1xuICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgbGltaXQ6IHRoaXMubGltaXQsXG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICBwYXRoOiByZXF1ZXN0LnBhdGgsXG4gICAgICAgICAgcm91dGU6IHJlcXVlc3Qucm91dGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYW5hZ2VyLmdsb2JhbFRpbWVvdXQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5tYW5hZ2VyLmdsb2JhbFRpbWVvdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgdGltZW91dCB0byBleHBpcmUgaW4gb3JkZXIgdG8gYXZvaWQgYW4gYWN0dWFsIDQyOVxuICAgICAgICBhd2FpdCBVdGlsLmRlbGF5Rm9yKHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gdGhlIHJlcXVlc3RcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBhd2FpdCByZXF1ZXN0Lm1ha2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gUmV0cnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMgZm9yIHJlcXVlc3QgYWJvcnRpb25zXG4gICAgICBpZiAocmVxdWVzdC5yZXRyaWVzID09PSB0aGlzLm1hbmFnZXIuY2xpZW50Lm9wdGlvbnMucmV0cnlMaW1pdCkge1xuICAgICAgICB0aHJvdyBuZXcgSFRUUEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLmNvbnN0cnVjdG9yLm5hbWUsIGVycm9yLnN0YXR1cywgcmVxdWVzdC5tZXRob2QsIHJlcXVlc3QucGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QucmV0cmllcysrO1xuICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBpZiAocmVzICYmIHJlcy5oZWFkZXJzKSB7XG4gICAgICBjb25zdCBzZXJ2ZXJEYXRlID0gcmVzLmhlYWRlcnMuZ2V0KCdkYXRlJyk7XG4gICAgICBjb25zdCBsaW1pdCA9IHJlcy5oZWFkZXJzLmdldCgneC1yYXRlbGltaXQtbGltaXQnKTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHJlcy5oZWFkZXJzLmdldCgneC1yYXRlbGltaXQtcmVtYWluaW5nJyk7XG4gICAgICBjb25zdCByZXNldCA9IHJlcy5oZWFkZXJzLmdldCgneC1yYXRlbGltaXQtcmVzZXQnKTtcbiAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXMuaGVhZGVycy5nZXQoJ3JldHJ5LWFmdGVyJyk7XG5cbiAgICAgIHRoaXMubGltaXQgPSBsaW1pdCA/IE51bWJlcihsaW1pdCkgOiBJbmZpbml0eTtcbiAgICAgIHRoaXMucmVtYWluaW5nID0gcmVtYWluaW5nID8gTnVtYmVyKHJlbWFpbmluZykgOiAxO1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0ID8gY2FsY3VsYXRlUmVzZXQocmVzZXQsIHNlcnZlckRhdGUpIDogRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMucmV0cnlBZnRlciA9IHJldHJ5QWZ0ZXIgPyBOdW1iZXIocmV0cnlBZnRlcikgOiAtMTtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rpc2NvcmRhcHAvZGlzY29yZC1hcGktZG9jcy9pc3N1ZXMvMTgyXG4gICAgICBpZiAocmVxdWVzdC5yb3V0ZS5pbmNsdWRlcygncmVhY3Rpb25zJykpIHtcbiAgICAgICAgdGhpcy5yZXNldCA9IG5ldyBEYXRlKHNlcnZlckRhdGUpLmdldFRpbWUoKSAtIGdldEFQSU9mZnNldChzZXJ2ZXJEYXRlKSArIDI1MDtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGdsb2JhbCByYXRlbGltaXRcbiAgICAgIGlmIChyZXMuaGVhZGVycy5nZXQoJ3gtcmF0ZWxpbWl0LWdsb2JhbCcpKSB7XG4gICAgICAgIC8vIFNldCB0aGUgbWFuYWdlcidzIGdsb2JhbCB0aW1lb3V0IGFzIHRoZSBwcm9taXNlIGZvciBvdGhlciByZXF1ZXN0cyB0byBcIndhaXRcIlxuICAgICAgICB0aGlzLm1hbmFnZXIuZ2xvYmFsVGltZW91dCA9IFV0aWwuZGVsYXlGb3IodGhpcy5yZXRyeUFmdGVyKTtcblxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgZ2xvYmFsIHRpbWVvdXQgdG8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICBhd2FpdCB0aGlzLm1hbmFnZXIuZ2xvYmFsVGltZW91dDtcblxuICAgICAgICAvLyBDbGVhbiB1cCBnbG9iYWwgdGltZW91dFxuICAgICAgICB0aGlzLm1hbmFnZXIuZ2xvYmFsVGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIDJ4eCBhbmQgM3h4IHJlc3BvbnNlc1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIC8vIE5vdGhpbmcgd3Jvbmcgd2l0aCB0aGUgcmVxdWVzdCwgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IG9uZVxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2UocmVzKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgNHh4IHJlc3BvbnNlc1xuICAgIGlmIChyZXMuc3RhdHVzID49IDQwMCAmJiByZXMuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAvLyBIYW5kbGUgcmF0ZWxpbWl0ZWQgcmVxdWVzdHNcbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgLy8gQSByYXRlbGltaXQgd2FzIGhpdCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB0aGlzLm1hbmFnZXIuY2xpZW50LmVtaXQoJ2RlYnVnJywgYDQyOSBoaXQgb24gcm91dGUgJHtyZXF1ZXN0LnJvdXRlfWApO1xuICAgICAgICBhd2FpdCBVdGlsLmRlbGF5Rm9yKHRoaXMucmV0cnlBZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGUocmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBwb3NzaWJsZSBtYWxmb3JtZWQgcmVxdWVzdHNcbiAgICAgIGxldCBkYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHBhcnNlUmVzcG9uc2UocmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgSFRUUEVycm9yKGVyci5tZXNzYWdlLCBlcnIuY29uc3RydWN0b3IubmFtZSwgZXJyLnN0YXR1cywgcmVxdWVzdC5tZXRob2QsIHJlcXVlc3QucGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBEaXNjb3JkQVBJRXJyb3IocmVxdWVzdC5wYXRoLCBkYXRhLCByZXF1ZXN0Lm1ldGhvZCwgcmVzLnN0YXR1cyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIDV4eCByZXNwb25zZXNcbiAgICBpZiAocmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyA8IDYwMCkge1xuICAgICAgLy8gUmV0cnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMgZm9yIHBvc3NpYmxlIHNlcnZlcnNpZGUgaXNzdWVzXG4gICAgICBpZiAocmVxdWVzdC5yZXRyaWVzID09PSB0aGlzLm1hbmFnZXIuY2xpZW50Lm9wdGlvbnMucmV0cnlMaW1pdCkge1xuICAgICAgICB0aHJvdyBuZXcgSFRUUEVycm9yKHJlcy5zdGF0dXNUZXh0LCByZXMuY29uc3RydWN0b3IubmFtZSwgcmVzLnN0YXR1cywgcmVxdWVzdC5tZXRob2QsIHJlcXVlc3QucGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QucmV0cmllcysrO1xuICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBpbiB0aGUgcmFyZSBjYXNlIGEgc3RhdHVzIGNvZGUgb3V0c2lkZSB0aGUgcmFuZ2UgMjAwLi49NTk5IGlzIHJldHVybmVkXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0SGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWVzc2FnZUF0dGFjaG1lbnQgPSByZXF1aXJlKCcuL01lc3NhZ2VBdHRhY2htZW50Jyk7XG5jb25zdCBNZXNzYWdlRW1iZWQgPSByZXF1aXJlKCcuL01lc3NhZ2VFbWJlZCcpO1xuY29uc3QgeyBSYW5nZUVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IHsgYnJvd3NlciB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IERhdGFSZXNvbHZlciA9IHJlcXVpcmUoJy4uL3V0aWwvRGF0YVJlc29sdmVyJyk7XG5jb25zdCBNZXNzYWdlRmxhZ3MgPSByZXF1aXJlKCcuLi91dGlsL01lc3NhZ2VGbGFncycpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gdGhlIEFQSS5cbiAqL1xuY2xhc3MgQVBJTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge01lc3NhZ2VUYXJnZXR9IHRhcmdldCAtIFRoZSB0YXJnZXQgZm9yIHRoaXMgbWVzc2FnZSB0byBiZSBzZW50IHRvXG4gICAqIEBwYXJhbSB7TWVzc2FnZU9wdGlvbnN8V2ViaG9va01lc3NhZ2VPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBwYXNzZWQgaW4gZnJvbSBzZW5kXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IGZvciB0aGlzIG1lc3NhZ2UgdG8gYmUgc2VudCB0b1xuICAgICAqIEB0eXBlIHtNZXNzYWdlVGFyZ2V0fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBwYXNzZWQgaW4gZnJvbSBzZW5kXG4gICAgICogQHR5cGUge01lc3NhZ2VPcHRpb25zfFdlYmhvb2tNZXNzYWdlT3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBzZW5kYWJsZSB0byB0aGUgQVBJXG4gICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEZpbGVzIHNlbmRhYmxlIHRvIHRoZSBBUElcbiAgICAgKiBAdHlwZSB7P09iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuZmlsZXMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0YXJnZXQgaXMgYSB3ZWJob29rXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpc1dlYmhvb2soKSB7XG4gICAgY29uc3QgV2ViaG9vayA9IHJlcXVpcmUoJy4vV2ViaG9vaycpO1xuICAgIGNvbnN0IFdlYmhvb2tDbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQvV2ViaG9va0NsaWVudCcpO1xuICAgIHJldHVybiB0aGlzLnRhcmdldCBpbnN0YW5jZW9mIFdlYmhvb2sgfHwgdGhpcy50YXJnZXQgaW5zdGFuY2VvZiBXZWJob29rQ2xpZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0YXJnZXQgaXMgYSB1c2VyXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpc1VzZXIoKSB7XG4gICAgY29uc3QgVXNlciA9IHJlcXVpcmUoJy4vVXNlcicpO1xuICAgIGNvbnN0IEd1aWxkTWVtYmVyID0gcmVxdWlyZSgnLi9HdWlsZE1lbWJlcicpO1xuICAgIHJldHVybiB0aGlzLnRhcmdldCBpbnN0YW5jZW9mIFVzZXIgfHwgdGhpcy50YXJnZXQgaW5zdGFuY2VvZiBHdWlsZE1lbWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdGFyZ2V0IGlzIGEgbWVzc2FnZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNNZXNzYWdlKCkge1xuICAgIGNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuL01lc3NhZ2UnKTtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQgaW5zdGFuY2VvZiBNZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIHRoZSBjb250ZW50IG9mIHRoaXMgbWVzc2FnZS5cbiAgICogQHJldHVybnMgez8oc3RyaW5nfHN0cmluZ1tdKX1cbiAgICovXG4gIG1ha2VDb250ZW50KCkge1xuICAgIGNvbnN0IEd1aWxkTWVtYmVyID0gcmVxdWlyZSgnLi9HdWlsZE1lbWJlcicpO1xuXG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50ID09PSBudWxsKSB7XG4gICAgICBjb250ZW50ID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb250ZW50ID0gVXRpbC5yZXNvbHZlU3RyaW5nKHRoaXMub3B0aW9ucy5jb250ZW50KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSByZXR1cm4gY29udGVudDtcblxuICAgIGNvbnN0IGRpc2FibGVNZW50aW9ucyA9XG4gICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmRpc2FibGVNZW50aW9ucyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB0aGlzLnRhcmdldC5jbGllbnQub3B0aW9ucy5kaXNhYmxlTWVudGlvbnNcbiAgICAgICAgOiB0aGlzLm9wdGlvbnMuZGlzYWJsZU1lbnRpb25zO1xuICAgIGlmIChkaXNhYmxlTWVudGlvbnMgPT09ICdhbGwnKSB7XG4gICAgICBjb250ZW50ID0gVXRpbC5yZW1vdmVNZW50aW9ucyhjb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKGRpc2FibGVNZW50aW9ucyA9PT0gJ2V2ZXJ5b25lJykge1xuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvQChbXjw+QCBdKikvZ21zdSwgKG1hdGNoLCB0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXlsmIV0/XFxkKyQvKSkge1xuICAgICAgICAgIHJldHVybiBgQCR7dGFyZ2V0fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGBAXFx1MjAwYiR7dGFyZ2V0fWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzU3BsaXQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNwbGl0ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wdGlvbnMuc3BsaXQgIT09IGZhbHNlO1xuICAgIGNvbnN0IGlzQ29kZSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuY29kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcHRpb25zLmNvZGUgIT09IGZhbHNlO1xuICAgIGNvbnN0IHNwbGl0T3B0aW9ucyA9IGlzU3BsaXQgPyB7IC4uLnRoaXMub3B0aW9ucy5zcGxpdCB9IDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IG1lbnRpb25QYXJ0ID0gJyc7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXBseSAmJiAhdGhpcy5pc1VzZXIgJiYgdGhpcy50YXJnZXQudHlwZSAhPT0gJ2RtJykge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLnRhcmdldC5jbGllbnQudXNlcnMucmVzb2x2ZUlEKHRoaXMub3B0aW9ucy5yZXBseSk7XG4gICAgICBtZW50aW9uUGFydCA9IGA8QCR7dGhpcy5vcHRpb25zLnJlcGx5IGluc3RhbmNlb2YgR3VpbGRNZW1iZXIgJiYgdGhpcy5vcHRpb25zLnJlcGx5Lm5pY2tuYW1lID8gJyEnIDogJyd9JHtpZH0+LCBgO1xuICAgICAgaWYgKGlzU3BsaXQpIHtcbiAgICAgICAgc3BsaXRPcHRpb25zLnByZXBlbmQgPSBgJHttZW50aW9uUGFydH0ke3NwbGl0T3B0aW9ucy5wcmVwZW5kIHx8ICcnfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnQgfHwgbWVudGlvblBhcnQpIHtcbiAgICAgIGlmIChpc0NvZGUpIHtcbiAgICAgICAgY29uc3QgY29kZU5hbWUgPSB0eXBlb2YgdGhpcy5vcHRpb25zLmNvZGUgPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLmNvZGUgOiAnJztcbiAgICAgICAgY29udGVudCA9IGAke21lbnRpb25QYXJ0fVxcYFxcYFxcYCR7Y29kZU5hbWV9XFxuJHtVdGlsLmNsZWFuQ29kZUJsb2NrQ29udGVudChjb250ZW50KX1cXG5cXGBcXGBcXGBgO1xuICAgICAgICBpZiAoaXNTcGxpdCkge1xuICAgICAgICAgIHNwbGl0T3B0aW9ucy5wcmVwZW5kID0gYCR7c3BsaXRPcHRpb25zLnByZXBlbmQgfHwgJyd9XFxgXFxgXFxgJHtjb2RlTmFtZX1cXG5gO1xuICAgICAgICAgIHNwbGl0T3B0aW9ucy5hcHBlbmQgPSBgXFxuXFxgXFxgXFxgJHtzcGxpdE9wdGlvbnMuYXBwZW5kIHx8ICcnfWA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWVudGlvblBhcnQpIHtcbiAgICAgICAgY29udGVudCA9IGAke21lbnRpb25QYXJ0fSR7Y29udGVudH1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTcGxpdCkge1xuICAgICAgICBjb250ZW50ID0gVXRpbC5zcGxpdE1lc3NhZ2UoY29udGVudCwgc3BsaXRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBkYXRhLlxuICAgKiBAcmV0dXJucyB7QVBJTWVzc2FnZX1cbiAgICovXG4gIHJlc29sdmVEYXRhKCkge1xuICAgIGlmICh0aGlzLmRhdGEpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgY29udGVudCA9IHRoaXMubWFrZUNvbnRlbnQoKTtcbiAgICBjb25zdCB0dHMgPSBCb29sZWFuKHRoaXMub3B0aW9ucy50dHMpO1xuXG4gICAgbGV0IG5vbmNlO1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm5vbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbm9uY2UgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMubm9uY2UpO1xuICAgICAgaWYgKGlzTmFOKG5vbmNlKSB8fCBub25jZSA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdNRVNTQUdFX05PTkNFX1RZUEUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbWJlZExpa2VzID0gW107XG4gICAgaWYgKHRoaXMuaXNXZWJob29rKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVtYmVkcykge1xuICAgICAgICBlbWJlZExpa2VzLnB1c2goLi4udGhpcy5vcHRpb25zLmVtYmVkcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZW1iZWQpIHtcbiAgICAgIGVtYmVkTGlrZXMucHVzaCh0aGlzLm9wdGlvbnMuZW1iZWQpO1xuICAgIH1cbiAgICBjb25zdCBlbWJlZHMgPSBlbWJlZExpa2VzLm1hcChlID0+IG5ldyBNZXNzYWdlRW1iZWQoZSkudG9KU09OKCkpO1xuXG4gICAgbGV0IHVzZXJuYW1lO1xuICAgIGxldCBhdmF0YXJVUkw7XG4gICAgaWYgKHRoaXMuaXNXZWJob29rKSB7XG4gICAgICB1c2VybmFtZSA9IHRoaXMub3B0aW9ucy51c2VybmFtZSB8fCB0aGlzLnRhcmdldC5uYW1lO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdmF0YXJVUkwpIGF2YXRhclVSTCA9IHRoaXMub3B0aW9ucy5hdmF0YXJVUkw7XG4gICAgfVxuXG4gICAgbGV0IGZsYWdzO1xuICAgIGlmICh0aGlzLmlzTWVzc2FnZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgZmxhZ3MgPSB0aGlzLm9wdGlvbnMuZmxhZ3MgIT0gbnVsbCA/IG5ldyBNZXNzYWdlRmxhZ3ModGhpcy5vcHRpb25zLmZsYWdzKS5iaXRmaWVsZCA6IHRoaXMudGFyZ2V0LmZsYWdzLmJpdGZpZWxkO1xuICAgIH1cblxuICAgIGxldCBhbGxvd2VkTWVudGlvbnMgPVxuICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5hbGxvd2VkTWVudGlvbnMgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gdGhpcy50YXJnZXQuY2xpZW50Lm9wdGlvbnMuYWxsb3dlZE1lbnRpb25zXG4gICAgICAgIDogdGhpcy5vcHRpb25zLmFsbG93ZWRNZW50aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlcGx5KSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMudGFyZ2V0LmNsaWVudC51c2Vycy5yZXNvbHZlSUQodGhpcy5vcHRpb25zLnJlcGx5KTtcbiAgICAgIGlmIChhbGxvd2VkTWVudGlvbnMpIHtcbiAgICAgICAgLy8gQ2xvbmUgdGhlIG9iamVjdCBhcyBub3QgdG8gYWx0ZXIgdGhlIENsaWVudE9wdGlvbnMgb2JqZWN0XG4gICAgICAgIGFsbG93ZWRNZW50aW9ucyA9IFV0aWwuY2xvbmVPYmplY3QoYWxsb3dlZE1lbnRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gYWxsb3dlZE1lbnRpb25zLnBhcnNlICYmIGFsbG93ZWRNZW50aW9ucy5wYXJzZS5pbmNsdWRlcygndXNlcnMnKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1lbnRpb24gd29uJ3QgYmUgcGFyc2VkLCBhbmQgaXNuJ3Qgc3VwcGxpZWQgaW4gYHVzZXJzYFxuICAgICAgICBpZiAoIXBhcnNlZCAmJiAhKGFsbG93ZWRNZW50aW9ucy51c2VycyAmJiBhbGxvd2VkTWVudGlvbnMudXNlcnMuaW5jbHVkZXMoaWQpKSkge1xuICAgICAgICAgIGlmICghYWxsb3dlZE1lbnRpb25zLnVzZXJzKSBhbGxvd2VkTWVudGlvbnMudXNlcnMgPSBbXTtcbiAgICAgICAgICBhbGxvd2VkTWVudGlvbnMudXNlcnMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93ZWRNZW50aW9ucyA9IHsgdXNlcnM6IFtpZF0gfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBjb250ZW50LFxuICAgICAgdHRzLFxuICAgICAgbm9uY2UsXG4gICAgICBlbWJlZDogdGhpcy5vcHRpb25zLmVtYmVkID09PSBudWxsID8gbnVsbCA6IGVtYmVkc1swXSxcbiAgICAgIGVtYmVkcyxcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgYXZhdGFyX3VybDogYXZhdGFyVVJMLFxuICAgICAgYWxsb3dlZF9tZW50aW9uczogdHlwZW9mIGNvbnRlbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogYWxsb3dlZE1lbnRpb25zLFxuICAgICAgZmxhZ3MsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBmaWxlcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QVBJTWVzc2FnZT59XG4gICAqL1xuICBhc3luYyByZXNvbHZlRmlsZXMoKSB7XG4gICAgaWYgKHRoaXMuZmlsZXMpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZW1iZWRMaWtlcyA9IFtdO1xuICAgIGlmICh0aGlzLmlzV2ViaG9vaykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbWJlZHMpIHtcbiAgICAgICAgZW1iZWRMaWtlcy5wdXNoKC4uLnRoaXMub3B0aW9ucy5lbWJlZHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVtYmVkKSB7XG4gICAgICBlbWJlZExpa2VzLnB1c2godGhpcy5vcHRpb25zLmVtYmVkKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlTGlrZXMgPSBbXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbGVzKSB7XG4gICAgICBmaWxlTGlrZXMucHVzaCguLi50aGlzLm9wdGlvbnMuZmlsZXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVtYmVkIG9mIGVtYmVkTGlrZXMpIHtcbiAgICAgIGlmIChlbWJlZC5maWxlcykge1xuICAgICAgICBmaWxlTGlrZXMucHVzaCguLi5lbWJlZC5maWxlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVMaWtlcy5tYXAoZiA9PiB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmVGaWxlKGYpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBBUElNZXNzYWdlIGludG8gYW4gYXJyYXkgb2YgQVBJTWVzc2FnZXMgZm9yIGVhY2ggc3BsaXQgY29udGVudFxuICAgKiBAcmV0dXJucyB7QVBJTWVzc2FnZVtdfVxuICAgKi9cbiAgc3BsaXQoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEpIHRoaXMucmVzb2x2ZURhdGEoKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEuY29udGVudCkpIHJldHVybiBbdGhpc107XG5cbiAgICBjb25zdCBhcGlNZXNzYWdlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGRhdGE7XG4gICAgICBsZXQgb3B0O1xuXG4gICAgICBpZiAoaSA9PT0gdGhpcy5kYXRhLmNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICBkYXRhID0geyAuLi50aGlzLmRhdGEsIGNvbnRlbnQ6IHRoaXMuZGF0YS5jb250ZW50W2ldIH07XG4gICAgICAgIG9wdCA9IHsgLi4udGhpcy5vcHRpb25zLCBjb250ZW50OiB0aGlzLmRhdGEuY29udGVudFtpXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHsgY29udGVudDogdGhpcy5kYXRhLmNvbnRlbnRbaV0sIHR0czogdGhpcy5kYXRhLnR0cywgYWxsb3dlZF9tZW50aW9uczogdGhpcy5vcHRpb25zLmFsbG93ZWRNZW50aW9ucyB9O1xuICAgICAgICBvcHQgPSB7IGNvbnRlbnQ6IHRoaXMuZGF0YS5jb250ZW50W2ldLCB0dHM6IHRoaXMuZGF0YS50dHMsIGFsbG93ZWRNZW50aW9uczogdGhpcy5vcHRpb25zLmFsbG93ZWRNZW50aW9ucyB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcGlNZXNzYWdlID0gbmV3IEFQSU1lc3NhZ2UodGhpcy50YXJnZXQsIG9wdCk7XG4gICAgICBhcGlNZXNzYWdlLmRhdGEgPSBkYXRhO1xuICAgICAgYXBpTWVzc2FnZXMucHVzaChhcGlNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBpTWVzc2FnZXM7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBzaW5nbGUgZmlsZSBpbnRvIGFuIG9iamVjdCBzZW5kYWJsZSB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge0J1ZmZlclJlc29sdmFibGV8U3RyZWFtfEZpbGVPcHRpb25zfE1lc3NhZ2VBdHRhY2htZW50fSBmaWxlTGlrZSBTb21ldGhpbmcgdGhhdCBjb3VsZCBiZSByZXNvbHZlZCB0byBhIGZpbGVcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBhc3luYyByZXNvbHZlRmlsZShmaWxlTGlrZSkge1xuICAgIGxldCBhdHRhY2htZW50O1xuICAgIGxldCBuYW1lO1xuXG4gICAgY29uc3QgZmluZE5hbWUgPSB0aGluZyA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gVXRpbC5iYXNlbmFtZSh0aGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGluZy5wYXRoKSB7XG4gICAgICAgIHJldHVybiBVdGlsLmJhc2VuYW1lKHRoaW5nLnBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ2ZpbGUuanBnJztcbiAgICB9O1xuXG4gICAgY29uc3Qgb3duQXR0YWNobWVudCA9XG4gICAgICB0eXBlb2YgZmlsZUxpa2UgPT09ICdzdHJpbmcnIHx8XG4gICAgICBmaWxlTGlrZSBpbnN0YW5jZW9mIChicm93c2VyID8gQXJyYXlCdWZmZXIgOiBCdWZmZXIpIHx8XG4gICAgICB0eXBlb2YgZmlsZUxpa2UucGlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAob3duQXR0YWNobWVudCkge1xuICAgICAgYXR0YWNobWVudCA9IGZpbGVMaWtlO1xuICAgICAgbmFtZSA9IGZpbmROYW1lKGF0dGFjaG1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRhY2htZW50ID0gZmlsZUxpa2UuYXR0YWNobWVudDtcbiAgICAgIG5hbWUgPSBmaWxlTGlrZS5uYW1lIHx8IGZpbmROYW1lKGF0dGFjaG1lbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlID0gYXdhaXQgRGF0YVJlc29sdmVyLnJlc29sdmVGaWxlKGF0dGFjaG1lbnQpO1xuICAgIHJldHVybiB7IGF0dGFjaG1lbnQsIG5hbWUsIGZpbGU6IHJlc291cmNlIH07XG4gIH1cblxuICAvKipcbiAgICogUGFydGl0aW9ucyBlbWJlZHMgYW5kIGF0dGFjaG1lbnRzLlxuICAgKiBAcGFyYW0ge0FycmF5PE1lc3NhZ2VFbWJlZHxNZXNzYWdlQXR0YWNobWVudD59IGl0ZW1zIEl0ZW1zIHRvIHBhcnRpdGlvblxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWVzc2FnZUVtYmVkW10sIE1lc3NhZ2VBdHRhY2htZW50W10+fVxuICAgKi9cbiAgc3RhdGljIHBhcnRpdGlvbk1lc3NhZ2VBZGRpdGlvbnMoaXRlbXMpIHtcbiAgICBjb25zdCBlbWJlZHMgPSBbXTtcbiAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBNZXNzYWdlRW1iZWQpIHtcbiAgICAgICAgZW1iZWRzLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBNZXNzYWdlQXR0YWNobWVudCkge1xuICAgICAgICBmaWxlcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbZW1iZWRzLCBmaWxlc107XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgdXNlci1sZXZlbCBhcmd1bWVudHMgaW50byBhIGZpbmFsIG9wdGlvbnMgb2JqZWN0LiBQYXNzaW5nIGEgdHJhbnNmb3JtZWQgb3B0aW9ucyBvYmplY3QgYWxvbmUgaW50b1xuICAgKiB0aGlzIG1ldGhvZCB3aWxsIGtlZXAgaXQgdGhlIHNhbWUsIGFsbG93aW5nIGZvciB0aGUgcmV1c2Ugb2YgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1N0cmluZ1Jlc29sdmFibGV9IFtjb250ZW50XSBDb250ZW50IHRvIHNlbmRcbiAgICogQHBhcmFtIHtNZXNzYWdlT3B0aW9uc3xXZWJob29rTWVzc2FnZU9wdGlvbnN8TWVzc2FnZUFkZGl0aW9uc30gW29wdGlvbnM9e31dIE9wdGlvbnMgdG8gdXNlXG4gICAqIEBwYXJhbSB7TWVzc2FnZU9wdGlvbnN8V2ViaG9va01lc3NhZ2VPcHRpb25zfSBbZXh0cmE9e31dIEV4dHJhIG9wdGlvbnMgdG8gYWRkIG9udG8gdHJhbnNmb3JtZWQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1dlYmhvb2s9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBXZWJob29rTWVzc2FnZU9wdGlvbnMgYXMgdGhlIHJlc3VsdFxuICAgKiBAcmV0dXJucyB7TWVzc2FnZU9wdGlvbnN8V2ViaG9va01lc3NhZ2VPcHRpb25zfVxuICAgKi9cbiAgc3RhdGljIHRyYW5zZm9ybU9wdGlvbnMoY29udGVudCwgb3B0aW9ucywgZXh0cmEgPSB7fSwgaXNXZWJob29rID0gZmFsc2UpIHtcbiAgICBpZiAoIW9wdGlvbnMgJiYgdHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICBvcHRpb25zID0gY29udGVudDtcbiAgICAgIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgTWVzc2FnZUVtYmVkKSB7XG4gICAgICByZXR1cm4gaXNXZWJob29rID8geyBjb250ZW50LCBlbWJlZHM6IFtvcHRpb25zXSwgLi4uZXh0cmEgfSA6IHsgY29udGVudCwgZW1iZWQ6IG9wdGlvbnMsIC4uLmV4dHJhIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgTWVzc2FnZUF0dGFjaG1lbnQpIHtcbiAgICAgIHJldHVybiB7IGNvbnRlbnQsIGZpbGVzOiBbb3B0aW9uc10sIC4uLmV4dHJhIH07XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIGNvbnN0IFtlbWJlZHMsIGZpbGVzXSA9IHRoaXMucGFydGl0aW9uTWVzc2FnZUFkZGl0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiBpc1dlYmhvb2sgPyB7IGNvbnRlbnQsIGVtYmVkcywgZmlsZXMsIC4uLmV4dHJhIH0gOiB7IGNvbnRlbnQsIGVtYmVkOiBlbWJlZHNbMF0sIGZpbGVzLCAuLi5leHRyYSB9O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgY29uc3QgW2VtYmVkcywgZmlsZXNdID0gdGhpcy5wYXJ0aXRpb25NZXNzYWdlQWRkaXRpb25zKGNvbnRlbnQpO1xuICAgICAgaWYgKGVtYmVkcy5sZW5ndGggfHwgZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpc1dlYmhvb2sgPyB7IGVtYmVkcywgZmlsZXMsIC4uLmV4dHJhIH0gOiB7IGVtYmVkOiBlbWJlZHNbMF0sIGZpbGVzLCAuLi5leHRyYSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRlbnQsIC4uLm9wdGlvbnMsIC4uLmV4dHJhIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBgQVBJTWVzc2FnZWAgZnJvbSB1c2VyLWxldmVsIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHtNZXNzYWdlVGFyZ2V0fSB0YXJnZXQgVGFyZ2V0IHRvIHNlbmQgdG9cbiAgICogQHBhcmFtIHtTdHJpbmdSZXNvbHZhYmxlfSBbY29udGVudF0gQ29udGVudCB0byBzZW5kXG4gICAqIEBwYXJhbSB7TWVzc2FnZU9wdGlvbnN8V2ViaG9va01lc3NhZ2VPcHRpb25zfE1lc3NhZ2VBZGRpdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIHRvIHVzZVxuICAgKiBAcGFyYW0ge01lc3NhZ2VPcHRpb25zfFdlYmhvb2tNZXNzYWdlT3B0aW9uc30gW2V4dHJhPXt9XSAtIEV4dHJhIG9wdGlvbnMgdG8gYWRkIG9udG8gdHJhbnNmb3JtZWQgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7TWVzc2FnZU9wdGlvbnN8V2ViaG9va01lc3NhZ2VPcHRpb25zfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSh0YXJnZXQsIGNvbnRlbnQsIG9wdGlvbnMsIGV4dHJhID0ge30pIHtcbiAgICBjb25zdCBXZWJob29rID0gcmVxdWlyZSgnLi9XZWJob29rJyk7XG4gICAgY29uc3QgV2ViaG9va0NsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC9XZWJob29rQ2xpZW50Jyk7XG5cbiAgICBjb25zdCBpc1dlYmhvb2sgPSB0YXJnZXQgaW5zdGFuY2VvZiBXZWJob29rIHx8IHRhcmdldCBpbnN0YW5jZW9mIFdlYmhvb2tDbGllbnQ7XG4gICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0aGlzLnRyYW5zZm9ybU9wdGlvbnMoY29udGVudCwgb3B0aW9ucywgZXh0cmEsIGlzV2ViaG9vayk7XG4gICAgcmV0dXJuIG5ldyB0aGlzKHRhcmdldCwgdHJhbnNmb3JtZWQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQVBJTWVzc2FnZTtcblxuLyoqXG4gKiBBIHRhcmdldCBmb3IgYSBtZXNzYWdlLlxuICogQHR5cGVkZWYge1RleHRDaGFubmVsfERNQ2hhbm5lbHxVc2VyfEd1aWxkTWVtYmVyfFdlYmhvb2t8V2ViaG9va0NsaWVudH0gTWVzc2FnZVRhcmdldFxuICovXG5cbi8qKlxuICogQWRkaXRpb25hbCBpdGVtcyB0aGF0IGNhbiBiZSBzZW50IHdpdGggYSBtZXNzYWdlLlxuICogQHR5cGVkZWYge01lc3NhZ2VFbWJlZHxNZXNzYWdlQXR0YWNobWVudHxBcnJheTxNZXNzYWdlRW1iZWR8TWVzc2FnZUF0dGFjaG1lbnQ+fSBNZXNzYWdlQWRkaXRpb25zXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBkYXRhIG1vZGVsIHRoYXQgaXMgaWRlbnRpZmlhYmxlIGJ5IGEgU25vd2ZsYWtlIChpLmUuIERpc2NvcmQgQVBJIGRhdGEgbW9kZWxzKS5cbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBCYXNlIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0aGF0IGluc3RhbnRpYXRlZCB0aGlzXG4gICAgICogQG5hbWUgQmFzZSNjbGllbnRcbiAgICAgKiBAdHlwZSB7Q2xpZW50fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2xpZW50JywgeyB2YWx1ZTogY2xpZW50IH0pO1xuICB9XG5cbiAgX2Nsb25lKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodGhpcyksIHRoaXMpO1xuICB9XG5cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIF91cGRhdGUoZGF0YSkge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fY2xvbmUoKTtcbiAgICB0aGlzLl9wYXRjaChkYXRhKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICB0b0pTT04oLi4ucHJvcHMpIHtcbiAgICByZXR1cm4gVXRpbC5mbGF0dGVuKHRoaXMsIC4uLnByb3BzKTtcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFbW9qaSA9IHJlcXVpcmUoJy4vRW1vamknKTtcblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIHtAbGluayBHdWlsZEVtb2ppfSBhbmQge0BsaW5rIEd1aWxkUHJldmlld0Vtb2ppfS5cbiAqIEBleHRlbmRzIHtFbW9qaX1cbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBCYXNlR3VpbGRFbW9qaSBleHRlbmRzIEVtb2ppIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhLCBndWlsZCkge1xuICAgIHN1cGVyKGNsaWVudCwgZGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3VpbGQgdGhpcyBlbW9qaSBpcyBhIHBhcnQgb2ZcbiAgICAgKiBAdHlwZSB7R3VpbGR8R3VpbGRQcmV2aWV3fVxuICAgICAqL1xuICAgIHRoaXMuZ3VpbGQgPSBndWlsZDtcblxuICAgIHRoaXMucmVxdWlyZUNvbG9ucyA9IG51bGw7XG4gICAgdGhpcy5tYW5hZ2VkID0gbnVsbDtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiByb2xlIGlkcyB0aGlzIGVtb2ppIGlzIGFjdGl2ZSBmb3JcbiAgICAgKiBAbmFtZSBCYXNlR3VpbGRFbW9qaSNfcm9sZXNcbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19yb2xlcycsIHsgdmFsdWU6IFtdLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICB9XG5cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5uYW1lKSB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEucmVxdWlyZV9jb2xvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgZW1vamkgcmVxdWlyZXMgY29sb25zIHN1cnJvdW5kaW5nIGl0XG4gICAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHRoaXMucmVxdWlyZXNDb2xvbnMgPSBkYXRhLnJlcXVpcmVfY29sb25zO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YS5tYW5hZ2VkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoaXMgZW1vamkgaXMgbWFuYWdlZCBieSBhbiBleHRlcm5hbCBzZXJ2aWNlXG4gICAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHRoaXMubWFuYWdlZCA9IGRhdGEubWFuYWdlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEuYXZhaWxhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoaXMgZW1vamkgaXMgYXZhaWxhYmxlXG4gICAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuYXZhaWxhYmxlID0gZGF0YS5hdmFpbGFibGU7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEucm9sZXMpIHRoaXMuX3JvbGVzID0gZGF0YS5yb2xlcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VHdWlsZEVtb2ppO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBHdWlsZENoYW5uZWwgPSByZXF1aXJlKCcuL0d1aWxkQ2hhbm5lbCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBndWlsZCBjYXRlZ29yeSBjaGFubmVsIG9uIERpc2NvcmQuXG4gKiBAZXh0ZW5kcyB7R3VpbGRDaGFubmVsfVxuICovXG5jbGFzcyBDYXRlZ29yeUNoYW5uZWwgZXh0ZW5kcyBHdWlsZENoYW5uZWwge1xuICAvKipcbiAgICogQ2hhbm5lbHMgdGhhdCBhcmUgYSBwYXJ0IG9mIHRoaXMgY2F0ZWdvcnlcbiAgICogQHR5cGUge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBHdWlsZENoYW5uZWw+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5ndWlsZC5jaGFubmVscy5jYWNoZS5maWx0ZXIoYyA9PiBjLnBhcmVudElEID09PSB0aGlzLmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYXRlZ29yeSBwYXJlbnQgb2YgdGhpcyBjaGFubmVsLlxuICAgKiA8d2Fybj5JdCBpcyBub3QgY3VycmVudGx5IHBvc3NpYmxlIHRvIHNldCB0aGUgcGFyZW50IG9mIGEgQ2F0ZWdvcnlDaGFubmVsLjwvd2Fybj5cbiAgICogQG1ldGhvZCBzZXRQYXJlbnRcbiAgICogQG1lbWJlcm9mIENhdGVnb3J5Q2hhbm5lbFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/R3VpbGRDaGFubmVsfFNub3dmbGFrZX0gY2hhbm5lbCBQYXJlbnQgY2hhbm5lbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgdG8gcGFzc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxvY2tQZXJtaXNzaW9ucz10cnVlXSBMb2NrIHRoZSBwZXJtaXNzaW9ucyB0byB3aGF0IHRoZSBwYXJlbnQncyBwZXJtaXNzaW9ucyBhcmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciBtb2RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGlzIGNoYW5uZWxcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRDaGFubmVsPn1cbiAgICovXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2F0ZWdvcnlDaGFubmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCB7IENoYW5uZWxUeXBlcyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IFNub3dmbGFrZSA9IHJlcXVpcmUoJy4uL3V0aWwvU25vd2ZsYWtlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbnkgY2hhbm5lbCBvbiBEaXNjb3JkLlxuICogQGV4dGVuZHMge0Jhc2V9XG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgQ2hhbm5lbCBleHRlbmRzIEJhc2Uge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGRhdGEpIHtcbiAgICBzdXBlcihjbGllbnQpO1xuXG4gICAgY29uc3QgdHlwZSA9IE9iamVjdC5rZXlzKENoYW5uZWxUeXBlcylbZGF0YS50eXBlXTtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgY2hhbm5lbCwgZWl0aGVyOlxuICAgICAqICogYGRtYCAtIGEgRE0gY2hhbm5lbFxuICAgICAqICogYHRleHRgIC0gYSBndWlsZCB0ZXh0IGNoYW5uZWxcbiAgICAgKiAqIGB2b2ljZWAgLSBhIGd1aWxkIHZvaWNlIGNoYW5uZWxcbiAgICAgKiAqIGBjYXRlZ29yeWAgLSBhIGd1aWxkIGNhdGVnb3J5IGNoYW5uZWxcbiAgICAgKiAqIGBuZXdzYCAtIGEgZ3VpbGQgbmV3cyBjaGFubmVsXG4gICAgICogKiBgc3RvcmVgIC0gYSBndWlsZCBzdG9yZSBjaGFubmVsXG4gICAgICogKiBgdW5rbm93bmAgLSBhIGdlbmVyaWMgY2hhbm5lbCBvZiB1bmtub3duIHR5cGUsIGNvdWxkIGJlIENoYW5uZWwgb3IgR3VpbGRDaGFubmVsXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlID8gdHlwZS50b0xvd2VyQ2FzZSgpIDogJ3Vua25vd24nO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hhbm5lbCBoYXMgYmVlbiBkZWxldGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZGF0YSkgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIGNoYW5uZWxcbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgdGhlIGNoYW5uZWwgd2FzIGNyZWF0ZWQgYXRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZFRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gU25vd2ZsYWtlLmRlY29uc3RydWN0KHRoaXMuaWQpLnRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgY2hhbm5lbCB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZEF0KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmNyZWF0ZWRUaW1lc3RhbXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gY29uY2F0ZW5hdGVkIHdpdGggYSBzdHJpbmcsIHRoaXMgYXV0b21hdGljYWxseSByZXR1cm5zIHRoZSBjaGFubmVsJ3MgbWVudGlvbiBpbnN0ZWFkIG9mIHRoZSBDaGFubmVsIG9iamVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gTG9nczogSGVsbG8gZnJvbSA8IzEyMzQ1Njc4OTAxMjM0NTY3OD4hXG4gICAqIGNvbnNvbGUubG9nKGBIZWxsbyBmcm9tICR7Y2hhbm5lbH0hYCk7XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYDwjJHt0aGlzLmlkfT5gO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhpcyBjaGFubmVsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRGVsZXRlIHRoZSBjaGFubmVsXG4gICAqIGNoYW5uZWwuZGVsZXRlKClcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBkZWxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmNoYW5uZWxzKHRoaXMuaWQpXG4gICAgICAuZGVsZXRlKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhpcyBjaGFubmVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gV2hldGhlciB0byBza2lwIHRoZSBjYWNoZSBjaGVjayBhbmQgcmVxdWVzdCB0aGUgQVBJXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWw+fVxuICAgKi9cbiAgZmV0Y2goZm9yY2UgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5jaGFubmVscy5mZXRjaCh0aGlzLmlkLCB0cnVlLCBmb3JjZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjaGFubmVsIGlzIHRleHQtYmFzZWQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNUZXh0KCkge1xuICAgIHJldHVybiAnbWVzc2FnZXMnIGluIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGNsaWVudCwgZGF0YSwgZ3VpbGQpIHtcbiAgICBjb25zdCBTdHJ1Y3R1cmVzID0gcmVxdWlyZSgnLi4vdXRpbC9TdHJ1Y3R1cmVzJyk7XG4gICAgbGV0IGNoYW5uZWw7XG4gICAgaWYgKCFkYXRhLmd1aWxkX2lkICYmICFndWlsZCkge1xuICAgICAgaWYgKChkYXRhLnJlY2lwaWVudHMgJiYgZGF0YS50eXBlICE9PSBDaGFubmVsVHlwZXMuR1JPVVApIHx8IGRhdGEudHlwZSA9PT0gQ2hhbm5lbFR5cGVzLkRNKSB7XG4gICAgICAgIGNvbnN0IERNQ2hhbm5lbCA9IFN0cnVjdHVyZXMuZ2V0KCdETUNoYW5uZWwnKTtcbiAgICAgICAgY2hhbm5lbCA9IG5ldyBETUNoYW5uZWwoY2xpZW50LCBkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBDaGFubmVsVHlwZXMuR1JPVVApIHtcbiAgICAgICAgY29uc3QgUGFydGlhbEdyb3VwRE1DaGFubmVsID0gcmVxdWlyZSgnLi9QYXJ0aWFsR3JvdXBETUNoYW5uZWwnKTtcbiAgICAgICAgY2hhbm5lbCA9IG5ldyBQYXJ0aWFsR3JvdXBETUNoYW5uZWwoY2xpZW50LCBkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ3VpbGQgPSBndWlsZCB8fCBjbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmd1aWxkX2lkKTtcbiAgICAgIGlmIChndWlsZCkge1xuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgQ2hhbm5lbFR5cGVzLlRFWFQ6IHtcbiAgICAgICAgICAgIGNvbnN0IFRleHRDaGFubmVsID0gU3RydWN0dXJlcy5nZXQoJ1RleHRDaGFubmVsJyk7XG4gICAgICAgICAgICBjaGFubmVsID0gbmV3IFRleHRDaGFubmVsKGd1aWxkLCBkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENoYW5uZWxUeXBlcy5WT0lDRToge1xuICAgICAgICAgICAgY29uc3QgVm9pY2VDaGFubmVsID0gU3RydWN0dXJlcy5nZXQoJ1ZvaWNlQ2hhbm5lbCcpO1xuICAgICAgICAgICAgY2hhbm5lbCA9IG5ldyBWb2ljZUNoYW5uZWwoZ3VpbGQsIGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ2hhbm5lbFR5cGVzLkNBVEVHT1JZOiB7XG4gICAgICAgICAgICBjb25zdCBDYXRlZ29yeUNoYW5uZWwgPSBTdHJ1Y3R1cmVzLmdldCgnQ2F0ZWdvcnlDaGFubmVsJyk7XG4gICAgICAgICAgICBjaGFubmVsID0gbmV3IENhdGVnb3J5Q2hhbm5lbChndWlsZCwgZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDaGFubmVsVHlwZXMuTkVXUzoge1xuICAgICAgICAgICAgY29uc3QgTmV3c0NoYW5uZWwgPSBTdHJ1Y3R1cmVzLmdldCgnTmV3c0NoYW5uZWwnKTtcbiAgICAgICAgICAgIGNoYW5uZWwgPSBuZXcgTmV3c0NoYW5uZWwoZ3VpbGQsIGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ2hhbm5lbFR5cGVzLlNUT1JFOiB7XG4gICAgICAgICAgICBjb25zdCBTdG9yZUNoYW5uZWwgPSBTdHJ1Y3R1cmVzLmdldCgnU3RvcmVDaGFubmVsJyk7XG4gICAgICAgICAgICBjaGFubmVsID0gbmV3IFN0b3JlQ2hhbm5lbChndWlsZCwgZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5uZWwpIGd1aWxkLmNoYW5uZWxzLmNhY2hlLnNldChjaGFubmVsLmlkLCBjaGFubmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cblxuICB0b0pTT04oLi4ucHJvcHMpIHtcbiAgICByZXR1cm4gc3VwZXIudG9KU09OKHsgY3JlYXRlZFRpbWVzdGFtcDogdHJ1ZSB9LCAuLi5wcm9wcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUZWFtID0gcmVxdWlyZSgnLi9UZWFtJyk7XG5jb25zdCBBcHBsaWNhdGlvbiA9IHJlcXVpcmUoJy4vaW50ZXJmYWNlcy9BcHBsaWNhdGlvbicpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBDbGllbnQgT0F1dGgyIEFwcGxpY2F0aW9uLlxuICogQGV4dGVuZHMge0FwcGxpY2F0aW9ufVxuICovXG5jbGFzcyBDbGllbnRBcHBsaWNhdGlvbiBleHRlbmRzIEFwcGxpY2F0aW9uIHtcbiAgX3BhdGNoKGRhdGEpIHtcbiAgICBzdXBlci5fcGF0Y2goZGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwJ3MgY292ZXIgaW1hZ2VcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvdmVyID0gZGF0YS5jb3Zlcl9pbWFnZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcCdzIFJQQyBvcmlnaW5zLCBpZiBlbmFibGVkXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMucnBjT3JpZ2lucyA9IGRhdGEucnBjX29yaWdpbnMgfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGFwcCdzIGJvdCByZXF1aXJlcyBhIGNvZGUgZ3JhbnQgd2hlbiB1c2luZyB0aGUgT0F1dGgyIGZsb3dcbiAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5ib3RSZXF1aXJlQ29kZUdyYW50ID0gdHlwZW9mIGRhdGEuYm90X3JlcXVpcmVfY29kZV9ncmFudCAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhLmJvdF9yZXF1aXJlX2NvZGVfZ3JhbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBhcHAncyBib3QgaXMgcHVibGljXG4gICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYm90UHVibGljID0gdHlwZW9mIGRhdGEuYm90X3B1YmxpYyAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhLmJvdF9wdWJsaWMgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG93bmVyIG9mIHRoaXMgT0F1dGggYXBwbGljYXRpb25cbiAgICAgKiBAdHlwZSB7P1VzZXJ8VGVhbX1cbiAgICAgKi9cbiAgICB0aGlzLm93bmVyID0gZGF0YS50ZWFtID8gbmV3IFRlYW0odGhpcy5jbGllbnQsIGRhdGEudGVhbSkgOiBkYXRhLm93bmVyID8gdGhpcy5jbGllbnQudXNlcnMuYWRkKGRhdGEub3duZXIpIDogbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudEFwcGxpY2F0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFByZXNlbmNlIH0gPSByZXF1aXJlKCcuL1ByZXNlbmNlJyk7XG5jb25zdCB7IFR5cGVFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9Db2xsZWN0aW9uJyk7XG5jb25zdCB7IEFjdGl2aXR5VHlwZXMsIE9QQ29kZXMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbmNsYXNzIENsaWVudFByZXNlbmNlIGV4dGVuZHMgUHJlc2VuY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCBUaGUgaW5zdGFudGlhdGluZyBjbGllbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhPXt9XSBUaGUgZGF0YSBmb3IgdGhlIGNsaWVudCBwcmVzZW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhID0ge30pIHtcbiAgICBzdXBlcihjbGllbnQsIE9iamVjdC5hc3NpZ24oZGF0YSwgeyBzdGF0dXM6ICdvbmxpbmUnLCB1c2VyOiB7IGlkOiBudWxsIH0gfSkpO1xuICB9XG5cbiAgYXN5bmMgc2V0KHByZXNlbmNlKSB7XG4gICAgY29uc3QgcGFja2V0ID0gYXdhaXQgdGhpcy5fcGFyc2UocHJlc2VuY2UpO1xuICAgIHRoaXMucGF0Y2gocGFja2V0KTtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlLnNoYXJkSUQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmNsaWVudC53cy5icm9hZGNhc3QoeyBvcDogT1BDb2Rlcy5TVEFUVVNfVVBEQVRFLCBkOiBwYWNrZXQgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByZXNlbmNlLnNoYXJkSUQpKSB7XG4gICAgICBmb3IgKGNvbnN0IHNoYXJkSUQgb2YgcHJlc2VuY2Uuc2hhcmRJRCkge1xuICAgICAgICB0aGlzLmNsaWVudC53cy5zaGFyZHMuZ2V0KHNoYXJkSUQpLnNlbmQoeyBvcDogT1BDb2Rlcy5TVEFUVVNfVVBEQVRFLCBkOiBwYWNrZXQgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xpZW50LndzLnNoYXJkcy5nZXQocHJlc2VuY2Uuc2hhcmRJRCkuc2VuZCh7IG9wOiBPUENvZGVzLlNUQVRVU19VUERBVEUsIGQ6IHBhY2tldCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhc3luYyBfcGFyc2UoeyBzdGF0dXMsIHNpbmNlLCBhZmssIGFjdGl2aXR5IH0pIHtcbiAgICBjb25zdCBhcHBsaWNhdGlvbklEID0gYWN0aXZpdHkgJiYgKGFjdGl2aXR5LmFwcGxpY2F0aW9uID8gYWN0aXZpdHkuYXBwbGljYXRpb24uaWQgfHwgYWN0aXZpdHkuYXBwbGljYXRpb24gOiBudWxsKTtcbiAgICBsZXQgYXNzZXRzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICBpZiAoYWN0aXZpdHkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHkubmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lOVkFMSURfVFlQRScsICduYW1lJywgJ3N0cmluZycpO1xuICAgICAgaWYgKCFhY3Rpdml0eS50eXBlKSBhY3Rpdml0eS50eXBlID0gMDtcbiAgICAgIGlmIChhY3Rpdml0eS5hc3NldHMgJiYgYXBwbGljYXRpb25JRCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkub2F1dGgyLmFwcGxpY2F0aW9ucyhhcHBsaWNhdGlvbklEKS5hc3NldHMuZ2V0KCk7XG4gICAgICAgICAgZm9yIChjb25zdCBhc3NldCBvZiBhKSBhc3NldHMuc2V0KGFzc2V0Lm5hbWUsIGFzc2V0LmlkKTtcbiAgICAgICAgfSBjYXRjaCB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgYWZrOiBhZmsgIT0gbnVsbCA/IGFmayA6IGZhbHNlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgc2luY2U6IHNpbmNlICE9IG51bGwgPyBzaW5jZSA6IG51bGwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICBzdGF0dXM6IHN0YXR1cyB8fCB0aGlzLnN0YXR1cyxcbiAgICAgIGdhbWU6IGFjdGl2aXR5XG4gICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogYWN0aXZpdHkudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IGFjdGl2aXR5Lm5hbWUsXG4gICAgICAgICAgICB1cmw6IGFjdGl2aXR5LnVybCxcbiAgICAgICAgICAgIGRldGFpbHM6IGFjdGl2aXR5LmRldGFpbHMgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RhdGU6IGFjdGl2aXR5LnN0YXRlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFzc2V0czogYWN0aXZpdHkuYXNzZXRzXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgbGFyZ2VfdGV4dDogYWN0aXZpdHkuYXNzZXRzLmxhcmdlVGV4dCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBzbWFsbF90ZXh0OiBhY3Rpdml0eS5hc3NldHMuc21hbGxUZXh0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGxhcmdlX2ltYWdlOiBhc3NldHMuZ2V0KGFjdGl2aXR5LmFzc2V0cy5sYXJnZUltYWdlKSB8fCBhY3Rpdml0eS5hc3NldHMubGFyZ2VJbWFnZSxcbiAgICAgICAgICAgICAgICAgIHNtYWxsX2ltYWdlOiBhc3NldHMuZ2V0KGFjdGl2aXR5LmFzc2V0cy5zbWFsbEltYWdlKSB8fCBhY3Rpdml0eS5hc3NldHMuc21hbGxJbWFnZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGltZXN0YW1wczogYWN0aXZpdHkudGltZXN0YW1wcyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJ0eTogYWN0aXZpdHkucGFydHkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXBwbGljYXRpb25faWQ6IGFwcGxpY2F0aW9uSUQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjcmV0czogYWN0aXZpdHkuc2VjcmV0cyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnN0YW5jZTogYWN0aXZpdHkuaW5zdGFuY2UgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiBudWxsLFxuICAgIH07XG5cbiAgICBpZiAoKHN0YXR1cyB8fCBhZmsgfHwgc2luY2UpICYmICFhY3Rpdml0eSkge1xuICAgICAgcGFja2V0LmdhbWUgPSB0aGlzLmFjdGl2aXRpZXNbMF0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocGFja2V0LmdhbWUpIHtcbiAgICAgIHBhY2tldC5nYW1lLnR5cGUgPVxuICAgICAgICB0eXBlb2YgcGFja2V0LmdhbWUudHlwZSA9PT0gJ251bWJlcicgPyBwYWNrZXQuZ2FtZS50eXBlIDogQWN0aXZpdHlUeXBlcy5pbmRleE9mKHBhY2tldC5nYW1lLnR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRQcmVzZW5jZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGF0YVJlc29sdmVyID0gcmVxdWlyZSgnLi4vdXRpbC9EYXRhUmVzb2x2ZXInKTtcbmNvbnN0IFN0cnVjdHVyZXMgPSByZXF1aXJlKCcuLi91dGlsL1N0cnVjdHVyZXMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2dnZWQgaW4gY2xpZW50J3MgRGlzY29yZCB1c2VyLlxuICogQGV4dGVuZHMge1VzZXJ9XG4gKi9cbmNsYXNzIENsaWVudFVzZXIgZXh0ZW5kcyBTdHJ1Y3R1cmVzLmdldCgnVXNlcicpIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhKSB7XG4gICAgc3VwZXIoY2xpZW50LCBkYXRhKTtcbiAgICB0aGlzLl90eXBpbmcgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIHN1cGVyLl9wYXRjaChkYXRhKTtcblxuICAgIGlmICgndmVyaWZpZWQnIGluIGRhdGEpIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGhhcyBiZWVuIHZlcmlmaWVkXG4gICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgdGhpcy52ZXJpZmllZCA9IGRhdGEudmVyaWZpZWQ7XG4gICAgfVxuXG4gICAgaWYgKCdtZmFfZW5hYmxlZCcgaW4gZGF0YSkge1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgYm90J3Mge0BsaW5rIENsaWVudEFwcGxpY2F0aW9uI293bmVyIE93bmVyfSBoYXMgTUZBIGVuYWJsZWQgb24gdGhlaXIgYWNjb3VudFxuICAgICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAgICovXG4gICAgICB0aGlzLm1mYUVuYWJsZWQgPSB0eXBlb2YgZGF0YS5tZmFfZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nID8gZGF0YS5tZmFfZW5hYmxlZCA6IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tZmFFbmFibGVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5tZmFFbmFibGVkID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50b2tlbikgdGhpcy5jbGllbnQudG9rZW4gPSBkYXRhLnRva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIENsaWVudFVzZXIncyBwcmVzZW5jZVxuICAgKiBAdHlwZSB7UHJlc2VuY2V9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXNlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5wcmVzZW5jZTtcbiAgfVxuXG4gIGVkaXQoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC51c2VycygnQG1lJylcbiAgICAgIC5wYXRjaCh7IGRhdGEgfSlcbiAgICAgIC50aGVuKG5ld0RhdGEgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC50b2tlbiA9IG5ld0RhdGEudG9rZW47XG4gICAgICAgIGNvbnN0IHsgdXBkYXRlZCB9ID0gdGhpcy5jbGllbnQuYWN0aW9ucy5Vc2VyVXBkYXRlLmhhbmRsZShuZXdEYXRhKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQpIHJldHVybiB1cGRhdGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVzZXJuYW1lIG9mIHRoZSBsb2dnZWQgaW4gY2xpZW50LlxuICAgKiA8aW5mbz5DaGFuZ2luZyB1c2VybmFtZXMgaW4gRGlzY29yZCBpcyBoZWF2aWx5IHJhdGUgbGltaXRlZCwgd2l0aCBvbmx5IDIgcmVxdWVzdHNcbiAgICogZXZlcnkgaG91ci4gVXNlIHRoaXMgc3BhcmluZ2x5ITwvaW5mbz5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSBuZXcgdXNlcm5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Q2xpZW50VXNlcj59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNldCB1c2VybmFtZVxuICAgKiBjbGllbnQudXNlci5zZXRVc2VybmFtZSgnZGlzY29yZGpzJylcbiAgICogICAudGhlbih1c2VyID0+IGNvbnNvbGUubG9nKGBNeSBuZXcgdXNlcm5hbWUgaXMgJHt1c2VyLnVzZXJuYW1lfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldFVzZXJuYW1lKHVzZXJuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IHVzZXJuYW1lIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF2YXRhciBvZiB0aGUgbG9nZ2VkIGluIGNsaWVudC5cbiAgICogQHBhcmFtIHtCdWZmZXJSZXNvbHZhYmxlfEJhc2U2NFJlc29sdmFibGV9IGF2YXRhciBUaGUgbmV3IGF2YXRhclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDbGllbnRVc2VyPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2V0IGF2YXRhclxuICAgKiBjbGllbnQudXNlci5zZXRBdmF0YXIoJy4vYXZhdGFyLnBuZycpXG4gICAqICAgLnRoZW4odXNlciA9PiBjb25zb2xlLmxvZyhgTmV3IGF2YXRhciBzZXQhYCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgYXN5bmMgc2V0QXZhdGFyKGF2YXRhcikge1xuICAgIHJldHVybiB0aGlzLmVkaXQoeyBhdmF0YXI6IGF3YWl0IERhdGFSZXNvbHZlci5yZXNvbHZlSW1hZ2UoYXZhdGFyKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIHJlc2VtYmxpbmcgYSByYXcgRGlzY29yZCBwcmVzZW5jZS5cbiAgICogQHR5cGVkZWYge09iamVjdH0gUHJlc2VuY2VEYXRhXG4gICAqIEBwcm9wZXJ0eSB7UHJlc2VuY2VTdGF0dXNEYXRhfSBbc3RhdHVzXSBTdGF0dXMgb2YgdGhlIHVzZXJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbYWZrXSBXaGV0aGVyIHRoZSB1c2VyIGlzIEFGS1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gW2FjdGl2aXR5XSBBY3Rpdml0eSB0aGUgdXNlciBpcyBwbGF5aW5nXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWN0aXZpdHkubmFtZV0gTmFtZSBvZiB0aGUgYWN0aXZpdHlcbiAgICogQHByb3BlcnR5IHtBY3Rpdml0eVR5cGV8bnVtYmVyfSBbYWN0aXZpdHkudHlwZV0gVHlwZSBvZiB0aGUgYWN0aXZpdHlcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthY3Rpdml0eS51cmxdIFR3aXRjaCAvIFlvdVR1YmUgc3RyZWFtIFVSTFxuICAgKiBAcHJvcGVydHkgez9udW1iZXJ8bnVtYmVyW119IFtzaGFyZElEXSBTaGFyZCBJZChzKSB0byBoYXZlIHRoZSBhY3Rpdml0eSBzZXQgb25cbiAgICovXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZ1bGwgcHJlc2VuY2Ugb2YgdGhlIGNsaWVudCB1c2VyLlxuICAgKiBAcGFyYW0ge1ByZXNlbmNlRGF0YX0gZGF0YSBEYXRhIGZvciB0aGUgcHJlc2VuY2VcbiAgICogQHJldHVybnMge1Byb21pc2U8UHJlc2VuY2U+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIGNsaWVudCB1c2VyJ3MgcHJlc2VuY2VcbiAgICogY2xpZW50LnVzZXIuc2V0UHJlc2VuY2UoeyBhY3Rpdml0eTogeyBuYW1lOiAnd2l0aCBkaXNjb3JkLmpzJyB9LCBzdGF0dXM6ICdpZGxlJyB9KVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldFByZXNlbmNlKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucHJlc2VuY2Uuc2V0KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdXNlcidzIHN0YXR1cy4gTXVzdCBiZSBvbmUgb2Y6XG4gICAqICogYG9ubGluZWBcbiAgICogKiBgaWRsZWBcbiAgICogKiBgaW52aXNpYmxlYFxuICAgKiAqIGBkbmRgIChkbyBub3QgZGlzdHVyYilcbiAgICogQHR5cGVkZWYge3N0cmluZ30gUHJlc2VuY2VTdGF0dXNEYXRhXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGNsaWVudCB1c2VyLlxuICAgKiBAcGFyYW0ge1ByZXNlbmNlU3RhdHVzRGF0YX0gc3RhdHVzIFN0YXR1cyB0byBjaGFuZ2UgdG9cbiAgICogQHBhcmFtIHs/bnVtYmVyfG51bWJlcltdfSBbc2hhcmRJRF0gU2hhcmQgSUQocykgdG8gaGF2ZSB0aGUgYWN0aXZpdHkgc2V0IG9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByZXNlbmNlPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2V0IHRoZSBjbGllbnQgdXNlcidzIHN0YXR1c1xuICAgKiBjbGllbnQudXNlci5zZXRTdGF0dXMoJ2lkbGUnKVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldFN0YXR1cyhzdGF0dXMsIHNoYXJkSUQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQcmVzZW5jZSh7IHN0YXR1cywgc2hhcmRJRCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBzZXR0aW5nIGFuIGFjdGl2aXR5LlxuICAgKiBAdHlwZWRlZiBBY3Rpdml0eU9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFR3aXRjaCAvIFlvdVR1YmUgc3RyZWFtIFVSTFxuICAgKiBAcHJvcGVydHkge0FjdGl2aXR5VHlwZXxudW1iZXJ9IFt0eXBlXSBUeXBlIG9mIHRoZSBhY3Rpdml0eVxuICAgKiBAcHJvcGVydHkgez9udW1iZXJ8bnVtYmVyW119IFtzaGFyZElEXSBTaGFyZCBJZChzKSB0byBoYXZlIHRoZSBhY3Rpdml0eSBzZXQgb25cbiAgICovXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2aXR5IHRoZSBjbGllbnQgdXNlciBpcyBwbGF5aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBY3Rpdml0eU9wdGlvbnN9IFtuYW1lXSBBY3Rpdml0eSBiZWluZyBwbGF5ZWQsIG9yIG9wdGlvbnMgZm9yIHNldHRpbmcgdGhlIGFjdGl2aXR5XG4gICAqIEBwYXJhbSB7QWN0aXZpdHlPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyBmb3Igc2V0dGluZyB0aGUgYWN0aXZpdHlcbiAgICogQHJldHVybnMge1Byb21pc2U8UHJlc2VuY2U+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIGNsaWVudCB1c2VyJ3MgYWN0aXZpdHlcbiAgICogY2xpZW50LnVzZXIuc2V0QWN0aXZpdHkoJ2Rpc2NvcmQuanMnLCB7IHR5cGU6ICdXQVRDSElORycgfSlcbiAgICogICAudGhlbihwcmVzZW5jZSA9PiBjb25zb2xlLmxvZyhgQWN0aXZpdHkgc2V0IHRvICR7cHJlc2VuY2UuYWN0aXZpdGllc1swXS5uYW1lfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldEFjdGl2aXR5KG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIHRoaXMuc2V0UHJlc2VuY2UoeyBhY3Rpdml0eTogbnVsbCwgc2hhcmRJRDogb3B0aW9ucy5zaGFyZElEIH0pO1xuXG4gICAgY29uc3QgYWN0aXZpdHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgPyBuYW1lIDogeyBuYW1lIH0pO1xuICAgIHJldHVybiB0aGlzLnNldFByZXNlbmNlKHsgYWN0aXZpdHksIHNoYXJkSUQ6IGFjdGl2aXR5LnNoYXJkSUQgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cy9yZW1vdmVzIHRoZSBBRksgZmxhZyBmb3IgdGhlIGNsaWVudCB1c2VyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFmayBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyBBRktcbiAgICogQHJldHVybnMge1Byb21pc2U8UHJlc2VuY2U+fVxuICAgKi9cbiAgc2V0QUZLKGFmaykge1xuICAgIHJldHVybiB0aGlzLnNldFByZXNlbmNlKHsgYWZrIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50VXNlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2hhbm5lbCA9IHJlcXVpcmUoJy4vQ2hhbm5lbCcpO1xuY29uc3QgVGV4dEJhc2VkQ2hhbm5lbCA9IHJlcXVpcmUoJy4vaW50ZXJmYWNlcy9UZXh0QmFzZWRDaGFubmVsJyk7XG5jb25zdCBNZXNzYWdlTWFuYWdlciA9IHJlcXVpcmUoJy4uL21hbmFnZXJzL01lc3NhZ2VNYW5hZ2VyJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGRpcmVjdCBtZXNzYWdlIGNoYW5uZWwgYmV0d2VlbiB0d28gdXNlcnMuXG4gKiBAZXh0ZW5kcyB7Q2hhbm5lbH1cbiAqIEBpbXBsZW1lbnRzIHtUZXh0QmFzZWRDaGFubmVsfVxuICovXG5jbGFzcyBETUNoYW5uZWwgZXh0ZW5kcyBDaGFubmVsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnQgVGhlIGluc3RhbnRpYXRpbmcgY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgRE0gY2hhbm5lbFxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhKSB7XG4gICAgc3VwZXIoY2xpZW50LCBkYXRhKTtcbiAgICAvLyBPdmVycmlkZSB0aGUgY2hhbm5lbCB0eXBlIHNvIHBhcnRpYWxzIGhhdmUgYSBrbm93biB0eXBlXG4gICAgdGhpcy50eXBlID0gJ2RtJztcbiAgICAvKipcbiAgICAgKiBBIG1hbmFnZXIgb2YgdGhlIG1lc3NhZ2VzIGJlbG9uZ2luZyB0byB0aGlzIGNoYW5uZWxcbiAgICAgKiBAdHlwZSB7TWVzc2FnZU1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLl90eXBpbmcgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIHN1cGVyLl9wYXRjaChkYXRhKTtcblxuICAgIGlmIChkYXRhLnJlY2lwaWVudHMpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJlY2lwaWVudCBvbiB0aGUgb3RoZXIgZW5kIG9mIHRoZSBETVxuICAgICAgICogQHR5cGUge1VzZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMucmVjaXBpZW50ID0gdGhpcy5jbGllbnQudXNlcnMuYWRkKGRhdGEucmVjaXBpZW50c1swXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBsYXN0IG1lc3NhZ2UgaW4gdGhlIGNoYW5uZWwsIGlmIG9uZSB3YXMgc2VudFxuICAgICAqIEB0eXBlIHs/U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMubGFzdE1lc3NhZ2VJRCA9IGRhdGEubGFzdF9tZXNzYWdlX2lkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBsYXN0IHBpbm5lZCBtZXNzYWdlIHdhcyBwaW5uZWQsIGlmIHRoZXJlIHdhcyBvbmVcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQaW5UaW1lc3RhbXAgPSBkYXRhLmxhc3RfcGluX3RpbWVzdGFtcCA/IG5ldyBEYXRlKGRhdGEubGFzdF9waW5fdGltZXN0YW1wKS5nZXRUaW1lKCkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBETUNoYW5uZWwgaXMgYSBwYXJ0aWFsXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwYXJ0aWFsKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5sYXN0TWVzc2FnZUlEID09PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGlzIERNQ2hhbm5lbC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgY2hlY2sgYW5kIHJlcXVlc3QgdGhlIEFQSVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxETUNoYW5uZWw+fVxuICAgKi9cbiAgZmV0Y2goZm9yY2UgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLnJlY2lwaWVudC5jcmVhdGVETShmb3JjZSk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIHJlY2lwaWVudCdzIG1lbnRpb24gaW5zdGVhZCBvZiB0aGVcbiAgICogRE1DaGFubmVsIG9iamVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gTG9nczogSGVsbG8gZnJvbSA8QDEyMzQ1Njc4OTAxMjM0NTY3OD4hXG4gICAqIGNvbnNvbGUubG9nKGBIZWxsbyBmcm9tICR7Y2hhbm5lbH0hYCk7XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNpcGllbnQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8vIFRoZXNlIGFyZSBoZXJlIG9ubHkgZm9yIGRvY3VtZW50YXRpb24gcHVycG9zZXMgLSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBieSBUZXh0QmFzZWRDaGFubmVsXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5LWZ1bmN0aW9uICovXG4gIGdldCBsYXN0TWVzc2FnZSgpIHt9XG4gIGdldCBsYXN0UGluQXQoKSB7fVxuICBzZW5kKCkge31cbiAgc3RhcnRUeXBpbmcoKSB7fVxuICBzdG9wVHlwaW5nKCkge31cbiAgZ2V0IHR5cGluZygpIHt9XG4gIGdldCB0eXBpbmdDb3VudCgpIHt9XG4gIGNyZWF0ZU1lc3NhZ2VDb2xsZWN0b3IoKSB7fVxuICBhd2FpdE1lc3NhZ2VzKCkge31cbiAgLy8gRG9lc24ndCB3b3JrIG9uIERNIGNoYW5uZWxzOyBidWxrRGVsZXRlKCkge31cbn1cblxuVGV4dEJhc2VkQ2hhbm5lbC5hcHBseVRvQ2xhc3MoRE1DaGFubmVsLCB0cnVlLCBbJ2J1bGtEZWxldGUnXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRE1DaGFubmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCBTbm93Zmxha2UgPSByZXF1aXJlKCcuLi91dGlsL1Nub3dmbGFrZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW1vamksIHNlZSB7QGxpbmsgR3VpbGRFbW9qaX0gYW5kIHtAbGluayBSZWFjdGlvbkVtb2ppfS5cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBFbW9qaSBleHRlbmRzIEJhc2Uge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGVtb2ppKSB7XG4gICAgc3VwZXIoY2xpZW50KTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZW1vamkgaXMgYW5pbWF0ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGVkID0gZW1vamkuYW5pbWF0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGVtb2ppXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBlbW9qaS5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoaXMgZW1vamlcbiAgICAgKiBAdHlwZSB7P1Nub3dmbGFrZX1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gZW1vamkuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZW1vamkgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyIG9mIHRoaXMgZW1vamksIHVzZWQgZm9yIG1lc3NhZ2UgcmVhY3Rpb25zXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMuaWQpIHJldHVybiBgJHt0aGlzLmFuaW1hdGVkID8gJ2E6JyA6ICcnfSR7dGhpcy5uYW1lfToke3RoaXMuaWR9YDtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMubmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFVSTCB0byB0aGUgZW1vamkgZmlsZSBpZiBpdHMgYSBjdXN0b20gZW1vamlcbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICBpZiAoIXRoaXMuaWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNkbi5FbW9qaSh0aGlzLmlkLCB0aGlzLmFuaW1hdGVkID8gJ2dpZicgOiAncG5nJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCB0aGUgZW1vamkgd2FzIGNyZWF0ZWQgYXQsIG9yIG51bGwgaWYgdW5pY29kZVxuICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZFRpbWVzdGFtcCgpIHtcbiAgICBpZiAoIXRoaXMuaWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBTbm93Zmxha2UuZGVjb25zdHJ1Y3QodGhpcy5pZCkudGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBlbW9qaSB3YXMgY3JlYXRlZCBhdCwgb3IgbnVsbCBpZiB1bmljb2RlXG4gICAqIEB0eXBlIHs/RGF0ZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZEF0KCkge1xuICAgIGlmICghdGhpcy5pZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuY3JlYXRlZFRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIHRleHQgcmVxdWlyZWQgdG8gZm9ybSBhIGdyYXBoaWNhbCBlbW9qaSBvbiBEaXNjb3JkXG4gICAqIGluc3RlYWQgb2YgdGhlIEVtb2ppIG9iamVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2VuZCBhIGN1c3RvbSBlbW9qaSBmcm9tIGEgZ3VpbGQ6XG4gICAqIGNvbnN0IGVtb2ppID0gZ3VpbGQuZW1vamlzLmNhY2hlLmZpcnN0KCk7XG4gICAqIG1zZy5yZXBseShgSGVsbG8hICR7ZW1vaml9YCk7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNlbmQgdGhlIGVtb2ppIHVzZWQgaW4gYSByZWFjdGlvbiB0byB0aGUgY2hhbm5lbCB0aGUgcmVhY3Rpb24gaXMgcGFydCBvZlxuICAgKiByZWFjdGlvbi5tZXNzYWdlLmNoYW5uZWwuc2VuZChgVGhlIGVtb2ppIHVzZWQgd2FzOiAke3JlYWN0aW9uLmVtb2ppfWApO1xuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQgPyBgPCR7dGhpcy5hbmltYXRlZCA/ICdhJyA6ICcnfToke3RoaXMubmFtZX06JHt0aGlzLmlkfT5gIDogdGhpcy5uYW1lO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oe1xuICAgICAgZ3VpbGQ6ICdndWlsZElEJyxcbiAgICAgIGNyZWF0ZWRUaW1lc3RhbXA6IHRydWUsXG4gICAgICB1cmw6IHRydWUsXG4gICAgICBpZGVudGlmaWVyOiB0cnVlLFxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW1vamk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgZGVwcmVjYXRlIH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCBHdWlsZEF1ZGl0TG9ncyA9IHJlcXVpcmUoJy4vR3VpbGRBdWRpdExvZ3MnKTtcbmNvbnN0IEd1aWxkUHJldmlldyA9IHJlcXVpcmUoJy4vR3VpbGRQcmV2aWV3Jyk7XG5jb25zdCBHdWlsZFRlbXBsYXRlID0gcmVxdWlyZSgnLi9HdWlsZFRlbXBsYXRlJyk7XG5jb25zdCBJbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4vSW50ZWdyYXRpb24nKTtcbmNvbnN0IEludml0ZSA9IHJlcXVpcmUoJy4vSW52aXRlJyk7XG5jb25zdCBWb2ljZVJlZ2lvbiA9IHJlcXVpcmUoJy4vVm9pY2VSZWdpb24nKTtcbmNvbnN0IFdlYmhvb2sgPSByZXF1aXJlKCcuL1dlYmhvb2snKTtcbmNvbnN0IHsgRXJyb3IsIFR5cGVFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBHdWlsZENoYW5uZWxNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvR3VpbGRDaGFubmVsTWFuYWdlcicpO1xuY29uc3QgR3VpbGRFbW9qaU1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9HdWlsZEVtb2ppTWFuYWdlcicpO1xuY29uc3QgR3VpbGRNZW1iZXJNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvR3VpbGRNZW1iZXJNYW5hZ2VyJyk7XG5jb25zdCBQcmVzZW5jZU1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9QcmVzZW5jZU1hbmFnZXInKTtcbmNvbnN0IFJvbGVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvUm9sZU1hbmFnZXInKTtcbmNvbnN0IFZvaWNlU3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvVm9pY2VTdGF0ZU1hbmFnZXInKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IHtcbiAgYnJvd3NlcixcbiAgQ2hhbm5lbFR5cGVzLFxuICBEZWZhdWx0TWVzc2FnZU5vdGlmaWNhdGlvbnMsXG4gIFBhcnRpYWxUeXBlcyxcbiAgVmVyaWZpY2F0aW9uTGV2ZWxzLFxuICBFeHBsaWNpdENvbnRlbnRGaWx0ZXJMZXZlbHMsXG59ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IERhdGFSZXNvbHZlciA9IHJlcXVpcmUoJy4uL3V0aWwvRGF0YVJlc29sdmVyJyk7XG5jb25zdCBTbm93Zmxha2UgPSByZXF1aXJlKCcuLi91dGlsL1Nub3dmbGFrZScpO1xuY29uc3QgU3lzdGVtQ2hhbm5lbEZsYWdzID0gcmVxdWlyZSgnLi4vdXRpbC9TeXN0ZW1DaGFubmVsRmxhZ3MnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZ3VpbGQgKG9yIGEgc2VydmVyKSBvbiBEaXNjb3JkLlxuICogPGluZm8+SXQncyByZWNvbW1lbmRlZCB0byBzZWUgaWYgYSBndWlsZCBpcyBhdmFpbGFibGUgYmVmb3JlIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyBvciByZWFkaW5nIGRhdGEgZnJvbSBpdC4gWW91IGNhblxuICogY2hlY2sgdGhpcyB3aXRoIGBndWlsZC5hdmFpbGFibGVgLjwvaW5mbz5cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBHdWlsZCBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCBUaGUgaW5zdGFudGlhdGluZyBjbGllbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSBndWlsZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhKSB7XG4gICAgc3VwZXIoY2xpZW50KTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFuYWdlciBvZiB0aGUgbWVtYmVycyBiZWxvbmdpbmcgdG8gdGhpcyBndWlsZFxuICAgICAqIEB0eXBlIHtHdWlsZE1lbWJlck1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5tZW1iZXJzID0gbmV3IEd1aWxkTWVtYmVyTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFuYWdlciBvZiB0aGUgY2hhbm5lbHMgYmVsb25naW5nIHRvIHRoaXMgZ3VpbGRcbiAgICAgKiBAdHlwZSB7R3VpbGRDaGFubmVsTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5uZWxzID0gbmV3IEd1aWxkQ2hhbm5lbE1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hbmFnZXIgb2YgdGhlIHJvbGVzIGJlbG9uZ2luZyB0byB0aGlzIGd1aWxkXG4gICAgICogQHR5cGUge1JvbGVNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMucm9sZXMgPSBuZXcgUm9sZU1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hbmFnZXIgb2YgdGhlIHByZXNlbmNlcyBiZWxvbmdpbmcgdG8gdGhpcyBndWlsZFxuICAgICAqIEB0eXBlIHtQcmVzZW5jZU1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmVzZW5jZXMgPSBuZXcgUHJlc2VuY2VNYW5hZ2VyKHRoaXMuY2xpZW50KTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFuYWdlciBvZiB0aGUgdm9pY2Ugc3RhdGVzIG9mIHRoaXMgZ3VpbGRcbiAgICAgKiBAdHlwZSB7Vm9pY2VTdGF0ZU1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy52b2ljZVN0YXRlcyA9IG5ldyBWb2ljZVN0YXRlTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJvdCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGd1aWxkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG5cbiAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICBpZiAoZGF0YS51bmF2YWlsYWJsZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSBndWlsZCBpcyBhdmFpbGFibGUgdG8gYWNjZXNzLiBJZiBpdCBpcyBub3QgYXZhaWxhYmxlLCBpdCBpbmRpY2F0ZXMgYSBzZXJ2ZXIgb3V0YWdlXG4gICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5hdmFpbGFibGUgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgVW5pcXVlIElEIG9mIHRoZSBndWlsZCwgdXNlZnVsIGZvciBjb21wYXJpc29uc1xuICAgICAgICogQHR5cGUge1Nub3dmbGFrZX1cbiAgICAgICAqL1xuICAgICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICAgICAgaWYgKCFkYXRhLmNoYW5uZWxzKSB0aGlzLmF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpZCBvZiB0aGUgc2hhcmQgdGhpcyBHdWlsZCBiZWxvbmdzIHRvLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaGFyZElEID0gZGF0YS5zaGFyZElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBTaGFyZCB0aGlzIEd1aWxkIGJlbG9uZ3MgdG8uXG4gICAqIEB0eXBlIHtXZWJTb2NrZXRTaGFyZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc2hhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LndzLnNoYXJkcy5nZXQodGhpcy5zaGFyZElEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSByYXcgZGF0YSBvZiB0aGUgZ3VpbGRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGd1aWxkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFzaCBvZiB0aGUgZ3VpbGQgaWNvblxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWNvbiA9IGRhdGEuaWNvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoYXNoIG9mIHRoZSBndWlsZCBpbnZpdGUgc3BsYXNoIGltYWdlXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zcGxhc2ggPSBkYXRhLnNwbGFzaDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoYXNoIG9mIHRoZSBndWlsZCBkaXNjb3Zlcnkgc3BsYXNoIGltYWdlXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kaXNjb3ZlcnlTcGxhc2ggPSBkYXRhLmRpc2NvdmVyeV9zcGxhc2g7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVnaW9uIHRoZSBndWlsZCBpcyBsb2NhdGVkIGluXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlZ2lvbiA9IGRhdGEucmVnaW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgYW1vdW50IG9mIG1lbWJlcnMgaW4gdGhpcyBndWlsZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tZW1iZXJDb3VudCA9IGRhdGEubWVtYmVyX2NvdW50IHx8IHRoaXMubWVtYmVyQ291bnQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBndWlsZCBpcyBcImxhcmdlXCIgKGhhcyBtb3JlIHRoYW4gbGFyZ2VfdGhyZXNob2xkIG1lbWJlcnMsIDUwIGJ5IGRlZmF1bHQpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sYXJnZSA9IEJvb2xlYW4oJ2xhcmdlJyBpbiBkYXRhID8gZGF0YS5sYXJnZSA6IHRoaXMubGFyZ2UpO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZW5hYmxlZCBndWlsZCBmZWF0dXJlcywgaGVyZSBhcmUgdGhlIHBvc3NpYmxlIHZhbHVlczpcbiAgICAgKiAqIEFOSU1BVEVEX0lDT05cbiAgICAgKiAqIEJBTk5FUlxuICAgICAqICogQ09NTUVSQ0VcbiAgICAgKiAqIENPTU1VTklUWVxuICAgICAqICogRElTQ09WRVJBQkxFXG4gICAgICogKiBGRUFUVVJBQkxFXG4gICAgICogKiBJTlZJVEVfU1BMQVNIXG4gICAgICogKiBORVdTXG4gICAgICogKiBQQVJUTkVSRURcbiAgICAgKiAqIFJFTEFZX0VOQUJMRURcbiAgICAgKiAqIFZBTklUWV9VUkxcbiAgICAgKiAqIFZFUklGSUVEXG4gICAgICogKiBWSVBfUkVHSU9OU1xuICAgICAqICogV0VMQ09NRV9TQ1JFRU5fRU5BQkxFRFxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEZlYXR1cmVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBndWlsZCBmZWF0dXJlcyBwYXJ0bmVyZWQgZ3VpbGRzIGhhdmUgZW5hYmxlZFxuICAgICAqIEB0eXBlIHtGZWF0dXJlc1tdfVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXMgPSBkYXRhLmZlYXR1cmVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBhcHBsaWNhdGlvbiB0aGF0IGNyZWF0ZWQgdGhpcyBndWlsZCAoaWYgYXBwbGljYWJsZSlcbiAgICAgKiBAdHlwZSB7P1Nub3dmbGFrZX1cbiAgICAgKi9cbiAgICB0aGlzLmFwcGxpY2F0aW9uSUQgPSBkYXRhLmFwcGxpY2F0aW9uX2lkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgYSB1c2VyIGlzIGNvdW50ZWQgYXMgXCJhd2F5IGZyb20ga2V5Ym9hcmRcIlxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYWZrVGltZW91dCA9IGRhdGEuYWZrX3RpbWVvdXQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHZvaWNlIGNoYW5uZWwgd2hlcmUgQUZLIG1lbWJlcnMgYXJlIG1vdmVkXG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5hZmtDaGFubmVsSUQgPSBkYXRhLmFma19jaGFubmVsX2lkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBzeXN0ZW0gY2hhbm5lbFxuICAgICAqIEB0eXBlIHs/U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuc3lzdGVtQ2hhbm5lbElEID0gZGF0YS5zeXN0ZW1fY2hhbm5lbF9pZDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW1iZWRkZWQgaW1hZ2VzIGFyZSBlbmFibGVkIG9uIHRoaXMgZ3VpbGRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHRoaXMuZW1iZWRFbmFibGVkID0gZGF0YS5lbWJlZF9lbmFibGVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgcHJlbWl1bSB0aWVyOlxuICAgICAqICogMDogTk9ORVxuICAgICAqICogMTogVElFUl8xXG4gICAgICogKiAyOiBUSUVSXzJcbiAgICAgKiAqIDM6IFRJRVJfM1xuICAgICAqIEB0eXBlZGVmIHtudW1iZXJ9IFByZW1pdW1UaWVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbWl1bSB0aWVyIG9uIHRoaXMgZ3VpbGRcbiAgICAgKiBAdHlwZSB7UHJlbWl1bVRpZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmVtaXVtVGllciA9IGRhdGEucHJlbWl1bV90aWVyO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhLnByZW1pdW1fc3Vic2NyaXB0aW9uX2NvdW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGJvb3N0cyBmb3IgdGhpcyBzZXJ2ZXJcbiAgICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLnByZW1pdW1TdWJzY3JpcHRpb25Db3VudCA9IGRhdGEucHJlbWl1bV9zdWJzY3JpcHRpb25fY291bnQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhLndpZGdldF9lbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHdpZGdldCBpbWFnZXMgYXJlIGVuYWJsZWQgb24gdGhpcyBndWlsZFxuICAgICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAgICovXG4gICAgICB0aGlzLndpZGdldEVuYWJsZWQgPSBkYXRhLndpZGdldF9lbmFibGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YS53aWRnZXRfY2hhbm5lbF9pZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHdpZGdldCBjaGFubmVsIElELCBpZiBlbmFibGVkXG4gICAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgdGhpcy53aWRnZXRDaGFubmVsSUQgPSBkYXRhLndpZGdldF9jaGFubmVsX2lkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YS5lbWJlZF9jaGFubmVsX2lkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZW1iZWQgY2hhbm5lbCBJRCwgaWYgZW5hYmxlZFxuICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICovXG4gICAgICB0aGlzLmVtYmVkQ2hhbm5lbElEID0gZGF0YS5lbWJlZF9jaGFubmVsX2lkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJpZmljYXRpb24gbGV2ZWwgb2YgdGhlIGd1aWxkXG4gICAgICogQHR5cGUge1ZlcmlmaWNhdGlvbkxldmVsfVxuICAgICAqL1xuICAgIHRoaXMudmVyaWZpY2F0aW9uTGV2ZWwgPSBWZXJpZmljYXRpb25MZXZlbHNbZGF0YS52ZXJpZmljYXRpb25fbGV2ZWxdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4cGxpY2l0IGNvbnRlbnQgZmlsdGVyIGxldmVsIG9mIHRoZSBndWlsZFxuICAgICAqIEB0eXBlIHtFeHBsaWNpdENvbnRlbnRGaWx0ZXJMZXZlbH1cbiAgICAgKi9cbiAgICB0aGlzLmV4cGxpY2l0Q29udGVudEZpbHRlciA9IEV4cGxpY2l0Q29udGVudEZpbHRlckxldmVsc1tkYXRhLmV4cGxpY2l0X2NvbnRlbnRfZmlsdGVyXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1aXJlZCBNRkEgbGV2ZWwgZm9yIHRoZSBndWlsZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tZmFMZXZlbCA9IGRhdGEubWZhX2xldmVsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVzdGFtcCB0aGUgY2xpZW50IHVzZXIgam9pbmVkIHRoZSBndWlsZCBhdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5qb2luZWRUaW1lc3RhbXAgPSBkYXRhLmpvaW5lZF9hdCA/IG5ldyBEYXRlKGRhdGEuam9pbmVkX2F0KS5nZXRUaW1lKCkgOiB0aGlzLmpvaW5lZFRpbWVzdGFtcDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBzZXQgZm9yIHRoZSBndWlsZCdzIGRlZmF1bHQgbWVzc2FnZSBub3RpZmljYXRpb25zXG4gICAgICogQHR5cGUge0RlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9uc3xudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0TWVzc2FnZU5vdGlmaWNhdGlvbnMgPVxuICAgICAgRGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zW2RhdGEuZGVmYXVsdF9tZXNzYWdlX25vdGlmaWNhdGlvbnNdIHx8IGRhdGEuZGVmYXVsdF9tZXNzYWdlX25vdGlmaWNhdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgc2V0IGZvciB0aGUgZ3VpbGQncyBzeXN0ZW0gY2hhbm5lbCBmbGFnc1xuICAgICAqIEB0eXBlIHtSZWFkb25seTxTeXN0ZW1DaGFubmVsRmxhZ3M+fVxuICAgICAqL1xuICAgIHRoaXMuc3lzdGVtQ2hhbm5lbEZsYWdzID0gbmV3IFN5c3RlbUNoYW5uZWxGbGFncyhkYXRhLnN5c3RlbV9jaGFubmVsX2ZsYWdzKS5mcmVlemUoKTtcblxuICAgIGlmICh0eXBlb2YgZGF0YS5tYXhfbWVtYmVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIG1lbWJlcnMgdGhlIGd1aWxkIGNhbiBoYXZlXG4gICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5tYXhpbXVtTWVtYmVycyA9IGRhdGEubWF4X21lbWJlcnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXhpbXVtTWVtYmVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubWF4aW11bU1lbWJlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YS5tYXhfcHJlc2VuY2VzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgcHJlc2VuY2VzIHRoZSBndWlsZCBjYW4gaGF2ZVxuICAgICAgICogPGluZm8+WW91IHdpbGwgbmVlZCB0byBmZXRjaCB0aGUgZ3VpbGQgdXNpbmcge0BsaW5rIEd1aWxkI2ZldGNofSBpZiB5b3Ugd2FudCB0byByZWNlaXZlIHRoaXMgcGFyYW1ldGVyPC9pbmZvPlxuICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMubWF4aW11bVByZXNlbmNlcyA9IGRhdGEubWF4X3ByZXNlbmNlcyB8fCAyNTAwMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1heGltdW1QcmVzZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLm1heGltdW1QcmVzZW5jZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YS5hcHByb3hpbWF0ZV9tZW1iZXJfY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBhcHByb3hpbWF0ZSBhbW91bnQgb2YgbWVtYmVycyB0aGUgZ3VpbGQgaGFzXG4gICAgICAgKiA8aW5mbz5Zb3Ugd2lsbCBuZWVkIHRvIGZldGNoIHRoZSBndWlsZCB1c2luZyB7QGxpbmsgR3VpbGQjZmV0Y2h9IGlmIHlvdSB3YW50IHRvIHJlY2VpdmUgdGhpcyBwYXJhbWV0ZXI8L2luZm8+XG4gICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5hcHByb3hpbWF0ZU1lbWJlckNvdW50ID0gZGF0YS5hcHByb3hpbWF0ZV9tZW1iZXJfY291bnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5hcHByb3hpbWF0ZU1lbWJlckNvdW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5hcHByb3hpbWF0ZU1lbWJlckNvdW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEuYXBwcm94aW1hdGVfcHJlc2VuY2VfY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBhcHByb3hpbWF0ZSBhbW91bnQgb2YgcHJlc2VuY2VzIHRoZSBndWlsZCBoYXNcbiAgICAgICAqIDxpbmZvPllvdSB3aWxsIG5lZWQgdG8gZmV0Y2ggdGhlIGd1aWxkIHVzaW5nIHtAbGluayBHdWlsZCNmZXRjaH0gaWYgeW91IHdhbnQgdG8gcmVjZWl2ZSB0aGlzIHBhcmFtZXRlcjwvaW5mbz5cbiAgICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLmFwcHJveGltYXRlUHJlc2VuY2VDb3VudCA9IGRhdGEuYXBwcm94aW1hdGVfcHJlc2VuY2VfY291bnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5hcHByb3hpbWF0ZVByZXNlbmNlQ291bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmFwcHJveGltYXRlUHJlc2VuY2VDb3VudCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbml0eSBpbnZpdGUgY29kZSBvZiB0aGUgZ3VpbGQsIGlmIGFueVxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmFuaXR5VVJMQ29kZSA9IGRhdGEudmFuaXR5X3VybF9jb2RlO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2UgY291bnQgb2YgdGhlIHZhbml0eSBVUkwgY29kZSBvZiB0aGUgZ3VpbGQsIGlmIGFueVxuICAgICAqIDxpbmZvPllvdSB3aWxsIG5lZWQgdG8gZmV0Y2ggdGhpcyBwYXJhbWV0ZXIgdXNpbmcge0BsaW5rIEd1aWxkI2ZldGNoVmFuaXR5RGF0YX0gaWYgeW91IHdhbnQgdG8gcmVjZWl2ZSBpdDwvaW5mbz5cbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbml0eVVSTFVzZXMgPSBudWxsO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBndWlsZCwgaWYgYW55XG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRhdGEuZGVzY3JpcHRpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFzaCBvZiB0aGUgZ3VpbGQgYmFubmVyXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5iYW5uZXIgPSBkYXRhLmJhbm5lcjtcblxuICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuICAgIHRoaXMuYXZhaWxhYmxlID0gIWRhdGEudW5hdmFpbGFibGU7XG4gICAgdGhpcy5mZWF0dXJlcyA9IGRhdGEuZmVhdHVyZXMgfHwgdGhpcy5mZWF0dXJlcyB8fCBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgcnVsZXMgY2hhbm5lbCBmb3IgdGhlIGd1aWxkXG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5ydWxlc0NoYW5uZWxJRCA9IGRhdGEucnVsZXNfY2hhbm5lbF9pZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgY29tbXVuaXR5IHVwZGF0ZXMgY2hhbm5lbCBmb3IgdGhlIGd1aWxkXG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5wdWJsaWNVcGRhdGVzQ2hhbm5lbElEID0gZGF0YS5wdWJsaWNfdXBkYXRlc19jaGFubmVsX2lkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWZlcnJlZCBsb2NhbGUgb2YgdGhlIGd1aWxkLCBkZWZhdWx0cyB0byBgZW4tVVNgXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByZWZlcnJlZExvY2FsZSA9IGRhdGEucHJlZmVycmVkX2xvY2FsZTtcblxuICAgIGlmIChkYXRhLmNoYW5uZWxzKSB7XG4gICAgICB0aGlzLmNoYW5uZWxzLmNhY2hlLmNsZWFyKCk7XG4gICAgICBmb3IgKGNvbnN0IHJhd0NoYW5uZWwgb2YgZGF0YS5jaGFubmVscykge1xuICAgICAgICB0aGlzLmNsaWVudC5jaGFubmVscy5hZGQocmF3Q2hhbm5lbCwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEucm9sZXMpIHtcbiAgICAgIHRoaXMucm9sZXMuY2FjaGUuY2xlYXIoKTtcbiAgICAgIGZvciAoY29uc3Qgcm9sZSBvZiBkYXRhLnJvbGVzKSB0aGlzLnJvbGVzLmFkZChyb2xlKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5tZW1iZXJzKSB7XG4gICAgICB0aGlzLm1lbWJlcnMuY2FjaGUuY2xlYXIoKTtcbiAgICAgIGZvciAoY29uc3QgZ3VpbGRVc2VyIG9mIGRhdGEubWVtYmVycykgdGhpcy5tZW1iZXJzLmFkZChndWlsZFVzZXIpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLm93bmVyX2lkKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB1c2VyIElEIG9mIHRoaXMgZ3VpbGQncyBvd25lclxuICAgICAgICogQHR5cGUge1Nub3dmbGFrZX1cbiAgICAgICAqL1xuICAgICAgdGhpcy5vd25lcklEID0gZGF0YS5vd25lcl9pZDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5wcmVzZW5jZXMpIHtcbiAgICAgIGZvciAoY29uc3QgcHJlc2VuY2Ugb2YgZGF0YS5wcmVzZW5jZXMpIHtcbiAgICAgICAgdGhpcy5wcmVzZW5jZXMuYWRkKE9iamVjdC5hc3NpZ24ocHJlc2VuY2UsIHsgZ3VpbGQ6IHRoaXMgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLnZvaWNlX3N0YXRlcykge1xuICAgICAgdGhpcy52b2ljZVN0YXRlcy5jYWNoZS5jbGVhcigpO1xuICAgICAgZm9yIChjb25zdCB2b2ljZVN0YXRlIG9mIGRhdGEudm9pY2Vfc3RhdGVzKSB7XG4gICAgICAgIHRoaXMudm9pY2VTdGF0ZXMuYWRkKHZvaWNlU3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5lbW9qaXMpIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBtYW5hZ2VyIG9mIHRoZSBlbW9qaXMgYmVsb25naW5nIHRvIHRoaXMgZ3VpbGRcbiAgICAgICAqIEB0eXBlIHtHdWlsZEVtb2ppTWFuYWdlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5lbW9qaXMgPSBuZXcgR3VpbGRFbW9qaU1hbmFnZXIodGhpcyk7XG4gICAgICBpZiAoZGF0YS5lbW9qaXMpIGZvciAoY29uc3QgZW1vamkgb2YgZGF0YS5lbW9qaXMpIHRoaXMuZW1vamlzLmFkZChlbW9qaSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmVtb2ppcykge1xuICAgICAgdGhpcy5jbGllbnQuYWN0aW9ucy5HdWlsZEVtb2ppc1VwZGF0ZS5oYW5kbGUoe1xuICAgICAgICBndWlsZF9pZDogdGhpcy5pZCxcbiAgICAgICAgZW1vamlzOiBkYXRhLmVtb2ppcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVVJMIHRvIHRoaXMgZ3VpbGQncyBiYW5uZXIuXG4gICAqIEBwYXJhbSB7SW1hZ2VVUkxPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIEltYWdlIFVSTFxuICAgKiBAcmV0dXJucyB7P3N0cmluZ31cbiAgICovXG4gIGJhbm5lclVSTCh7IGZvcm1hdCwgc2l6ZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuYmFubmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jZG4uQmFubmVyKHRoaXMuaWQsIHRoaXMuYmFubmVyLCBmb3JtYXQsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgdGhlIGd1aWxkIHdhcyBjcmVhdGVkIGF0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNyZWF0ZWRUaW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIFNub3dmbGFrZS5kZWNvbnN0cnVjdCh0aGlzLmlkKS50aW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIGd1aWxkIHdhcyBjcmVhdGVkIGF0XG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkQXQoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuY3JlYXRlZFRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIGNsaWVudCB1c2VyIGpvaW5lZCB0aGUgZ3VpbGRcbiAgICogQHR5cGUge0RhdGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGpvaW5lZEF0KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmpvaW5lZFRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyBndWlsZCBpcyBwYXJ0bmVyZWRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcnRuZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlcy5pbmNsdWRlcygnUEFSVE5FUkVEJyk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyBndWlsZCBpcyB2ZXJpZmllZFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdmVyaWZpZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMuaW5jbHVkZXMoJ1ZFUklGSUVEJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFVSTCB0byB0aGlzIGd1aWxkJ3MgaWNvbi5cbiAgICogQHBhcmFtIHtJbWFnZVVSTE9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgSW1hZ2UgVVJMXG4gICAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICAgKi9cbiAgaWNvblVSTCh7IGZvcm1hdCwgc2l6ZSwgZHluYW1pYyB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaWNvbikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2RuLkljb24odGhpcy5pZCwgdGhpcy5pY29uLCBmb3JtYXQsIHNpemUsIGR5bmFtaWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhY3JvbnltIHRoYXQgc2hvd3MgdXAgaW4gcGxhY2Ugb2YgYSBndWlsZCBpY29uLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuYW1lQWNyb255bSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXG4gICAgICAucmVwbGFjZSgvJ3MgL2csICcgJylcbiAgICAgIC5yZXBsYWNlKC9cXHcrL2csIGUgPT4gZVswXSlcbiAgICAgIC5yZXBsYWNlKC9cXHMvZywgJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgdG8gdGhpcyBndWlsZCdzIGludml0ZSBzcGxhc2ggaW1hZ2UuXG4gICAqIEBwYXJhbSB7SW1hZ2VVUkxPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIEltYWdlIFVSTFxuICAgKiBAcmV0dXJucyB7P3N0cmluZ31cbiAgICovXG4gIHNwbGFzaFVSTCh7IGZvcm1hdCwgc2l6ZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuc3BsYXNoKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jZG4uU3BsYXNoKHRoaXMuaWQsIHRoaXMuc3BsYXNoLCBmb3JtYXQsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgdG8gdGhpcyBndWlsZCdzIGRpc2NvdmVyeSBzcGxhc2ggaW1hZ2UuXG4gICAqIEBwYXJhbSB7SW1hZ2VVUkxPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIEltYWdlIFVSTFxuICAgKiBAcmV0dXJucyB7P3N0cmluZ31cbiAgICovXG4gIGRpc2NvdmVyeVNwbGFzaFVSTCh7IGZvcm1hdCwgc2l6ZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuZGlzY292ZXJ5U3BsYXNoKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jZG4uRGlzY292ZXJ5U3BsYXNoKHRoaXMuaWQsIHRoaXMuZGlzY292ZXJ5U3BsYXNoLCBmb3JtYXQsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvd25lciBvZiB0aGUgZ3VpbGRcbiAgICogQHR5cGUgez9HdWlsZE1lbWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3duZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWVtYmVycy5jYWNoZS5nZXQodGhpcy5vd25lcklEKSB8fFxuICAgICAgKHRoaXMuY2xpZW50Lm9wdGlvbnMucGFydGlhbHMuaW5jbHVkZXMoUGFydGlhbFR5cGVzLkdVSUxEX01FTUJFUilcbiAgICAgICAgPyB0aGlzLm1lbWJlcnMuYWRkKHsgdXNlcjogeyBpZDogdGhpcy5vd25lcklEIH0gfSwgdHJ1ZSlcbiAgICAgICAgOiBudWxsKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQUZLIHZvaWNlIGNoYW5uZWwgZm9yIHRoaXMgZ3VpbGRcbiAgICogQHR5cGUgez9Wb2ljZUNoYW5uZWx9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGFma0NoYW5uZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmNoYW5uZWxzLmNhY2hlLmdldCh0aGlzLmFma0NoYW5uZWxJRCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeXN0ZW0gY2hhbm5lbCBmb3IgdGhpcyBndWlsZFxuICAgKiBAdHlwZSB7P1RleHRDaGFubmVsfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzeXN0ZW1DaGFubmVsKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5jaGFubmVscy5jYWNoZS5nZXQodGhpcy5zeXN0ZW1DaGFubmVsSUQpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2lkZ2V0IGNoYW5uZWwgZm9yIHRoaXMgZ3VpbGRcbiAgICogQHR5cGUgez9UZXh0Q2hhbm5lbH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgd2lkZ2V0Q2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuY2hhbm5lbHMuY2FjaGUuZ2V0KHRoaXMud2lkZ2V0Q2hhbm5lbElEKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtYmVkIGNoYW5uZWwgZm9yIHRoaXMgZ3VpbGRcbiAgICogQHR5cGUgez9UZXh0Q2hhbm5lbH1cbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZW1iZWRDaGFubmVsKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5jaGFubmVscy5jYWNoZS5nZXQodGhpcy5lbWJlZENoYW5uZWxJRCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdWxlcyBjaGFubmVsIGZvciB0aGlzIGd1aWxkXG4gICAqIEB0eXBlIHs/VGV4dENoYW5uZWx9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJ1bGVzQ2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuY2hhbm5lbHMuY2FjaGUuZ2V0KHRoaXMucnVsZXNDaGFubmVsSUQpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIHVwZGF0ZXMgY2hhbm5lbCBmb3IgdGhpcyBndWlsZFxuICAgKiBAdHlwZSB7P1RleHRDaGFubmVsfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwdWJsaWNVcGRhdGVzQ2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuY2hhbm5lbHMuY2FjaGUuZ2V0KHRoaXMucHVibGljVXBkYXRlc0NoYW5uZWxJRCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2xpZW50IHVzZXIgYXMgYSBHdWlsZE1lbWJlciBvZiB0aGlzIGd1aWxkXG4gICAqIEB0eXBlIHs/R3VpbGRNZW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1lbWJlcnMuY2FjaGUuZ2V0KHRoaXMuY2xpZW50LnVzZXIuaWQpIHx8XG4gICAgICAodGhpcy5jbGllbnQub3B0aW9ucy5wYXJ0aWFscy5pbmNsdWRlcyhQYXJ0aWFsVHlwZXMuR1VJTERfTUVNQkVSKVxuICAgICAgICA/IHRoaXMubWVtYmVycy5hZGQoeyB1c2VyOiB7IGlkOiB0aGlzLmNsaWVudC51c2VyLmlkIH0gfSwgdHJ1ZSlcbiAgICAgICAgOiBudWxsKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZvaWNlIHN0YXRlIGZvciB0aGUgY2xpZW50IHVzZXIgb2YgdGhpcyBndWlsZCwgaWYgYW55XG4gICAqIEB0eXBlIHs/Vm9pY2VTdGF0ZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdm9pY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudm9pY2VTdGF0ZXMuY2FjaGUuZ2V0KHRoaXMuY2xpZW50LnVzZXIuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEd1aWxkTWVtYmVyIGZvcm0gb2YgYSBVc2VyIG9iamVjdCwgaWYgdGhlIHVzZXIgaXMgcHJlc2VudCBpbiB0aGUgZ3VpbGQuXG4gICAqIEBwYXJhbSB7VXNlclJlc29sdmFibGV9IHVzZXIgVGhlIHVzZXIgdGhhdCB5b3Ugd2FudCB0byBvYnRhaW4gdGhlIEd1aWxkTWVtYmVyIG9mXG4gICAqIEByZXR1cm5zIHs/R3VpbGRNZW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCB0aGUgZ3VpbGQgbWVtYmVyIG9mIGEgdXNlclxuICAgKiBjb25zdCBtZW1iZXIgPSBndWlsZC5tZW1iZXIobWVzc2FnZS5hdXRob3IpO1xuICAgKi9cbiAgbWVtYmVyKHVzZXIpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJzLnJlc29sdmUodXNlcik7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyB0aGlzIGd1aWxkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqL1xuICBmZXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuaWQpXG4gICAgICAuZ2V0KHsgcXVlcnk6IHsgd2l0aF9jb3VudHM6IHRydWUgfSB9KVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGEgZ3VpbGQgbWVtYmVyJ3MgYmFuLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBCYW5JbmZvXG4gICAqIEBwcm9wZXJ0eSB7VXNlcn0gdXNlciBVc2VyIHRoYXQgd2FzIGJhbm5lZFxuICAgKiBAcHJvcGVydHkgez9zdHJpbmd9IHJlYXNvbiBSZWFzb24gdGhlIHVzZXIgd2FzIGJhbm5lZFxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBvbiBhIGJhbm5lZCB1c2VyIGZyb20gdGhpcyBndWlsZC5cbiAgICogQHBhcmFtIHtVc2VyUmVzb2x2YWJsZX0gdXNlciBUaGUgVXNlciB0byBmZXRjaCB0aGUgYmFuIGluZm8gb2ZcbiAgICogQHJldHVybnMge1Byb21pc2U8QmFuSW5mbz59XG4gICAqL1xuICBmZXRjaEJhbih1c2VyKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmNsaWVudC51c2Vycy5yZXNvbHZlSUQodXNlcik7XG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKCdGRVRDSF9CQU5fUkVTT0xWRV9JRCcpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5pZClcbiAgICAgIC5iYW5zKGlkKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihiYW4gPT4gKHtcbiAgICAgICAgcmVhc29uOiBiYW4ucmVhc29uLFxuICAgICAgICB1c2VyOiB0aGlzLmNsaWVudC51c2Vycy5hZGQoYmFuLnVzZXIpLFxuICAgICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYSBjb2xsZWN0aW9uIG9mIGJhbm5lZCB1c2VycyBpbiB0aGlzIGd1aWxkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uPFNub3dmbGFrZSwgQmFuSW5mbz4+fVxuICAgKi9cbiAgZmV0Y2hCYW5zKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5pZClcbiAgICAgIC5iYW5zLmdldCgpXG4gICAgICAudGhlbihiYW5zID0+XG4gICAgICAgIGJhbnMucmVkdWNlKChjb2xsZWN0aW9uLCBiYW4pID0+IHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnNldChiYW4udXNlci5pZCwge1xuICAgICAgICAgICAgcmVhc29uOiBiYW4ucmVhc29uLFxuICAgICAgICAgICAgdXNlcjogdGhpcy5jbGllbnQudXNlcnMuYWRkKGJhbi51c2VyKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfSwgbmV3IENvbGxlY3Rpb24oKSksXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYSBjb2xsZWN0aW9uIG9mIGludGVncmF0aW9ucyB0byB0aGlzIGd1aWxkLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgY29sbGVjdGlvbiBtYXBwaW5nIGludGVncmF0aW9ucyBieSB0aGVpciBpZHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgZmV0Y2hpbmcgaW50ZWdyYXRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZUFwcGxpY2F0aW9uc10gV2hldGhlciB0byBpbmNsdWRlIGJvdCBhbmQgT2F1dGgyIHdlYmhvb2sgaW50ZWdyYXRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbGxlY3Rpb248c3RyaW5nLCBJbnRlZ3JhdGlvbj4+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGZXRjaCBpbnRlZ3JhdGlvbnNcbiAgICogZ3VpbGQuZmV0Y2hJbnRlZ3JhdGlvbnMoKVxuICAgKiAgIC50aGVuKGludGVncmF0aW9ucyA9PiBjb25zb2xlLmxvZyhgRmV0Y2hlZCAke2ludGVncmF0aW9ucy5zaXplfSBpbnRlZ3JhdGlvbnNgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaEludGVncmF0aW9ucyh7IGluY2x1ZGVBcHBsaWNhdGlvbnMgPSBmYWxzZSB9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuaWQpXG4gICAgICAuaW50ZWdyYXRpb25zLmdldCh7XG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgaW5jbHVkZV9hcHBsaWNhdGlvbnM6IGluY2x1ZGVBcHBsaWNhdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLnRoZW4oZGF0YSA9PlxuICAgICAgICBkYXRhLnJlZHVjZShcbiAgICAgICAgICAoY29sbGVjdGlvbiwgaW50ZWdyYXRpb24pID0+IGNvbGxlY3Rpb24uc2V0KGludGVncmF0aW9uLmlkLCBuZXcgSW50ZWdyYXRpb24odGhpcy5jbGllbnQsIGludGVncmF0aW9uLCB0aGlzKSksXG4gICAgICAgICAgbmV3IENvbGxlY3Rpb24oKSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhIGNvbGxlY3Rpb24gb2YgdGVtcGxhdGVzIGZyb20gdGhpcyBndWlsZC5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGNvbGxlY3Rpb24gbWFwcGluZyB0ZW1wbGF0ZXMgYnkgdGhlaXIgY29kZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbGxlY3Rpb248c3RyaW5nLCBHdWlsZFRlbXBsYXRlPj59XG4gICAqL1xuICBmZXRjaFRlbXBsYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuaWQpXG4gICAgICAudGVtcGxhdGVzLmdldCgpXG4gICAgICAudGhlbih0ZW1wbGF0ZXMgPT5cbiAgICAgICAgdGVtcGxhdGVzLnJlZHVjZSgoY29sLCBkYXRhKSA9PiBjb2wuc2V0KGRhdGEuY29kZSwgbmV3IEd1aWxkVGVtcGxhdGUodGhpcy5jbGllbnQsIGRhdGEpKSwgbmV3IENvbGxlY3Rpb24oKSksXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIGZvciBjcmVhdGluZyBhbiBpbnRlZ3JhdGlvbi5cbiAgICogQHR5cGVkZWYge09iamVjdH0gSW50ZWdyYXRpb25EYXRhXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCBUaGUgaW50ZWdyYXRpb24gaWRcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGludGVncmF0aW9uIHR5cGVcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW50ZWdyYXRpb24gYnkgYXR0YWNoaW5nIGFuIGludGVncmF0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0ge0ludGVncmF0aW9uRGF0YX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIGludGVncmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gUmVhc29uIGZvciBjcmVhdGluZyB0aGUgaW50ZWdyYXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKi9cbiAgY3JlYXRlSW50ZWdyYXRpb24oZGF0YSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLmludGVncmF0aW9ucy5wb3N0KHsgZGF0YSwgcmVhc29uIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgZm9yIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXSBUaGUgZGVzY3JpcHRpb24gZm9yIHRoZSB0ZW1wbGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZFRlbXBsYXRlPn1cbiAgICovXG4gIGNyZWF0ZVRlbXBsYXRlKG5hbWUsIGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLnRlbXBsYXRlcy5wb3N0KHsgZGF0YTogeyBuYW1lLCBkZXNjcmlwdGlvbiB9IH0pXG4gICAgICAudGhlbihkYXRhID0+IG5ldyBHdWlsZFRlbXBsYXRlKHRoaXMuY2xpZW50LCBkYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhIGNvbGxlY3Rpb24gb2YgaW52aXRlcyB0byB0aGlzIGd1aWxkLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgY29sbGVjdGlvbiBtYXBwaW5nIGludml0ZXMgYnkgdGhlaXIgY29kZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbGxlY3Rpb248c3RyaW5nLCBJbnZpdGU+Pn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmV0Y2ggaW52aXRlc1xuICAgKiBndWlsZC5mZXRjaEludml0ZXMoKVxuICAgKiAgIC50aGVuKGludml0ZXMgPT4gY29uc29sZS5sb2coYEZldGNoZWQgJHtpbnZpdGVzLnNpemV9IGludml0ZXNgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZldGNoIGludml0ZSBjcmVhdG9yIGJ5IHRoZWlyIGlkXG4gICAqIGd1aWxkLmZldGNoSW52aXRlcygpXG4gICAqICAudGhlbihpbnZpdGVzID0+IGNvbnNvbGUubG9nKGludml0ZXMuZmluZChpbnZpdGUgPT4gaW52aXRlLmludml0ZXIuaWQgPT09ICc4NDQ4NDY1MzY4NzI2NzMyOCcpKSlcbiAgICogIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGZldGNoSW52aXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuaWQpXG4gICAgICAuaW52aXRlcy5nZXQoKVxuICAgICAgLnRoZW4oaW52aXRlSXRlbXMgPT4ge1xuICAgICAgICBjb25zdCBpbnZpdGVzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBpbnZpdGVJdGVtIG9mIGludml0ZUl0ZW1zKSB7XG4gICAgICAgICAgY29uc3QgaW52aXRlID0gbmV3IEludml0ZSh0aGlzLmNsaWVudCwgaW52aXRlSXRlbSk7XG4gICAgICAgICAgaW52aXRlcy5zZXQoaW52aXRlLmNvZGUsIGludml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludml0ZXM7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRhaW5zIGEgZ3VpbGQgcHJldmlldyBmb3IgdGhpcyBndWlsZCBmcm9tIERpc2NvcmQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkUHJldmlldz59XG4gICAqL1xuICBmZXRjaFByZXZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLnByZXZpZXcuZ2V0KClcbiAgICAgIC50aGVuKGRhdGEgPT4gbmV3IEd1aWxkUHJldmlldyh0aGlzLmNsaWVudCwgZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHZhbml0eSB1cmwgaW52aXRlIGNvZGUgdG8gdGhpcyBndWlsZC5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIHN0cmluZyBtYXRjaGluZyB0aGUgdmFuaXR5IHVybCBpbnZpdGUgY29kZSwgbm90IHRoZSBmdWxsIHVybC5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmV0Y2ggaW52aXRlc1xuICAgKiBndWlsZC5mZXRjaFZhbml0eUNvZGUoKVxuICAgKiAgIC50aGVuKGNvZGUgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2coYFZhbml0eSBVUkw6IGh0dHBzOi8vZGlzY29yZC5nZy8ke2NvZGV9YCk7XG4gICAqICAgfSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaFZhbml0eUNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hWYW5pdHlEYXRhKCkudGhlbih2YW5pdHkgPT4gdmFuaXR5LmNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGEgZ3VpbGQncyB2YW5pdHkgaW52aXRlLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBWYW5pdHlcbiAgICogQHByb3BlcnR5IHs/c3RyaW5nfSBjb2RlIFZhbml0eSBpbnZpdGUgY29kZVxuICAgKiBAcHJvcGVydHkgez9udW1iZXJ9IHVzZXMgSG93IG1hbnkgdGltZXMgdGhpcyBpbnZpdGUgaGFzIGJlZW4gdXNlZFxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgdmFuaXR5IHVybCBpbnZpdGUgb2JqZWN0IHRvIHRoaXMgZ3VpbGQuXG4gICAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZhbml0eSB1cmwgaW52aXRlIGNvZGUgYW5kIHRoZSB1c2UgY291bnRcbiAgICogQHJldHVybnMge1Byb21pc2U8VmFuaXR5Pn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmV0Y2ggaW52aXRlIGRhdGFcbiAgICogZ3VpbGQuZmV0Y2hWYW5pdHlEYXRhKClcbiAgICogICAudGhlbihyZXMgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2coYFZhbml0eSBVUkw6IGh0dHBzOi8vZGlzY29yZC5nZy8ke3Jlcy5jb2RlfSB3aXRoICR7cmVzLnVzZXN9IHVzZXNgKTtcbiAgICogICB9KVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGFzeW5jIGZldGNoVmFuaXR5RGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuaW5jbHVkZXMoJ1ZBTklUWV9VUkwnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWQU5JVFlfVVJMJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkuZ3VpbGRzKHRoaXMuaWQsICd2YW5pdHktdXJsJykuZ2V0KCk7XG4gICAgdGhpcy52YW5pdHlVUkxVc2VzID0gZGF0YS51c2VzO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgd2ViaG9va3MgZm9yIHRoZSBndWlsZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q29sbGVjdGlvbjxTbm93Zmxha2UsIFdlYmhvb2s+Pn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmV0Y2ggd2ViaG9va3NcbiAgICogZ3VpbGQuZmV0Y2hXZWJob29rcygpXG4gICAqICAgLnRoZW4od2ViaG9va3MgPT4gY29uc29sZS5sb2coYEZldGNoZWQgJHt3ZWJob29rcy5zaXplfSB3ZWJob29rc2ApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGZldGNoV2ViaG9va3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLndlYmhvb2tzLmdldCgpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgY29uc3QgaG9va3MgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgZGF0YSkgaG9va3Muc2V0KGhvb2suaWQsIG5ldyBXZWJob29rKHRoaXMuY2xpZW50LCBob29rKSk7XG4gICAgICAgIHJldHVybiBob29rcztcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYXZhaWxhYmxlIHZvaWNlIHJlZ2lvbnMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbGxlY3Rpb248c3RyaW5nLCBWb2ljZVJlZ2lvbj4+fVxuICAgKi9cbiAgZmV0Y2hWb2ljZVJlZ2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLnJlZ2lvbnMuZ2V0KClcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiByZXMpIHJlZ2lvbnMuc2V0KHJlZ2lvbi5pZCwgbmV3IFZvaWNlUmVnaW9uKHJlZ2lvbikpO1xuICAgICAgICByZXR1cm4gcmVnaW9ucztcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgZm9yIHRoZSBHdWlsZCBXaWRnZXQgb2JqZWN0XG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEd1aWxkV2lkZ2V0XG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlZCBXaGV0aGVyIHRoZSB3aWRnZXQgaXMgZW5hYmxlZFxuICAgKiBAcHJvcGVydHkgez9HdWlsZENoYW5uZWx9IGNoYW5uZWwgVGhlIHdpZGdldCBjaGFubmVsXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgR3VpbGQgV2lkZ2V0IG9iamVjdFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBHdWlsZFdpZGdldERhdGFcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkIFdoZXRoZXIgdGhlIHdpZGdldCBpcyBlbmFibGVkXG4gICAqIEBwcm9wZXJ0eSB7P0d1aWxkQ2hhbm5lbFJlc29sdmFibGV9IGNoYW5uZWwgVGhlIHdpZGdldCBjaGFubmVsXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBndWlsZCBlbWJlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRXaWRnZXQ+fVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGZXRjaGVzIHRoZSBndWlsZCBlbWJlZFxuICAgKiBndWlsZC5mZXRjaEVtYmVkKClcbiAgICogICAudGhlbihlbWJlZCA9PiBjb25zb2xlLmxvZyhgVGhlIGVtYmVkIGlzICR7ZW1iZWQuZW5hYmxlZCA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgZmV0Y2hFbWJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFdpZGdldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIGd1aWxkIHdpZGdldC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRXaWRnZXQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGZXRjaGVzIHRoZSBndWlsZCB3aWRnZXRcbiAgICogZ3VpbGQuZmV0Y2hXaWRnZXQoKVxuICAgKiAgIC50aGVuKHdpZGdldCA9PiBjb25zb2xlLmxvZyhgVGhlIHdpZGdldCBpcyAke3dpZGdldC5lbmFibGVkID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ31gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBhc3luYyBmZXRjaFdpZGdldCgpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuYXBpLmd1aWxkcyh0aGlzLmlkKS53aWRnZXQuZ2V0KCk7XG4gICAgdGhpcy53aWRnZXRFbmFibGVkID0gdGhpcy5lbWJlZEVuYWJsZWQgPSBkYXRhLmVuYWJsZWQ7XG4gICAgdGhpcy53aWRnZXRDaGFubmVsSUQgPSB0aGlzLmVtYmVkQ2hhbm5lbElEID0gZGF0YS5jaGFubmVsX2lkO1xuICAgIHJldHVybiB7XG4gICAgICBlbmFibGVkOiBkYXRhLmVuYWJsZWQsXG4gICAgICBjaGFubmVsOiBkYXRhLmNoYW5uZWxfaWQgPyB0aGlzLmNoYW5uZWxzLmNhY2hlLmdldChkYXRhLmNoYW5uZWxfaWQpIDogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYXVkaXQgbG9ncyBmb3IgdGhpcyBndWlsZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciBmZXRjaGluZyBhdWRpdCBsb2dzXG4gICAqIEBwYXJhbSB7U25vd2ZsYWtlfEd1aWxkQXVkaXRMb2dzRW50cnl9IFtvcHRpb25zLmJlZm9yZV0gTGltaXQgdG8gZW50cmllcyBmcm9tIGJlZm9yZSBzcGVjaWZpZWQgZW50cnlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbWl0XSBMaW1pdCBudW1iZXIgb2YgZW50cmllc1xuICAgKiBAcGFyYW0ge1VzZXJSZXNvbHZhYmxlfSBbb3B0aW9ucy51c2VyXSBPbmx5IHNob3cgZW50cmllcyBpbnZvbHZpbmcgdGhpcyB1c2VyXG4gICAqIEBwYXJhbSB7QXVkaXRMb2dBY3Rpb258bnVtYmVyfSBbb3B0aW9ucy50eXBlXSBPbmx5IHNob3cgZW50cmllcyBpbnZvbHZpbmcgdGhpcyBhY3Rpb24gdHlwZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZEF1ZGl0TG9ncz59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE91dHB1dCBhdWRpdCBsb2cgZW50cmllc1xuICAgKiBndWlsZC5mZXRjaEF1ZGl0TG9ncygpXG4gICAqICAgLnRoZW4oYXVkaXQgPT4gY29uc29sZS5sb2coYXVkaXQuZW50cmllcy5maXJzdCgpKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaEF1ZGl0TG9ncyhvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5iZWZvcmUgJiYgb3B0aW9ucy5iZWZvcmUgaW5zdGFuY2VvZiBHdWlsZEF1ZGl0TG9ncy5FbnRyeSkgb3B0aW9ucy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZS5pZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gJ3N0cmluZycpIG9wdGlvbnMudHlwZSA9IEd1aWxkQXVkaXRMb2dzLkFjdGlvbnNbb3B0aW9ucy50eXBlXTtcblxuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5pZClcbiAgICAgIFsnYXVkaXQtbG9ncyddLmdldCh7XG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSxcbiAgICAgICAgICBsaW1pdDogb3B0aW9ucy5saW1pdCxcbiAgICAgICAgICB1c2VyX2lkOiB0aGlzLmNsaWVudC51c2Vycy5yZXNvbHZlSUQob3B0aW9ucy51c2VyKSxcbiAgICAgICAgICBhY3Rpb25fdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC50aGVuKGRhdGEgPT4gR3VpbGRBdWRpdExvZ3MuYnVpbGQodGhpcywgZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB1c2VyIHRvIHRoZSBndWlsZCB1c2luZyBPQXV0aDIuIFJlcXVpcmVzIHRoZSBgQ1JFQVRFX0lOU1RBTlRfSU5WSVRFYCBwZXJtaXNzaW9uLlxuICAgKiBAcGFyYW0ge1VzZXJSZXNvbHZhYmxlfSB1c2VyIFVzZXIgdG8gYWRkIHRvIHRoZSBndWlsZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYWRkaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWNjZXNzVG9rZW4gQW4gT0F1dGgyIGFjY2VzcyB0b2tlbiBmb3IgdGhlIHVzZXIgd2l0aCB0aGUgYGd1aWxkcy5qb2luYCBzY29wZSBncmFudGVkIHRvIHRoZVxuICAgKiBib3QncyBhcHBsaWNhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmlja10gTmlja25hbWUgdG8gZ2l2ZSB0aGUgbWVtYmVyIChyZXF1aXJlcyBgTUFOQUdFX05JQ0tOQU1FU2ApXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIFJvbGU+fFJvbGVSZXNvbHZhYmxlW119IFtvcHRpb25zLnJvbGVzXSBSb2xlcyB0byBhZGQgdG8gdGhlIG1lbWJlclxuICAgKiAocmVxdWlyZXMgYE1BTkFHRV9ST0xFU2ApXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubXV0ZV0gV2hldGhlciB0aGUgbWVtYmVyIHNob3VsZCBiZSBtdXRlZCAocmVxdWlyZXMgYE1VVEVfTUVNQkVSU2ApXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVhZl0gV2hldGhlciB0aGUgbWVtYmVyIHNob3VsZCBiZSBkZWFmZW5lZCAocmVxdWlyZXMgYERFQUZFTl9NRU1CRVJTYClcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRNZW1iZXI+fVxuICAgKi9cbiAgYXN5bmMgYWRkTWVtYmVyKHVzZXIsIG9wdGlvbnMpIHtcbiAgICB1c2VyID0gdGhpcy5jbGllbnQudXNlcnMucmVzb2x2ZUlEKHVzZXIpO1xuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IFR5cGVFcnJvcignSU5WQUxJRF9UWVBFJywgJ3VzZXInLCAnVXNlclJlc29sdmFibGUnKTtcbiAgICBpZiAodGhpcy5tZW1iZXJzLmNhY2hlLmhhcyh1c2VyKSkgcmV0dXJuIHRoaXMubWVtYmVycy5jYWNoZS5nZXQodXNlcik7XG4gICAgb3B0aW9ucy5hY2Nlc3NfdG9rZW4gPSBvcHRpb25zLmFjY2Vzc1Rva2VuO1xuICAgIGlmIChvcHRpb25zLnJvbGVzKSB7XG4gICAgICBjb25zdCByb2xlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgcm9sZSBvZiBvcHRpb25zLnJvbGVzIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IG9wdGlvbnMucm9sZXMudmFsdWVzKCkgOiBvcHRpb25zLnJvbGVzKSB7XG4gICAgICAgIHJvbGUgPSB0aGlzLnJvbGVzLnJlc29sdmUocm9sZSk7XG4gICAgICAgIGlmICghcm9sZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lOVkFMSURfVFlQRScsICdvcHRpb25zLnJvbGVzJywgJ0FycmF5IG9yIENvbGxlY3Rpb24gb2YgUm9sZXMgb3IgU25vd2ZsYWtlcycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJvbGVzLnB1c2gocm9sZS5pZCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnJvbGVzID0gcm9sZXM7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkuZ3VpbGRzKHRoaXMuaWQpLm1lbWJlcnModXNlcikucHV0KHsgZGF0YTogb3B0aW9ucyB9KTtcbiAgICAvLyBEYXRhIGlzIGFuIGVtcHR5IGJ1ZmZlciBpZiB0aGUgbWVtYmVyIGlzIGFscmVhZHkgcGFydCBvZiB0aGUgZ3VpbGQuXG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiAoYnJvd3NlciA/IEFycmF5QnVmZmVyIDogQnVmZmVyKSA/IHRoaXMubWVtYmVycy5mZXRjaCh1c2VyKSA6IHRoaXMubWVtYmVycy5hZGQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRhdGEgZm9yIGVkaXRpbmcgYSBndWlsZC5cbiAgICogQHR5cGVkZWYge09iamVjdH0gR3VpbGRFZGl0RGF0YVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIFRoZSBuYW1lIG9mIHRoZSBndWlsZFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3JlZ2lvbl0gVGhlIHJlZ2lvbiBvZiB0aGUgZ3VpbGRcbiAgICogQHByb3BlcnR5IHtWZXJpZmljYXRpb25MZXZlbHxudW1iZXJ9IFt2ZXJpZmljYXRpb25MZXZlbF0gVGhlIHZlcmlmaWNhdGlvbiBsZXZlbCBvZiB0aGUgZ3VpbGRcbiAgICogQHByb3BlcnR5IHtFeHBsaWNpdENvbnRlbnRGaWx0ZXJMZXZlbHxudW1iZXJ9IFtleHBsaWNpdENvbnRlbnRGaWx0ZXJdIFRoZSBsZXZlbCBvZiB0aGUgZXhwbGljaXQgY29udGVudCBmaWx0ZXJcbiAgICogQHByb3BlcnR5IHtDaGFubmVsUmVzb2x2YWJsZX0gW2Fma0NoYW5uZWxdIFRoZSBBRksgY2hhbm5lbCBvZiB0aGUgZ3VpbGRcbiAgICogQHByb3BlcnR5IHtDaGFubmVsUmVzb2x2YWJsZX0gW3N5c3RlbUNoYW5uZWxdIFRoZSBzeXN0ZW0gY2hhbm5lbCBvZiB0aGUgZ3VpbGRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFthZmtUaW1lb3V0XSBUaGUgQUZLIHRpbWVvdXQgb2YgdGhlIGd1aWxkXG4gICAqIEBwcm9wZXJ0eSB7QmFzZTY0UmVzb2x2YWJsZX0gW2ljb25dIFRoZSBpY29uIG9mIHRoZSBndWlsZFxuICAgKiBAcHJvcGVydHkge0d1aWxkTWVtYmVyUmVzb2x2YWJsZX0gW293bmVyXSBUaGUgb3duZXIgb2YgdGhlIGd1aWxkXG4gICAqIEBwcm9wZXJ0eSB7QmFzZTY0UmVzb2x2YWJsZX0gW3NwbGFzaF0gVGhlIGludml0ZSBzcGxhc2ggaW1hZ2Ugb2YgdGhlIGd1aWxkXG4gICAqIEBwcm9wZXJ0eSB7QmFzZTY0UmVzb2x2YWJsZX0gW2Rpc2NvdmVyeVNwbGFzaF0gVGhlIGRpc2NvdmVyeSBzcGxhc2ggaW1hZ2Ugb2YgdGhlIGd1aWxkXG4gICAqIEBwcm9wZXJ0eSB7QmFzZTY0UmVzb2x2YWJsZX0gW2Jhbm5lcl0gVGhlIGJhbm5lciBvZiB0aGUgZ3VpbGRcbiAgICogQHByb3BlcnR5IHtEZWZhdWx0TWVzc2FnZU5vdGlmaWNhdGlvbnN8bnVtYmVyfSBbZGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zXSBUaGUgZGVmYXVsdCBtZXNzYWdlIG5vdGlmaWNhdGlvbnNcbiAgICogQHByb3BlcnR5IHtTeXN0ZW1DaGFubmVsRmxhZ3NSZXNvbHZhYmxlfSBbc3lzdGVtQ2hhbm5lbEZsYWdzXSBUaGUgc3lzdGVtIGNoYW5uZWwgZmxhZ3Mgb2YgdGhlIGd1aWxkXG4gICAqIEBwcm9wZXJ0eSB7Q2hhbm5lbFJlc29sdmFibGV9IFtydWxlc0NoYW5uZWxdIFRoZSBydWxlcyBjaGFubmVsIG9mIHRoZSBndWlsZFxuICAgKiBAcHJvcGVydHkge0NoYW5uZWxSZXNvbHZhYmxlfSBbcHVibGljVXBkYXRlc0NoYW5uZWxdIFRoZSBjb21tdW5pdHkgdXBkYXRlcyBjaGFubmVsIG9mIHRoZSBndWlsZFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ByZWZlcnJlZExvY2FsZV0gVGhlIHByZWZlcnJlZCBsb2NhbGUgb2YgdGhlIGd1aWxkXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBndWlsZCB3aXRoIG5ldyBpbmZvcm1hdGlvbiAtIGUuZy4gYSBuZXcgbmFtZS5cbiAgICogQHBhcmFtIHtHdWlsZEVkaXREYXRhfSBkYXRhIFRoZSBkYXRhIHRvIHVwZGF0ZSB0aGUgZ3VpbGQgd2l0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBlZGl0aW5nIHRoaXMgZ3VpbGRcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIGd1aWxkIG5hbWUgYW5kIHJlZ2lvblxuICAgKiBndWlsZC5lZGl0KHtcbiAgICogICBuYW1lOiAnRGlzY29yZCBHdWlsZCcsXG4gICAqICAgcmVnaW9uOiAnbG9uZG9uJyxcbiAgICogfSlcbiAgICogICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKGBOZXcgZ3VpbGQgbmFtZSAke3VwZGF0ZWR9IGluIHJlZ2lvbiAke3VwZGF0ZWQucmVnaW9ufWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGVkaXQoZGF0YSwgcmVhc29uKSB7XG4gICAgY29uc3QgX2RhdGEgPSB7fTtcbiAgICBpZiAoZGF0YS5uYW1lKSBfZGF0YS5uYW1lID0gZGF0YS5uYW1lO1xuICAgIGlmIChkYXRhLnJlZ2lvbikgX2RhdGEucmVnaW9uID0gZGF0YS5yZWdpb247XG4gICAgaWYgKHR5cGVvZiBkYXRhLnZlcmlmaWNhdGlvbkxldmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2RhdGEudmVyaWZpY2F0aW9uX2xldmVsID1cbiAgICAgICAgdHlwZW9mIGRhdGEudmVyaWZpY2F0aW9uTGV2ZWwgPT09ICdudW1iZXInXG4gICAgICAgICAgPyBOdW1iZXIoZGF0YS52ZXJpZmljYXRpb25MZXZlbClcbiAgICAgICAgICA6IFZlcmlmaWNhdGlvbkxldmVscy5pbmRleE9mKGRhdGEudmVyaWZpY2F0aW9uTGV2ZWwpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEuYWZrQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIF9kYXRhLmFma19jaGFubmVsX2lkID0gdGhpcy5jbGllbnQuY2hhbm5lbHMucmVzb2x2ZUlEKGRhdGEuYWZrQ2hhbm5lbCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YS5zeXN0ZW1DaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2RhdGEuc3lzdGVtX2NoYW5uZWxfaWQgPSB0aGlzLmNsaWVudC5jaGFubmVscy5yZXNvbHZlSUQoZGF0YS5zeXN0ZW1DaGFubmVsKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYWZrVGltZW91dCkgX2RhdGEuYWZrX3RpbWVvdXQgPSBOdW1iZXIoZGF0YS5hZmtUaW1lb3V0KTtcbiAgICBpZiAodHlwZW9mIGRhdGEuaWNvbiAhPT0gJ3VuZGVmaW5lZCcpIF9kYXRhLmljb24gPSBkYXRhLmljb247XG4gICAgaWYgKGRhdGEub3duZXIpIF9kYXRhLm93bmVyX2lkID0gdGhpcy5jbGllbnQudXNlcnMucmVzb2x2ZUlEKGRhdGEub3duZXIpO1xuICAgIGlmIChkYXRhLnNwbGFzaCkgX2RhdGEuc3BsYXNoID0gZGF0YS5zcGxhc2g7XG4gICAgaWYgKGRhdGEuZGlzY292ZXJ5U3BsYXNoKSBfZGF0YS5kaXNjb3Zlcnlfc3BsYXNoID0gZGF0YS5kaXNjb3ZlcnlTcGxhc2g7XG4gICAgaWYgKGRhdGEuYmFubmVyKSBfZGF0YS5iYW5uZXIgPSBkYXRhLmJhbm5lcjtcbiAgICBpZiAodHlwZW9mIGRhdGEuZXhwbGljaXRDb250ZW50RmlsdGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2RhdGEuZXhwbGljaXRfY29udGVudF9maWx0ZXIgPVxuICAgICAgICB0eXBlb2YgZGF0YS5leHBsaWNpdENvbnRlbnRGaWx0ZXIgPT09ICdudW1iZXInXG4gICAgICAgICAgPyBkYXRhLmV4cGxpY2l0Q29udGVudEZpbHRlclxuICAgICAgICAgIDogRXhwbGljaXRDb250ZW50RmlsdGVyTGV2ZWxzLmluZGV4T2YoZGF0YS5leHBsaWNpdENvbnRlbnRGaWx0ZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEuZGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2RhdGEuZGVmYXVsdF9tZXNzYWdlX25vdGlmaWNhdGlvbnMgPVxuICAgICAgICB0eXBlb2YgZGF0YS5kZWZhdWx0TWVzc2FnZU5vdGlmaWNhdGlvbnMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgPyBEZWZhdWx0TWVzc2FnZU5vdGlmaWNhdGlvbnMuaW5kZXhPZihkYXRhLmRlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9ucylcbiAgICAgICAgICA6IGRhdGEuZGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEuc3lzdGVtQ2hhbm5lbEZsYWdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2RhdGEuc3lzdGVtX2NoYW5uZWxfZmxhZ3MgPSBTeXN0ZW1DaGFubmVsRmxhZ3MucmVzb2x2ZShkYXRhLnN5c3RlbUNoYW5uZWxGbGFncyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YS5ydWxlc0NoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfZGF0YS5ydWxlc19jaGFubmVsX2lkID0gdGhpcy5jbGllbnQuY2hhbm5lbHMucmVzb2x2ZUlEKGRhdGEucnVsZXNDaGFubmVsKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhLnB1YmxpY1VwZGF0ZXNDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2RhdGEucHVibGljX3VwZGF0ZXNfY2hhbm5lbF9pZCA9IHRoaXMuY2xpZW50LmNoYW5uZWxzLnJlc29sdmVJRChkYXRhLnB1YmxpY1VwZGF0ZXNDaGFubmVsKTtcbiAgICB9XG4gICAgaWYgKGRhdGEucHJlZmVycmVkTG9jYWxlKSBfZGF0YS5wcmVmZXJyZWRfbG9jYWxlID0gZGF0YS5wcmVmZXJyZWRMb2NhbGU7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLnBhdGNoKHsgZGF0YTogX2RhdGEsIHJlYXNvbiB9KVxuICAgICAgLnRoZW4obmV3RGF0YSA9PiB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkVXBkYXRlLmhhbmRsZShuZXdEYXRhKS51cGRhdGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFZGl0cyB0aGUgbGV2ZWwgb2YgdGhlIGV4cGxpY2l0IGNvbnRlbnQgZmlsdGVyLlxuICAgKiBAcGFyYW0ge0V4cGxpY2l0Q29udGVudEZpbHRlckxldmVsfG51bWJlcn0gZXhwbGljaXRDb250ZW50RmlsdGVyIFRoZSBuZXcgbGV2ZWwgb2YgdGhlIGV4cGxpY2l0IGNvbnRlbnQgZmlsdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSBsZXZlbCBvZiB0aGUgZ3VpbGQncyBleHBsaWNpdCBjb250ZW50IGZpbHRlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqL1xuICBzZXRFeHBsaWNpdENvbnRlbnRGaWx0ZXIoZXhwbGljaXRDb250ZW50RmlsdGVyLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgZXhwbGljaXRDb250ZW50RmlsdGVyIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gIC8qKlxuICAgKiBFZGl0cyB0aGUgc2V0dGluZyBvZiB0aGUgZGVmYXVsdCBtZXNzYWdlIG5vdGlmaWNhdGlvbnMgb2YgdGhlIGd1aWxkLlxuICAgKiBAcGFyYW0ge0RlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9uc3xudW1iZXJ9IGRlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9ucyBUaGUgbmV3IHNldHRpbmcgZm9yIHRoZSBkZWZhdWx0IG1lc3NhZ2Ugbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgc2V0dGluZyBvZiB0aGUgZGVmYXVsdCBtZXNzYWdlIG5vdGlmaWNhdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKi9cbiAgc2V0RGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zKGRlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9ucywgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IGRlZmF1bHRNZXNzYWdlTm90aWZpY2F0aW9ucyB9LCByZWFzb24pO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gIC8qKlxuICAgKiBFZGl0cyB0aGUgZmxhZ3Mgb2YgdGhlIGRlZmF1bHQgbWVzc2FnZSBub3RpZmljYXRpb25zIG9mIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtTeXN0ZW1DaGFubmVsRmxhZ3NSZXNvbHZhYmxlfSBzeXN0ZW1DaGFubmVsRmxhZ3MgVGhlIG5ldyBmbGFncyBmb3IgdGhlIGRlZmF1bHQgbWVzc2FnZSBub3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSBmbGFncyBvZiB0aGUgZGVmYXVsdCBtZXNzYWdlIG5vdGlmaWNhdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKi9cbiAgc2V0U3lzdGVtQ2hhbm5lbEZsYWdzKHN5c3RlbUNoYW5uZWxGbGFncywgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IHN5c3RlbUNoYW5uZWxGbGFncyB9LCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVkaXRzIHRoZSBuYW1lIG9mIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5ldyBuYW1lIG9mIHRoZSBndWlsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgZ3VpbGQncyBuYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRWRpdCB0aGUgZ3VpbGQgbmFtZVxuICAgKiBndWlsZC5zZXROYW1lKCdEaXNjb3JkIEd1aWxkJylcbiAgICogIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFVwZGF0ZWQgZ3VpbGQgbmFtZSB0byAke3VwZGF0ZWQubmFtZX1gKSlcbiAgICogIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldE5hbWUobmFtZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IG5hbWUgfSwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFZGl0cyB0aGUgcmVnaW9uIG9mIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lvbiBUaGUgbmV3IHJlZ2lvbiBvZiB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkJ3MgcmVnaW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRWRpdCB0aGUgZ3VpbGQgcmVnaW9uXG4gICAqIGd1aWxkLnNldFJlZ2lvbignbG9uZG9uJylcbiAgICogIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFVwZGF0ZWQgZ3VpbGQgcmVnaW9uIHRvICR7dXBkYXRlZC5yZWdpb259YCkpXG4gICAqICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRSZWdpb24ocmVnaW9uLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgcmVnaW9uIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogRWRpdHMgdGhlIHZlcmlmaWNhdGlvbiBsZXZlbCBvZiB0aGUgZ3VpbGQuXG4gICAqIEBwYXJhbSB7VmVyaWZpY2F0aW9uTGV2ZWx8bnVtYmVyfSB2ZXJpZmljYXRpb25MZXZlbCBUaGUgbmV3IHZlcmlmaWNhdGlvbiBsZXZlbCBvZiB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkJ3MgdmVyaWZpY2F0aW9uIGxldmVsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRWRpdCB0aGUgZ3VpbGQgdmVyaWZpY2F0aW9uIGxldmVsXG4gICAqIGd1aWxkLnNldFZlcmlmaWNhdGlvbkxldmVsKDEpXG4gICAqICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKGBVcGRhdGVkIGd1aWxkIHZlcmlmaWNhdGlvbiBsZXZlbCB0byAke2d1aWxkLnZlcmlmaWNhdGlvbkxldmVsfWApKVxuICAgKiAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgc2V0VmVyaWZpY2F0aW9uTGV2ZWwodmVyaWZpY2F0aW9uTGV2ZWwsIHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXQoeyB2ZXJpZmljYXRpb25MZXZlbCB9LCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVkaXRzIHRoZSBBRksgY2hhbm5lbCBvZiB0aGUgZ3VpbGQuXG4gICAqIEBwYXJhbSB7Q2hhbm5lbFJlc29sdmFibGV9IGFma0NoYW5uZWwgVGhlIG5ldyBBRksgY2hhbm5lbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgZ3VpbGQncyBBRksgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVkaXQgdGhlIGd1aWxkIEFGSyBjaGFubmVsXG4gICAqIGd1aWxkLnNldEFGS0NoYW5uZWwoY2hhbm5lbClcbiAgICogIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFVwZGF0ZWQgZ3VpbGQgQUZLIGNoYW5uZWwgdG8gJHtndWlsZC5hZmtDaGFubmVsLm5hbWV9YCkpXG4gICAqICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRBRktDaGFubmVsKGFma0NoYW5uZWwsIHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXQoeyBhZmtDaGFubmVsIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogRWRpdHMgdGhlIHN5c3RlbSBjaGFubmVsIG9mIHRoZSBndWlsZC5cbiAgICogQHBhcmFtIHtDaGFubmVsUmVzb2x2YWJsZX0gc3lzdGVtQ2hhbm5lbCBUaGUgbmV3IHN5c3RlbSBjaGFubmVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSBndWlsZCdzIHN5c3RlbSBjaGFubmVsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRWRpdCB0aGUgZ3VpbGQgc3lzdGVtIGNoYW5uZWxcbiAgICogZ3VpbGQuc2V0U3lzdGVtQ2hhbm5lbChjaGFubmVsKVxuICAgKiAgLnRoZW4odXBkYXRlZCA9PiBjb25zb2xlLmxvZyhgVXBkYXRlZCBndWlsZCBzeXN0ZW0gY2hhbm5lbCB0byAke2d1aWxkLnN5c3RlbUNoYW5uZWwubmFtZX1gKSlcbiAgICogIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldFN5c3RlbUNoYW5uZWwoc3lzdGVtQ2hhbm5lbCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IHN5c3RlbUNoYW5uZWwgfSwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFZGl0cyB0aGUgQUZLIHRpbWVvdXQgb2YgdGhlIGd1aWxkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWZrVGltZW91dCBUaGUgdGltZSBpbiBzZWNvbmRzIHRoYXQgYSB1c2VyIG11c3QgYmUgaWRsZSB0byBiZSBjb25zaWRlcmVkIEFGS1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgZ3VpbGQncyBBRksgdGltZW91dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVkaXQgdGhlIGd1aWxkIEFGSyBjaGFubmVsXG4gICAqIGd1aWxkLnNldEFGS1RpbWVvdXQoNjApXG4gICAqICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKGBVcGRhdGVkIGd1aWxkIEFGSyB0aW1lb3V0IHRvICR7Z3VpbGQuYWZrVGltZW91dH1gKSlcbiAgICogIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldEFGS1RpbWVvdXQoYWZrVGltZW91dCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IGFma1RpbWVvdXQgfSwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IGd1aWxkIGljb24uXG4gICAqIEBwYXJhbSB7QmFzZTY0UmVzb2x2YWJsZXxCdWZmZXJSZXNvbHZhYmxlfSBpY29uIFRoZSBuZXcgaWNvbiBvZiB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkJ3MgaWNvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVkaXQgdGhlIGd1aWxkIGljb25cbiAgICogZ3VpbGQuc2V0SWNvbignLi9pY29uLnBuZycpXG4gICAqICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKCdVcGRhdGVkIHRoZSBndWlsZCBpY29uJykpXG4gICAqICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBhc3luYyBzZXRJY29uKGljb24sIHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXQoeyBpY29uOiBhd2FpdCBEYXRhUmVzb2x2ZXIucmVzb2x2ZUltYWdlKGljb24pLCByZWFzb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIG5ldyBvd25lciBvZiB0aGUgZ3VpbGQuXG4gICAqIEBwYXJhbSB7R3VpbGRNZW1iZXJSZXNvbHZhYmxlfSBvd25lciBUaGUgbmV3IG93bmVyIG9mIHRoZSBndWlsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBzZXR0aW5nIHRoZSBuZXcgb3duZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBFZGl0IHRoZSBndWlsZCBvd25lclxuICAgKiBndWlsZC5zZXRPd25lcihndWlsZC5tZW1iZXJzLmNhY2hlLmZpcnN0KCkpXG4gICAqICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKGBVcGRhdGVkIHRoZSBndWlsZCBvd25lciB0byAke3VwZGF0ZWQub3duZXIuZGlzcGxheU5hbWV9YCkpXG4gICAqICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRPd25lcihvd25lciwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IG93bmVyIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIG5ldyBndWlsZCBpbnZpdGUgc3BsYXNoIGltYWdlLlxuICAgKiBAcGFyYW0ge0Jhc2U2NFJlc29sdmFibGV8QnVmZmVyUmVzb2x2YWJsZX0gc3BsYXNoIFRoZSBuZXcgaW52aXRlIHNwbGFzaCBpbWFnZSBvZiB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkJ3MgaW52aXRlIHNwbGFzaCBpbWFnZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVkaXQgdGhlIGd1aWxkIHNwbGFzaFxuICAgKiBndWlsZC5zZXRTcGxhc2goJy4vc3BsYXNoLnBuZycpXG4gICAqICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKCdVcGRhdGVkIHRoZSBndWlsZCBzcGxhc2gnKSlcbiAgICogIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGFzeW5jIHNldFNwbGFzaChzcGxhc2gsIHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXQoeyBzcGxhc2g6IGF3YWl0IERhdGFSZXNvbHZlci5yZXNvbHZlSW1hZ2Uoc3BsYXNoKSwgcmVhc29uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgZ3VpbGQgZGlzY292ZXJ5IHNwbGFzaCBpbWFnZS5cbiAgICogQHBhcmFtIHtCYXNlNjRSZXNvbHZhYmxlfEJ1ZmZlclJlc29sdmFibGV9IGRpc2NvdmVyeVNwbGFzaCBUaGUgbmV3IGRpc2NvdmVyeSBzcGxhc2ggaW1hZ2Ugb2YgdGhlIGd1aWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSBndWlsZCdzIGRpc2NvdmVyeSBzcGxhc2ggaW1hZ2VcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBFZGl0IHRoZSBndWlsZCBkaXNjb3Zlcnkgc3BsYXNoXG4gICAqIGd1aWxkLnNldERpc2NvdmVyeVNwbGFzaCgnLi9kaXNjb3ZlcnlzcGxhc2gucG5nJylcbiAgICogICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKCdVcGRhdGVkIHRoZSBndWlsZCBkaXNjb3Zlcnkgc3BsYXNoJykpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgYXN5bmMgc2V0RGlzY292ZXJ5U3BsYXNoKGRpc2NvdmVyeVNwbGFzaCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IGRpc2NvdmVyeVNwbGFzaDogYXdhaXQgRGF0YVJlc29sdmVyLnJlc29sdmVJbWFnZShkaXNjb3ZlcnlTcGxhc2gpLCByZWFzb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIG5ldyBndWlsZCBiYW5uZXIuXG4gICAqIEBwYXJhbSB7QmFzZTY0UmVzb2x2YWJsZXxCdWZmZXJSZXNvbHZhYmxlfSBiYW5uZXIgVGhlIG5ldyBiYW5uZXIgb2YgdGhlIGd1aWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSBndWlsZCdzIGJhbm5lclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBleGFtcGxlXG4gICAqIGd1aWxkLnNldEJhbm5lcignLi9iYW5uZXIucG5nJylcbiAgICogIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coJ1VwZGF0ZWQgdGhlIGd1aWxkIGJhbm5lcicpKVxuICAgKiAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgYXN5bmMgc2V0QmFubmVyKGJhbm5lciwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IGJhbm5lcjogYXdhaXQgRGF0YVJlc29sdmVyLnJlc29sdmVJbWFnZShiYW5uZXIpLCByZWFzb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogRWRpdHMgdGhlIHJ1bGVzIGNoYW5uZWwgb2YgdGhlIGd1aWxkLlxuICAgKiBAcGFyYW0ge0NoYW5uZWxSZXNvbHZhYmxlfSBydWxlc0NoYW5uZWwgVGhlIG5ldyBydWxlcyBjaGFubmVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSBndWlsZCdzIHJ1bGVzIGNoYW5uZWxcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBFZGl0IHRoZSBndWlsZCBydWxlcyBjaGFubmVsXG4gICAqIGd1aWxkLnNldFJ1bGVzQ2hhbm5lbChjaGFubmVsKVxuICAgKiAgLnRoZW4odXBkYXRlZCA9PiBjb25zb2xlLmxvZyhgVXBkYXRlZCBndWlsZCBydWxlcyBjaGFubmVsIHRvICR7Z3VpbGQucnVsZXNDaGFubmVsLm5hbWV9YCkpXG4gICAqICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRSdWxlc0NoYW5uZWwocnVsZXNDaGFubmVsLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgcnVsZXNDaGFubmVsIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogRWRpdHMgdGhlIGNvbW11bml0eSB1cGRhdGVzIGNoYW5uZWwgb2YgdGhlIGd1aWxkLlxuICAgKiBAcGFyYW0ge0NoYW5uZWxSZXNvbHZhYmxlfSBwdWJsaWNVcGRhdGVzQ2hhbm5lbCBUaGUgbmV3IGNvbW11bml0eSB1cGRhdGVzIGNoYW5uZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkJ3MgY29tbXVuaXR5IHVwZGF0ZXMgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVkaXQgdGhlIGd1aWxkIGNvbW11bml0eSB1cGRhdGVzIGNoYW5uZWxcbiAgICogZ3VpbGQuc2V0UHVibGljVXBkYXRlc0NoYW5uZWwoY2hhbm5lbClcbiAgICogIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFVwZGF0ZWQgZ3VpbGQgY29tbXVuaXR5IHVwZGF0ZXMgY2hhbm5lbCB0byAke2d1aWxkLnB1YmxpY1VwZGF0ZXNDaGFubmVsLm5hbWV9YCkpXG4gICAqICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRQdWJsaWNVcGRhdGVzQ2hhbm5lbChwdWJsaWNVcGRhdGVzQ2hhbm5lbCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IHB1YmxpY1VwZGF0ZXNDaGFubmVsIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogRWRpdHMgdGhlIHByZWZlcnJlZCBsb2NhbGUgb2YgdGhlIGd1aWxkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZmVycmVkTG9jYWxlIFRoZSBuZXcgcHJlZmVycmVkIGxvY2FsZSBvZiB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkJ3MgcHJlZmVycmVkIGxvY2FsZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVkaXQgdGhlIGd1aWxkIHByZWZlcnJlZCBsb2NhbGVcbiAgICogZ3VpbGQuc2V0UHJlZmVycmVkTG9jYWxlKCdlbi1VUycpXG4gICAqICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKGBVcGRhdGVkIGd1aWxkIHByZWZlcnJlZCBsb2NhbGUgdG8gJHtndWlsZC5wcmVmZXJyZWRMb2NhbGV9YCkpXG4gICAqICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRQcmVmZXJyZWRMb2NhbGUocHJlZmVycmVkTG9jYWxlLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgcHJlZmVycmVkTG9jYWxlIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRhdGEgbmVlZGVkIGZvciB1cGRhdGluZyBhIGNoYW5uZWwncyBwb3NpdGlvbi5cbiAgICogQHR5cGVkZWYge09iamVjdH0gQ2hhbm5lbFBvc2l0aW9uXG4gICAqIEBwcm9wZXJ0eSB7Q2hhbm5lbFJlc29sdmFibGV9IGNoYW5uZWwgQ2hhbm5lbCB0byB1cGRhdGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc2l0aW9uIE5ldyBwb3NpdGlvbiBmb3IgdGhlIGNoYW5uZWxcbiAgICovXG5cbiAgLyoqXG4gICAqIEJhdGNoLXVwZGF0ZXMgdGhlIGd1aWxkJ3MgY2hhbm5lbHMnIHBvc2l0aW9ucy5cbiAgICogQHBhcmFtIHtDaGFubmVsUG9zaXRpb25bXX0gY2hhbm5lbFBvc2l0aW9ucyBDaGFubmVsIHBvc2l0aW9ucyB0byB1cGRhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBndWlsZC5zZXRDaGFubmVsUG9zaXRpb25zKFt7IGNoYW5uZWw6IGNoYW5uZWxJRCwgcG9zaXRpb246IG5ld0NoYW5uZWxJbmRleCB9XSlcbiAgICogICAudGhlbihndWlsZCA9PiBjb25zb2xlLmxvZyhgVXBkYXRlZCBjaGFubmVsIHBvc2l0aW9ucyBmb3IgJHtndWlsZH1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRDaGFubmVsUG9zaXRpb25zKGNoYW5uZWxQb3NpdGlvbnMpIHtcbiAgICBjb25zdCB1cGRhdGVkQ2hhbm5lbHMgPSBjaGFubmVsUG9zaXRpb25zLm1hcChyID0+ICh7XG4gICAgICBpZDogdGhpcy5jbGllbnQuY2hhbm5lbHMucmVzb2x2ZUlEKHIuY2hhbm5lbCksXG4gICAgICBwb3NpdGlvbjogci5wb3NpdGlvbixcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuaWQpXG4gICAgICAuY2hhbm5lbHMucGF0Y2goeyBkYXRhOiB1cGRhdGVkQ2hhbm5lbHMgfSlcbiAgICAgIC50aGVuKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgIHRoaXMuY2xpZW50LmFjdGlvbnMuR3VpbGRDaGFubmVsc1Bvc2l0aW9uVXBkYXRlLmhhbmRsZSh7XG4gICAgICAgICAgICBndWlsZF9pZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNoYW5uZWxzOiB1cGRhdGVkQ2hhbm5lbHMsXG4gICAgICAgICAgfSkuZ3VpbGQsXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIG5lZWRlZCBmb3IgdXBkYXRpbmcgYSBndWlsZCByb2xlJ3MgcG9zaXRpb25cbiAgICogQHR5cGVkZWYge09iamVjdH0gR3VpbGRSb2xlUG9zaXRpb25cbiAgICogQHByb3BlcnR5IHtSb2xlUmVzb2x2ZWFibGV9IHJvbGUgVGhlIElEIG9mIHRoZSByb2xlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gdXBkYXRlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBCYXRjaC11cGRhdGVzIHRoZSBndWlsZCdzIHJvbGUgcG9zaXRpb25zXG4gICAqIEBwYXJhbSB7R3VpbGRSb2xlUG9zaXRpb25bXX0gcm9sZVBvc2l0aW9ucyBSb2xlIHBvc2l0aW9ucyB0byB1cGRhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBndWlsZC5zZXRSb2xlUG9zaXRpb25zKFt7IHJvbGU6IHJvbGVJRCwgcG9zaXRpb246IHVwZGF0ZWRSb2xlSW5kZXggfV0pXG4gICAqICAudGhlbihndWlsZCA9PiBjb25zb2xlLmxvZyhgUm9sZSBwZXJtaXNzaW9ucyB1cGRhdGVkIGZvciAke2d1aWxkfWApKVxuICAgKiAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgc2V0Um9sZVBvc2l0aW9ucyhyb2xlUG9zaXRpb25zKSB7XG4gICAgLy8gTWFrZSBzdXJlIHJvbGVQb3NpdGlvbnMgYXJlIHByZXBhcmVkIGZvciBBUElcbiAgICByb2xlUG9zaXRpb25zID0gcm9sZVBvc2l0aW9ucy5tYXAobyA9PiAoe1xuICAgICAgaWQ6IHRoaXMucm9sZXMucmVzb2x2ZUlEKG8ucm9sZSksXG4gICAgICBwb3NpdGlvbjogby5wb3NpdGlvbixcbiAgICB9KSk7XG5cbiAgICAvLyBDYWxsIHRoZSBBUEkgdG8gdXBkYXRlIHJvbGUgcG9zaXRpb25zXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLnJvbGVzLnBhdGNoKHtcbiAgICAgICAgZGF0YTogcm9sZVBvc2l0aW9ucyxcbiAgICAgIH0pXG4gICAgICAudGhlbihcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkUm9sZXNQb3NpdGlvblVwZGF0ZS5oYW5kbGUoe1xuICAgICAgICAgICAgZ3VpbGRfaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICByb2xlczogcm9sZVBvc2l0aW9ucyxcbiAgICAgICAgICB9KS5ndWlsZCxcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRWRpdHMgdGhlIGd1aWxkJ3MgZW1iZWQuXG4gICAqIEBwYXJhbSB7R3VpbGRXaWRnZXREYXRhfSBlbWJlZCBUaGUgZW1iZWQgZm9yIHRoZSBndWlsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgZ3VpbGQncyBlbWJlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRFbWJlZChlbWJlZCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0V2lkZ2V0KGVtYmVkLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVkaXRzIHRoZSBndWlsZCdzIHdpZGdldC5cbiAgICogQHBhcmFtIHtHdWlsZFdpZGdldERhdGF9IHdpZGdldCBUaGUgd2lkZ2V0IGZvciB0aGUgZ3VpbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkJ3Mgd2lkZ2V0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkPn1cbiAgICovXG4gIHNldFdpZGdldCh3aWRnZXQsIHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5pZClcbiAgICAgIC53aWRnZXQucGF0Y2goe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hYmxlZDogd2lkZ2V0LmVuYWJsZWQsXG4gICAgICAgICAgY2hhbm5lbF9pZDogdGhpcy5jaGFubmVscy5yZXNvbHZlSUQod2lkZ2V0LmNoYW5uZWwpLFxuICAgICAgICB9LFxuICAgICAgICByZWFzb24sXG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogTGVhdmVzIHRoZSBndWlsZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBMZWF2ZSBhIGd1aWxkXG4gICAqIGd1aWxkLmxlYXZlKClcbiAgICogICAudGhlbihnID0+IGNvbnNvbGUubG9nKGBMZWZ0IHRoZSBndWlsZCAke2d9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgbGVhdmUoKSB7XG4gICAgaWYgKHRoaXMub3duZXJJRCA9PT0gdGhpcy5jbGllbnQudXNlci5pZCkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignR1VJTERfT1dORUQnKSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLnVzZXJzKCdAbWUnKVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkRGVsZXRlLmhhbmRsZSh7IGlkOiB0aGlzLmlkIH0pLmd1aWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBndWlsZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGQ+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBEZWxldGUgYSBndWlsZFxuICAgKiBndWlsZC5kZWxldGUoKVxuICAgKiAgIC50aGVuKGcgPT4gY29uc29sZS5sb2coYERlbGV0ZWQgdGhlIGd1aWxkICR7Z31gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBkZWxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmlkKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkRGVsZXRlLmhhbmRsZSh7IGlkOiB0aGlzLmlkIH0pLmd1aWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgZ3VpbGQgZXF1YWxzIGFub3RoZXIgZ3VpbGQuIEl0IGNvbXBhcmVzIGFsbCBwcm9wZXJ0aWVzLCBzbyBmb3IgbW9zdCBvcGVyYXRpb25zXG4gICAqIGl0IGlzIGFkdmlzYWJsZSB0byBqdXN0IGNvbXBhcmUgYGd1aWxkLmlkID09PSBndWlsZDIuaWRgIGFzIGl0IGlzIG11Y2ggZmFzdGVyIGFuZCBpcyBvZnRlblxuICAgKiB3aGF0IG1vc3QgdXNlcnMgbmVlZC5cbiAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRvIGNvbXBhcmUgd2l0aFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhndWlsZCkge1xuICAgIGxldCBlcXVhbCA9XG4gICAgICBndWlsZCAmJlxuICAgICAgZ3VpbGQgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yICYmXG4gICAgICB0aGlzLmlkID09PSBndWlsZC5pZCAmJlxuICAgICAgdGhpcy5hdmFpbGFibGUgPT09IGd1aWxkLmF2YWlsYWJsZSAmJlxuICAgICAgdGhpcy5zcGxhc2ggPT09IGd1aWxkLnNwbGFzaCAmJlxuICAgICAgdGhpcy5kaXNjb3ZlcnlTcGxhc2ggPT09IGd1aWxkLmRpc2NvdmVyeVNwbGFzaCAmJlxuICAgICAgdGhpcy5yZWdpb24gPT09IGd1aWxkLnJlZ2lvbiAmJlxuICAgICAgdGhpcy5uYW1lID09PSBndWlsZC5uYW1lICYmXG4gICAgICB0aGlzLm1lbWJlckNvdW50ID09PSBndWlsZC5tZW1iZXJDb3VudCAmJlxuICAgICAgdGhpcy5sYXJnZSA9PT0gZ3VpbGQubGFyZ2UgJiZcbiAgICAgIHRoaXMuaWNvbiA9PT0gZ3VpbGQuaWNvbiAmJlxuICAgICAgdGhpcy5vd25lcklEID09PSBndWlsZC5vd25lcklEICYmXG4gICAgICB0aGlzLnZlcmlmaWNhdGlvbkxldmVsID09PSBndWlsZC52ZXJpZmljYXRpb25MZXZlbCAmJlxuICAgICAgdGhpcy5lbWJlZEVuYWJsZWQgPT09IGd1aWxkLmVtYmVkRW5hYmxlZCAmJlxuICAgICAgKHRoaXMuZmVhdHVyZXMgPT09IGd1aWxkLmZlYXR1cmVzIHx8XG4gICAgICAgICh0aGlzLmZlYXR1cmVzLmxlbmd0aCA9PT0gZ3VpbGQuZmVhdHVyZXMubGVuZ3RoICYmXG4gICAgICAgICAgdGhpcy5mZWF0dXJlcy5ldmVyeSgoZmVhdCwgaSkgPT4gZmVhdCA9PT0gZ3VpbGQuZmVhdHVyZXNbaV0pKSk7XG5cbiAgICBpZiAoZXF1YWwpIHtcbiAgICAgIGlmICh0aGlzLmVtYmVkQ2hhbm5lbCkge1xuICAgICAgICBpZiAoIWd1aWxkLmVtYmVkQ2hhbm5lbCB8fCB0aGlzLmVtYmVkQ2hhbm5lbC5pZCAhPT0gZ3VpbGQuZW1iZWRDaGFubmVsLmlkKSBlcXVhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChndWlsZC5lbWJlZENoYW5uZWwpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIGd1aWxkJ3MgbmFtZSBpbnN0ZWFkIG9mIHRoZSBHdWlsZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExvZ3M6IEhlbGxvIGZyb20gTXkgR3VpbGQhXG4gICAqIGNvbnNvbGUubG9nKGBIZWxsbyBmcm9tICR7Z3VpbGR9IWApO1xuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKHtcbiAgICAgIGF2YWlsYWJsZTogZmFsc2UsXG4gICAgICBjcmVhdGVkVGltZXN0YW1wOiB0cnVlLFxuICAgICAgbmFtZUFjcm9ueW06IHRydWUsXG4gICAgICBwcmVzZW5jZXM6IGZhbHNlLFxuICAgICAgdm9pY2VTdGF0ZXM6IGZhbHNlLFxuICAgIH0pO1xuICAgIGpzb24uaWNvblVSTCA9IHRoaXMuaWNvblVSTCgpO1xuICAgIGpzb24uc3BsYXNoVVJMID0gdGhpcy5zcGxhc2hVUkwoKTtcbiAgICBqc29uLmRpc2NvdmVyeVNwbGFzaFVSTCA9IHRoaXMuZGlzY292ZXJ5U3BsYXNoVVJMKCk7XG4gICAganNvbi5iYW5uZXJVUkwgPSB0aGlzLmJhbm5lclVSTCgpO1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9mIHRoaXMgZ3VpbGQncyByb2xlcywgc29ydGVkIGJ5IHRoZWlyIHBvc2l0aW9uIGFuZCBJRHMuXG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9uPFJvbGU+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NvcnRlZFJvbGVzKCkge1xuICAgIHJldHVybiBVdGlsLmRpc2NvcmRTb3J0KHRoaXMucm9sZXMuY2FjaGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9mIHRoaXMgZ3VpbGQncyBvciBhIHNwZWNpZmljIGNhdGVnb3J5J3MgY2hhbm5lbHMsIHNvcnRlZCBieSB0aGVpciBwb3NpdGlvbiBhbmQgSURzLlxuICAgKiBAcGFyYW0ge0d1aWxkQ2hhbm5lbH0gW2NoYW5uZWxdIENhdGVnb3J5IHRvIGdldCB0aGUgY2hhbm5lbHMgb2ZcbiAgICogQHJldHVybnMge0NvbGxlY3Rpb248R3VpbGRDaGFubmVsPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zb3J0ZWRDaGFubmVscyhjaGFubmVsKSB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBjaGFubmVsLnR5cGUgPT09IENoYW5uZWxUeXBlcy5DQVRFR09SWTtcbiAgICByZXR1cm4gVXRpbC5kaXNjb3JkU29ydChcbiAgICAgIHRoaXMuY2hhbm5lbHMuY2FjaGUuZmlsdGVyKFxuICAgICAgICBjID0+XG4gICAgICAgICAgKFsndGV4dCcsICduZXdzJywgJ3N0b3JlJ10uaW5jbHVkZXMoY2hhbm5lbC50eXBlKVxuICAgICAgICAgICAgPyBbJ3RleHQnLCAnbmV3cycsICdzdG9yZSddLmluY2x1ZGVzKGMudHlwZSlcbiAgICAgICAgICAgIDogYy50eXBlID09PSBjaGFubmVsLnR5cGUpICYmXG4gICAgICAgICAgKGNhdGVnb3J5IHx8IGMucGFyZW50ID09PSBjaGFubmVsLnBhcmVudCksXG4gICAgICApLFxuICAgICk7XG4gIH1cbn1cblxuR3VpbGQucHJvdG90eXBlLnNldEVtYmVkID0gZGVwcmVjYXRlKEd1aWxkLnByb3RvdHlwZS5zZXRFbWJlZCwgJ0d1aWxkI3NldEVtYmVkOiBVc2Ugc2V0V2lkZ2V0IGluc3RlYWQnKTtcblxuR3VpbGQucHJvdG90eXBlLmZldGNoRW1iZWQgPSBkZXByZWNhdGUoR3VpbGQucHJvdG90eXBlLmZldGNoRW1iZWQsICdHdWlsZCNmZXRjaEVtYmVkOiBVc2UgZmV0Y2hXaWRnZXQgaW5zdGVhZCcpO1xuXG5HdWlsZC5wcm90b3R5cGUuZmV0Y2hWYW5pdHlDb2RlID0gZGVwcmVjYXRlKFxuICBHdWlsZC5wcm90b3R5cGUuZmV0Y2hWYW5pdHlDb2RlLFxuICAnR3VpbGQjZmV0Y2hWYW5pdHlDb2RlOiBVc2UgZmV0Y2hWYW5pdHlEYXRhKCkgaW5zdGVhZCcsXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBJbnRlZ3JhdGlvbiA9IHJlcXVpcmUoJy4vSW50ZWdyYXRpb24nKTtcbmNvbnN0IFdlYmhvb2sgPSByZXF1aXJlKCcuL1dlYmhvb2snKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IHsgUGFydGlhbFR5cGVzIH0gPSByZXF1aXJlKCcuLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgU25vd2ZsYWtlID0gcmVxdWlyZSgnLi4vdXRpbC9Tbm93Zmxha2UnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBUaGUgdGFyZ2V0IHR5cGUgb2YgYW4gZW50cnksIGUuZy4gYEdVSUxEYC4gSGVyZSBhcmUgdGhlIGF2YWlsYWJsZSB0eXBlczpcbiAqICogR1VJTERcbiAqICogQ0hBTk5FTFxuICogKiBVU0VSXG4gKiAqIFJPTEVcbiAqICogSU5WSVRFXG4gKiAqIFdFQkhPT0tcbiAqICogRU1PSklcbiAqICogTUVTU0FHRVxuICogKiBJTlRFR1JBVElPTlxuICogQHR5cGVkZWYge3N0cmluZ30gQXVkaXRMb2dUYXJnZXRUeXBlXG4gKi9cblxuLyoqXG4gKiBLZXkgbWlycm9yIG9mIGFsbCBhdmFpbGFibGUgYXVkaXQgbG9nIHRhcmdldHMuXG4gKiBAbmFtZSBHdWlsZEF1ZGl0TG9ncy5UYXJnZXRzXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgVGFyZ2V0cyA9IHtcbiAgQUxMOiAnQUxMJyxcbiAgR1VJTEQ6ICdHVUlMRCcsXG4gIENIQU5ORUw6ICdDSEFOTkVMJyxcbiAgVVNFUjogJ1VTRVInLFxuICBST0xFOiAnUk9MRScsXG4gIElOVklURTogJ0lOVklURScsXG4gIFdFQkhPT0s6ICdXRUJIT09LJyxcbiAgRU1PSkk6ICdFTU9KSScsXG4gIE1FU1NBR0U6ICdNRVNTQUdFJyxcbiAgSU5URUdSQVRJT046ICdJTlRFR1JBVElPTicsXG4gIFVOS05PV046ICdVTktOT1dOJyxcbn07XG5cbi8qKlxuICogVGhlIGFjdGlvbiBvZiBhbiBlbnRyeS4gSGVyZSBhcmUgdGhlIGF2YWlsYWJsZSBhY3Rpb25zOlxuICogKiBBTEw6IG51bGxcbiAqICogR1VJTERfVVBEQVRFOiAxXG4gKiAqIENIQU5ORUxfQ1JFQVRFOiAxMFxuICogKiBDSEFOTkVMX1VQREFURTogMTFcbiAqICogQ0hBTk5FTF9ERUxFVEU6IDEyXG4gKiAqIENIQU5ORUxfT1ZFUldSSVRFX0NSRUFURTogMTNcbiAqICogQ0hBTk5FTF9PVkVSV1JJVEVfVVBEQVRFOiAxNFxuICogKiBDSEFOTkVMX09WRVJXUklURV9ERUxFVEU6IDE1XG4gKiAqIE1FTUJFUl9LSUNLOiAyMFxuICogKiBNRU1CRVJfUFJVTkU6IDIxXG4gKiAqIE1FTUJFUl9CQU5fQUREOiAyMlxuICogKiBNRU1CRVJfQkFOX1JFTU9WRTogMjNcbiAqICogTUVNQkVSX1VQREFURTogMjRcbiAqICogTUVNQkVSX1JPTEVfVVBEQVRFOiAyNVxuICogKiBNRU1CRVJfTU9WRTogMjZcbiAqICogTUVNQkVSX0RJU0NPTk5FQ1Q6IDI3XG4gKiAqIEJPVF9BREQ6IDI4LFxuICogKiBST0xFX0NSRUFURTogMzBcbiAqICogUk9MRV9VUERBVEU6IDMxXG4gKiAqIFJPTEVfREVMRVRFOiAzMlxuICogKiBJTlZJVEVfQ1JFQVRFOiA0MFxuICogKiBJTlZJVEVfVVBEQVRFOiA0MVxuICogKiBJTlZJVEVfREVMRVRFOiA0MlxuICogKiBXRUJIT09LX0NSRUFURTogNTBcbiAqICogV0VCSE9PS19VUERBVEU6IDUxXG4gKiAqIFdFQkhPT0tfREVMRVRFOiA1MlxuICogKiBFTU9KSV9DUkVBVEU6IDYwXG4gKiAqIEVNT0pJX1VQREFURTogNjFcbiAqICogRU1PSklfREVMRVRFOiA2MlxuICogKiBNRVNTQUdFX0RFTEVURTogNzJcbiAqICogTUVTU0FHRV9CVUxLX0RFTEVURTogNzNcbiAqICogTUVTU0FHRV9QSU46IDc0XG4gKiAqIE1FU1NBR0VfVU5QSU46IDc1XG4gKiAqIElOVEVHUkFUSU9OX0NSRUFURTogODBcbiAqICogSU5URUdSQVRJT05fVVBEQVRFOiA4MVxuICogKiBJTlRFR1JBVElPTl9ERUxFVEU6IDgyXG4gKiBAdHlwZWRlZiB7P251bWJlcnxzdHJpbmd9IEF1ZGl0TG9nQWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBbGwgYXZhaWxhYmxlIGFjdGlvbnMga2V5ZWQgdW5kZXIgdGhlaXIgbmFtZXMgdG8gdGhlaXIgbnVtZXJpYyB2YWx1ZXMuXG4gKiBAbmFtZSBHdWlsZEF1ZGl0TG9ncy5BY3Rpb25zXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAqL1xuY29uc3QgQWN0aW9ucyA9IHtcbiAgQUxMOiBudWxsLFxuICBHVUlMRF9VUERBVEU6IDEsXG4gIENIQU5ORUxfQ1JFQVRFOiAxMCxcbiAgQ0hBTk5FTF9VUERBVEU6IDExLFxuICBDSEFOTkVMX0RFTEVURTogMTIsXG4gIENIQU5ORUxfT1ZFUldSSVRFX0NSRUFURTogMTMsXG4gIENIQU5ORUxfT1ZFUldSSVRFX1VQREFURTogMTQsXG4gIENIQU5ORUxfT1ZFUldSSVRFX0RFTEVURTogMTUsXG4gIE1FTUJFUl9LSUNLOiAyMCxcbiAgTUVNQkVSX1BSVU5FOiAyMSxcbiAgTUVNQkVSX0JBTl9BREQ6IDIyLFxuICBNRU1CRVJfQkFOX1JFTU9WRTogMjMsXG4gIE1FTUJFUl9VUERBVEU6IDI0LFxuICBNRU1CRVJfUk9MRV9VUERBVEU6IDI1LFxuICBNRU1CRVJfTU9WRTogMjYsXG4gIE1FTUJFUl9ESVNDT05ORUNUOiAyNyxcbiAgQk9UX0FERDogMjgsXG4gIFJPTEVfQ1JFQVRFOiAzMCxcbiAgUk9MRV9VUERBVEU6IDMxLFxuICBST0xFX0RFTEVURTogMzIsXG4gIElOVklURV9DUkVBVEU6IDQwLFxuICBJTlZJVEVfVVBEQVRFOiA0MSxcbiAgSU5WSVRFX0RFTEVURTogNDIsXG4gIFdFQkhPT0tfQ1JFQVRFOiA1MCxcbiAgV0VCSE9PS19VUERBVEU6IDUxLFxuICBXRUJIT09LX0RFTEVURTogNTIsXG4gIEVNT0pJX0NSRUFURTogNjAsXG4gIEVNT0pJX1VQREFURTogNjEsXG4gIEVNT0pJX0RFTEVURTogNjIsXG4gIE1FU1NBR0VfREVMRVRFOiA3MixcbiAgTUVTU0FHRV9CVUxLX0RFTEVURTogNzMsXG4gIE1FU1NBR0VfUElOOiA3NCxcbiAgTUVTU0FHRV9VTlBJTjogNzUsXG4gIElOVEVHUkFUSU9OX0NSRUFURTogODAsXG4gIElOVEVHUkFUSU9OX1VQREFURTogODEsXG4gIElOVEVHUkFUSU9OX0RFTEVURTogODIsXG59O1xuXG4vKipcbiAqIEF1ZGl0IGxvZ3MgZW50cmllcyBhcmUgaGVsZCBpbiB0aGlzIGNsYXNzLlxuICovXG5jbGFzcyBHdWlsZEF1ZGl0TG9ncyB7XG4gIGNvbnN0cnVjdG9yKGd1aWxkLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEudXNlcnMpIGZvciAoY29uc3QgdXNlciBvZiBkYXRhLnVzZXJzKSBndWlsZC5jbGllbnQudXNlcnMuYWRkKHVzZXIpO1xuICAgIC8qKlxuICAgICAqIENhY2hlZCB3ZWJob29rc1xuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgV2ViaG9vaz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndlYmhvb2tzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICBpZiAoZGF0YS53ZWJob29rcykge1xuICAgICAgZm9yIChjb25zdCBob29rIG9mIGRhdGEud2ViaG9va3MpIHtcbiAgICAgICAgdGhpcy53ZWJob29rcy5zZXQoaG9vay5pZCwgbmV3IFdlYmhvb2soZ3VpbGQuY2xpZW50LCBob29rKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGludGVncmF0aW9uc1xuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgSW50ZWdyYXRpb24+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnRlZ3JhdGlvbnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIGlmIChkYXRhLmludGVncmF0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBpbnRlZ3JhdGlvbiBvZiBkYXRhLmludGVncmF0aW9ucykge1xuICAgICAgICB0aGlzLmludGVncmF0aW9ucy5zZXQoaW50ZWdyYXRpb24uaWQsIG5ldyBJbnRlZ3JhdGlvbihndWlsZC5jbGllbnQsIGludGVncmF0aW9uLCBndWlsZCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBlbnRyaWVzIGZvciB0aGlzIGd1aWxkJ3MgYXVkaXQgbG9nc1xuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRBdWRpdExvZ3NFbnRyeT59XG4gICAgICovXG4gICAgdGhpcy5lbnRyaWVzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YS5hdWRpdF9sb2dfZW50cmllcykge1xuICAgICAgY29uc3QgZW50cnkgPSBuZXcgR3VpbGRBdWRpdExvZ3NFbnRyeSh0aGlzLCBndWlsZCwgaXRlbSk7XG4gICAgICB0aGlzLmVudHJpZXMuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgcG9zc2libGUgcHJvbWlzZXMgZm9yIGVudHJ5IHRhcmdldHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkQXVkaXRMb2dzPn1cbiAgICovXG4gIHN0YXRpYyBidWlsZCguLi5hcmdzKSB7XG4gICAgY29uc3QgbG9ncyA9IG5ldyBHdWlsZEF1ZGl0TG9ncyguLi5hcmdzKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9ncy5lbnRyaWVzLm1hcChlID0+IGUudGFyZ2V0KSkudGhlbigoKSA9PiBsb2dzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IG9mIGFuIGVudHJ5LiBJdCBjYW4gYmUgb25lIG9mOlxuICAgKiAqIEEgZ3VpbGRcbiAgICogKiBBIHVzZXJcbiAgICogKiBBIHJvbGVcbiAgICogKiBBbiBlbW9qaVxuICAgKiAqIEFuIGludml0ZVxuICAgKiAqIEEgd2ViaG9va1xuICAgKiAqIEFuIGludGVncmF0aW9uXG4gICAqICogQW4gb2JqZWN0IHdpdGggYW4gaWQga2V5IGlmIHRhcmdldCB3YXMgZGVsZXRlZFxuICAgKiAqIEFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyByZXByZXNlbnQgZWl0aGVyIHRoZSBuZXcgdmFsdWUgb3IgdGhlIG9sZCB2YWx1ZVxuICAgKiBAdHlwZWRlZiB7P09iamVjdHxHdWlsZHxVc2VyfFJvbGV8R3VpbGRFbW9qaXxJbnZpdGV8V2ViaG9va3xJbnRlZ3JhdGlvbn0gQXVkaXRMb2dFbnRyeVRhcmdldFxuICAgKi9cblxuICAvKipcbiAgICogRmluZHMgdGhlIHRhcmdldCB0eXBlIGZyb20gdGhlIGVudHJ5IGFjdGlvbi5cbiAgICogQHBhcmFtIHtBdWRpdExvZ0FjdGlvbn0gdGFyZ2V0IFRoZSBhY3Rpb24gdGFyZ2V0XG4gICAqIEByZXR1cm5zIHtBdWRpdExvZ1RhcmdldFR5cGV9XG4gICAqL1xuICBzdGF0aWMgdGFyZ2V0VHlwZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0IDwgMTApIHJldHVybiBUYXJnZXRzLkdVSUxEO1xuICAgIGlmICh0YXJnZXQgPCAyMCkgcmV0dXJuIFRhcmdldHMuQ0hBTk5FTDtcbiAgICBpZiAodGFyZ2V0IDwgMzApIHJldHVybiBUYXJnZXRzLlVTRVI7XG4gICAgaWYgKHRhcmdldCA8IDQwKSByZXR1cm4gVGFyZ2V0cy5ST0xFO1xuICAgIGlmICh0YXJnZXQgPCA1MCkgcmV0dXJuIFRhcmdldHMuSU5WSVRFO1xuICAgIGlmICh0YXJnZXQgPCA2MCkgcmV0dXJuIFRhcmdldHMuV0VCSE9PSztcbiAgICBpZiAodGFyZ2V0IDwgNzApIHJldHVybiBUYXJnZXRzLkVNT0pJO1xuICAgIGlmICh0YXJnZXQgPCA4MCkgcmV0dXJuIFRhcmdldHMuTUVTU0FHRTtcbiAgICBpZiAodGFyZ2V0IDwgOTApIHJldHVybiBUYXJnZXRzLklOVEVHUkFUSU9OO1xuICAgIHJldHVybiBUYXJnZXRzLlVOS05PV047XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFjdGlvbiB0eXBlIG9mIGFuIGVudHJ5LCBlLmcuIGBDUkVBVEVgLiBIZXJlIGFyZSB0aGUgYXZhaWxhYmxlIHR5cGVzOlxuICAgKiAqIENSRUFURVxuICAgKiAqIERFTEVURVxuICAgKiAqIFVQREFURVxuICAgKiAqIEFMTFxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBBdWRpdExvZ0FjdGlvblR5cGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBhY3Rpb24gdHlwZSBmcm9tIHRoZSBlbnRyeSBhY3Rpb24uXG4gICAqIEBwYXJhbSB7QXVkaXRMb2dBY3Rpb259IGFjdGlvbiBUaGUgYWN0aW9uIHRhcmdldFxuICAgKiBAcmV0dXJucyB7QXVkaXRMb2dBY3Rpb25UeXBlfVxuICAgKi9cbiAgc3RhdGljIGFjdGlvblR5cGUoYWN0aW9uKSB7XG4gICAgaWYgKFxuICAgICAgW1xuICAgICAgICBBY3Rpb25zLkNIQU5ORUxfQ1JFQVRFLFxuICAgICAgICBBY3Rpb25zLkNIQU5ORUxfT1ZFUldSSVRFX0NSRUFURSxcbiAgICAgICAgQWN0aW9ucy5NRU1CRVJfQkFOX1JFTU9WRSxcbiAgICAgICAgQWN0aW9ucy5CT1RfQURELFxuICAgICAgICBBY3Rpb25zLlJPTEVfQ1JFQVRFLFxuICAgICAgICBBY3Rpb25zLklOVklURV9DUkVBVEUsXG4gICAgICAgIEFjdGlvbnMuV0VCSE9PS19DUkVBVEUsXG4gICAgICAgIEFjdGlvbnMuRU1PSklfQ1JFQVRFLFxuICAgICAgICBBY3Rpb25zLk1FU1NBR0VfUElOLFxuICAgICAgICBBY3Rpb25zLklOVEVHUkFUSU9OX0NSRUFURSxcbiAgICAgIF0uaW5jbHVkZXMoYWN0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuICdDUkVBVEUnO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIFtcbiAgICAgICAgQWN0aW9ucy5DSEFOTkVMX0RFTEVURSxcbiAgICAgICAgQWN0aW9ucy5DSEFOTkVMX09WRVJXUklURV9ERUxFVEUsXG4gICAgICAgIEFjdGlvbnMuTUVNQkVSX0tJQ0ssXG4gICAgICAgIEFjdGlvbnMuTUVNQkVSX1BSVU5FLFxuICAgICAgICBBY3Rpb25zLk1FTUJFUl9CQU5fQURELFxuICAgICAgICBBY3Rpb25zLk1FTUJFUl9ESVNDT05ORUNULFxuICAgICAgICBBY3Rpb25zLlJPTEVfREVMRVRFLFxuICAgICAgICBBY3Rpb25zLklOVklURV9ERUxFVEUsXG4gICAgICAgIEFjdGlvbnMuV0VCSE9PS19ERUxFVEUsXG4gICAgICAgIEFjdGlvbnMuRU1PSklfREVMRVRFLFxuICAgICAgICBBY3Rpb25zLk1FU1NBR0VfREVMRVRFLFxuICAgICAgICBBY3Rpb25zLk1FU1NBR0VfQlVMS19ERUxFVEUsXG4gICAgICAgIEFjdGlvbnMuTUVTU0FHRV9VTlBJTixcbiAgICAgICAgQWN0aW9ucy5JTlRFR1JBVElPTl9ERUxFVEUsXG4gICAgICBdLmluY2x1ZGVzKGFjdGlvbilcbiAgICApIHtcbiAgICAgIHJldHVybiAnREVMRVRFJztcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBbXG4gICAgICAgIEFjdGlvbnMuR1VJTERfVVBEQVRFLFxuICAgICAgICBBY3Rpb25zLkNIQU5ORUxfVVBEQVRFLFxuICAgICAgICBBY3Rpb25zLkNIQU5ORUxfT1ZFUldSSVRFX1VQREFURSxcbiAgICAgICAgQWN0aW9ucy5NRU1CRVJfVVBEQVRFLFxuICAgICAgICBBY3Rpb25zLk1FTUJFUl9ST0xFX1VQREFURSxcbiAgICAgICAgQWN0aW9ucy5NRU1CRVJfTU9WRSxcbiAgICAgICAgQWN0aW9ucy5ST0xFX1VQREFURSxcbiAgICAgICAgQWN0aW9ucy5JTlZJVEVfVVBEQVRFLFxuICAgICAgICBBY3Rpb25zLldFQkhPT0tfVVBEQVRFLFxuICAgICAgICBBY3Rpb25zLkVNT0pJX1VQREFURSxcbiAgICAgICAgQWN0aW9ucy5JTlRFR1JBVElPTl9VUERBVEUsXG4gICAgICBdLmluY2x1ZGVzKGFjdGlvbilcbiAgICApIHtcbiAgICAgIHJldHVybiAnVVBEQVRFJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ0FMTCc7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIFV0aWwuZmxhdHRlbih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEF1ZGl0IGxvZ3MgZW50cnkuXG4gKi9cbmNsYXNzIEd1aWxkQXVkaXRMb2dzRW50cnkge1xuICBjb25zdHJ1Y3Rvcihsb2dzLCBndWlsZCwgZGF0YSkge1xuICAgIGNvbnN0IHRhcmdldFR5cGUgPSBHdWlsZEF1ZGl0TG9ncy50YXJnZXRUeXBlKGRhdGEuYWN0aW9uX3R5cGUpO1xuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgdHlwZSBvZiB0aGlzIGVudHJ5XG4gICAgICogQHR5cGUge0F1ZGl0TG9nVGFyZ2V0VHlwZX1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFR5cGUgPSB0YXJnZXRUeXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFjdGlvbiB0eXBlIG9mIHRoaXMgZW50cnlcbiAgICAgKiBAdHlwZSB7QXVkaXRMb2dBY3Rpb25UeXBlfVxuICAgICAqL1xuICAgIHRoaXMuYWN0aW9uVHlwZSA9IEd1aWxkQXVkaXRMb2dzLmFjdGlvblR5cGUoZGF0YS5hY3Rpb25fdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpYyBhY3Rpb24gdHlwZSBvZiB0aGlzIGVudHJ5IGluIGl0cyBzdHJpbmcgcHJlc2VudGF0aW9uXG4gICAgICogQHR5cGUge0F1ZGl0TG9nQWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYWN0aW9uID0gT2JqZWN0LmtleXMoQWN0aW9ucykuZmluZChrID0+IEFjdGlvbnNba10gPT09IGRhdGEuYWN0aW9uX3R5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiBvZiB0aGlzIGVudHJ5XG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZWFzb24gPSBkYXRhLnJlYXNvbiB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVzZXIgdGhhdCBleGVjdXRlZCB0aGlzIGVudHJ5XG4gICAgICogQHR5cGUge1VzZXJ9XG4gICAgICovXG4gICAgdGhpcy5leGVjdXRvciA9IGd1aWxkLmNsaWVudC5vcHRpb25zLnBhcnRpYWxzLmluY2x1ZGVzKFBhcnRpYWxUeXBlcy5VU0VSKVxuICAgICAgPyBndWlsZC5jbGllbnQudXNlcnMuYWRkKHsgaWQ6IGRhdGEudXNlcl9pZCB9KVxuICAgICAgOiBndWlsZC5jbGllbnQudXNlcnMuY2FjaGUuZ2V0KGRhdGEudXNlcl9pZCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBlbnRyeSBpbiB0aGUgYXVkaXQgbG9nIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGNoYW5nZS5cbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBBdWRpdExvZ0NoYW5nZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXkgVGhlIHByb3BlcnR5IHRoYXQgd2FzIGNoYW5nZWQsIGUuZy4gYG5pY2tgIGZvciBuaWNrbmFtZSBjaGFuZ2VzXG4gICAgICogQHByb3BlcnR5IHsqfSBbb2xkXSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBjaGFuZ2UsIGUuZy4gZm9yIG5pY2tuYW1lcywgdGhlIG9sZCBuaWNrbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7Kn0gW25ld10gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2hhbmdlLCBlLmcuIGZvciBuaWNrbmFtZXMsIHRoZSBuZXcgbmlja25hbWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmljIHByb3BlcnR5IGNoYW5nZXNcbiAgICAgKiBAdHlwZSB7QXVkaXRMb2dDaGFuZ2VbXX1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZXMgPSBkYXRhLmNoYW5nZXMgPyBkYXRhLmNoYW5nZXMubWFwKGMgPT4gKHsga2V5OiBjLmtleSwgb2xkOiBjLm9sZF92YWx1ZSwgbmV3OiBjLm5ld192YWx1ZSB9KSkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoaXMgZW50cnlcbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuXG4gICAgLyoqXG4gICAgICogQW55IGV4dHJhIGRhdGEgZnJvbSB0aGUgZW50cnlcbiAgICAgKiBAdHlwZSB7P09iamVjdHxSb2xlfEd1aWxkTWVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXh0cmEgPSBudWxsO1xuICAgIHN3aXRjaCAoZGF0YS5hY3Rpb25fdHlwZSkge1xuICAgICAgY2FzZSBBY3Rpb25zLk1FTUJFUl9QUlVORTpcbiAgICAgICAgdGhpcy5leHRyYSA9IHtcbiAgICAgICAgICByZW1vdmVkOiBOdW1iZXIoZGF0YS5vcHRpb25zLm1lbWJlcnNfcmVtb3ZlZCksXG4gICAgICAgICAgZGF5czogTnVtYmVyKGRhdGEub3B0aW9ucy5kZWxldGVfbWVtYmVyX2RheXMpLFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBY3Rpb25zLk1FTUJFUl9NT1ZFOlxuICAgICAgY2FzZSBBY3Rpb25zLk1FU1NBR0VfREVMRVRFOlxuICAgICAgY2FzZSBBY3Rpb25zLk1FU1NBR0VfQlVMS19ERUxFVEU6XG4gICAgICAgIHRoaXMuZXh0cmEgPSB7XG4gICAgICAgICAgY2hhbm5lbDogZ3VpbGQuY2hhbm5lbHMuY2FjaGUuZ2V0KGRhdGEub3B0aW9ucy5jaGFubmVsX2lkKSB8fCB7IGlkOiBkYXRhLm9wdGlvbnMuY2hhbm5lbF9pZCB9LFxuICAgICAgICAgIGNvdW50OiBOdW1iZXIoZGF0YS5vcHRpb25zLmNvdW50KSxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQWN0aW9ucy5NRVNTQUdFX1BJTjpcbiAgICAgIGNhc2UgQWN0aW9ucy5NRVNTQUdFX1VOUElOOlxuICAgICAgICB0aGlzLmV4dHJhID0ge1xuICAgICAgICAgIGNoYW5uZWw6IGd1aWxkLmNsaWVudC5jaGFubmVscy5jYWNoZS5nZXQoZGF0YS5vcHRpb25zLmNoYW5uZWxfaWQpIHx8IHsgaWQ6IGRhdGEub3B0aW9ucy5jaGFubmVsX2lkIH0sXG4gICAgICAgICAgbWVzc2FnZUlEOiBkYXRhLm9wdGlvbnMubWVzc2FnZV9pZCxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQWN0aW9ucy5NRU1CRVJfRElTQ09OTkVDVDpcbiAgICAgICAgdGhpcy5leHRyYSA9IHtcbiAgICAgICAgICBjb3VudDogTnVtYmVyKGRhdGEub3B0aW9ucy5jb3VudCksXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEFjdGlvbnMuQ0hBTk5FTF9PVkVSV1JJVEVfQ1JFQVRFOlxuICAgICAgY2FzZSBBY3Rpb25zLkNIQU5ORUxfT1ZFUldSSVRFX1VQREFURTpcbiAgICAgIGNhc2UgQWN0aW9ucy5DSEFOTkVMX09WRVJXUklURV9ERUxFVEU6XG4gICAgICAgIHN3aXRjaCAoZGF0YS5vcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdtZW1iZXInOlxuICAgICAgICAgICAgdGhpcy5leHRyYSA9IGd1aWxkLm1lbWJlcnMuY2FjaGUuZ2V0KGRhdGEub3B0aW9ucy5pZCkgfHwgeyBpZDogZGF0YS5vcHRpb25zLmlkLCB0eXBlOiAnbWVtYmVyJyB9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyb2xlJzpcbiAgICAgICAgICAgIHRoaXMuZXh0cmEgPSBndWlsZC5yb2xlcy5jYWNoZS5nZXQoZGF0YS5vcHRpb25zLmlkKSB8fCB7XG4gICAgICAgICAgICAgIGlkOiBkYXRhLm9wdGlvbnMuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IGRhdGEub3B0aW9ucy5yb2xlX25hbWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdyb2xlJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGVudHJ5XG4gICAgICogQHR5cGUgez9BdWRpdExvZ0VudHJ5VGFyZ2V0fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gVGFyZ2V0cy5VTktOT1dOKSB7XG4gICAgICB0aGlzLnRhcmdldCA9IHRoaXMuY2hhbmdlcy5yZWR1Y2UoKG8sIGMpID0+IHtcbiAgICAgICAgb1tjLmtleV0gPSBjLm5ldyB8fCBjLm9sZDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9LCB7fSk7XG4gICAgICB0aGlzLnRhcmdldC5pZCA9IGRhdGEudGFyZ2V0X2lkO1xuICAgICAgLy8gTUVNQkVSX0RJU0NPTk5FQ1QgYW5kIHNpbWlsYXIgdHlwZXMgZG8gbm90IHByb3ZpZGUgYSB0YXJnZXRfaWQuXG4gICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSBUYXJnZXRzLlVTRVIgJiYgZGF0YS50YXJnZXRfaWQpIHtcbiAgICAgIHRoaXMudGFyZ2V0ID0gZ3VpbGQuY2xpZW50Lm9wdGlvbnMucGFydGlhbHMuaW5jbHVkZXMoUGFydGlhbFR5cGVzLlVTRVIpXG4gICAgICAgID8gZ3VpbGQuY2xpZW50LnVzZXJzLmFkZCh7IGlkOiBkYXRhLnRhcmdldF9pZCB9KVxuICAgICAgICA6IGd1aWxkLmNsaWVudC51c2Vycy5jYWNoZS5nZXQoZGF0YS50YXJnZXRfaWQpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gVGFyZ2V0cy5HVUlMRCkge1xuICAgICAgdGhpcy50YXJnZXQgPSBndWlsZC5jbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLnRhcmdldF9pZCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSBUYXJnZXRzLldFQkhPT0spIHtcbiAgICAgIHRoaXMudGFyZ2V0ID1cbiAgICAgICAgbG9ncy53ZWJob29rcy5nZXQoZGF0YS50YXJnZXRfaWQpIHx8XG4gICAgICAgIG5ldyBXZWJob29rKFxuICAgICAgICAgIGd1aWxkLmNsaWVudCxcbiAgICAgICAgICB0aGlzLmNoYW5nZXMucmVkdWNlKFxuICAgICAgICAgICAgKG8sIGMpID0+IHtcbiAgICAgICAgICAgICAgb1tjLmtleV0gPSBjLm5ldyB8fCBjLm9sZDtcbiAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogZGF0YS50YXJnZXRfaWQsXG4gICAgICAgICAgICAgIGd1aWxkX2lkOiBndWlsZC5pZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09IFRhcmdldHMuSU5WSVRFKSB7XG4gICAgICB0aGlzLnRhcmdldCA9IGd1aWxkLm1lbWJlcnMuZmV0Y2goZ3VpbGQuY2xpZW50LnVzZXIuaWQpLnRoZW4obWUgPT4ge1xuICAgICAgICBpZiAobWUucGVybWlzc2lvbnMuaGFzKCdNQU5BR0VfR1VJTEQnKSkge1xuICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuY2hhbmdlcy5maW5kKGMgPT4gYy5rZXkgPT09ICdjb2RlJyk7XG4gICAgICAgICAgcmV0dXJuIGd1aWxkLmZldGNoSW52aXRlcygpLnRoZW4oaW52aXRlcyA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IGludml0ZXMuZmluZChpID0+IGkuY29kZSA9PT0gKGNoYW5nZS5uZXcgfHwgY2hhbmdlLm9sZCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5jaGFuZ2VzLnJlZHVjZSgobywgYykgPT4ge1xuICAgICAgICAgICAgb1tjLmtleV0gPSBjLm5ldyB8fCBjLm9sZDtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gVGFyZ2V0cy5NRVNTQUdFKSB7XG4gICAgICAvLyBEaXNjb3JkIHNlbmRzIGEgY2hhbm5lbCBpZCBmb3IgdGhlIE1FU1NBR0VfQlVMS19ERUxFVEUgYWN0aW9uIHR5cGUuXG4gICAgICB0aGlzLnRhcmdldCA9XG4gICAgICAgIGRhdGEuYWN0aW9uX3R5cGUgPT09IEFjdGlvbnMuTUVTU0FHRV9CVUxLX0RFTEVURVxuICAgICAgICAgID8gZ3VpbGQuY2hhbm5lbHMuY2FjaGUuZ2V0KGRhdGEudGFyZ2V0X2lkKSB8fCB7IGlkOiBkYXRhLnRhcmdldF9pZCB9XG4gICAgICAgICAgOiBndWlsZC5jbGllbnQudXNlcnMuY2FjaGUuZ2V0KGRhdGEudGFyZ2V0X2lkKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09IFRhcmdldHMuSU5URUdSQVRJT04pIHtcbiAgICAgIHRoaXMudGFyZ2V0ID1cbiAgICAgICAgbG9ncy5pbnRlZ3JhdGlvbnMuZ2V0KGRhdGEudGFyZ2V0X2lkKSB8fFxuICAgICAgICBuZXcgSW50ZWdyYXRpb24oXG4gICAgICAgICAgZ3VpbGQuY2xpZW50LFxuICAgICAgICAgIHRoaXMuY2hhbmdlcy5yZWR1Y2UoXG4gICAgICAgICAgICAobywgYykgPT4ge1xuICAgICAgICAgICAgICBvW2Mua2V5XSA9IGMubmV3IHx8IGMub2xkO1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IGlkOiBkYXRhLnRhcmdldF9pZCB9LFxuICAgICAgICAgICksXG4gICAgICAgICAgZ3VpbGQsXG4gICAgICAgICk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnRhcmdldF9pZCkge1xuICAgICAgdGhpcy50YXJnZXQgPSBndWlsZFtgJHt0YXJnZXRUeXBlLnRvTG93ZXJDYXNlKCl9c2BdLmNhY2hlLmdldChkYXRhLnRhcmdldF9pZCkgfHwgeyBpZDogZGF0YS50YXJnZXRfaWQgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCB0aGlzIGVudHJ5IHdhcyBjcmVhdGVkIGF0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNyZWF0ZWRUaW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIFNub3dmbGFrZS5kZWNvbnN0cnVjdCh0aGlzLmlkKS50aW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhpcyBlbnRyeSB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZEF0KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmNyZWF0ZWRUaW1lc3RhbXApO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBVdGlsLmZsYXR0ZW4odGhpcywgeyBjcmVhdGVkVGltZXN0YW1wOiB0cnVlIH0pO1xuICB9XG59XG5cbkd1aWxkQXVkaXRMb2dzLkFjdGlvbnMgPSBBY3Rpb25zO1xuR3VpbGRBdWRpdExvZ3MuVGFyZ2V0cyA9IFRhcmdldHM7XG5HdWlsZEF1ZGl0TG9ncy5FbnRyeSA9IEd1aWxkQXVkaXRMb2dzRW50cnk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpbGRBdWRpdExvZ3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENoYW5uZWwgPSByZXF1aXJlKCcuL0NoYW5uZWwnKTtcbmNvbnN0IEludml0ZSA9IHJlcXVpcmUoJy4vSW52aXRlJyk7XG5jb25zdCBQZXJtaXNzaW9uT3ZlcndyaXRlcyA9IHJlcXVpcmUoJy4vUGVybWlzc2lvbk92ZXJ3cml0ZXMnKTtcbmNvbnN0IFJvbGUgPSByZXF1aXJlKCcuL1JvbGUnKTtcbmNvbnN0IHsgRXJyb3IsIFR5cGVFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9Db2xsZWN0aW9uJyk7XG5jb25zdCBQZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvUGVybWlzc2lvbnMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZ3VpbGQgY2hhbm5lbCBmcm9tIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICogLSB7QGxpbmsgVGV4dENoYW5uZWx9XG4gKiAtIHtAbGluayBWb2ljZUNoYW5uZWx9XG4gKiAtIHtAbGluayBDYXRlZ29yeUNoYW5uZWx9XG4gKiAtIHtAbGluayBOZXdzQ2hhbm5lbH1cbiAqIC0ge0BsaW5rIFN0b3JlQ2hhbm5lbH1cbiAqIEBleHRlbmRzIHtDaGFubmVsfVxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEd1aWxkQ2hhbm5lbCBleHRlbmRzIENoYW5uZWwge1xuICAvKipcbiAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoZSBndWlsZCBjaGFubmVsIGlzIHBhcnQgb2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSBndWlsZCBjaGFubmVsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihndWlsZCwgZGF0YSkge1xuICAgIHN1cGVyKGd1aWxkLmNsaWVudCwgZGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3VpbGQgdGhlIGNoYW5uZWwgaXMgaW5cbiAgICAgKiBAdHlwZSB7R3VpbGR9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZCA9IGd1aWxkO1xuICB9XG5cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICBzdXBlci5fcGF0Y2goZGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZ3VpbGQgY2hhbm5lbFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhdyBwb3NpdGlvbiBvZiB0aGUgY2hhbm5lbCBmcm9tIGRpc2NvcmRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmF3UG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBjYXRlZ29yeSBwYXJlbnQgb2YgdGhpcyBjaGFubmVsXG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRJRCA9IGRhdGEucGFyZW50X2lkIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBwZXJtaXNzaW9uIG92ZXJ3cml0ZXMgaW4gdGhpcyBjaGFubmVsIGZvciByb2xlcyBhbmQgdXNlcnNcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIFBlcm1pc3Npb25PdmVyd3JpdGVzPn1cbiAgICAgKi9cbiAgICB0aGlzLnBlcm1pc3Npb25PdmVyd3JpdGVzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICBpZiAoZGF0YS5wZXJtaXNzaW9uX292ZXJ3cml0ZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgb3ZlcndyaXRlIG9mIGRhdGEucGVybWlzc2lvbl9vdmVyd3JpdGVzKSB7XG4gICAgICAgIHRoaXMucGVybWlzc2lvbk92ZXJ3cml0ZXMuc2V0KG92ZXJ3cml0ZS5pZCwgbmV3IFBlcm1pc3Npb25PdmVyd3JpdGVzKHRoaXMsIG92ZXJ3cml0ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2F0ZWdvcnkgcGFyZW50IG9mIHRoaXMgY2hhbm5lbFxuICAgKiBAdHlwZSB7P0NhdGVnb3J5Q2hhbm5lbH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmd1aWxkLmNoYW5uZWxzLmNhY2hlLmdldCh0aGlzLnBhcmVudElEKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBwZXJtaXNzaW9uT3ZlcndyaXRlcyBtYXRjaCB0aGUgcGFyZW50IGNoYW5uZWwsIG51bGwgaWYgbm8gcGFyZW50XG4gICAqIEB0eXBlIHs/Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGVybWlzc2lvbnNMb2NrZWQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHRoaXMucGVybWlzc2lvbk92ZXJ3cml0ZXMuc2l6ZSAhPT0gdGhpcy5wYXJlbnQucGVybWlzc2lvbk92ZXJ3cml0ZXMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25PdmVyd3JpdGVzLmV2ZXJ5KCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjb25zdCB0ZXN0VmFsID0gdGhpcy5wYXJlbnQucGVybWlzc2lvbk92ZXJ3cml0ZXMuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0ZXN0VmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdGVzdFZhbC5kZW55LmJpdGZpZWxkID09PSB2YWx1ZS5kZW55LmJpdGZpZWxkICYmXG4gICAgICAgIHRlc3RWYWwuYWxsb3cuYml0ZmllbGQgPT09IHZhbHVlLmFsbG93LmJpdGZpZWxkXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2hhbm5lbFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICBjb25zdCBzb3J0ZWQgPSB0aGlzLmd1aWxkLl9zb3J0ZWRDaGFubmVscyh0aGlzKTtcbiAgICByZXR1cm4gc29ydGVkLmFycmF5KCkuaW5kZXhPZihzb3J0ZWQuZ2V0KHRoaXMuaWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvdmVyYWxsIHNldCBvZiBwZXJtaXNzaW9ucyBmb3IgYSBtZW1iZXIgb3Igcm9sZSBpbiB0aGlzIGNoYW5uZWwsIHRha2luZyBpbnRvIGFjY291bnQgY2hhbm5lbCBvdmVyd3JpdGVzLlxuICAgKiBAcGFyYW0ge0d1aWxkTWVtYmVyUmVzb2x2YWJsZXxSb2xlUmVzb2x2YWJsZX0gbWVtYmVyT3JSb2xlIFRoZSBtZW1iZXIgb3Igcm9sZSB0byBvYnRhaW4gdGhlIG92ZXJhbGwgcGVybWlzc2lvbnMgZm9yXG4gICAqIEByZXR1cm5zIHs/UmVhZG9ubHk8UGVybWlzc2lvbnM+fVxuICAgKi9cbiAgcGVybWlzc2lvbnNGb3IobWVtYmVyT3JSb2xlKSB7XG4gICAgY29uc3QgbWVtYmVyID0gdGhpcy5ndWlsZC5tZW1iZXJzLnJlc29sdmUobWVtYmVyT3JSb2xlKTtcbiAgICBpZiAobWVtYmVyKSByZXR1cm4gdGhpcy5tZW1iZXJQZXJtaXNzaW9ucyhtZW1iZXIpO1xuICAgIGNvbnN0IHJvbGUgPSB0aGlzLmd1aWxkLnJvbGVzLnJlc29sdmUobWVtYmVyT3JSb2xlKTtcbiAgICBpZiAocm9sZSkgcmV0dXJuIHRoaXMucm9sZVBlcm1pc3Npb25zKHJvbGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgb3ZlcndyaXRlc0ZvcihtZW1iZXIsIHZlcmlmaWVkID0gZmFsc2UsIHJvbGVzID0gbnVsbCkge1xuICAgIGlmICghdmVyaWZpZWQpIG1lbWJlciA9IHRoaXMuZ3VpbGQubWVtYmVycy5yZXNvbHZlKG1lbWJlcik7XG4gICAgaWYgKCFtZW1iZXIpIHJldHVybiBbXTtcblxuICAgIHJvbGVzID0gcm9sZXMgfHwgbWVtYmVyLnJvbGVzLmNhY2hlO1xuICAgIGNvbnN0IHJvbGVPdmVyd3JpdGVzID0gW107XG4gICAgbGV0IG1lbWJlck92ZXJ3cml0ZXM7XG4gICAgbGV0IGV2ZXJ5b25lT3ZlcndyaXRlcztcblxuICAgIGZvciAoY29uc3Qgb3ZlcndyaXRlIG9mIHRoaXMucGVybWlzc2lvbk92ZXJ3cml0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChvdmVyd3JpdGUuaWQgPT09IHRoaXMuZ3VpbGQuaWQpIHtcbiAgICAgICAgZXZlcnlvbmVPdmVyd3JpdGVzID0gb3ZlcndyaXRlO1xuICAgICAgfSBlbHNlIGlmIChyb2xlcy5oYXMob3ZlcndyaXRlLmlkKSkge1xuICAgICAgICByb2xlT3ZlcndyaXRlcy5wdXNoKG92ZXJ3cml0ZSk7XG4gICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZS5pZCA9PT0gbWVtYmVyLmlkKSB7XG4gICAgICAgIG1lbWJlck92ZXJ3cml0ZXMgPSBvdmVyd3JpdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZXJ5b25lOiBldmVyeW9uZU92ZXJ3cml0ZXMsXG4gICAgICByb2xlczogcm9sZU92ZXJ3cml0ZXMsXG4gICAgICBtZW1iZXI6IG1lbWJlck92ZXJ3cml0ZXMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvdmVyYWxsIHNldCBvZiBwZXJtaXNzaW9ucyBmb3IgYSBtZW1iZXIgaW4gdGhpcyBjaGFubmVsLCB0YWtpbmcgaW50byBhY2NvdW50IGNoYW5uZWwgb3ZlcndyaXRlcy5cbiAgICogQHBhcmFtIHtHdWlsZE1lbWJlcn0gbWVtYmVyIFRoZSBtZW1iZXIgdG8gb2J0YWluIHRoZSBvdmVyYWxsIHBlcm1pc3Npb25zIGZvclxuICAgKiBAcmV0dXJucyB7UmVhZG9ubHk8UGVybWlzc2lvbnM+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWVtYmVyUGVybWlzc2lvbnMobWVtYmVyKSB7XG4gICAgaWYgKG1lbWJlci5pZCA9PT0gdGhpcy5ndWlsZC5vd25lcklEKSByZXR1cm4gbmV3IFBlcm1pc3Npb25zKFBlcm1pc3Npb25zLkFMTCkuZnJlZXplKCk7XG5cbiAgICBjb25zdCByb2xlcyA9IG1lbWJlci5yb2xlcy5jYWNoZTtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IG5ldyBQZXJtaXNzaW9ucyhyb2xlcy5tYXAocm9sZSA9PiByb2xlLnBlcm1pc3Npb25zKSk7XG5cbiAgICBpZiAocGVybWlzc2lvbnMuaGFzKFBlcm1pc3Npb25zLkZMQUdTLkFETUlOSVNUUkFUT1IpKSByZXR1cm4gbmV3IFBlcm1pc3Npb25zKFBlcm1pc3Npb25zLkFMTCkuZnJlZXplKCk7XG5cbiAgICBjb25zdCBvdmVyd3JpdGVzID0gdGhpcy5vdmVyd3JpdGVzRm9yKG1lbWJlciwgdHJ1ZSwgcm9sZXMpO1xuXG4gICAgcmV0dXJuIHBlcm1pc3Npb25zXG4gICAgICAucmVtb3ZlKG92ZXJ3cml0ZXMuZXZlcnlvbmUgPyBvdmVyd3JpdGVzLmV2ZXJ5b25lLmRlbnkgOiAwKVxuICAgICAgLmFkZChvdmVyd3JpdGVzLmV2ZXJ5b25lID8gb3ZlcndyaXRlcy5ldmVyeW9uZS5hbGxvdyA6IDApXG4gICAgICAucmVtb3ZlKG92ZXJ3cml0ZXMucm9sZXMubGVuZ3RoID4gMCA/IG92ZXJ3cml0ZXMucm9sZXMubWFwKHJvbGUgPT4gcm9sZS5kZW55KSA6IDApXG4gICAgICAuYWRkKG92ZXJ3cml0ZXMucm9sZXMubGVuZ3RoID4gMCA/IG92ZXJ3cml0ZXMucm9sZXMubWFwKHJvbGUgPT4gcm9sZS5hbGxvdykgOiAwKVxuICAgICAgLnJlbW92ZShvdmVyd3JpdGVzLm1lbWJlciA/IG92ZXJ3cml0ZXMubWVtYmVyLmRlbnkgOiAwKVxuICAgICAgLmFkZChvdmVyd3JpdGVzLm1lbWJlciA/IG92ZXJ3cml0ZXMubWVtYmVyLmFsbG93IDogMClcbiAgICAgIC5mcmVlemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvdmVyYWxsIHNldCBvZiBwZXJtaXNzaW9ucyBmb3IgYSByb2xlIGluIHRoaXMgY2hhbm5lbCwgdGFraW5nIGludG8gYWNjb3VudCBjaGFubmVsIG92ZXJ3cml0ZXMuXG4gICAqIEBwYXJhbSB7Um9sZX0gcm9sZSBUaGUgcm9sZSB0byBvYnRhaW4gdGhlIG92ZXJhbGwgcGVybWlzc2lvbnMgZm9yXG4gICAqIEByZXR1cm5zIHtSZWFkb25seTxQZXJtaXNzaW9ucz59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByb2xlUGVybWlzc2lvbnMocm9sZSkge1xuICAgIGlmIChyb2xlLnBlcm1pc3Npb25zLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5BRE1JTklTVFJBVE9SKSkgcmV0dXJuIG5ldyBQZXJtaXNzaW9ucyhQZXJtaXNzaW9ucy5BTEwpLmZyZWV6ZSgpO1xuXG4gICAgY29uc3QgZXZlcnlvbmVPdmVyd3JpdGVzID0gdGhpcy5wZXJtaXNzaW9uT3ZlcndyaXRlcy5nZXQodGhpcy5ndWlsZC5pZCk7XG4gICAgY29uc3Qgcm9sZU92ZXJ3cml0ZXMgPSB0aGlzLnBlcm1pc3Npb25PdmVyd3JpdGVzLmdldChyb2xlLmlkKTtcblxuICAgIHJldHVybiByb2xlLnBlcm1pc3Npb25zXG4gICAgICAucmVtb3ZlKGV2ZXJ5b25lT3ZlcndyaXRlcyA/IGV2ZXJ5b25lT3ZlcndyaXRlcy5kZW55IDogMClcbiAgICAgIC5hZGQoZXZlcnlvbmVPdmVyd3JpdGVzID8gZXZlcnlvbmVPdmVyd3JpdGVzLmFsbG93IDogMClcbiAgICAgIC5yZW1vdmUocm9sZU92ZXJ3cml0ZXMgPyByb2xlT3ZlcndyaXRlcy5kZW55IDogMClcbiAgICAgIC5hZGQocm9sZU92ZXJ3cml0ZXMgPyByb2xlT3ZlcndyaXRlcy5hbGxvdyA6IDApXG4gICAgICAuZnJlZXplKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHBlcm1pc3Npb24gb3ZlcndyaXRlcyBpbiB0aGlzIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7T3ZlcndyaXRlUmVzb2x2YWJsZVtdfENvbGxlY3Rpb248U25vd2ZsYWtlLCBPdmVyd3JpdGVSZXNvbHZhYmxlPn0gb3ZlcndyaXRlc1xuICAgKiBQZXJtaXNzaW9uIG92ZXJ3cml0ZXMgdGhlIGNoYW5uZWwgZ2V0cyB1cGRhdGVkIHdpdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgdXBkYXRpbmcgdGhlIGNoYW5uZWwgb3ZlcndyaXRlc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZENoYW5uZWw+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLm92ZXJ3cml0ZVBlcm1pc3Npb25zKFtcbiAgICogICB7XG4gICAqICAgICAgaWQ6IG1lc3NhZ2UuYXV0aG9yLmlkLFxuICAgKiAgICAgIGRlbnk6IFsnVklFV19DSEFOTkVMJ10sXG4gICAqICAgfSxcbiAgICogXSwgJ05lZWRlZCB0byBjaGFuZ2UgcGVybWlzc2lvbnMnKTtcbiAgICovXG4gIG92ZXJ3cml0ZVBlcm1pc3Npb25zKG92ZXJ3cml0ZXMsIHJlYXNvbikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvdmVyd3JpdGVzKSAmJiAhKG92ZXJ3cml0ZXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAnb3ZlcndyaXRlcycsICdBcnJheSBvciBDb2xsZWN0aW9uIG9mIFBlcm1pc3Npb24gT3ZlcndyaXRlcycsIHRydWUpLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IHBlcm1pc3Npb25PdmVyd3JpdGVzOiBvdmVyd3JpdGVzLCByZWFzb24gfSkudGhlbigoKSA9PiB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIE92ZXJ3cml0ZXMgZm9yIGEgdXNlciBvciByb2xlIGluIHRoaXMgY2hhbm5lbC4gKGNyZWF0ZXMgaWYgbm9uLWV4aXN0ZW50KVxuICAgKiBAcGFyYW0ge1JvbGVSZXNvbHZhYmxlfFVzZXJSZXNvbHZhYmxlfSB1c2VyT3JSb2xlIFRoZSB1c2VyIG9yIHJvbGUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7UGVybWlzc2lvbk92ZXJ3cml0ZU9wdGlvbnN9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSB1cGRhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY3JlYXRpbmcvZWRpdGluZyB0aGlzIG92ZXJ3cml0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZENoYW5uZWw+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVcGRhdGUgb3IgQ3JlYXRlIHBlcm1pc3Npb24gb3ZlcndyaXRlcyBmb3IgYSBtZXNzYWdlIGF1dGhvclxuICAgKiBtZXNzYWdlLmNoYW5uZWwudXBkYXRlT3ZlcndyaXRlKG1lc3NhZ2UuYXV0aG9yLCB7XG4gICAqICAgU0VORF9NRVNTQUdFUzogZmFsc2VcbiAgICogfSlcbiAgICogICAudGhlbihjaGFubmVsID0+IGNvbnNvbGUubG9nKGNoYW5uZWwucGVybWlzc2lvbk92ZXJ3cml0ZXMuZ2V0KG1lc3NhZ2UuYXV0aG9yLmlkKSkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgdXBkYXRlT3ZlcndyaXRlKHVzZXJPclJvbGUsIG9wdGlvbnMsIHJlYXNvbikge1xuICAgIHVzZXJPclJvbGUgPSB0aGlzLmd1aWxkLnJvbGVzLnJlc29sdmUodXNlck9yUm9sZSkgfHwgdGhpcy5jbGllbnQudXNlcnMucmVzb2x2ZSh1c2VyT3JSb2xlKTtcbiAgICBpZiAoIXVzZXJPclJvbGUpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAncGFyYW1ldGVyJywgJ1VzZXIgbm9yIGEgUm9sZScpKTtcblxuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5wZXJtaXNzaW9uT3ZlcndyaXRlcy5nZXQodXNlck9yUm9sZS5pZCk7XG4gICAgaWYgKGV4aXN0aW5nKSByZXR1cm4gZXhpc3RpbmcudXBkYXRlKG9wdGlvbnMsIHJlYXNvbikudGhlbigoKSA9PiB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVPdmVyd3JpdGUodXNlck9yUm9sZSwgb3B0aW9ucywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIHRoZSBwZXJtaXNzaW9ucyBmb3IgYSB1c2VyIG9yIHJvbGUgaW4gdGhpcyBjaGFubmVsLiAocmVwbGFjZXMgaWYgZXhpc3RlbnQpXG4gICAqIEBwYXJhbSB7Um9sZVJlc29sdmFibGV8VXNlclJlc29sdmFibGV9IHVzZXJPclJvbGUgVGhlIHVzZXIgb3Igcm9sZSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uT3ZlcndyaXRlT3B0aW9uc30gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjcmVhdGluZy9lZGl0aW5nIHRoaXMgb3ZlcndyaXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkQ2hhbm5lbD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBvciBSZXBsYWNlIHBlcm1pc3Npb25zIG92ZXJ3cml0ZXMgZm9yIGEgbWVzc2FnZSBhdXRob3JcbiAgICogbWVzc2FnZS5jaGFubmVsLmNyZWF0ZU92ZXJ3cml0ZShtZXNzYWdlLmF1dGhvciwge1xuICAgKiAgIFNFTkRfTUVTU0FHRVM6IGZhbHNlXG4gICAqIH0pXG4gICAqICAgLnRoZW4oY2hhbm5lbCA9PiBjb25zb2xlLmxvZyhjaGFubmVsLnBlcm1pc3Npb25PdmVyd3JpdGVzLmdldChtZXNzYWdlLmF1dGhvci5pZCkpKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGNyZWF0ZU92ZXJ3cml0ZSh1c2VyT3JSb2xlLCBvcHRpb25zLCByZWFzb24pIHtcbiAgICB1c2VyT3JSb2xlID0gdGhpcy5ndWlsZC5yb2xlcy5yZXNvbHZlKHVzZXJPclJvbGUpIHx8IHRoaXMuY2xpZW50LnVzZXJzLnJlc29sdmUodXNlck9yUm9sZSk7XG4gICAgaWYgKCF1c2VyT3JSb2xlKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignSU5WQUxJRF9UWVBFJywgJ3BhcmFtZXRlcicsICdVc2VyIG5vciBhIFJvbGUnKSk7XG5cbiAgICBjb25zdCB0eXBlID0gdXNlck9yUm9sZSBpbnN0YW5jZW9mIFJvbGUgPyAncm9sZScgOiAnbWVtYmVyJztcbiAgICBjb25zdCB7IGFsbG93LCBkZW55IH0gPSBQZXJtaXNzaW9uT3ZlcndyaXRlcy5yZXNvbHZlT3ZlcndyaXRlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5jaGFubmVscyh0aGlzLmlkKVxuICAgICAgLnBlcm1pc3Npb25zW3VzZXJPclJvbGUuaWRdLnB1dCh7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHVzZXJPclJvbGUuaWQsIHR5cGUsIGFsbG93OiBhbGxvdy5iaXRmaWVsZCwgZGVueTogZGVueS5iaXRmaWVsZCB9LFxuICAgICAgICByZWFzb24sXG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9ja3MgaW4gdGhlIHBlcm1pc3Npb24gb3ZlcndyaXRlcyBmcm9tIHRoZSBwYXJlbnQgY2hhbm5lbC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRDaGFubmVsPn1cbiAgICovXG4gIGxvY2tQZXJtaXNzaW9ucygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdHVUlMRF9DSEFOTkVMX09SUEhBTicpKTtcbiAgICBjb25zdCBwZXJtaXNzaW9uT3ZlcndyaXRlcyA9IHRoaXMucGFyZW50LnBlcm1pc3Npb25PdmVyd3JpdGVzLm1hcChvdmVyd3JpdGUgPT4gb3ZlcndyaXRlLnRvSlNPTigpKTtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgcGVybWlzc2lvbk92ZXJ3cml0ZXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBjb2xsZWN0aW9uIG9mIG1lbWJlcnMgdGhhdCBjYW4gc2VlIHRoaXMgY2hhbm5lbCwgbWFwcGVkIGJ5IHRoZWlyIElEXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRNZW1iZXI+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtZW1iZXJzKCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRoaXMuZ3VpbGQubWVtYmVycy5jYWNoZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKHRoaXMucGVybWlzc2lvbnNGb3IobWVtYmVyKS5oYXMoJ1ZJRVdfQ0hBTk5FTCcsIGZhbHNlKSkge1xuICAgICAgICBtZW1iZXJzLnNldChtZW1iZXIuaWQsIG1lbWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIGZvciBhIGd1aWxkIGNoYW5uZWwuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IENoYW5uZWxEYXRhXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtwb3NpdGlvbl0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjaGFubmVsXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdG9waWNdIFRoZSB0b3BpYyBvZiB0aGUgdGV4dCBjaGFubmVsXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25zZnddIFdoZXRoZXIgdGhlIGNoYW5uZWwgaXMgTlNGV1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2JpdHJhdGVdIFRoZSBiaXRyYXRlIG9mIHRoZSB2b2ljZSBjaGFubmVsXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdXNlckxpbWl0XSBUaGUgdXNlciBsaW1pdCBvZiB0aGUgdm9pY2UgY2hhbm5lbFxuICAgKiBAcHJvcGVydHkgez9Tbm93Zmxha2V9IFtwYXJlbnRJRF0gVGhlIHBhcmVudCBJRCBvZiB0aGUgY2hhbm5lbFxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2NrUGVybWlzc2lvbnNdXG4gICAqIExvY2sgdGhlIHBlcm1pc3Npb25zIG9mIHRoZSBjaGFubmVsIHRvIHdoYXQgdGhlIHBhcmVudCdzIHBlcm1pc3Npb25zIGFyZVxuICAgKiBAcHJvcGVydHkge092ZXJ3cml0ZVJlc29sdmFibGVbXXxDb2xsZWN0aW9uPFNub3dmbGFrZSwgT3ZlcndyaXRlUmVzb2x2YWJsZT59IFtwZXJtaXNzaW9uT3ZlcndyaXRlc11cbiAgICogUGVybWlzc2lvbiBvdmVyd3JpdGVzIGZvciB0aGUgY2hhbm5lbFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3JhdGVMaW1pdFBlclVzZXJdIFRoZSByYXRlbGltaXQgcGVyIHVzZXIgZm9yIHRoZSBjaGFubmVsIGluIHNlY29uZHNcbiAgICovXG5cbiAgLyoqXG4gICAqIEVkaXRzIHRoZSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge0NoYW5uZWxEYXRhfSBkYXRhIFRoZSBuZXcgZGF0YSBmb3IgdGhlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgZWRpdGluZyB0aGlzIGNoYW5uZWxcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRDaGFubmVsPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRWRpdCBhIGNoYW5uZWxcbiAgICogY2hhbm5lbC5lZGl0KHsgbmFtZTogJ25ldy1jaGFubmVsJyB9KVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGFzeW5jIGVkaXQoZGF0YSwgcmVhc29uKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYXdhaXQgVXRpbC5zZXRQb3NpdGlvbihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZGF0YS5wb3NpdGlvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuZ3VpbGQuX3NvcnRlZENoYW5uZWxzKHRoaXMpLFxuICAgICAgICB0aGlzLmNsaWVudC5hcGkuZ3VpbGRzKHRoaXMuZ3VpbGQuaWQpLmNoYW5uZWxzLFxuICAgICAgICByZWFzb24sXG4gICAgICApLnRoZW4odXBkYXRlZENoYW5uZWxzID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuYWN0aW9ucy5HdWlsZENoYW5uZWxzUG9zaXRpb25VcGRhdGUuaGFuZGxlKHtcbiAgICAgICAgICBndWlsZF9pZDogdGhpcy5ndWlsZC5pZCxcbiAgICAgICAgICBjaGFubmVsczogdXBkYXRlZENoYW5uZWxzLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBwZXJtaXNzaW9uX292ZXJ3cml0ZXM7XG5cbiAgICBpZiAoZGF0YS5wZXJtaXNzaW9uT3ZlcndyaXRlcykge1xuICAgICAgcGVybWlzc2lvbl9vdmVyd3JpdGVzID0gZGF0YS5wZXJtaXNzaW9uT3ZlcndyaXRlcy5tYXAobyA9PiBQZXJtaXNzaW9uT3ZlcndyaXRlcy5yZXNvbHZlKG8sIHRoaXMuZ3VpbGQpKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sb2NrUGVybWlzc2lvbnMpIHtcbiAgICAgIGlmIChkYXRhLnBhcmVudElEKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IHRoaXMuZ3VpbGQuY2hhbm5lbHMucmVzb2x2ZShkYXRhLnBhcmVudElEKTtcbiAgICAgICAgaWYgKG5ld1BhcmVudCAmJiBuZXdQYXJlbnQudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIHBlcm1pc3Npb25fb3ZlcndyaXRlcyA9IG5ld1BhcmVudC5wZXJtaXNzaW9uT3ZlcndyaXRlcy5tYXAobyA9PiBQZXJtaXNzaW9uT3ZlcndyaXRlcy5yZXNvbHZlKG8sIHRoaXMuZ3VpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICBwZXJtaXNzaW9uX292ZXJ3cml0ZXMgPSB0aGlzLnBhcmVudC5wZXJtaXNzaW9uT3ZlcndyaXRlcy5tYXAobyA9PiBQZXJtaXNzaW9uT3ZlcndyaXRlcy5yZXNvbHZlKG8sIHRoaXMuZ3VpbGQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXdEYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuYXBpLmNoYW5uZWxzKHRoaXMuaWQpLnBhdGNoKHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbmFtZTogKGRhdGEubmFtZSB8fCB0aGlzLm5hbWUpLnRyaW0oKSxcbiAgICAgICAgdG9waWM6IGRhdGEudG9waWMsXG4gICAgICAgIG5zZnc6IGRhdGEubnNmdyxcbiAgICAgICAgYml0cmF0ZTogZGF0YS5iaXRyYXRlIHx8IHRoaXMuYml0cmF0ZSxcbiAgICAgICAgdXNlcl9saW1pdDogdHlwZW9mIGRhdGEudXNlckxpbWl0ICE9PSAndW5kZWZpbmVkJyA/IGRhdGEudXNlckxpbWl0IDogdGhpcy51c2VyTGltaXQsXG4gICAgICAgIHBhcmVudF9pZDogZGF0YS5wYXJlbnRJRCxcbiAgICAgICAgbG9ja19wZXJtaXNzaW9uczogZGF0YS5sb2NrUGVybWlzc2lvbnMsXG4gICAgICAgIHJhdGVfbGltaXRfcGVyX3VzZXI6IGRhdGEucmF0ZUxpbWl0UGVyVXNlcixcbiAgICAgICAgcGVybWlzc2lvbl9vdmVyd3JpdGVzLFxuICAgICAgfSxcbiAgICAgIHJlYXNvbixcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fY2xvbmUoKTtcbiAgICBjbG9uZS5fcGF0Y2gobmV3RGF0YSk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgbmFtZSBmb3IgdGhlIGd1aWxkIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuZXcgbmFtZSBmb3IgdGhlIGd1aWxkIGNoYW5uZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkIGNoYW5uZWwncyBuYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkQ2hhbm5lbD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNldCBhIG5ldyBjaGFubmVsIG5hbWVcbiAgICogY2hhbm5lbC5zZXROYW1lKCdub3RfZ2VuZXJhbCcpXG4gICAqICAgLnRoZW4obmV3Q2hhbm5lbCA9PiBjb25zb2xlLmxvZyhgQ2hhbm5lbCdzIG5ldyBuYW1lIGlzICR7bmV3Q2hhbm5lbC5uYW1lfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldE5hbWUobmFtZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IG5hbWUgfSwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYXRlZ29yeSBwYXJlbnQgb2YgdGhpcyBjaGFubmVsLlxuICAgKiBAcGFyYW0gez9DYXRlZ29yeUNoYW5uZWx8U25vd2ZsYWtlfSBjaGFubmVsIFBhcmVudCBjaGFubmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyB0byBwYXNzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubG9ja1Blcm1pc3Npb25zPXRydWVdIExvY2sgdGhlIHBlcm1pc3Npb25zIHRvIHdoYXQgdGhlIHBhcmVudCdzIHBlcm1pc3Npb25zIGFyZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVhc29uXSBSZWFzb24gZm9yIG1vZGlmeWluZyB0aGUgcGFyZW50IG9mIHRoaXMgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZENoYW5uZWw+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBBZGQgYSBwYXJlbnQgdG8gYSBjaGFubmVsXG4gICAqIG1lc3NhZ2UuY2hhbm5lbC5zZXRQYXJlbnQoJzM1NTkwODEwODQzMTkxNzA2NicsIHsgbG9ja1Blcm1pc3Npb25zOiBmYWxzZSB9KVxuICAgKiAgIC50aGVuKGNoYW5uZWwgPT4gY29uc29sZS5sb2coYE5ldyBwYXJlbnQgb2YgJHttZXNzYWdlLmNoYW5uZWwubmFtZX06ICR7Y2hhbm5lbC5uYW1lfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldFBhcmVudChjaGFubmVsLCB7IGxvY2tQZXJtaXNzaW9ucyA9IHRydWUsIHJlYXNvbiB9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KFxuICAgICAge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHBhcmVudElEOiBjaGFubmVsICE9PSBudWxsID8gKGNoYW5uZWwuaGFzT3duUHJvcGVydHkoJ2lkJykgPyBjaGFubmVsLmlkIDogY2hhbm5lbCkgOiBudWxsLFxuICAgICAgICBsb2NrUGVybWlzc2lvbnMsXG4gICAgICB9LFxuICAgICAgcmVhc29uLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIG5ldyB0b3BpYyBmb3IgdGhlIGd1aWxkIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdG9waWMgVGhlIG5ldyB0b3BpYyBmb3IgdGhlIGd1aWxkIGNoYW5uZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGd1aWxkIGNoYW5uZWwncyB0b3BpY1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZENoYW5uZWw+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgYSBuZXcgY2hhbm5lbCB0b3BpY1xuICAgKiBjaGFubmVsLnNldFRvcGljKCduZWVkcyBtb3JlIHJhdGUgbGltaXRpbmcnKVxuICAgKiAgIC50aGVuKG5ld0NoYW5uZWwgPT4gY29uc29sZS5sb2coYENoYW5uZWwncyBuZXcgdG9waWMgaXMgJHtuZXdDaGFubmVsLnRvcGljfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldFRvcGljKHRvcGljLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgdG9waWMgfSwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IHBvc2l0aW9uIGZvciB0aGUgZ3VpbGQgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSBuZXcgcG9zaXRpb24gZm9yIHRoZSBndWlsZCBjaGFubmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3Igc2V0dGluZyBwb3NpdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlbGF0aXZlPWZhbHNlXSBDaGFuZ2UgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGl0cyBjdXJyZW50IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIHBvc2l0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkQ2hhbm5lbD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNldCBhIG5ldyBjaGFubmVsIHBvc2l0aW9uXG4gICAqIGNoYW5uZWwuc2V0UG9zaXRpb24oMilcbiAgICogICAudGhlbihuZXdDaGFubmVsID0+IGNvbnNvbGUubG9nKGBDaGFubmVsJ3MgbmV3IHBvc2l0aW9uIGlzICR7bmV3Q2hhbm5lbC5wb3NpdGlvbn1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRQb3NpdGlvbihwb3NpdGlvbiwgeyByZWxhdGl2ZSwgcmVhc29uIH0gPSB7fSkge1xuICAgIHJldHVybiBVdGlsLnNldFBvc2l0aW9uKFxuICAgICAgdGhpcyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB0aGlzLmd1aWxkLl9zb3J0ZWRDaGFubmVscyh0aGlzKSxcbiAgICAgIHRoaXMuY2xpZW50LmFwaS5ndWlsZHModGhpcy5ndWlsZC5pZCkuY2hhbm5lbHMsXG4gICAgICByZWFzb24sXG4gICAgKS50aGVuKHVwZGF0ZWRDaGFubmVscyA9PiB7XG4gICAgICB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkQ2hhbm5lbHNQb3NpdGlvblVwZGF0ZS5oYW5kbGUoe1xuICAgICAgICBndWlsZF9pZDogdGhpcy5ndWlsZC5pZCxcbiAgICAgICAgY2hhbm5lbHM6IHVwZGF0ZWRDaGFubmVscyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnZpdGUgdG8gdGhpcyBndWlsZCBjaGFubmVsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSBpbnZpdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZW1wb3Jhcnk9ZmFsc2VdIFdoZXRoZXIgbWVtYmVycyB0aGF0IGpvaW5lZCB2aWEgdGhlIGludml0ZSBzaG91bGQgYmUgYXV0b21hdGljYWxseVxuICAgKiBraWNrZWQgYWZ0ZXIgMjQgaG91cnMgaWYgdGhleSBoYXZlIG5vdCB5ZXQgcmVjZWl2ZWQgYSByb2xlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhBZ2U9ODY0MDBdIEhvdyBsb25nIHRoZSBpbnZpdGUgc2hvdWxkIGxhc3QgKGluIHNlY29uZHMsIDAgZm9yIGZvcmV2ZXIpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhVc2VzPTBdIE1heGltdW0gbnVtYmVyIG9mIHVzZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bmlxdWU9ZmFsc2VdIENyZWF0ZSBhIHVuaXF1ZSBpbnZpdGUsIG9yIHVzZSBhbiBleGlzdGluZyBvbmUgd2l0aCBzaW1pbGFyIHNldHRpbmdzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3IgY3JlYXRpbmcgdGhpc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbnZpdGU+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBDcmVhdGUgYW4gaW52aXRlIHRvIGEgY2hhbm5lbFxuICAgKiBjaGFubmVsLmNyZWF0ZUludml0ZSgpXG4gICAqICAgLnRoZW4oaW52aXRlID0+IGNvbnNvbGUubG9nKGBDcmVhdGVkIGFuIGludml0ZSB3aXRoIGEgY29kZSBvZiAke2ludml0ZS5jb2RlfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGNyZWF0ZUludml0ZSh7IHRlbXBvcmFyeSA9IGZhbHNlLCBtYXhBZ2UgPSA4NjQwMCwgbWF4VXNlcyA9IDAsIHVuaXF1ZSwgcmVhc29uIH0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5jaGFubmVscyh0aGlzLmlkKVxuICAgICAgLmludml0ZXMucG9zdCh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0ZW1wb3JhcnksXG4gICAgICAgICAgbWF4X2FnZTogbWF4QWdlLFxuICAgICAgICAgIG1heF91c2VzOiBtYXhVc2VzLFxuICAgICAgICAgIHVuaXF1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVhc29uLFxuICAgICAgfSlcbiAgICAgIC50aGVuKGludml0ZSA9PiBuZXcgSW52aXRlKHRoaXMuY2xpZW50LCBpbnZpdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGEgY29sbGVjdGlvbiBvZiBpbnZpdGVzIHRvIHRoaXMgZ3VpbGQgY2hhbm5lbC5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGNvbGxlY3Rpb24gbWFwcGluZyBpbnZpdGVzIGJ5IHRoZWlyIGNvZGVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uPHN0cmluZywgSW52aXRlPj59XG4gICAqL1xuICBhc3luYyBmZXRjaEludml0ZXMoKSB7XG4gICAgY29uc3QgaW52aXRlSXRlbXMgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkuY2hhbm5lbHModGhpcy5pZCkuaW52aXRlcy5nZXQoKTtcbiAgICBjb25zdCBpbnZpdGVzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICBmb3IgKGNvbnN0IGludml0ZUl0ZW0gb2YgaW52aXRlSXRlbXMpIHtcbiAgICAgIGNvbnN0IGludml0ZSA9IG5ldyBJbnZpdGUodGhpcy5jbGllbnQsIGludml0ZUl0ZW0pO1xuICAgICAgaW52aXRlcy5zZXQoaW52aXRlLmNvZGUsIGludml0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZpdGVzO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAvKipcbiAgICogQ2xvbmVzIHRoaXMgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZT10aGlzLm5hbWVdIE5hbWUgb2YgdGhlIG5ldyBjaGFubmVsXG4gICAqIEBwYXJhbSB7T3ZlcndyaXRlUmVzb2x2YWJsZVtdfENvbGxlY3Rpb248U25vd2ZsYWtlLCBPdmVyd3JpdGVSZXNvbHZhYmxlPn0gW29wdGlvbnMucGVybWlzc2lvbk92ZXJ3cml0ZXM9dGhpcy5wZXJtaXNzaW9uT3ZlcndyaXRlc11cbiAgICogUGVybWlzc2lvbiBvdmVyd3JpdGVzIG9mIHRoZSBuZXcgY2hhbm5lbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZT10aGlzLnR5cGVdIFR5cGUgb2YgdGhlIG5ldyBjaGFubmVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b3BpYz10aGlzLnRvcGljXSBUb3BpYyBvZiB0aGUgbmV3IGNoYW5uZWwgKG9ubHkgdGV4dClcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5uc2Z3PXRoaXMubnNmd10gV2hldGhlciB0aGUgbmV3IGNoYW5uZWwgaXMgbnNmdyAob25seSB0ZXh0KVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYml0cmF0ZT10aGlzLmJpdHJhdGVdIEJpdHJhdGUgb2YgdGhlIG5ldyBjaGFubmVsIGluIGJpdHMgKG9ubHkgdm9pY2UpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy51c2VyTGltaXQ9dGhpcy51c2VyTGltaXRdIE1heGltdW0gYW1vdW50IG9mIHVzZXJzIGFsbG93ZWQgaW4gdGhlIG5ldyBjaGFubmVsIChvbmx5IHZvaWNlKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmF0ZUxpbWl0UGVyVXNlcj10aGlzLnJhdGVMaW1pdFBlclVzZXJdIFJhdGVsaW1pdCBwZXIgdXNlciBmb3IgdGhlIG5ldyBjaGFubmVsIChvbmx5IHRleHQpXG4gICAqIEBwYXJhbSB7Q2hhbm5lbFJlc29sdmFibGV9IFtvcHRpb25zLnBhcmVudD10aGlzLnBhcmVudF0gUGFyZW50IG9mIHRoZSBuZXcgY2hhbm5lbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVhc29uXSBSZWFzb24gZm9yIGNsb25pbmcgdGhpcyBjaGFubmVsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkQ2hhbm5lbD59XG4gICAqL1xuICBjbG9uZShvcHRpb25zID0ge30pIHtcbiAgICBVdGlsLm1lcmdlRGVmYXVsdChcbiAgICAgIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBwZXJtaXNzaW9uT3ZlcndyaXRlczogdGhpcy5wZXJtaXNzaW9uT3ZlcndyaXRlcyxcbiAgICAgICAgdG9waWM6IHRoaXMudG9waWMsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgbnNmdzogdGhpcy5uc2Z3LFxuICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgICBiaXRyYXRlOiB0aGlzLmJpdHJhdGUsXG4gICAgICAgIHVzZXJMaW1pdDogdGhpcy51c2VyTGltaXQsXG4gICAgICAgIHJhdGVMaW1pdFBlclVzZXI6IHRoaXMucmF0ZUxpbWl0UGVyVXNlcixcbiAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5ndWlsZC5jaGFubmVscy5jcmVhdGUob3B0aW9ucy5uYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY2hhbm5lbCBoYXMgdGhlIHNhbWUgdHlwZSwgdG9waWMsIHBvc2l0aW9uLCBuYW1lLCBvdmVyd3JpdGVzIGFuZCBJRCBhcyBhbm90aGVyIGNoYW5uZWwuXG4gICAqIEluIG1vc3QgY2FzZXMsIGEgc2ltcGxlIGBjaGFubmVsLmlkID09PSBjaGFubmVsMi5pZGAgd2lsbCBkbywgYW5kIGlzIG11Y2ggZmFzdGVyIHRvby5cbiAgICogQHBhcmFtIHtHdWlsZENoYW5uZWx9IGNoYW5uZWwgQ2hhbm5lbCB0byBjb21wYXJlIHdpdGhcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMoY2hhbm5lbCkge1xuICAgIGxldCBlcXVhbCA9XG4gICAgICBjaGFubmVsICYmXG4gICAgICB0aGlzLmlkID09PSBjaGFubmVsLmlkICYmXG4gICAgICB0aGlzLnR5cGUgPT09IGNoYW5uZWwudHlwZSAmJlxuICAgICAgdGhpcy50b3BpYyA9PT0gY2hhbm5lbC50b3BpYyAmJlxuICAgICAgdGhpcy5wb3NpdGlvbiA9PT0gY2hhbm5lbC5wb3NpdGlvbiAmJlxuICAgICAgdGhpcy5uYW1lID09PSBjaGFubmVsLm5hbWU7XG5cbiAgICBpZiAoZXF1YWwpIHtcbiAgICAgIGlmICh0aGlzLnBlcm1pc3Npb25PdmVyd3JpdGVzICYmIGNoYW5uZWwucGVybWlzc2lvbk92ZXJ3cml0ZXMpIHtcbiAgICAgICAgZXF1YWwgPSB0aGlzLnBlcm1pc3Npb25PdmVyd3JpdGVzLmVxdWFscyhjaGFubmVsLnBlcm1pc3Npb25PdmVyd3JpdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVxdWFsID0gIXRoaXMucGVybWlzc2lvbk92ZXJ3cml0ZXMgJiYgIWNoYW5uZWwucGVybWlzc2lvbk92ZXJ3cml0ZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNoYW5uZWwgaXMgZGVsZXRhYmxlIGJ5IHRoZSBjbGllbnQgdXNlclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVsZXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zRm9yKHRoaXMuY2xpZW50LnVzZXIpLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5NQU5BR0VfQ0hBTk5FTFMsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjaGFubmVsIGlzIG1hbmFnZWFibGUgYnkgdGhlIGNsaWVudCB1c2VyXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtYW5hZ2VhYmxlKCkge1xuICAgIGlmICh0aGlzLmNsaWVudC51c2VyLmlkID09PSB0aGlzLmd1aWxkLm93bmVySUQpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09ICd2b2ljZScpIHtcbiAgICAgIGlmICghdGhpcy5wZXJtaXNzaW9uc0Zvcih0aGlzLmNsaWVudC51c2VyKS5oYXMoUGVybWlzc2lvbnMuRkxBR1MuQ09OTkVDVCwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLnZpZXdhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zRm9yKHRoaXMuY2xpZW50LnVzZXIpLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5NQU5BR0VfQ0hBTk5FTFMsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjaGFubmVsIGlzIHZpZXdhYmxlIGJ5IHRoZSBjbGllbnQgdXNlclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdmlld2FibGUoKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50LnVzZXIuaWQgPT09IHRoaXMuZ3VpbGQub3duZXJJRCkgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgcGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zRm9yKHRoaXMuY2xpZW50LnVzZXIpO1xuICAgIGlmICghcGVybWlzc2lvbnMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcGVybWlzc2lvbnMuaGFzKFBlcm1pc3Npb25zLkZMQUdTLlZJRVdfQ0hBTk5FTCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhpcyBjaGFubmVsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBkZWxldGluZyB0aGlzIGNoYW5uZWxcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRDaGFubmVsPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRGVsZXRlIHRoZSBjaGFubmVsXG4gICAqIGNoYW5uZWwuZGVsZXRlKCdtYWtpbmcgcm9vbSBmb3IgbmV3IGNoYW5uZWxzJylcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBkZWxldGUocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmNoYW5uZWxzKHRoaXMuaWQpXG4gICAgICAuZGVsZXRlKHsgcmVhc29uIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkQ2hhbm5lbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUd1aWxkRW1vamkgPSByZXF1aXJlKCcuL0Jhc2VHdWlsZEVtb2ppJyk7XG5jb25zdCB7IEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEd1aWxkRW1vamlSb2xlTWFuYWdlciA9IHJlcXVpcmUoJy4uL21hbmFnZXJzL0d1aWxkRW1vamlSb2xlTWFuYWdlcicpO1xuY29uc3QgUGVybWlzc2lvbnMgPSByZXF1aXJlKCcuLi91dGlsL1Blcm1pc3Npb25zJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGN1c3RvbSBlbW9qaS5cbiAqIEBleHRlbmRzIHtCYXNlR3VpbGRFbW9qaX1cbiAqL1xuY2xhc3MgR3VpbGRFbW9qaSBleHRlbmRzIEJhc2VHdWlsZEVtb2ppIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnQgVGhlIGluc3RhbnRpYXRpbmcgY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgZ3VpbGQgZW1vamlcbiAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoZSBndWlsZCBlbW9qaSBpcyBwYXJ0IG9mXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGRhdGEsIGd1aWxkKSB7XG4gICAgc3VwZXIoY2xpZW50LCBkYXRhLCBndWlsZCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciB3aG8gY3JlYXRlZCB0aGlzIGVtb2ppXG4gICAgICogQHR5cGUgez9Vc2VyfVxuICAgICAqL1xuICAgIHRoaXMuYXV0aG9yID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZ3VpbGQgdGhpcyBlbW9qaSBpcyBwYXJ0IG9mXG4gICAqIEB0eXBlIHtHdWlsZH1cbiAgICogQG5hbWUgR3VpbGRFbW9qaSNndWlsZFxuICAgKi9cblxuICBfY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5fY2xvbmUoKTtcbiAgICBjbG9uZS5fcm9sZXMgPSB0aGlzLl9yb2xlcy5zbGljZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgc3VwZXIuX3BhdGNoKGRhdGEpO1xuICAgIGlmICh0eXBlb2YgZGF0YS51c2VyICE9PSAndW5kZWZpbmVkJykgdGhpcy5hdXRob3IgPSB0aGlzLmNsaWVudC51c2Vycy5hZGQoZGF0YS51c2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbW9qaSBpcyBkZWxldGFibGUgYnkgdGhlIGNsaWVudCB1c2VyXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkZWxldGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmd1aWxkLm1lKSB0aHJvdyBuZXcgRXJyb3IoJ0dVSUxEX1VOQ0FDSEVEX01FJyk7XG4gICAgcmV0dXJuICF0aGlzLm1hbmFnZWQgJiYgdGhpcy5ndWlsZC5tZS5oYXNQZXJtaXNzaW9uKFBlcm1pc3Npb25zLkZMQUdTLk1BTkFHRV9FTU9KSVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWFuYWdlciBmb3Igcm9sZXMgdGhpcyBlbW9qaSBpcyBhY3RpdmUgZm9yLlxuICAgKiBAdHlwZSB7R3VpbGRFbW9qaVJvbGVNYW5hZ2VyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCByb2xlcygpIHtcbiAgICByZXR1cm4gbmV3IEd1aWxkRW1vamlSb2xlTWFuYWdlcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBhdXRob3IgZm9yIHRoaXMgZW1vamlcbiAgICogQHJldHVybnMge1Byb21pc2U8VXNlcj59XG4gICAqL1xuICBhc3luYyBmZXRjaEF1dGhvcigpIHtcbiAgICBpZiAodGhpcy5tYW5hZ2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VNT0pJX01BTkFHRUQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmd1aWxkLm1lKSB0aHJvdyBuZXcgRXJyb3IoJ0dVSUxEX1VOQ0FDSEVEX01FJyk7XG4gICAgICBpZiAoIXRoaXMuZ3VpbGQubWUucGVybWlzc2lvbnMuaGFzKFBlcm1pc3Npb25zLkZMQUdTLk1BTkFHRV9FTU9KSVMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTUlTU0lOR19NQU5BR0VfRU1PSklTX1BFUk1JU1NJT04nLCB0aGlzLmd1aWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LmFwaS5ndWlsZHModGhpcy5ndWlsZC5pZCkuZW1vamlzKHRoaXMuaWQpLmdldCgpO1xuICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLmF1dGhvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIGZvciBlZGl0aW5nIGFuIGVtb2ppLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBHdWlsZEVtb2ppRWRpdERhdGFcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBUaGUgbmFtZSBvZiB0aGUgZW1vamlcbiAgICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgUm9sZT58Um9sZVJlc29sdmFibGVbXX0gW3JvbGVzXSBSb2xlcyB0byByZXN0cmljdCBlbW9qaSB0b1xuICAgKi9cblxuICAvKipcbiAgICogRWRpdHMgdGhlIGVtb2ppLlxuICAgKiBAcGFyYW0ge0d1aWxkRW1vamlFZGl0RGF0YX0gZGF0YSBUaGUgbmV3IGRhdGEgZm9yIHRoZSBlbW9qaVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBlZGl0aW5nIHRoaXMgZW1vamlcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRFbW9qaT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVkaXQgYW4gZW1vamlcbiAgICogZW1vamkuZWRpdCh7IG5hbWU6ICduZXdlbW9qaScgfSlcbiAgICogICAudGhlbihlID0+IGNvbnNvbGUubG9nKGBFZGl0ZWQgZW1vamkgJHtlfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGVkaXQoZGF0YSwgcmVhc29uKSB7XG4gICAgY29uc3Qgcm9sZXMgPSBkYXRhLnJvbGVzID8gZGF0YS5yb2xlcy5tYXAociA9PiByLmlkIHx8IHIpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5ndWlsZC5pZClcbiAgICAgIC5lbW9qaXModGhpcy5pZClcbiAgICAgIC5wYXRjaCh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgcm9sZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXNvbixcbiAgICAgIH0pXG4gICAgICAudGhlbihuZXdEYXRhID0+IHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLl9jbG9uZSgpO1xuICAgICAgICBjbG9uZS5fcGF0Y2gobmV3RGF0YSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGVtb2ppLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmV3IG5hbWUgZm9yIHRoZSBlbW9qaVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgZW1vamkncyBuYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkRW1vamk+fVxuICAgKi9cbiAgc2V0TmFtZShuYW1lLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgbmFtZSB9LCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGVtb2ppLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBkZWxldGluZyB0aGUgZW1vamlcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRFbW9qaT59XG4gICAqL1xuICBkZWxldGUocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmd1aWxkLmlkKVxuICAgICAgLmVtb2ppcyh0aGlzLmlkKVxuICAgICAgLmRlbGV0ZSh7IHJlYXNvbiB9KVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGVtb2ppIGlzIHRoZSBzYW1lIGFzIGFub3RoZXIgb25lLlxuICAgKiBAcGFyYW0ge0d1aWxkRW1vaml8T2JqZWN0fSBvdGhlciBUaGUgZW1vamkgdG8gY29tcGFyZSBpdCB0b1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZW1vamkgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGVtb2ppIG9yIG5vdFxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgR3VpbGRFbW9qaSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgb3RoZXIuaWQgPT09IHRoaXMuaWQgJiZcbiAgICAgICAgb3RoZXIubmFtZSA9PT0gdGhpcy5uYW1lICYmXG4gICAgICAgIG90aGVyLm1hbmFnZWQgPT09IHRoaXMubWFuYWdlZCAmJlxuICAgICAgICBvdGhlci5yZXF1aXJlc0NvbG9ucyA9PT0gdGhpcy5yZXF1aXJlc0NvbG9ucyAmJlxuICAgICAgICBvdGhlci5yb2xlcy5jYWNoZS5zaXplID09PSB0aGlzLnJvbGVzLmNhY2hlLnNpemUgJiZcbiAgICAgICAgb3RoZXIucm9sZXMuY2FjaGUuZXZlcnkocm9sZSA9PiB0aGlzLnJvbGVzLmNhY2hlLmhhcyhyb2xlLmlkKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG90aGVyLmlkID09PSB0aGlzLmlkICYmXG4gICAgICAgIG90aGVyLm5hbWUgPT09IHRoaXMubmFtZSAmJlxuICAgICAgICBvdGhlci5yb2xlcy5sZW5ndGggPT09IHRoaXMucm9sZXMuY2FjaGUuc2l6ZSAmJlxuICAgICAgICBvdGhlci5yb2xlcy5ldmVyeShyb2xlID0+IHRoaXMucm9sZXMuY2FjaGUuaGFzKHJvbGUpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZEVtb2ppO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCBSb2xlID0gcmVxdWlyZSgnLi9Sb2xlJyk7XG5jb25zdCBUZXh0QmFzZWRDaGFubmVsID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzL1RleHRCYXNlZENoYW5uZWwnKTtcbmNvbnN0IHsgRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgR3VpbGRNZW1iZXJSb2xlTWFuYWdlciA9IHJlcXVpcmUoJy4uL21hbmFnZXJzL0d1aWxkTWVtYmVyUm9sZU1hbmFnZXInKTtcbmNvbnN0IFBlcm1pc3Npb25zID0gcmVxdWlyZSgnLi4vdXRpbC9QZXJtaXNzaW9ucycpO1xubGV0IFN0cnVjdHVyZXM7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG1lbWJlciBvZiBhIGd1aWxkIG9uIERpc2NvcmQuXG4gKiBAaW1wbGVtZW50cyB7VGV4dEJhc2VkQ2hhbm5lbH1cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBHdWlsZE1lbWJlciBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCBUaGUgaW5zdGFudGlhdGluZyBjbGllbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSBndWlsZCBtZW1iZXJcbiAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoZSBtZW1iZXIgaXMgcGFydCBvZlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhLCBndWlsZCkge1xuICAgIHN1cGVyKGNsaWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3VpbGQgdGhhdCB0aGlzIG1lbWJlciBpcyBwYXJ0IG9mXG4gICAgICogQHR5cGUge0d1aWxkfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpbGQgPSBndWlsZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lc3RhbXAgdGhlIG1lbWJlciBqb2luZWQgdGhlIGd1aWxkIGF0XG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5qb2luZWRUaW1lc3RhbXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBsYXN0IG1lc3NhZ2Ugc2VudCBieSB0aGUgbWVtYmVyIGluIHRoZWlyIGd1aWxkLCBpZiBvbmUgd2FzIHNlbnRcbiAgICAgKiBAdHlwZSB7P1Nub3dmbGFrZX1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RNZXNzYWdlSUQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBjaGFubmVsIGZvciB0aGUgbGFzdCBtZXNzYWdlIHNlbnQgYnkgdGhlIG1lbWJlciBpbiB0aGVpciBndWlsZCwgaWYgb25lIHdhcyBzZW50XG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5sYXN0TWVzc2FnZUNoYW5uZWxJRCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXN0YW1wIG9mIHdoZW4gdGhlIG1lbWJlciB1c2VkIHRoZWlyIE5pdHJvIGJvb3N0IG9uIHRoZSBndWlsZCwgaWYgaXQgd2FzIHVzZWRcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnByZW1pdW1TaW5jZVRpbWVzdGFtcCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtZW1iZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBndWlsZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5pY2tuYW1lIG9mIHRoaXMgbWVtYmVyLCBpZiB0aGV5IGhhdmUgb25lXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uaWNrbmFtZSA9IG51bGw7XG5cbiAgICB0aGlzLl9yb2xlcyA9IFtdO1xuICAgIGlmIChkYXRhKSB0aGlzLl9wYXRjaChkYXRhKTtcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgaWYgKCd1c2VyJyBpbiBkYXRhKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB1c2VyIHRoYXQgdGhpcyBndWlsZCBtZW1iZXIgaW5zdGFuY2UgcmVwcmVzZW50c1xuICAgICAgICogQHR5cGUge1VzZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudXNlciA9IHRoaXMuY2xpZW50LnVzZXJzLmFkZChkYXRhLnVzZXIsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICgnbmljaycgaW4gZGF0YSkgdGhpcy5uaWNrbmFtZSA9IGRhdGEubmljaztcbiAgICBpZiAoJ2pvaW5lZF9hdCcgaW4gZGF0YSkgdGhpcy5qb2luZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZShkYXRhLmpvaW5lZF9hdCkuZ2V0VGltZSgpO1xuICAgIGlmICgncHJlbWl1bV9zaW5jZScgaW4gZGF0YSkgdGhpcy5wcmVtaXVtU2luY2VUaW1lc3RhbXAgPSBuZXcgRGF0ZShkYXRhLnByZW1pdW1fc2luY2UpLmdldFRpbWUoKTtcbiAgICBpZiAoJ3JvbGVzJyBpbiBkYXRhKSB0aGlzLl9yb2xlcyA9IGRhdGEucm9sZXM7XG4gIH1cblxuICBfY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5fY2xvbmUoKTtcbiAgICBjbG9uZS5fcm9sZXMgPSB0aGlzLl9yb2xlcy5zbGljZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgR3VpbGRNZW1iZXIgaXMgYSBwYXJ0aWFsXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwYXJ0aWFsKCkge1xuICAgIHJldHVybiAhdGhpcy5qb2luZWRUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogQSBtYW5hZ2VyIGZvciB0aGUgcm9sZXMgYmVsb25naW5nIHRvIHRoaXMgbWVtYmVyXG4gICAqIEB0eXBlIHtHdWlsZE1lbWJlclJvbGVNYW5hZ2VyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCByb2xlcygpIHtcbiAgICByZXR1cm4gbmV3IEd1aWxkTWVtYmVyUm9sZU1hbmFnZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE1lc3NhZ2Ugb2JqZWN0IG9mIHRoZSBsYXN0IG1lc3NhZ2Ugc2VudCBieSB0aGUgbWVtYmVyIGluIHRoZWlyIGd1aWxkLCBpZiBvbmUgd2FzIHNlbnRcbiAgICogQHR5cGUgez9NZXNzYWdlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsYXN0TWVzc2FnZSgpIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5ndWlsZC5jaGFubmVscy5jYWNoZS5nZXQodGhpcy5sYXN0TWVzc2FnZUNoYW5uZWxJRCk7XG4gICAgcmV0dXJuIChjaGFubmVsICYmIGNoYW5uZWwubWVzc2FnZXMuY2FjaGUuZ2V0KHRoaXMubGFzdE1lc3NhZ2VJRCkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZvaWNlIHN0YXRlIG9mIHRoaXMgbWVtYmVyXG4gICAqIEB0eXBlIHtWb2ljZVN0YXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2b2ljZSgpIHtcbiAgICBpZiAoIVN0cnVjdHVyZXMpIFN0cnVjdHVyZXMgPSByZXF1aXJlKCcuLi91dGlsL1N0cnVjdHVyZXMnKTtcbiAgICBjb25zdCBWb2ljZVN0YXRlID0gU3RydWN0dXJlcy5nZXQoJ1ZvaWNlU3RhdGUnKTtcbiAgICByZXR1cm4gdGhpcy5ndWlsZC52b2ljZVN0YXRlcy5jYWNoZS5nZXQodGhpcy5pZCkgfHwgbmV3IFZvaWNlU3RhdGUodGhpcy5ndWlsZCwgeyB1c2VyX2lkOiB0aGlzLmlkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoaXMgbWVtYmVyIGpvaW5lZCB0aGUgZ3VpbGRcbiAgICogQHR5cGUgez9EYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBqb2luZWRBdCgpIHtcbiAgICByZXR1cm4gdGhpcy5qb2luZWRUaW1lc3RhbXAgPyBuZXcgRGF0ZSh0aGlzLmpvaW5lZFRpbWVzdGFtcCkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIG9mIHdoZW4gdGhlIG1lbWJlciB1c2VkIHRoZWlyIE5pdHJvIGJvb3N0IG9uIHRoZSBndWlsZCwgaWYgaXQgd2FzIHVzZWRcbiAgICogQHR5cGUgez9EYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmVtaXVtU2luY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlbWl1bVNpbmNlVGltZXN0YW1wID8gbmV3IERhdGUodGhpcy5wcmVtaXVtU2luY2VUaW1lc3RhbXApIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBndWlsZCBtZW1iZXJcbiAgICogQHR5cGUge1ByZXNlbmNlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmVzZW5jZSgpIHtcbiAgICBpZiAoIVN0cnVjdHVyZXMpIFN0cnVjdHVyZXMgPSByZXF1aXJlKCcuLi91dGlsL1N0cnVjdHVyZXMnKTtcbiAgICBjb25zdCBQcmVzZW5jZSA9IFN0cnVjdHVyZXMuZ2V0KCdQcmVzZW5jZScpO1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmd1aWxkLnByZXNlbmNlcy5jYWNoZS5nZXQodGhpcy5pZCkgfHxcbiAgICAgIG5ldyBQcmVzZW5jZSh0aGlzLmNsaWVudCwge1xuICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIH0sXG4gICAgICAgIGd1aWxkOiB0aGlzLmd1aWxkLFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkaXNwbGF5ZWQgY29sb3Igb2YgdGhpcyBtZW1iZXIgaW4gYmFzZSAxMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkaXNwbGF5Q29sb3IoKSB7XG4gICAgY29uc3Qgcm9sZSA9IHRoaXMucm9sZXMuY29sb3I7XG4gICAgcmV0dXJuIChyb2xlICYmIHJvbGUuY29sb3IpIHx8IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpc3BsYXllZCBjb2xvciBvZiB0aGlzIG1lbWJlciBpbiBoZXhhZGVjaW1hbFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkaXNwbGF5SGV4Q29sb3IoKSB7XG4gICAgY29uc3Qgcm9sZSA9IHRoaXMucm9sZXMuY29sb3I7XG4gICAgcmV0dXJuIChyb2xlICYmIHJvbGUuaGV4Q29sb3IpIHx8ICcjMDAwMDAwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhpcyBtZW1iZXJcbiAgICogQHR5cGUge1Nub3dmbGFrZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlci5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmlja25hbWUgb2YgdGhpcyBtZW1iZXIsIG9yIHRoZWlyIHVzZXJuYW1lIGlmIHRoZXkgZG9uJ3QgaGF2ZSBvbmVcbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5pY2tuYW1lIHx8IHRoaXMudXNlci51c2VybmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb3ZlcmFsbCBzZXQgb2YgcGVybWlzc2lvbnMgZm9yIHRoaXMgbWVtYmVyLCB0YWtpbmcgb25seSByb2xlcyBpbnRvIGFjY291bnRcbiAgICogQHR5cGUge1JlYWRvbmx5PFBlcm1pc3Npb25zPn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGVybWlzc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMudXNlci5pZCA9PT0gdGhpcy5ndWlsZC5vd25lcklEKSByZXR1cm4gbmV3IFBlcm1pc3Npb25zKFBlcm1pc3Npb25zLkFMTCkuZnJlZXplKCk7XG4gICAgcmV0dXJuIG5ldyBQZXJtaXNzaW9ucyh0aGlzLnJvbGVzLmNhY2hlLm1hcChyb2xlID0+IHJvbGUucGVybWlzc2lvbnMpKS5mcmVlemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjbGllbnQgdXNlciBpcyBhYm92ZSB0aGlzIHVzZXIgaW4gdGhlIGhpZXJhcmNoeSwgYWNjb3JkaW5nIHRvIHJvbGUgcG9zaXRpb24gYW5kIGd1aWxkIG93bmVyc2hpcC5cbiAgICogVGhpcyBpcyBhIHByZXJlcXVpc2l0ZSBmb3IgbWFueSBtb2RlcmF0aXZlIGFjdGlvbnMuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtYW5hZ2VhYmxlKCkge1xuICAgIGlmICh0aGlzLnVzZXIuaWQgPT09IHRoaXMuZ3VpbGQub3duZXJJRCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLnVzZXIuaWQgPT09IHRoaXMuY2xpZW50LnVzZXIuaWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5jbGllbnQudXNlci5pZCA9PT0gdGhpcy5ndWlsZC5vd25lcklEKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuZ3VpbGQubWUpIHRocm93IG5ldyBFcnJvcignR1VJTERfVU5DQUNIRURfTUUnKTtcbiAgICByZXR1cm4gdGhpcy5ndWlsZC5tZS5yb2xlcy5oaWdoZXN0LmNvbXBhcmVQb3NpdGlvblRvKHRoaXMucm9sZXMuaGlnaGVzdCkgPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBtZW1iZXIgaXMga2lja2FibGUgYnkgdGhlIGNsaWVudCB1c2VyXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBraWNrYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5hZ2VhYmxlICYmIHRoaXMuZ3VpbGQubWUucGVybWlzc2lvbnMuaGFzKFBlcm1pc3Npb25zLkZMQUdTLktJQ0tfTUVNQkVSUyk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIG1lbWJlciBpcyBiYW5uYWJsZSBieSB0aGUgY2xpZW50IHVzZXJcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhbm5hYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZWFibGUgJiYgdGhpcy5ndWlsZC5tZS5wZXJtaXNzaW9ucy5oYXMoUGVybWlzc2lvbnMuRkxBR1MuQkFOX01FTUJFUlMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYGNoYW5uZWwucGVybWlzc2lvbnNGb3IoZ3VpbGRNZW1iZXIpYC4gUmV0dXJucyBwZXJtaXNzaW9ucyBmb3IgYSBtZW1iZXIgaW4gYSBndWlsZCBjaGFubmVsLFxuICAgKiB0YWtpbmcgaW50byBhY2NvdW50IHJvbGVzIGFuZCBwZXJtaXNzaW9uIG92ZXJ3cml0ZXMuXG4gICAqIEBwYXJhbSB7Q2hhbm5lbFJlc29sdmFibGV9IGNoYW5uZWwgVGhlIGd1aWxkIGNoYW5uZWwgdG8gdXNlIGFzIGNvbnRleHRcbiAgICogQHJldHVybnMge1JlYWRvbmx5PFBlcm1pc3Npb25zPn1cbiAgICovXG4gIHBlcm1pc3Npb25zSW4oY2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSB0aGlzLmd1aWxkLmNoYW5uZWxzLnJlc29sdmUoY2hhbm5lbCk7XG4gICAgaWYgKCFjaGFubmVsKSB0aHJvdyBuZXcgRXJyb3IoJ0dVSUxEX0NIQU5ORUxfUkVTT0xWRScpO1xuICAgIHJldHVybiBjaGFubmVsLm1lbWJlclBlcm1pc3Npb25zKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbnkgb2YgdGhpcyBtZW1iZXIncyByb2xlcyBoYXZlIGEgcGVybWlzc2lvbi5cbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uUmVzb2x2YWJsZX0gcGVybWlzc2lvbiBQZXJtaXNzaW9uKHMpIHRvIGNoZWNrIGZvclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0FkbWluPXRydWVdIFdoZXRoZXIgdG8gYWxsb3cgdGhlIGFkbWluaXN0cmF0b3IgcGVybWlzc2lvbiB0byBvdmVycmlkZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrT3duZXI9dHJ1ZV0gV2hldGhlciB0byBhbGxvdyBiZWluZyB0aGUgZ3VpbGQncyBvd25lciB0byBvdmVycmlkZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1Blcm1pc3Npb24ocGVybWlzc2lvbiwgeyBjaGVja0FkbWluID0gdHJ1ZSwgY2hlY2tPd25lciA9IHRydWUgfSA9IHt9KSB7XG4gICAgaWYgKGNoZWNrT3duZXIgJiYgdGhpcy51c2VyLmlkID09PSB0aGlzLmd1aWxkLm93bmVySUQpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHBlcm1pc3Npb25zID0gbmV3IFBlcm1pc3Npb25zKHRoaXMucm9sZXMuY2FjaGUubWFwKHJvbGUgPT4gcm9sZS5wZXJtaXNzaW9ucykpO1xuICAgIHJldHVybiBwZXJtaXNzaW9ucy5oYXMocGVybWlzc2lvbiwgY2hlY2tBZG1pbik7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRhdGEgZm9yIGVkaXRpbmcgYSBndWlsZCBtZW1iZXIuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEd1aWxkTWVtYmVyRWRpdERhdGFcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtuaWNrXSBUaGUgbmlja25hbWUgdG8gc2V0IGZvciB0aGUgbWVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIFJvbGU+fFJvbGVSZXNvbHZhYmxlW119IFtyb2xlc10gVGhlIHJvbGVzIG9yIHJvbGUgSURzIHRvIGFwcGx5XG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW211dGVdIFdoZXRoZXIgb3Igbm90IHRoZSBtZW1iZXIgc2hvdWxkIGJlIG11dGVkXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlYWZdIFdoZXRoZXIgb3Igbm90IHRoZSBtZW1iZXIgc2hvdWxkIGJlIGRlYWZlbmVkXG4gICAqIEBwcm9wZXJ0eSB7Q2hhbm5lbFJlc29sdmFibGV8bnVsbH0gW2NoYW5uZWxdIENoYW5uZWwgdG8gbW92ZSBtZW1iZXIgdG8gKGlmIHRoZXkgYXJlIGNvbm5lY3RlZCB0byB2b2ljZSksIG9yIGBudWxsYFxuICAgKiBpZiB5b3Ugd2FudCB0byBraWNrIHRoZW0gZnJvbSB2b2ljZVxuICAgKi9cblxuICAvKipcbiAgICogRWRpdHMgdGhpcyBtZW1iZXIuXG4gICAqIEBwYXJhbSB7R3VpbGRNZW1iZXJFZGl0RGF0YX0gZGF0YSBUaGUgZGF0YSB0byBlZGl0IHRoZSBtZW1iZXIgd2l0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBlZGl0aW5nIHRoaXMgdXNlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZE1lbWJlcj59XG4gICAqL1xuICBhc3luYyBlZGl0KGRhdGEsIHJlYXNvbikge1xuICAgIGlmIChkYXRhLmNoYW5uZWwpIHtcbiAgICAgIGRhdGEuY2hhbm5lbCA9IHRoaXMuZ3VpbGQuY2hhbm5lbHMucmVzb2x2ZShkYXRhLmNoYW5uZWwpO1xuICAgICAgaWYgKCFkYXRhLmNoYW5uZWwgfHwgZGF0YS5jaGFubmVsLnR5cGUgIT09ICd2b2ljZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHVUlMRF9WT0lDRV9DSEFOTkVMX1JFU09MVkUnKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuY2hhbm5lbF9pZCA9IGRhdGEuY2hhbm5lbC5pZDtcbiAgICAgIGRhdGEuY2hhbm5lbCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGRhdGEuY2hhbm5lbCA9PT0gbnVsbCkge1xuICAgICAgZGF0YS5jaGFubmVsX2lkID0gbnVsbDtcbiAgICAgIGRhdGEuY2hhbm5lbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGRhdGEucm9sZXMpIGRhdGEucm9sZXMgPSBkYXRhLnJvbGVzLm1hcChyb2xlID0+IChyb2xlIGluc3RhbmNlb2YgUm9sZSA/IHJvbGUuaWQgOiByb2xlKSk7XG4gICAgbGV0IGVuZHBvaW50ID0gdGhpcy5jbGllbnQuYXBpLmd1aWxkcyh0aGlzLmd1aWxkLmlkKTtcbiAgICBpZiAodGhpcy51c2VyLmlkID09PSB0aGlzLmNsaWVudC51c2VyLmlkKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ25pY2snKSBlbmRwb2ludCA9IGVuZHBvaW50Lm1lbWJlcnMoJ0BtZScpLm5pY2s7XG4gICAgICBlbHNlIGVuZHBvaW50ID0gZW5kcG9pbnQubWVtYmVycyh0aGlzLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kcG9pbnQgPSBlbmRwb2ludC5tZW1iZXJzKHRoaXMuaWQpO1xuICAgIH1cbiAgICBhd2FpdCBlbmRwb2ludC5wYXRjaCh7IGRhdGEsIHJlYXNvbiB9KTtcblxuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fY2xvbmUoKTtcbiAgICBkYXRhLnVzZXIgPSB0aGlzLnVzZXI7XG4gICAgY2xvbmUuX3BhdGNoKGRhdGEpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuaWNrbmFtZSBmb3IgdGhpcyBtZW1iZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuaWNrIFRoZSBuaWNrbmFtZSBmb3IgdGhlIGd1aWxkIG1lbWJlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBzZXR0aW5nIHRoZSBuaWNrbmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZE1lbWJlcj59XG4gICAqL1xuICBzZXROaWNrbmFtZShuaWNrLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgbmljayB9LCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBETSBjaGFubmVsIGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhpcyBtZW1iZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERNQ2hhbm5lbD59XG4gICAqL1xuICBjcmVhdGVETSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VyLmNyZWF0ZURNKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbnkgRE1zIHdpdGggdGhpcyBtZW1iZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERNQ2hhbm5lbD59XG4gICAqL1xuICBkZWxldGVETSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VyLmRlbGV0ZURNKCk7XG4gIH1cblxuICAvKipcbiAgICogS2lja3MgdGhpcyBtZW1iZXIgZnJvbSB0aGUgZ3VpbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGtpY2tpbmcgdXNlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZE1lbWJlcj59XG4gICAqL1xuICBraWNrKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5ndWlsZC5pZClcbiAgICAgIC5tZW1iZXJzKHRoaXMudXNlci5pZClcbiAgICAgIC5kZWxldGUoeyByZWFzb24gfSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhbnMgdGhpcyBndWlsZCBtZW1iZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGJhblxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGF5cz0wXSBOdW1iZXIgb2YgZGF5cyBvZiBtZXNzYWdlcyB0byBkZWxldGUsIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA3XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3IgYmFubmluZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZE1lbWJlcj59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGJhbiBhIGd1aWxkIG1lbWJlclxuICAgKiBndWlsZE1lbWJlci5iYW4oeyBkYXlzOiA3LCByZWFzb246ICdUaGV5IGRlc2VydmVkIGl0JyB9KVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGJhbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3VpbGQubWVtYmVycy5iYW4odGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyB0aGlzIEd1aWxkTWVtYmVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gV2hldGhlciB0byBza2lwIHRoZSBjYWNoZSBjaGVjayBhbmQgcmVxdWVzdCB0aGUgQVBJXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkTWVtYmVyPn1cbiAgICovXG4gIGZldGNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5ndWlsZC5tZW1iZXJzLmZldGNoKHsgdXNlcjogdGhpcy5pZCwgY2FjaGU6IHRydWUsIGZvcmNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gY29uY2F0ZW5hdGVkIHdpdGggYSBzdHJpbmcsIHRoaXMgYXV0b21hdGljYWxseSByZXR1cm5zIHRoZSB1c2VyJ3MgbWVudGlvbiBpbnN0ZWFkIG9mIHRoZSBHdWlsZE1lbWJlciBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExvZ3M6IEhlbGxvIGZyb20gPEAxMjM0NTY3ODkwMTIzNDU2Nzg+IVxuICAgKiBjb25zb2xlLmxvZyhgSGVsbG8gZnJvbSAke21lbWJlcn0hYCk7XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYDxAJHt0aGlzLm5pY2tuYW1lID8gJyEnIDogJyd9JHt0aGlzLnVzZXIuaWR9PmA7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSlNPTih7XG4gICAgICBndWlsZDogJ2d1aWxkSUQnLFxuICAgICAgdXNlcjogJ3VzZXJJRCcsXG4gICAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICAgIHNwZWFraW5nOiBmYWxzZSxcbiAgICAgIGxhc3RNZXNzYWdlOiBmYWxzZSxcbiAgICAgIGxhc3RNZXNzYWdlSUQ6IGZhbHNlLFxuICAgICAgcm9sZXM6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvLyBUaGVzZSBhcmUgaGVyZSBvbmx5IGZvciBkb2N1bWVudGF0aW9uIHB1cnBvc2VzIC0gdGhleSBhcmUgaW1wbGVtZW50ZWQgYnkgVGV4dEJhc2VkQ2hhbm5lbFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eS1mdW5jdGlvbiAqL1xuICBzZW5kKCkge31cbn1cblxuVGV4dEJhc2VkQ2hhbm5lbC5hcHBseVRvQ2xhc3MoR3VpbGRNZW1iZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkTWVtYmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCBHdWlsZFByZXZpZXdFbW9qaSA9IHJlcXVpcmUoJy4vR3VpbGRQcmV2aWV3RW1vamknKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhIGFib3V0IHRoZSBndWlsZCBhbnkgYm90IGNhbiBwcmV2aWV3LCBjb25uZWN0ZWQgdG8gdGhlIHNwZWNpZmllZCBndWlsZC5cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBHdWlsZFByZXZpZXcgZXh0ZW5kcyBCYXNlIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhKSB7XG4gICAgc3VwZXIoY2xpZW50KTtcblxuICAgIGlmICghZGF0YSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBndWlsZCB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIHJhdyBkYXRhIG9mIHRoZSBndWlsZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaWQgb2YgdGhpcyBndWlsZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGd1aWxkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaWNvbiBvZiB0aGlzIGd1aWxkXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pY29uID0gZGF0YS5pY29uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwbGFzaCBpY29uIG9mIHRoaXMgZ3VpbGRcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNwbGFzaCA9IGRhdGEuc3BsYXNoO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc2NvdmVyeSBzcGxhc2ggaWNvbiBvZiB0aGlzIGd1aWxkXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kaXNjb3ZlcnlTcGxhc2ggPSBkYXRhLmRpc2NvdmVyeV9zcGxhc2g7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBlbmFibGVkIGd1aWxkIGZlYXR1cmVzXG4gICAgICogQHR5cGUge0ZlYXR1cmVzW119XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlcyA9IGRhdGEuZmVhdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwcm94aW1hdGUgY291bnQgb2YgbWVtYmVycyBpbiB0aGlzIGd1aWxkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcHJveGltYXRlTWVtYmVyQ291bnQgPSBkYXRhLmFwcHJveGltYXRlX21lbWJlcl9jb3VudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHByb3hpbWF0ZSBjb3VudCBvZiBvbmxpbmUgbWVtYmVycyBpbiB0aGlzIGd1aWxkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcHJveGltYXRlUHJlc2VuY2VDb3VudCA9IGRhdGEuYXBwcm94aW1hdGVfcHJlc2VuY2VfY291bnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gZm9yIHRoaXMgZ3VpbGRcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGF0YS5kZXNjcmlwdGlvbiB8fCBudWxsO1xuXG4gICAgaWYgKCF0aGlzLmVtb2ppcykge1xuICAgICAgLyoqXG4gICAgICAgKiBDb2xsZWN0aW9uIG9mIGVtb2ppcyBiZWxvbmdpbmcgdG8gdGhpcyBndWlsZFxuICAgICAgICogQHR5cGUge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBHdWlsZFByZXZpZXdFbW9qaT59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1vamlzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbW9qaXMuY2xlYXIoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbW9qaSBvZiBkYXRhLmVtb2ppcykge1xuICAgICAgdGhpcy5lbW9qaXMuc2V0KGVtb2ppLmlkLCBuZXcgR3VpbGRQcmV2aWV3RW1vamkodGhpcy5jbGllbnQsIGVtb2ppLCB0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgdG8gdGhpcyBndWlsZCdzIHNwbGFzaC5cbiAgICogQHBhcmFtIHtJbWFnZVVSTE9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgSW1hZ2UgVVJMXG4gICAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICAgKi9cbiAgc3BsYXNoVVJMKHsgZm9ybWF0LCBzaXplIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5zcGxhc2gpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNkbi5TcGxhc2godGhpcy5pZCwgdGhpcy5zcGxhc2gsIGZvcm1hdCwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFVSTCB0byB0aGlzIGd1aWxkJ3MgZGlzY292ZXJ5IHNwbGFzaC5cbiAgICogQHBhcmFtIHtJbWFnZVVSTE9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgSW1hZ2UgVVJMXG4gICAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICAgKi9cbiAgZGlzY292ZXJ5U3BsYXNoVVJMKHsgZm9ybWF0LCBzaXplIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5kaXNjb3ZlcnlTcGxhc2gpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNkbi5EaXNjb3ZlcnlTcGxhc2godGhpcy5pZCwgdGhpcy5kaXNjb3ZlcnlTcGxhc2gsIGZvcm1hdCwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFVSTCB0byB0aGlzIGd1aWxkJ3MgaWNvbi5cbiAgICogQHBhcmFtIHtJbWFnZVVSTE9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgSW1hZ2UgVVJMXG4gICAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICAgKi9cbiAgaWNvblVSTCh7IGZvcm1hdCwgc2l6ZSwgZHluYW1pYyB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaWNvbikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2RuLkljb24odGhpcy5pZCwgdGhpcy5pY29uLCBmb3JtYXQsIHNpemUsIGR5bmFtaWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhpcyBndWlsZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRQcmV2aWV3Pn1cbiAgICovXG4gIGZldGNoKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5pZClcbiAgICAgIC5wcmV2aWV3LmdldCgpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5fcGF0Y2goZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIGd1aWxkJ3MgbmFtZSBpbnN0ZWFkIG9mIHRoZSBHdWlsZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExvZ3M6IEhlbGxvIGZyb20gTXkgR3VpbGQhXG4gICAqIGNvbnNvbGUubG9nKGBIZWxsbyBmcm9tICR7cHJldmlld0d1aWxkfSFgKTtcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QganNvbiA9IHN1cGVyLnRvSlNPTigpO1xuICAgIGpzb24uaWNvblVSTCA9IHRoaXMuaWNvblVSTCgpO1xuICAgIGpzb24uc3BsYXNoVVJMID0gdGhpcy5zcGxhc2hVUkwoKTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkUHJldmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUd1aWxkRW1vamkgPSByZXF1aXJlKCcuL0Jhc2VHdWlsZEVtb2ppJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhbiBlbW9qaSBiZWxvbmdpbmcgdG8gYSBwdWJsaWMgZ3VpbGQgb2J0YWluZWQgdGhyb3VnaCBEaXNjb3JkJ3MgcHJldmlldyBlbmRwb2ludC5cbiAqIEBleHRlbmRzIHtCYXNlR3VpbGRFbW9qaX1cbiAqL1xuY2xhc3MgR3VpbGRQcmV2aWV3RW1vamkgZXh0ZW5kcyBCYXNlR3VpbGRFbW9qaSB7XG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGd1aWxkIHRoaXMgZW1vamkgaXMgcGFydCBvZlxuICAgKiBAdHlwZSB7R3VpbGRQcmV2aWV3fVxuICAgKiBAbmFtZSBHdWlsZFByZXZpZXdFbW9qaSNndWlsZFxuICAgKi9cblxuICAvKipcbiAgICogU2V0IG9mIHJvbGVzIHRoaXMgZW1vamkgaXMgYWN0aXZlIGZvclxuICAgKiBAdHlwZSB7U2V0PFNub3dmbGFrZT59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJvbGVzKCkge1xuICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX3JvbGVzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1aWxkUHJldmlld0Vtb2ppO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IERhdGFSZXNvbHZlciA9IHJlcXVpcmUoJy4uL3V0aWwvRGF0YVJlc29sdmVyJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZm9yIGEgZ3VpbGQuXG4gKiBAZXh0ZW5kcyB7QmFzZX1cbiAqL1xuY2xhc3MgR3VpbGRUZW1wbGF0ZSBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCBUaGUgaW5zdGFudGlhdGluZyBjbGllbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIHJhdyBkYXRhIGZvciB0aGUgdGVtcGxhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgZGF0YSkge1xuICAgIHN1cGVyKGNsaWVudCk7XG4gICAgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG9yIHVwZGF0ZXMgdGhlIHRlbXBsYXRlIHdpdGggdGhlIHByb3ZpZGVkIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSByYXcgZGF0YSBmb3IgdGhlIHRlbXBsYXRlXG4gICAqIEByZXR1cm5zIHtHdWlsZFRlbXBsYXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIGNvZGUgb2YgdGhpcyB0ZW1wbGF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb2RlID0gZGF0YS5jb2RlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyB0ZW1wbGF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoaXMgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGF0YS5kZXNjcmlwdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgdGltZXMgdGhpcyB0ZW1wbGF0ZSBoYXMgYmVlbiB1c2VkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVzYWdlQ291bnQgPSBkYXRhLnVzYWdlX2NvdW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSB1c2VyIHRoYXQgY3JlYXRlZCB0aGlzIHRlbXBsYXRlXG4gICAgICogQHR5cGUge1Nub3dmbGFrZX1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0b3JJRCA9IGRhdGEuY3JlYXRvcl9pZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1c2VyIHRoYXQgY3JlYXRlZCB0aGlzIHRlbXBsYXRlXG4gICAgICogQHR5cGUge1VzZXJ9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdG9yID0gdGhpcy5jbGllbnQudXNlcnMuYWRkKGRhdGEuY3JlYXRvcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBvZiB3aGVuIHRoaXMgdGVtcGxhdGUgd2FzIGNyZWF0ZWQgYXRcbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZF9hdCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBvZiB3aGVuIHRoaXMgdGVtcGxhdGUgd2FzIGxhc3Qgc3luY2VkIHRvIHRoZSBndWlsZFxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkX2F0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgZ3VpbGQgdGhhdCB0aGlzIHRlbXBsYXRlIGJlbG9uZ3MgdG9cbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpbGRJRCA9IGRhdGEuc291cmNlX2d1aWxkX2lkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgb2YgdGhlIGd1aWxkIHRoYXQgdGhpcyB0ZW1wbGF0ZSB3b3VsZCBjcmVhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGlzY29yZC5jb20vZGV2ZWxvcGVycy9kb2NzL3Jlc291cmNlcy9ndWlsZCNndWlsZC1yZXNvdXJjZX1cbiAgICAgKi9cbiAgICB0aGlzLnNlcmlhbGl6ZWRHdWlsZCA9IGRhdGEuc2VyaWFsaXplZF9zb3VyY2VfZ3VpbGQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgdGVtcGxhdGUgaGFzIHVuc3luY2VkIGNoYW5nZXNcbiAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51blN5bmNlZCA9ICdpc19kaXJ0eScgaW4gZGF0YSA/IEJvb2xlYW4oZGF0YS5pc19kaXJ0eSkgOiBudWxsO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGd1aWxkIGJhc2VkIGZyb20gdGhpcyB0ZW1wbGF0ZS5cbiAgICogPHdhcm4+VGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB0byBib3RzIGluIGZld2VyIHRoYW4gMTAgZ3VpbGRzLjwvd2Fybj5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGd1aWxkXG4gICAqIEBwYXJhbSB7QnVmZmVyUmVzb2x2YWJsZXxCYXNlNjRSZXNvbHZhYmxlfSBbaWNvbl0gVGhlIGljb24gZm9yIHRoZSBndWlsZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZD59XG4gICAqL1xuICBhc3luYyBjcmVhdGVHdWlsZChuYW1lLCBpY29uKSB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHRoaXM7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGNsaWVudC5hcGkuZ3VpbGRzLnRlbXBsYXRlcyh0aGlzLmNvZGUpLnBvc3Qoe1xuICAgICAgZGF0YToge1xuICAgICAgICBuYW1lLFxuICAgICAgICBpY29uOiBhd2FpdCBEYXRhUmVzb2x2ZXIucmVzb2x2ZUltYWdlKGljb24pLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBjcmVhdGVkR3VpbGQgPSBjbGllbnQuZ3VpbGRzLmNhY2hlLmdldChkYXRhLmlkKTtcbiAgICAgIGlmIChjcmVhdGVkR3VpbGQpIHJldHVybiByZXNvbHZlKGNyZWF0ZWRHdWlsZCk7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVHdWlsZCA9IGd1aWxkID0+IHtcbiAgICAgICAgY2xpZW50Lm9mZihFdmVudHMuR1VJTERfQ1JFQVRFLCBoYW5kbGVHdWlsZCk7XG4gICAgICAgIGNsaWVudC5kZWNyZW1lbnRNYXhMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmVzb2x2ZShndWlsZCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBoYW5kbGVHdWlsZCA9IGd1aWxkID0+IHtcbiAgICAgICAgaWYgKGd1aWxkLmlkID09PSBkYXRhLmlkKSB7XG4gICAgICAgICAgY2xpZW50LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlR3VpbGQoZ3VpbGQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjbGllbnQuaW5jcmVtZW50TWF4TGlzdGVuZXJzKCk7XG4gICAgICBjbGllbnQub24oRXZlbnRzLkdVSUxEX0NSRUFURSwgaGFuZGxlR3VpbGQpO1xuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gY2xpZW50LnNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZUd1aWxkKGNsaWVudC5ndWlsZHMuYWRkKGRhdGEpKSwgMTAwMDApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG1ldGFkYXRhIG9uIHRoaXMgdGVtcGxhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gVGhlIG5hbWUgb2YgdGhpcyB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGlzIHRlbXBsYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkVGVtcGxhdGU+fVxuICAgKi9cbiAgZWRpdCh7IG5hbWUsIGRlc2NyaXB0aW9uIH0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5ndWlsZElEKVxuICAgICAgLnRlbXBsYXRlcyh0aGlzLmNvZGUpXG4gICAgICAucGF0Y2goeyBkYXRhOiB7IG5hbWUsIGRlc2NyaXB0aW9uIH0gfSlcbiAgICAgIC50aGVuKGRhdGEgPT4gdGhpcy5fcGF0Y2goZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhpcyB0ZW1wbGF0ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRUZW1wbGF0ZT59XG4gICAqL1xuICBkZWxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmd1aWxkcyh0aGlzLmd1aWxkSUQpXG4gICAgICAudGVtcGxhdGVzKHRoaXMuY29kZSlcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU3luY3MgdGhpcyB0ZW1wbGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ3VpbGQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkVGVtcGxhdGU+fVxuICAgKi9cbiAgc3luYygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuZ3VpbGRzKHRoaXMuZ3VpbGRJRClcbiAgICAgIC50ZW1wbGF0ZXModGhpcy5jb2RlKVxuICAgICAgLnB1dCgpXG4gICAgICAudGhlbihkYXRhID0+IHRoaXMuX3BhdGNoKGRhdGEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZXN0YW1wIG9mIHdoZW4gdGhpcyB0ZW1wbGF0ZSB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkVGltZXN0YW1wKCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZWRBdC5nZXRUaW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCBvZiB3aGVuIHRoaXMgdGVtcGxhdGUgd2FzIGxhc3Qgc3luY2VkIHRvIHRoZSBndWlsZFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB1cGRhdGVkVGltZXN0YW1wKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZWRBdC5nZXRUaW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGd1aWxkIHRoYXQgdGhpcyB0ZW1wbGF0ZSBiZWxvbmdzIHRvXG4gICAqIEB0eXBlIHs/R3VpbGR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGd1aWxkKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5ndWlsZHMuY2FjaGUuZ2V0KHRoaXMuZ3VpbGRJRCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVVJMIG9mIHRoaXMgdGVtcGxhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNsaWVudC5vcHRpb25zLmh0dHAudGVtcGxhdGV9LyR7dGhpcy5jb2RlfWA7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIHRlbXBsYXRlcydzIGNvZGUgaW5zdGVhZCBvZiB0aGUgdGVtcGxhdGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBMb2dzOiBUZW1wbGF0ZTogRkt2bWN6SDJIeVVmXG4gICAqIGNvbnNvbGUubG9nKGBUZW1wbGF0ZTogJHtndWlsZFRlbXBsYXRlfSFgKTtcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvZGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHdWlsZFRlbXBsYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCBJbnRlZ3JhdGlvbkFwcGxpY2F0aW9uID0gcmVxdWlyZSgnLi9JbnRlZ3JhdGlvbkFwcGxpY2F0aW9uJyk7XG5cbi8qKlxuICogVGhlIGluZm9ybWF0aW9uIGFjY291bnQgZm9yIGFuIGludGVncmF0aW9uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbnRlZ3JhdGlvbkFjY291bnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGFjY291bnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiAgUmVwcmVzZW50cyBhIGd1aWxkIGludGVncmF0aW9uLlxuICovXG5jbGFzcyBJbnRlZ3JhdGlvbiBleHRlbmRzIEJhc2Uge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGRhdGEsIGd1aWxkKSB7XG4gICAgc3VwZXIoY2xpZW50KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBndWlsZCB0aGlzIGludGVncmF0aW9uIGJlbG9uZ3MgdG9cbiAgICAgKiBAdHlwZSB7R3VpbGR9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZCA9IGd1aWxkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVncmF0aW9uIGlkXG4gICAgICogQHR5cGUge1Nub3dmbGFrZX1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gZGF0YS5pZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlZ3JhdGlvbiBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZWdyYXRpb24gdHlwZSAodHdpdGNoLCB5b3V0dWJlLCBldGMpXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBkYXRhLnR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgaW50ZWdyYXRpb24gaXMgZW5hYmxlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IGRhdGEuZW5hYmxlZDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBpbnRlZ3JhdGlvbiBpcyBzeW5jaW5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zeW5jaW5nID0gZGF0YS5zeW5jaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgdGhhdCB0aGlzIGludGVncmF0aW9uIHVzZXMgZm9yIHN1YnNjcmliZXJzXG4gICAgICogQHR5cGUge1JvbGV9XG4gICAgICovXG4gICAgdGhpcy5yb2xlID0gdGhpcy5ndWlsZC5yb2xlcy5jYWNoZS5nZXQoZGF0YS5yb2xlX2lkKTtcblxuICAgIGlmIChkYXRhLnVzZXIpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHVzZXIgZm9yIHRoaXMgaW50ZWdyYXRpb25cbiAgICAgICAqIEB0eXBlIHs/VXNlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy51c2VyID0gdGhpcy5jbGllbnQudXNlcnMuYWRkKGRhdGEudXNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXNlciA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFjY291bnQgaW50ZWdyYXRpb24gaW5mb3JtYXRpb25cbiAgICAgKiBAdHlwZSB7SW50ZWdyYXRpb25BY2NvdW50fVxuICAgICAqL1xuICAgIHRoaXMuYWNjb3VudCA9IGRhdGEuYWNjb3VudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IHRpbWUgdGhpcyBpbnRlZ3JhdGlvbiB3YXMgbGFzdCBzeW5jZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3luY2VkQXQgPSBkYXRhLnN5bmNlZF9hdDtcbiAgICB0aGlzLl9wYXRjaChkYXRhKTtcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGJlaGF2aW9yIG9mIGV4cGlyaW5nIHN1YnNjcmliZXJzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmV4cGlyZUJlaGF2aW9yID0gZGF0YS5leHBpcmVfYmVoYXZpb3I7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3JhY2UgcGVyaW9kIGJlZm9yZSBleHBpcmluZyBzdWJzY3JpYmVyc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHBpcmVHcmFjZVBlcmlvZCA9IGRhdGEuZXhwaXJlX2dyYWNlX3BlcmlvZDtcblxuICAgIGlmICgnYXBwbGljYXRpb24nIGluIGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uX3BhdGNoKGRhdGEuYXBwbGljYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcHBsaWNhdGlvbiBmb3IgdGhpcyBpbnRlZ3JhdGlvblxuICAgICAgICAgKiBAdHlwZSB7P0ludGVncmF0aW9uQXBwbGljYXRpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gbmV3IEludGVncmF0aW9uQXBwbGljYXRpb24odGhpcy5jbGllbnQsIGRhdGEuYXBwbGljYXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuYXBwbGljYXRpb24pIHtcbiAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jIHRoaXMgaW50ZWdyYXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8SW50ZWdyYXRpb24+fVxuICAgKi9cbiAgc3luYygpIHtcbiAgICB0aGlzLnN5bmNpbmcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5ndWlsZC5pZClcbiAgICAgIC5pbnRlZ3JhdGlvbnModGhpcy5pZClcbiAgICAgIC5wb3N0KClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5zeW5jaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luY2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIGZvciBlZGl0aW5nIGFuIGludGVncmF0aW9uLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJbnRlZ3JhdGlvbkVkaXREYXRhXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZXhwaXJlQmVoYXZpb3JdIFRoZSBuZXcgYmVoYXZpb3VyIG9mIGV4cGlyaW5nIHN1YnNjcmliZXJzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZXhwaXJlR3JhY2VQZXJpb2RdIFRoZSBuZXcgZ3JhY2UgcGVyaW9kIGJlZm9yZSBleHBpcmluZyBzdWJzY3JpYmVyc1xuICAgKi9cblxuICAvKipcbiAgICogRWRpdHMgdGhpcyBpbnRlZ3JhdGlvbi5cbiAgICogQHBhcmFtIHtJbnRlZ3JhdGlvbkVkaXREYXRhfSBkYXRhIFRoZSBkYXRhIHRvIGVkaXQgdGhpcyBpbnRlZ3JhdGlvbiB3aXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gUmVhc29uIGZvciBlZGl0aW5nIHRoaXMgaW50ZWdyYXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8SW50ZWdyYXRpb24+fVxuICAgKi9cbiAgZWRpdChkYXRhLCByZWFzb24pIHtcbiAgICBpZiAoJ2V4cGlyZUJlaGF2aW9yJyBpbiBkYXRhKSB7XG4gICAgICBkYXRhLmV4cGlyZV9iZWhhdmlvciA9IGRhdGEuZXhwaXJlQmVoYXZpb3I7XG4gICAgICBkYXRhLmV4cGlyZUJlaGF2aW9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCdleHBpcmVHcmFjZVBlcmlvZCcgaW4gZGF0YSkge1xuICAgICAgZGF0YS5leHBpcmVfZ3JhY2VfcGVyaW9kID0gZGF0YS5leHBpcmVHcmFjZVBlcmlvZDtcbiAgICAgIGRhdGEuZXhwaXJlR3JhY2VQZXJpb2QgPSBudWxsO1xuICAgIH1cbiAgICAvLyBUaGUgb3B0aW9uIGVuYWJsZV9lbW90aWNvbnMgaXMgb25seSBhdmFpbGFibGUgZm9yIFR3aXRjaCBhdCB0aGlzIG1vbWVudFxuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5ndWlsZC5pZClcbiAgICAgIC5pbnRlZ3JhdGlvbnModGhpcy5pZClcbiAgICAgIC5wYXRjaCh7IGRhdGEsIHJlYXNvbiB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9wYXRjaChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoaXMgaW50ZWdyYXRpb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEludGVncmF0aW9uPn1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgZGVsZXRpbmcgdGhpcyBpbnRlZ3JhdGlvblxuICAgKi9cbiAgZGVsZXRlKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5ndWlsZHModGhpcy5ndWlsZC5pZClcbiAgICAgIC5pbnRlZ3JhdGlvbnModGhpcy5pZClcbiAgICAgIC5kZWxldGUoeyByZWFzb24gfSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oe1xuICAgICAgcm9sZTogJ3JvbGVJRCcsXG4gICAgICBndWlsZDogJ2d1aWxkSUQnLFxuICAgICAgdXNlcjogJ3VzZXJJRCcsXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ3JhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXBwbGljYXRpb24gPSByZXF1aXJlKCcuL2ludGVyZmFjZXMvQXBwbGljYXRpb24nKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEludGVncmF0aW9uJ3MgT0F1dGgyIEFwcGxpY2F0aW9uLlxuICogQGV4dGVuZHMge0FwcGxpY2F0aW9ufVxuICovXG5jbGFzcyBJbnRlZ3JhdGlvbkFwcGxpY2F0aW9uIGV4dGVuZHMgQXBwbGljYXRpb24ge1xuICBfcGF0Y2goZGF0YSkge1xuICAgIHN1cGVyLl9wYXRjaChkYXRhKTtcblxuICAgIGlmICh0eXBlb2YgZGF0YS5ib3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBib3Qge0BsaW5rIFVzZXIgdXNlcn0gZm9yIHRoaXMgYXBwbGljYXRpb25cbiAgICAgICAqIEB0eXBlIHs/VXNlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5ib3QgPSB0aGlzLmNsaWVudC51c2Vycy5hZGQoZGF0YS5ib3QpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuYm90KSB7XG4gICAgICB0aGlzLmJvdCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZWdyYXRpb25BcHBsaWNhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuY29uc3QgeyBFbmRwb2ludHMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5jb25zdCBQZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvUGVybWlzc2lvbnMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGludml0YXRpb24gdG8gYSBndWlsZCBjaGFubmVsLlxuICogPHdhcm4+VGhlIG9ubHkgZ3VhcmFudGVlZCBwcm9wZXJ0aWVzIGFyZSBgY29kZWAsIGBjaGFubmVsYCwgYW5kIGB1cmxgLiBPdGhlciBwcm9wZXJ0aWVzIGNhbiBiZSBtaXNzaW5nLjwvd2Fybj5cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBJbnZpdGUgZXh0ZW5kcyBCYXNlIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhKSB7XG4gICAgc3VwZXIoY2xpZW50KTtcbiAgICB0aGlzLl9wYXRjaChkYXRhKTtcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGd1aWxkIHRoZSBpbnZpdGUgaXMgZm9yXG4gICAgICogQHR5cGUgez9HdWlsZH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWxkID0gZGF0YS5ndWlsZCA/IHRoaXMuY2xpZW50Lmd1aWxkcy5hZGQoZGF0YS5ndWlsZCwgZmFsc2UpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb2RlIGZvciB0aGlzIGludml0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb2RlID0gZGF0YS5jb2RlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiBvbmxpbmUgbWVtYmVycyBvZiB0aGUgZ3VpbGQgdGhpcyBpbnZpdGUgaXMgZm9yXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmVzZW5jZUNvdW50ID0gJ2FwcHJveGltYXRlX3ByZXNlbmNlX2NvdW50JyBpbiBkYXRhID8gZGF0YS5hcHByb3hpbWF0ZV9wcmVzZW5jZV9jb3VudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwcm94aW1hdGUgdG90YWwgbnVtYmVyIG9mIG1lbWJlcnMgb2YgdGhlIGd1aWxkIHRoaXMgaW52aXRlIGlzIGZvclxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWVtYmVyQ291bnQgPSAnYXBwcm94aW1hdGVfbWVtYmVyX2NvdW50JyBpbiBkYXRhID8gZGF0YS5hcHByb3hpbWF0ZV9tZW1iZXJfY291bnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhpcyBpbnZpdGUgaXMgdGVtcG9yYXJ5XG4gICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudGVtcG9yYXJ5ID0gJ3RlbXBvcmFyeScgaW4gZGF0YSA/IGRhdGEudGVtcG9yYXJ5IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGFnZSBvZiB0aGUgaW52aXRlLCBpbiBzZWNvbmRzLCAwIGlmIG5ldmVyIGV4cGlyZXNcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heEFnZSA9ICdtYXhfYWdlJyBpbiBkYXRhID8gZGF0YS5tYXhfYWdlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IHRpbWVzIHRoaXMgaW52aXRlIGhhcyBiZWVuIHVzZWRcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXMgPSAndXNlcycgaW4gZGF0YSA/IGRhdGEudXNlcyA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB1c2VzIG9mIHRoaXMgaW52aXRlXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhVc2VzID0gJ21heF91c2VzJyBpbiBkYXRhID8gZGF0YS5tYXhfdXNlcyA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciB3aG8gY3JlYXRlZCB0aGlzIGludml0ZVxuICAgICAqIEB0eXBlIHs/VXNlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludml0ZXIgPSBkYXRhLmludml0ZXIgPyB0aGlzLmNsaWVudC51c2Vycy5hZGQoZGF0YS5pbnZpdGVyKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IHVzZXIgZm9yIHRoaXMgaW52aXRlXG4gICAgICogQHR5cGUgez9Vc2VyfVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VXNlciA9IGRhdGEudGFyZ2V0X3VzZXIgPyB0aGlzLmNsaWVudC51c2Vycy5hZGQoZGF0YS50YXJnZXRfdXNlcikgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHRhcmdldCB1c2VyOlxuICAgICAqICogMTogU1RSRUFNXG4gICAgICogQHR5cGVkZWYge251bWJlcn0gVGFyZ2V0VXNlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCB1c2VyIHR5cGVcbiAgICAgKiBAdHlwZSB7P1RhcmdldFVzZXJ9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRVc2VyVHlwZSA9IHR5cGVvZiBkYXRhLnRhcmdldF91c2VyX3R5cGUgPT09ICdudW1iZXInID8gZGF0YS50YXJnZXRfdXNlcl90eXBlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjaGFubmVsIHRoZSBpbnZpdGUgaXMgZm9yXG4gICAgICogQHR5cGUge0NoYW5uZWx9XG4gICAgICovXG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5jbGllbnQuY2hhbm5lbHMuYWRkKGRhdGEuY2hhbm5lbCwgdGhpcy5ndWlsZCwgZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVzdGFtcCB0aGUgaW52aXRlIHdhcyBjcmVhdGVkIGF0XG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVkVGltZXN0YW1wID0gJ2NyZWF0ZWRfYXQnIGluIGRhdGEgPyBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRfYXQpLmdldFRpbWUoKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIGludml0ZSB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7P0RhdGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVkVGltZXN0YW1wID8gbmV3IERhdGUodGhpcy5jcmVhdGVkVGltZXN0YW1wKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgaW52aXRlIGlzIGRlbGV0YWJsZSBieSB0aGUgY2xpZW50IHVzZXJcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlbGV0YWJsZSgpIHtcbiAgICBjb25zdCBndWlsZCA9IHRoaXMuZ3VpbGQ7XG4gICAgaWYgKCFndWlsZCB8fCAhdGhpcy5jbGllbnQuZ3VpbGRzLmNhY2hlLmhhcyhndWlsZC5pZCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWd1aWxkLm1lKSB0aHJvdyBuZXcgRXJyb3IoJ0dVSUxEX1VOQ0FDSEVEX01FJyk7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuY2hhbm5lbC5wZXJtaXNzaW9uc0Zvcih0aGlzLmNsaWVudC51c2VyKS5oYXMoUGVybWlzc2lvbnMuRkxBR1MuTUFOQUdFX0NIQU5ORUxTLCBmYWxzZSkgfHxcbiAgICAgIGd1aWxkLm1lLnBlcm1pc3Npb25zLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5NQU5BR0VfR1VJTEQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZXN0YW1wIHRoZSBpbnZpdGUgd2lsbCBleHBpcmUgYXRcbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGV4cGlyZXNUaW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlZFRpbWVzdGFtcCAmJiB0aGlzLm1heEFnZSA/IHRoaXMuY3JlYXRlZFRpbWVzdGFtcCArIHRoaXMubWF4QWdlICogMTAwMCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIGludml0ZSB3aWxsIGV4cGlyZSBhdFxuICAgKiBAdHlwZSB7P0RhdGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGV4cGlyZXNBdCgpIHtcbiAgICBjb25zdCB7IGV4cGlyZXNUaW1lc3RhbXAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGV4cGlyZXNUaW1lc3RhbXAgPyBuZXcgRGF0ZShleHBpcmVzVGltZXN0YW1wKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFVSTCB0byB0aGUgaW52aXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gRW5kcG9pbnRzLmludml0ZSh0aGlzLmNsaWVudC5vcHRpb25zLmh0dHAuaW52aXRlLCB0aGlzLmNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhpcyBpbnZpdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGRlbGV0aW5nIHRoaXMgaW52aXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEludml0ZT59XG4gICAqL1xuICBkZWxldGUocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaS5pbnZpdGVzW3RoaXMuY29kZV0uZGVsZXRlKHsgcmVhc29uIH0pLnRoZW4oKCkgPT4gdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IGNvbmNhdGVuYXRlcyB0aGUgaW52aXRlJ3MgVVJMIGluc3RlYWQgb2YgdGhlIG9iamVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gTG9nczogSW52aXRlOiBodHRwczovL2Rpc2NvcmQuZ2cvQTFiMkMzXG4gICAqIGNvbnNvbGUubG9nKGBJbnZpdGU6ICR7aW52aXRlfWApO1xuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oe1xuICAgICAgdXJsOiB0cnVlLFxuICAgICAgZXhwaXJlc1RpbWVzdGFtcDogdHJ1ZSxcbiAgICAgIHByZXNlbmNlQ291bnQ6IGZhbHNlLFxuICAgICAgbWVtYmVyQ291bnQ6IGZhbHNlLFxuICAgICAgdXNlczogZmFsc2UsXG4gICAgICBjaGFubmVsOiAnY2hhbm5lbElEJyxcbiAgICAgIGludml0ZXI6ICdpbnZpdGVySUQnLFxuICAgICAgZ3VpbGQ6ICdndWlsZElEJyxcbiAgICB9KTtcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludml0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQVBJTWVzc2FnZSA9IHJlcXVpcmUoJy4vQVBJTWVzc2FnZScpO1xuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuY29uc3QgQ2xpZW50QXBwbGljYXRpb24gPSByZXF1aXJlKCcuL0NsaWVudEFwcGxpY2F0aW9uJyk7XG5jb25zdCBNZXNzYWdlQXR0YWNobWVudCA9IHJlcXVpcmUoJy4vTWVzc2FnZUF0dGFjaG1lbnQnKTtcbmNvbnN0IEVtYmVkID0gcmVxdWlyZSgnLi9NZXNzYWdlRW1iZWQnKTtcbmNvbnN0IE1lbnRpb25zID0gcmVxdWlyZSgnLi9NZXNzYWdlTWVudGlvbnMnKTtcbmNvbnN0IFJlYWN0aW9uQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9SZWFjdGlvbkNvbGxlY3RvcicpO1xuY29uc3QgeyBFcnJvciwgVHlwZUVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlYWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uL21hbmFnZXJzL1JlYWN0aW9uTWFuYWdlcicpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuY29uc3QgeyBNZXNzYWdlVHlwZXMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5jb25zdCBNZXNzYWdlRmxhZ3MgPSByZXF1aXJlKCcuLi91dGlsL01lc3NhZ2VGbGFncycpO1xuY29uc3QgUGVybWlzc2lvbnMgPSByZXF1aXJlKCcuLi91dGlsL1Blcm1pc3Npb25zJyk7XG5jb25zdCBTbm93Zmxha2VVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9Tbm93Zmxha2UnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWVzc2FnZSBvbiBEaXNjb3JkLlxuICogQGV4dGVuZHMge0Jhc2V9XG4gKi9cbmNsYXNzIE1lc3NhZ2UgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnQgVGhlIGluc3RhbnRpYXRpbmcgY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge1RleHRDaGFubmVsfERNQ2hhbm5lbHxOZXdzQ2hhbm5lbH0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0aGUgbWVzc2FnZSB3YXMgc2VudCBpblxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhLCBjaGFubmVsKSB7XG4gICAgc3VwZXIoY2xpZW50KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjaGFubmVsIHRoYXQgdGhlIG1lc3NhZ2Ugd2FzIHNlbnQgaW5cbiAgICAgKiBAdHlwZSB7VGV4dENoYW5uZWx8RE1DaGFubmVsfE5ld3NDaGFubmVsfVxuICAgICAqL1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgbWVzc2FnZSBoYXMgYmVlbiBkZWxldGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZGF0YSkgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgbWVzc2FnZVxuICAgICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG5cbiAgICBpZiAoJ3R5cGUnIGluIGRhdGEpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAqIEB0eXBlIHs/TWVzc2FnZVR5cGV9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlc1tkYXRhLnR5cGVdO1xuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgbWVzc2FnZSB3YXMgc2VudCBieSBEaXNjb3JkLCBub3QgYWN0dWFsbHkgYSB1c2VyIChlLmcuIHBpbiBub3RpZmljYXRpb25zKVxuICAgICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAgICovXG4gICAgICB0aGlzLnN5c3RlbSA9IGRhdGEudHlwZSAhPT0gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnN5c3RlbSA9IG51bGw7XG4gICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnY29udGVudCcgaW4gZGF0YSkge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZVxuICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29udGVudCA9IGRhdGEuY29udGVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnYXV0aG9yJyBpbiBkYXRhKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBhdXRob3Igb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAqIEB0eXBlIHs/VXNlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5hdXRob3IgPSB0aGlzLmNsaWVudC51c2Vycy5hZGQoZGF0YS5hdXRob3IsICFkYXRhLndlYmhvb2tfaWQpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuYXV0aG9yKSB7XG4gICAgICB0aGlzLmF1dGhvciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdwaW5uZWQnIGluIGRhdGEpIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBtZXNzYWdlIGlzIHBpbm5lZFxuICAgICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAgICovXG4gICAgICB0aGlzLnBpbm5lZCA9IEJvb2xlYW4oZGF0YS5waW5uZWQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMucGlubmVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMucGlubmVkID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ3R0cycgaW4gZGF0YSkge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbWVzc2FnZSB3YXMgVGV4dC1Uby1TcGVlY2hcbiAgICAgICAqIEB0eXBlIHs/Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgdGhpcy50dHMgPSBkYXRhLnR0cztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnR0cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnR0cyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSByYW5kb20gbnVtYmVyIG9yIHN0cmluZyB1c2VkIGZvciBjaGVja2luZyBtZXNzYWdlIGRlbGl2ZXJ5XG4gICAgICogPHdhcm4+VGhpcyBpcyBvbmx5IHJlY2VpdmVkIGFmdGVyIHRoZSBtZXNzYWdlIHdhcyBzZW50IHN1Y2Nlc3NmdWxseSwgYW5kXG4gICAgICogbG9zdCBpZiByZS1mZXRjaGVkPC93YXJuPlxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubm9uY2UgPSAnbm9uY2UnIGluIGRhdGEgPyBkYXRhLm5vbmNlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBlbWJlZHMgaW4gdGhlIG1lc3NhZ2UgLSBlLmcuIFlvdVR1YmUgUGxheWVyXG4gICAgICogQHR5cGUge01lc3NhZ2VFbWJlZFtdfVxuICAgICAqL1xuICAgIHRoaXMuZW1iZWRzID0gKGRhdGEuZW1iZWRzIHx8IFtdKS5tYXAoZSA9PiBuZXcgRW1iZWQoZSwgdHJ1ZSkpO1xuXG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIGF0dGFjaG1lbnRzIGluIHRoZSBtZXNzYWdlIC0gZS5nLiBQaWN0dXJlcyAtIG1hcHBlZCBieSB0aGVpciBJRFxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgTWVzc2FnZUF0dGFjaG1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuYXR0YWNobWVudHMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIGlmIChkYXRhLmF0dGFjaG1lbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgZGF0YS5hdHRhY2htZW50cykge1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRzLnNldChhdHRhY2htZW50LmlkLCBuZXcgTWVzc2FnZUF0dGFjaG1lbnQoYXR0YWNobWVudC51cmwsIGF0dGFjaG1lbnQuZmlsZW5hbWUsIGF0dGFjaG1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXN0YW1wIHRoZSBtZXNzYWdlIHdhcyBzZW50IGF0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPSBTbm93Zmxha2VVdGlsLmRlY29uc3RydWN0KHRoaXMuaWQpLnRpbWVzdGFtcDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lc3RhbXAgdGhlIG1lc3NhZ2Ugd2FzIGxhc3QgZWRpdGVkIGF0IChpZiBhcHBsaWNhYmxlKVxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZWRpdGVkVGltZXN0YW1wID0gJ2VkaXRlZF90aW1lc3RhbXAnIGluIGRhdGEgPyBuZXcgRGF0ZShkYXRhLmVkaXRlZF90aW1lc3RhbXApLmdldFRpbWUoKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hbmFnZXIgb2YgdGhlIHJlYWN0aW9ucyBiZWxvbmdpbmcgdG8gdGhpcyBtZXNzYWdlXG4gICAgICogQHR5cGUge1JlYWN0aW9uTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWN0aW9ucyA9IG5ldyBSZWFjdGlvbk1hbmFnZXIodGhpcyk7XG4gICAgaWYgKGRhdGEucmVhY3Rpb25zICYmIGRhdGEucmVhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgcmVhY3Rpb24gb2YgZGF0YS5yZWFjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZWFjdGlvbnMuYWRkKHJlYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGwgdmFsaWQgbWVudGlvbnMgdGhhdCB0aGUgbWVzc2FnZSBjb250YWluc1xuICAgICAqIEB0eXBlIHtNZXNzYWdlTWVudGlvbnN9XG4gICAgICovXG4gICAgdGhpcy5tZW50aW9ucyA9IG5ldyBNZW50aW9ucyh0aGlzLCBkYXRhLm1lbnRpb25zLCBkYXRhLm1lbnRpb25fcm9sZXMsIGRhdGEubWVudGlvbl9ldmVyeW9uZSwgZGF0YS5tZW50aW9uX2NoYW5uZWxzKTtcblxuICAgIC8qKlxuICAgICAqIElEIG9mIHRoZSB3ZWJob29rIHRoYXQgc2VudCB0aGUgbWVzc2FnZSwgaWYgYXBwbGljYWJsZVxuICAgICAqIEB0eXBlIHs/U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMud2ViaG9va0lEID0gZGF0YS53ZWJob29rX2lkIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTdXBwbGVtZW50YWwgYXBwbGljYXRpb24gaW5mb3JtYXRpb24gZm9yIGdyb3VwIGFjdGl2aXRpZXNcbiAgICAgKiBAdHlwZSB7P0NsaWVudEFwcGxpY2F0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYXBwbGljYXRpb24gPSBkYXRhLmFwcGxpY2F0aW9uID8gbmV3IENsaWVudEFwcGxpY2F0aW9uKHRoaXMuY2xpZW50LCBkYXRhLmFwcGxpY2F0aW9uKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBHcm91cCBhY3Rpdml0eVxuICAgICAqIEB0eXBlIHs/TWVzc2FnZUFjdGl2aXR5fVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZpdHkgPSBkYXRhLmFjdGl2aXR5XG4gICAgICA/IHtcbiAgICAgICAgICBwYXJ0eUlEOiBkYXRhLmFjdGl2aXR5LnBhcnR5X2lkLFxuICAgICAgICAgIHR5cGU6IGRhdGEuYWN0aXZpdHkudHlwZSxcbiAgICAgICAgfVxuICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHZlcnNpb25zIG9mIHRoZSBtZXNzYWdlLCBzb3J0ZWQgd2l0aCB0aGUgbW9zdCByZWNlbnQgZmlyc3RcbiAgICAgKiBAdHlwZSB7TWVzc2FnZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZWRpdHMgPSBbXTtcblxuICAgIGlmICh0aGlzLm1lbWJlciAmJiBkYXRhLm1lbWJlcikge1xuICAgICAgdGhpcy5tZW1iZXIuX3BhdGNoKGRhdGEubWVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEubWVtYmVyICYmIHRoaXMuZ3VpbGQgJiYgdGhpcy5hdXRob3IpIHtcbiAgICAgIHRoaXMuZ3VpbGQubWVtYmVycy5hZGQoT2JqZWN0LmFzc2lnbihkYXRhLm1lbWJlciwgeyB1c2VyOiB0aGlzLmF1dGhvciB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhZ3MgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgbWVzc2FnZVxuICAgICAqIEB0eXBlIHtSZWFkb25seTxNZXNzYWdlRmxhZ3M+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSBuZXcgTWVzc2FnZUZsYWdzKGRhdGEuZmxhZ3MpLmZyZWV6ZSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIGRhdGEgc2VudCBpbiBhIGNyb3NzcG9zdGVkIG1lc3NhZ2UuXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZVJlZmVyZW5jZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjaGFubmVsSUQgSUQgb2YgdGhlIGNoYW5uZWwgdGhlIG1lc3NhZ2Ugd2FzIGNyb3NzcG9zdGVkIGZyb21cbiAgICAgKiBAcHJvcGVydHkgez9zdHJpbmd9IGd1aWxkSUQgSUQgb2YgdGhlIGd1aWxkIHRoZSBtZXNzYWdlIHdhcyBjcm9zc3Bvc3RlZCBmcm9tXG4gICAgICogQHByb3BlcnR5IHs/c3RyaW5nfSBtZXNzYWdlSUQgSUQgb2YgdGhlIG1lc3NhZ2UgdGhhdCB3YXMgY3Jvc3Nwb3N0ZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgcmVmZXJlbmNlIGRhdGFcbiAgICAgKiBAdHlwZSB7P01lc3NhZ2VSZWZlcmVuY2V9XG4gICAgICovXG4gICAgdGhpcy5yZWZlcmVuY2UgPSBkYXRhLm1lc3NhZ2VfcmVmZXJlbmNlXG4gICAgICA/IHtcbiAgICAgICAgICBjaGFubmVsSUQ6IGRhdGEubWVzc2FnZV9yZWZlcmVuY2UuY2hhbm5lbF9pZCxcbiAgICAgICAgICBndWlsZElEOiBkYXRhLm1lc3NhZ2VfcmVmZXJlbmNlLmd1aWxkX2lkLFxuICAgICAgICAgIG1lc3NhZ2VJRDogZGF0YS5tZXNzYWdlX3JlZmVyZW5jZS5tZXNzYWdlX2lkLFxuICAgICAgICB9XG4gICAgICA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhpcyBtZXNzYWdlIGlzIGEgcGFydGlhbFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFydGlhbCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuY29udGVudCAhPT0gJ3N0cmluZycgfHwgIXRoaXMuYXV0aG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG1lc3NhZ2UgYW5kIHJldHVybnMgdGhlIG9sZCBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBSYXcgRGlzY29yZCBtZXNzYWdlIHVwZGF0ZSBkYXRhXG4gICAqIEByZXR1cm5zIHtNZXNzYWdlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGF0Y2goZGF0YSkge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fY2xvbmUoKTtcbiAgICBjb25zdCB7IG1lc3NhZ2VFZGl0SGlzdG9yeU1heFNpemUgfSA9IHRoaXMuY2xpZW50Lm9wdGlvbnM7XG4gICAgaWYgKG1lc3NhZ2VFZGl0SGlzdG9yeU1heFNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGVkaXRzTGltaXQgPSBtZXNzYWdlRWRpdEhpc3RvcnlNYXhTaXplID09PSAtMSA/IEluZmluaXR5IDogbWVzc2FnZUVkaXRIaXN0b3J5TWF4U2l6ZTtcbiAgICAgIGlmICh0aGlzLl9lZGl0cy51bnNoaWZ0KGNsb25lKSA+IGVkaXRzTGltaXQpIHRoaXMuX2VkaXRzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmICgnZWRpdGVkX3RpbWVzdGFtcCcgaW4gZGF0YSkgdGhpcy5lZGl0ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZShkYXRhLmVkaXRlZF90aW1lc3RhbXApLmdldFRpbWUoKTtcbiAgICBpZiAoJ2NvbnRlbnQnIGluIGRhdGEpIHRoaXMuY29udGVudCA9IGRhdGEuY29udGVudDtcbiAgICBpZiAoJ3Bpbm5lZCcgaW4gZGF0YSkgdGhpcy5waW5uZWQgPSBkYXRhLnBpbm5lZDtcbiAgICBpZiAoJ3R0cycgaW4gZGF0YSkgdGhpcy50dHMgPSBkYXRhLnR0cztcbiAgICBpZiAoJ2VtYmVkcycgaW4gZGF0YSkgdGhpcy5lbWJlZHMgPSBkYXRhLmVtYmVkcy5tYXAoZSA9PiBuZXcgRW1iZWQoZSwgdHJ1ZSkpO1xuICAgIGVsc2UgdGhpcy5lbWJlZHMgPSB0aGlzLmVtYmVkcy5zbGljZSgpO1xuXG4gICAgaWYgKCdhdHRhY2htZW50cycgaW4gZGF0YSkge1xuICAgICAgdGhpcy5hdHRhY2htZW50cyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgZGF0YS5hdHRhY2htZW50cykge1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRzLnNldChhdHRhY2htZW50LmlkLCBuZXcgTWVzc2FnZUF0dGFjaG1lbnQoYXR0YWNobWVudC51cmwsIGF0dGFjaG1lbnQuZmlsZW5hbWUsIGF0dGFjaG1lbnQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2htZW50cyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuYXR0YWNobWVudHMpO1xuICAgIH1cblxuICAgIHRoaXMubWVudGlvbnMgPSBuZXcgTWVudGlvbnMoXG4gICAgICB0aGlzLFxuICAgICAgJ21lbnRpb25zJyBpbiBkYXRhID8gZGF0YS5tZW50aW9ucyA6IHRoaXMubWVudGlvbnMudXNlcnMsXG4gICAgICAnbWVudGlvbl9yb2xlcycgaW4gZGF0YSA/IGRhdGEubWVudGlvbl9yb2xlcyA6IHRoaXMubWVudGlvbnMucm9sZXMsXG4gICAgICAnbWVudGlvbl9ldmVyeW9uZScgaW4gZGF0YSA/IGRhdGEubWVudGlvbl9ldmVyeW9uZSA6IHRoaXMubWVudGlvbnMuZXZlcnlvbmUsXG4gICAgICAnbWVudGlvbl9jaGFubmVscycgaW4gZGF0YSA/IGRhdGEubWVudGlvbl9jaGFubmVscyA6IHRoaXMubWVudGlvbnMuY3Jvc3Nwb3N0ZWRDaGFubmVscyxcbiAgICApO1xuXG4gICAgdGhpcy5mbGFncyA9IG5ldyBNZXNzYWdlRmxhZ3MoJ2ZsYWdzJyBpbiBkYXRhID8gZGF0YS5mbGFncyA6IDApLmZyZWV6ZSgpO1xuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIGF1dGhvciBvZiB0aGUgbWVzc2FnZSBhcyBhIGd1aWxkIG1lbWJlci5cbiAgICogT25seSBhdmFpbGFibGUgaWYgdGhlIG1lc3NhZ2UgY29tZXMgZnJvbSBhIGd1aWxkIHdoZXJlIHRoZSBhdXRob3IgaXMgc3RpbGwgYSBtZW1iZXJcbiAgICogQHR5cGUgez9HdWlsZE1lbWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmd1aWxkID8gdGhpcy5ndWlsZC5tZW1iZXIodGhpcy5hdXRob3IpIHx8IG51bGwgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBtZXNzYWdlIHdhcyBzZW50IGF0XG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkQXQoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuY3JlYXRlZFRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIG1lc3NhZ2Ugd2FzIGxhc3QgZWRpdGVkIGF0IChpZiBhcHBsaWNhYmxlKVxuICAgKiBAdHlwZSB7P0RhdGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGVkaXRlZEF0KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRlZFRpbWVzdGFtcCA/IG5ldyBEYXRlKHRoaXMuZWRpdGVkVGltZXN0YW1wKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGd1aWxkIHRoZSBtZXNzYWdlIHdhcyBzZW50IGluIChpZiBpbiBhIGd1aWxkIGNoYW5uZWwpXG4gICAqIEB0eXBlIHs/R3VpbGR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGd1aWxkKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ3VpbGQgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdXJsIHRvIGp1bXAgdG8gdGhpcyBtZXNzYWdlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvJHt0aGlzLmd1aWxkID8gdGhpcy5ndWlsZC5pZCA6ICdAbWUnfS8ke3RoaXMuY2hhbm5lbC5pZH0vJHt0aGlzLmlkfWA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1lc3NhZ2UgY29udGVudHMgd2l0aCBhbGwgbWVudGlvbnMgcmVwbGFjZWQgYnkgdGhlIGVxdWl2YWxlbnQgdGV4dC5cbiAgICogSWYgbWVudGlvbnMgY2Fubm90IGJlIHJlc29sdmVkIHRvIGEgbmFtZSwgdGhlIHJlbGV2YW50IG1lbnRpb24gaW4gdGhlIG1lc3NhZ2UgY29udGVudCB3aWxsIG5vdCBiZSBjb252ZXJ0ZWQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNsZWFuQ29udGVudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgcmV0dXJuIHRoaXMuY29udGVudCAhPSBudWxsID8gVXRpbC5jbGVhbkNvbnRlbnQodGhpcy5jb250ZW50LCB0aGlzKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlYWN0aW9uIGNvbGxlY3Rvci5cbiAgICogQHBhcmFtIHtDb2xsZWN0b3JGaWx0ZXJ9IGZpbHRlciBUaGUgZmlsdGVyIHRvIGFwcGx5XG4gICAqIEBwYXJhbSB7UmVhY3Rpb25Db2xsZWN0b3JPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyB0byBzZW5kIHRvIHRoZSBjb2xsZWN0b3JcbiAgICogQHJldHVybnMge1JlYWN0aW9uQ29sbGVjdG9yfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBDcmVhdGUgYSByZWFjdGlvbiBjb2xsZWN0b3JcbiAgICogY29uc3QgZmlsdGVyID0gKHJlYWN0aW9uLCB1c2VyKSA9PiByZWFjdGlvbi5lbW9qaS5uYW1lID09PSAn8J+RjCcgJiYgdXNlci5pZCA9PT0gJ3NvbWVJRCc7XG4gICAqIGNvbnN0IGNvbGxlY3RvciA9IG1lc3NhZ2UuY3JlYXRlUmVhY3Rpb25Db2xsZWN0b3IoZmlsdGVyLCB7IHRpbWU6IDE1MDAwIH0pO1xuICAgKiBjb2xsZWN0b3Iub24oJ2NvbGxlY3QnLCByID0+IGNvbnNvbGUubG9nKGBDb2xsZWN0ZWQgJHtyLmVtb2ppLm5hbWV9YCkpO1xuICAgKiBjb2xsZWN0b3Iub24oJ2VuZCcsIGNvbGxlY3RlZCA9PiBjb25zb2xlLmxvZyhgQ29sbGVjdGVkICR7Y29sbGVjdGVkLnNpemV9IGl0ZW1zYCkpO1xuICAgKi9cbiAgY3JlYXRlUmVhY3Rpb25Db2xsZWN0b3IoZmlsdGVyLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0aW9uQ29sbGVjdG9yKHRoaXMsIGZpbHRlciwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBDb2xsZWN0b3JPcHRpb25zLCBidXQgYSBmZXcgbW9yZTpcbiAgICogQHR5cGVkZWYge1JlYWN0aW9uQ29sbGVjdG9yT3B0aW9uc30gQXdhaXRSZWFjdGlvbnNPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtlcnJvcnNdIFN0b3AvZW5kIHJlYXNvbnMgdGhhdCBjYXVzZSB0aGUgcHJvbWlzZSB0byByZWplY3RcbiAgICovXG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gY3JlYXRlUmVhY3Rpb25Db2xsZWN0b3IgYnV0IGluIHByb21pc2UgZm9ybS5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGNvbGxlY3Rpb24gb2YgcmVhY3Rpb25zIHRoYXQgcGFzcyB0aGUgc3BlY2lmaWVkIGZpbHRlci5cbiAgICogQHBhcmFtIHtDb2xsZWN0b3JGaWx0ZXJ9IGZpbHRlciBUaGUgZmlsdGVyIGZ1bmN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0ge0F3YWl0UmVhY3Rpb25zT3B0aW9uc30gW29wdGlvbnM9e31dIE9wdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgaW50ZXJuYWwgY29sbGVjdG9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbGxlY3Rpb248c3RyaW5nLCBNZXNzYWdlUmVhY3Rpb24+Pn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIGEgcmVhY3Rpb24gY29sbGVjdG9yXG4gICAqIGNvbnN0IGZpbHRlciA9IChyZWFjdGlvbiwgdXNlcikgPT4gcmVhY3Rpb24uZW1vamkubmFtZSA9PT0gJ/CfkYwnICYmIHVzZXIuaWQgPT09ICdzb21lSUQnXG4gICAqIG1lc3NhZ2UuYXdhaXRSZWFjdGlvbnMoZmlsdGVyLCB7IHRpbWU6IDE1MDAwIH0pXG4gICAqICAgLnRoZW4oY29sbGVjdGVkID0+IGNvbnNvbGUubG9nKGBDb2xsZWN0ZWQgJHtjb2xsZWN0ZWQuc2l6ZX0gcmVhY3Rpb25zYCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgYXdhaXRSZWFjdGlvbnMoZmlsdGVyLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdG9yID0gdGhpcy5jcmVhdGVSZWFjdGlvbkNvbGxlY3RvcihmaWx0ZXIsIG9wdGlvbnMpO1xuICAgICAgY29sbGVjdG9yLm9uY2UoJ2VuZCcsIChyZWFjdGlvbnMsIHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuaW5jbHVkZXMocmVhc29uKSkgcmVqZWN0KHJlYWN0aW9ucyk7XG4gICAgICAgIGVsc2UgcmVzb2x2ZShyZWFjdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgY2FjaGVkIHZlcnNpb25zIG9mIHRoZSBtZXNzYWdlLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgdmVyc2lvblxuICAgKiBTb3J0ZWQgZnJvbSBsYXRlc3QgKGZpcnN0KSB0byBvbGRlc3QgKGxhc3QpXG4gICAqIEB0eXBlIHtNZXNzYWdlW119XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGVkaXRzKCkge1xuICAgIGNvbnN0IGNvcHkgPSB0aGlzLl9lZGl0cy5zbGljZSgpO1xuICAgIGNvcHkudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBtZXNzYWdlIGlzIGVkaXRhYmxlIGJ5IHRoZSBjbGllbnQgdXNlclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZWRpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aG9yLmlkID09PSB0aGlzLmNsaWVudC51c2VyLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgZGVsZXRhYmxlIGJ5IHRoZSBjbGllbnQgdXNlclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVsZXRhYmxlKCkge1xuICAgIHJldHVybiAoXG4gICAgICAhdGhpcy5kZWxldGVkICYmXG4gICAgICAodGhpcy5hdXRob3IuaWQgPT09IHRoaXMuY2xpZW50LnVzZXIuaWQgfHxcbiAgICAgICAgKHRoaXMuZ3VpbGQgJiYgdGhpcy5jaGFubmVsLnBlcm1pc3Npb25zRm9yKHRoaXMuY2xpZW50LnVzZXIpLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5NQU5BR0VfTUVTU0FHRVMsIGZhbHNlKSkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBtZXNzYWdlIGlzIHBpbm5hYmxlIGJ5IHRoZSBjbGllbnQgdXNlclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGlubmFibGUoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMudHlwZSA9PT0gJ0RFRkFVTFQnICYmXG4gICAgICAoIXRoaXMuZ3VpbGQgfHwgdGhpcy5jaGFubmVsLnBlcm1pc3Npb25zRm9yKHRoaXMuY2xpZW50LnVzZXIpLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5NQU5BR0VfTUVTU0FHRVMsIGZhbHNlKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgY3Jvc3Nwb3N0YWJsZSBieSB0aGUgY2xpZW50IHVzZXJcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNyb3NzcG9zdGFibGUoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuY2hhbm5lbC50eXBlID09PSAnbmV3cycgJiZcbiAgICAgICF0aGlzLmZsYWdzLmhhcyhNZXNzYWdlRmxhZ3MuRkxBR1MuQ1JPU1NQT1NURUQpICYmXG4gICAgICB0aGlzLnR5cGUgPT09ICdERUZBVUxUJyAmJlxuICAgICAgdGhpcy5jaGFubmVsLnZpZXdhYmxlICYmXG4gICAgICB0aGlzLmNoYW5uZWwucGVybWlzc2lvbnNGb3IodGhpcy5jbGllbnQudXNlcikuaGFzKFBlcm1pc3Npb25zLkZMQUdTLlNFTkRfTUVTU0FHRVMpICYmXG4gICAgICAodGhpcy5hdXRob3IuaWQgPT09IHRoaXMuY2xpZW50LnVzZXIuaWQgfHxcbiAgICAgICAgdGhpcy5jaGFubmVsLnBlcm1pc3Npb25zRm9yKHRoaXMuY2xpZW50LnVzZXIpLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5NQU5BR0VfTUVTU0FHRVMpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byBlZGl0TWVzc2FnZS5cbiAgICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZUVkaXRPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29udGVudF0gQ29udGVudCB0byBiZSBlZGl0ZWRcbiAgICogQHByb3BlcnR5IHtNZXNzYWdlRW1iZWR8T2JqZWN0fSBbZW1iZWRdIEFuIGVtYmVkIHRvIGJlIGFkZGVkL2VkaXRlZFxuICAgKiBAcHJvcGVydHkge3N0cmluZ3xib29sZWFufSBbY29kZV0gTGFuZ3VhZ2UgZm9yIG9wdGlvbmFsIGNvZGVibG9jayBmb3JtYXR0aW5nIHRvIGFwcGx5XG4gICAqIEBwcm9wZXJ0eSB7TWVzc2FnZU1lbnRpb25PcHRpb25zfSBbYWxsb3dlZE1lbnRpb25zXSBXaGljaCBtZW50aW9ucyBzaG91bGQgYmUgcGFyc2VkIGZyb20gdGhlIG1lc3NhZ2UgY29udGVudFxuICAgKi9cblxuICAvKipcbiAgICogRWRpdHMgdGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nUmVzb2x2YWJsZXxBUElNZXNzYWdlfSBbY29udGVudF0gVGhlIG5ldyBjb250ZW50IGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge01lc3NhZ2VFZGl0T3B0aW9uc3xNZXNzYWdlRW1iZWR9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyB0byBwcm92aWRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlXG4gICAqIG1lc3NhZ2UuZWRpdCgnVGhpcyBpcyBteSBuZXcgY29udGVudCEnKVxuICAgKiAgIC50aGVuKG1zZyA9PiBjb25zb2xlLmxvZyhgVXBkYXRlZCB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UgdG8gJHttc2cuY29udGVudH1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBlZGl0KGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9XG4gICAgICBjb250ZW50IGluc3RhbmNlb2YgQVBJTWVzc2FnZSA/IGNvbnRlbnQucmVzb2x2ZURhdGEoKSA6IEFQSU1lc3NhZ2UuY3JlYXRlKHRoaXMsIGNvbnRlbnQsIG9wdGlvbnMpLnJlc29sdmVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaS5jaGFubmVsc1t0aGlzLmNoYW5uZWwuaWRdLm1lc3NhZ2VzW3RoaXMuaWRdLnBhdGNoKHsgZGF0YSB9KS50aGVuKGQgPT4ge1xuICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLl9jbG9uZSgpO1xuICAgICAgY2xvbmUuX3BhdGNoKGQpO1xuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhIG1lc3NhZ2UgaW4gYW4gYW5ub3VuY2VtZW50IGNoYW5uZWwgdG8gYWxsIGNoYW5uZWxzIGZvbGxvd2luZyBpdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyb3NzcG9zdCBhIG1lc3NhZ2VcbiAgICogaWYgKG1lc3NhZ2UuY2hhbm5lbC50eXBlID09PSAnbmV3cycpIHtcbiAgICogICBtZXNzYWdlLmNyb3NzcG9zdCgpXG4gICAqICAgICAudGhlbigoKSA9PiBjb25zb2xlLmxvZygnQ3Jvc3Nwb3N0ZWQgbWVzc2FnZScpKVxuICAgKiAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKiB9XG4gICAqL1xuICBhc3luYyBjcm9zc3Bvc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQuYXBpLmNoYW5uZWxzKHRoaXMuY2hhbm5lbC5pZCkubWVzc2FnZXModGhpcy5pZCkuY3Jvc3Nwb3N0LnBvc3QoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQaW5zIHRoaXMgbWVzc2FnZSB0byB0aGUgY2hhbm5lbCdzIHBpbm5lZCBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciBwaW5uaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3IgcGlubmluZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gUGluIGEgbWVzc2FnZSB3aXRoIGEgcmVhc29uXG4gICAqIG1lc3NhZ2UucGluKHsgcmVhc29uOiAnaW1wb3J0YW50JyB9KVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKVxuICAgKi9cbiAgcGluKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAuY2hhbm5lbHModGhpcy5jaGFubmVsLmlkKVxuICAgICAgLnBpbnModGhpcy5pZClcbiAgICAgIC5wdXQob3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGlucyB0aGlzIG1lc3NhZ2UgZnJvbSB0aGUgY2hhbm5lbCdzIHBpbm5lZCBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB1bnBpbm5pbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciB1bnBpbm5pbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVucGluIGEgbWVzc2FnZSB3aXRoIGEgcmVhc29uXG4gICAqIG1lc3NhZ2UudW5waW4oeyByZWFzb246ICdubyBsb25nZXIgcmVsZXZhbnQnIH0pXG4gICAqICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpXG4gICAqL1xuICB1bnBpbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaVxuICAgICAgLmNoYW5uZWxzKHRoaXMuY2hhbm5lbC5pZClcbiAgICAgIC5waW5zKHRoaXMuaWQpXG4gICAgICAuZGVsZXRlKG9wdGlvbnMpXG4gICAgICAudGhlbigoKSA9PiB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcmVhY3Rpb24gdG8gdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7RW1vamlJZGVudGlmaWVyUmVzb2x2YWJsZX0gZW1vamkgVGhlIGVtb2ppIHRvIHJlYWN0IHdpdGhcbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZVJlYWN0aW9uPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gUmVhY3QgdG8gYSBtZXNzYWdlIHdpdGggYSB1bmljb2RlIGVtb2ppXG4gICAqIG1lc3NhZ2UucmVhY3QoJ/CfpJQnKVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUmVhY3QgdG8gYSBtZXNzYWdlIHdpdGggYSBjdXN0b20gZW1vamlcbiAgICogbWVzc2FnZS5yZWFjdChtZXNzYWdlLmd1aWxkLmVtb2ppcy5jYWNoZS5nZXQoJzEyMzQ1Njc4OTAxMjM0NTY3OCcpKVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHJlYWN0KGVtb2ppKSB7XG4gICAgZW1vamkgPSB0aGlzLmNsaWVudC5lbW9qaXMucmVzb2x2ZUlkZW50aWZpZXIoZW1vamkpO1xuICAgIGlmICghZW1vamkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VNT0pJX1RZUEUnKTtcblxuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5jaGFubmVscyh0aGlzLmNoYW5uZWwuaWQpXG4gICAgICAubWVzc2FnZXModGhpcy5pZClcbiAgICAgIC5yZWFjdGlvbnMoZW1vamksICdAbWUnKVxuICAgICAgLnB1dCgpXG4gICAgICAudGhlbihcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICB0aGlzLmNsaWVudC5hY3Rpb25zLk1lc3NhZ2VSZWFjdGlvbkFkZC5oYW5kbGUoe1xuICAgICAgICAgICAgdXNlcjogdGhpcy5jbGllbnQudXNlcixcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMsXG4gICAgICAgICAgICBlbW9qaTogVXRpbC5wYXJzZUVtb2ppKGVtb2ppKSxcbiAgICAgICAgICB9KS5yZWFjdGlvbixcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50aW1lb3V0PTBdIEhvdyBsb25nIHRvIHdhaXQgdG8gZGVsZXRlIHRoZSBtZXNzYWdlIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVhc29uXSBSZWFzb24gZm9yIGRlbGV0aW5nIHRoaXMgbWVzc2FnZSwgaWYgaXQgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBjbGllbnQgdXNlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRGVsZXRlIGEgbWVzc2FnZVxuICAgKiBtZXNzYWdlLmRlbGV0ZSh7IHRpbWVvdXQ6IDUwMDAgfSlcbiAgICogICAudGhlbihtc2cgPT4gY29uc29sZS5sb2coYERlbGV0ZWQgbWVzc2FnZSBmcm9tICR7bXNnLmF1dGhvci51c2VybmFtZX0gYWZ0ZXIgNSBzZWNvbmRzYCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgZGVsZXRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdJTlZBTElEX1RZUEUnLCAnb3B0aW9ucycsICdvYmplY3QnLCB0cnVlKSk7XG4gICAgY29uc3QgeyB0aW1lb3V0ID0gMCwgcmVhc29uIH0gPSBvcHRpb25zO1xuICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwubWVzc2FnZXMuZGVsZXRlKHRoaXMuaWQsIHJlYXNvbikudGhlbigoKSA9PiB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuZGVsZXRlKHsgcmVhc29uIH0pKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwbGllcyB0byB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtTdHJpbmdSZXNvbHZhYmxlfEFQSU1lc3NhZ2V9IFtjb250ZW50PScnXSBUaGUgY29udGVudCBmb3IgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtNZXNzYWdlT3B0aW9uc3xNZXNzYWdlQWRkaXRpb25zfSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gcHJvdmlkZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlfE1lc3NhZ2VbXT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFJlcGx5IHRvIGEgbWVzc2FnZVxuICAgKiBtZXNzYWdlLnJlcGx5KCdIZXksIElcXCdtIGEgcmVwbHkhJylcbiAgICogICAudGhlbigoKSA9PiBjb25zb2xlLmxvZyhgU2VudCBhIHJlcGx5IHRvICR7bWVzc2FnZS5hdXRob3IudXNlcm5hbWV9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgcmVwbHkoY29udGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuc2VuZChcbiAgICAgIGNvbnRlbnQgaW5zdGFuY2VvZiBBUElNZXNzYWdlXG4gICAgICAgID8gY29udGVudFxuICAgICAgICA6IEFQSU1lc3NhZ2UudHJhbnNmb3JtT3B0aW9ucyhjb250ZW50LCBvcHRpb25zLCB7IHJlcGx5OiB0aGlzLm1lbWJlciB8fCB0aGlzLmF1dGhvciB9KSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoaXMgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgY2hlY2sgYW5kIHJlcXVlc3QgdGhlIEFQSVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPn1cbiAgICovXG4gIGZldGNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLm1lc3NhZ2VzLmZldGNoKHRoaXMuaWQsIHRydWUsIGZvcmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSB3ZWJob29rIHVzZWQgdG8gY3JlYXRlIHRoaXMgbWVzc2FnZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8P1dlYmhvb2s+fVxuICAgKi9cbiAgZmV0Y2hXZWJob29rKCkge1xuICAgIGlmICghdGhpcy53ZWJob29rSUQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dFQkhPT0tfTUVTU0FHRScpKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZmV0Y2hXZWJob29rKHRoaXMud2ViaG9va0lEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdXBwcmVzc2VzIG9yIHVuc3VwcHJlc3NlcyBlbWJlZHMgb24gYSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N1cHByZXNzPXRydWVdIElmIHRoZSBlbWJlZHMgc2hvdWxkIGJlIHN1cHByZXNzZWQgb3Igbm90XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U+fVxuICAgKi9cbiAgc3VwcHJlc3NFbWJlZHMoc3VwcHJlc3MgPSB0cnVlKSB7XG4gICAgY29uc3QgZmxhZ3MgPSBuZXcgTWVzc2FnZUZsYWdzKHRoaXMuZmxhZ3MuYml0ZmllbGQpO1xuXG4gICAgaWYgKHN1cHByZXNzKSB7XG4gICAgICBmbGFncy5hZGQoTWVzc2FnZUZsYWdzLkZMQUdTLlNVUFBSRVNTX0VNQkVEUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWdzLnJlbW92ZShNZXNzYWdlRmxhZ3MuRkxBR1MuU1VQUFJFU1NfRU1CRURTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgZmxhZ3MgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBtYWlubHkgaW50ZXJuYWxseS4gV2hldGhlciB0d28gbWVzc2FnZXMgYXJlIGlkZW50aWNhbCBpbiBwcm9wZXJ0aWVzLiBJZiB5b3Ugd2FudCB0byBjb21wYXJlIG1lc3NhZ2VzXG4gICAqIHdpdGhvdXQgY2hlY2tpbmcgYWxsIHRoZSBwcm9wZXJ0aWVzLCB1c2UgYG1lc3NhZ2UuaWQgPT09IG1lc3NhZ2UyLmlkYCwgd2hpY2ggaXMgbXVjaCBtb3JlIGVmZmljaWVudC4gVGhpc1xuICAgKiBtZXRob2QgYWxsb3dzIHlvdSB0byBzZWUgaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzIGluIGNvbnRlbnQsIGVtYmVkcywgYXR0YWNobWVudHMsIG5vbmNlIGFuZCB0dHMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGNvbXBhcmUgaXQgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHJhd0RhdGEgUmF3IGRhdGEgcGFzc2VkIHRocm91Z2ggdGhlIFdlYlNvY2tldCBhYm91dCB0aGlzIG1lc3NhZ2VcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMobWVzc2FnZSwgcmF3RGF0YSkge1xuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGVtYmVkVXBkYXRlID0gIW1lc3NhZ2UuYXV0aG9yICYmICFtZXNzYWdlLmF0dGFjaG1lbnRzO1xuICAgIGlmIChlbWJlZFVwZGF0ZSkgcmV0dXJuIHRoaXMuaWQgPT09IG1lc3NhZ2UuaWQgJiYgdGhpcy5lbWJlZHMubGVuZ3RoID09PSBtZXNzYWdlLmVtYmVkcy5sZW5ndGg7XG5cbiAgICBsZXQgZXF1YWwgPVxuICAgICAgdGhpcy5pZCA9PT0gbWVzc2FnZS5pZCAmJlxuICAgICAgdGhpcy5hdXRob3IuaWQgPT09IG1lc3NhZ2UuYXV0aG9yLmlkICYmXG4gICAgICB0aGlzLmNvbnRlbnQgPT09IG1lc3NhZ2UuY29udGVudCAmJlxuICAgICAgdGhpcy50dHMgPT09IG1lc3NhZ2UudHRzICYmXG4gICAgICB0aGlzLm5vbmNlID09PSBtZXNzYWdlLm5vbmNlICYmXG4gICAgICB0aGlzLmVtYmVkcy5sZW5ndGggPT09IG1lc3NhZ2UuZW1iZWRzLmxlbmd0aCAmJlxuICAgICAgdGhpcy5hdHRhY2htZW50cy5sZW5ndGggPT09IG1lc3NhZ2UuYXR0YWNobWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKGVxdWFsICYmIHJhd0RhdGEpIHtcbiAgICAgIGVxdWFsID1cbiAgICAgICAgdGhpcy5tZW50aW9ucy5ldmVyeW9uZSA9PT0gbWVzc2FnZS5tZW50aW9ucy5ldmVyeW9uZSAmJlxuICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPT09IG5ldyBEYXRlKHJhd0RhdGEudGltZXN0YW1wKS5nZXRUaW1lKCkgJiZcbiAgICAgICAgdGhpcy5lZGl0ZWRUaW1lc3RhbXAgPT09IG5ldyBEYXRlKHJhd0RhdGEuZWRpdGVkX3RpbWVzdGFtcCkuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBlcXVhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNvbmNhdGVuYXRlZCB3aXRoIGEgc3RyaW5nLCB0aGlzIGF1dG9tYXRpY2FsbHkgY29uY2F0ZW5hdGVzIHRoZSBtZXNzYWdlJ3MgY29udGVudCBpbnN0ZWFkIG9mIHRoZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExvZ3M6IE1lc3NhZ2U6IFRoaXMgaXMgYSBtZXNzYWdlIVxuICAgKiBjb25zb2xlLmxvZyhgTWVzc2FnZTogJHttZXNzYWdlfWApO1xuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gc3VwZXIudG9KU09OKHtcbiAgICAgIGNoYW5uZWw6ICdjaGFubmVsSUQnLFxuICAgICAgYXV0aG9yOiAnYXV0aG9ySUQnLFxuICAgICAgYXBwbGljYXRpb246ICdhcHBsaWNhdGlvbklEJyxcbiAgICAgIGd1aWxkOiAnZ3VpbGRJRCcsXG4gICAgICBjbGVhbkNvbnRlbnQ6IHRydWUsXG4gICAgICBtZW1iZXI6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBmYWxzZSxcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGF0dGFjaG1lbnQgaW4gYSBtZXNzYWdlLlxuICovXG5jbGFzcyBNZXNzYWdlQXR0YWNobWVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlclJlc29sdmFibGV8U3RyZWFtfSBhdHRhY2htZW50IFRoZSBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1udWxsXSBUaGUgbmFtZSBvZiB0aGUgZmlsZSwgaWYgYW55XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gRXh0cmEgZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoYXR0YWNobWVudCwgbmFtZSA9IG51bGwsIGRhdGEpIHtcbiAgICB0aGlzLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgYXR0YWNobWVudFxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgaWYgKGRhdGEpIHRoaXMuX3BhdGNoKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbGUgb2YgdGhpcyBhdHRhY2htZW50LlxuICAgKiBAcGFyYW0ge0J1ZmZlclJlc29sdmFibGV8U3RyZWFtfSBhdHRhY2htZW50IFRoZSBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1udWxsXSBUaGUgbmFtZSBvZiB0aGUgZmlsZSwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtNZXNzYWdlQXR0YWNobWVudH0gVGhpcyBhdHRhY2htZW50XG4gICAqL1xuICBzZXRGaWxlKGF0dGFjaG1lbnQsIG5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5hdHRhY2htZW50ID0gYXR0YWNobWVudDtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhpcyBhdHRhY2htZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZVxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUF0dGFjaG1lbnR9IFRoaXMgYXR0YWNobWVudFxuICAgKi9cbiAgc2V0TmFtZShuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoaXMgYXR0YWNobWVudFxuICAgICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGlzIGF0dGFjaG1lbnQgaW4gYnl0ZXNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBVUkwgdG8gdGhpcyBhdHRhY2htZW50XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IGRhdGEudXJsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFByb3h5IFVSTCB0byB0aGlzIGF0dGFjaG1lbnRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJveHlVUkwgPSBkYXRhLnByb3h5X3VybDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhpcyBhdHRhY2htZW50IChpZiBhbiBpbWFnZSBvciB2aWRlbylcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IHR5cGVvZiBkYXRhLmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhLmhlaWdodCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhpcyBhdHRhY2htZW50IChpZiBhbiBpbWFnZSBvciB2aWRlbylcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gdHlwZW9mIGRhdGEud2lkdGggIT09ICd1bmRlZmluZWQnID8gZGF0YS53aWR0aCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhpcyBhdHRhY2htZW50IGhhcyBiZWVuIG1hcmtlZCBhcyBhIHNwb2lsZXJcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNwb2lsZXIoKSB7XG4gICAgcmV0dXJuIFV0aWwuYmFzZW5hbWUodGhpcy51cmwpLnN0YXJ0c1dpdGgoJ1NQT0lMRVJfJyk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIFV0aWwuZmxhdHRlbih0aGlzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VBdHRhY2htZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL2ludGVyZmFjZXMvQ29sbGVjdG9yJyk7XG5jb25zdCB7IEV2ZW50cyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7Q29sbGVjdG9yT3B0aW9uc30gTWVzc2FnZUNvbGxlY3Rvck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gYW1vdW50IG9mIG1lc3NhZ2VzIHRvIGNvbGxlY3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhQcm9jZXNzZWQgVGhlIG1heGltdW0gYW1vdW50IG9mIG1lc3NhZ2VzIHRvIHByb2Nlc3NcbiAqL1xuXG4vKipcbiAqIENvbGxlY3RzIG1lc3NhZ2VzIG9uIGEgY2hhbm5lbC5cbiAqIFdpbGwgYXV0b21hdGljYWxseSBzdG9wIGlmIHRoZSBjaGFubmVsIChgJ2NoYW5uZWxEZWxldGUnYCkgb3IgZ3VpbGQgKGAnZ3VpbGREZWxldGUnYCkgYXJlIGRlbGV0ZWQuXG4gKiBAZXh0ZW5kcyB7Q29sbGVjdG9yfVxuICovXG5jbGFzcyBNZXNzYWdlQ29sbGVjdG9yIGV4dGVuZHMgQ29sbGVjdG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGV4dENoYW5uZWx8RE1DaGFubmVsfSBjaGFubmVsIFRoZSBjaGFubmVsXG4gICAqIEBwYXJhbSB7Q29sbGVjdG9yRmlsdGVyfSBmaWx0ZXIgVGhlIGZpbHRlciB0byBiZSBhcHBsaWVkIHRvIHRoaXMgY29sbGVjdG9yXG4gICAqIEBwYXJhbSB7TWVzc2FnZUNvbGxlY3Rvck9wdGlvbnN9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGlzIGNvbGxlY3RvclxuICAgKiBAZW1pdHMgTWVzc2FnZUNvbGxlY3RvciNtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBmaWx0ZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNoYW5uZWwuY2xpZW50LCBmaWx0ZXIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNoYW5uZWxcbiAgICAgKiBAdHlwZSB7VGV4dEJhc2VkQ2hhbm5lbH1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgbnVtYmVyIG9mIG1lc3NhZ2VzIHRoYXQgd2VyZSByZWNlaXZlZCBpbiB0aGUgY2hhbm5lbCBkdXJpbmcgbWVzc2FnZSBjb2xsZWN0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlY2VpdmVkID0gMDtcblxuICAgIGNvbnN0IGJ1bGtEZWxldGVMaXN0ZW5lciA9IG1lc3NhZ2VzID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcy52YWx1ZXMoKSkgdGhpcy5oYW5kbGVEaXNwb3NlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgdGhpcy5faGFuZGxlQ2hhbm5lbERlbGV0aW9uID0gdGhpcy5faGFuZGxlQ2hhbm5lbERlbGV0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlR3VpbGREZWxldGlvbiA9IHRoaXMuX2hhbmRsZUd1aWxkRGVsZXRpb24uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY2xpZW50LmluY3JlbWVudE1heExpc3RlbmVycygpO1xuICAgIHRoaXMuY2xpZW50Lm9uKEV2ZW50cy5NRVNTQUdFX0NSRUFURSwgdGhpcy5oYW5kbGVDb2xsZWN0KTtcbiAgICB0aGlzLmNsaWVudC5vbihFdmVudHMuTUVTU0FHRV9ERUxFVEUsIHRoaXMuaGFuZGxlRGlzcG9zZSk7XG4gICAgdGhpcy5jbGllbnQub24oRXZlbnRzLk1FU1NBR0VfQlVMS19ERUxFVEUsIGJ1bGtEZWxldGVMaXN0ZW5lcik7XG4gICAgdGhpcy5jbGllbnQub24oRXZlbnRzLkNIQU5ORUxfREVMRVRFLCB0aGlzLl9oYW5kbGVDaGFubmVsRGVsZXRpb24pO1xuICAgIHRoaXMuY2xpZW50Lm9uKEV2ZW50cy5HVUlMRF9ERUxFVEUsIHRoaXMuX2hhbmRsZUd1aWxkRGVsZXRpb24pO1xuXG4gICAgdGhpcy5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsaWVudC5yZW1vdmVMaXN0ZW5lcihFdmVudHMuTUVTU0FHRV9DUkVBVEUsIHRoaXMuaGFuZGxlQ29sbGVjdCk7XG4gICAgICB0aGlzLmNsaWVudC5yZW1vdmVMaXN0ZW5lcihFdmVudHMuTUVTU0FHRV9ERUxFVEUsIHRoaXMuaGFuZGxlRGlzcG9zZSk7XG4gICAgICB0aGlzLmNsaWVudC5yZW1vdmVMaXN0ZW5lcihFdmVudHMuTUVTU0FHRV9CVUxLX0RFTEVURSwgYnVsa0RlbGV0ZUxpc3RlbmVyKTtcbiAgICAgIHRoaXMuY2xpZW50LnJlbW92ZUxpc3RlbmVyKEV2ZW50cy5DSEFOTkVMX0RFTEVURSwgdGhpcy5faGFuZGxlQ2hhbm5lbERlbGV0aW9uKTtcbiAgICAgIHRoaXMuY2xpZW50LnJlbW92ZUxpc3RlbmVyKEV2ZW50cy5HVUlMRF9ERUxFVEUsIHRoaXMuX2hhbmRsZUd1aWxkRGVsZXRpb24pO1xuICAgICAgdGhpcy5jbGllbnQuZGVjcmVtZW50TWF4TGlzdGVuZXJzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIG1lc3NhZ2UgZm9yIHBvc3NpYmxlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0aGF0IGNvdWxkIGJlIGNvbGxlY3RlZFxuICAgKiBAcmV0dXJucyB7P1Nub3dmbGFrZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbGxlY3QobWVzc2FnZSkge1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIGNvbGxlY3RlZC5cbiAgICAgKiBAZXZlbnQgTWVzc2FnZUNvbGxlY3RvciNjb2xsZWN0XG4gICAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoYXQgd2FzIGNvbGxlY3RlZFxuICAgICAqL1xuICAgIGlmIChtZXNzYWdlLmNoYW5uZWwuaWQgIT09IHRoaXMuY2hhbm5lbC5pZCkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5yZWNlaXZlZCsrO1xuICAgIHJldHVybiBtZXNzYWdlLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBtZXNzYWdlIGZvciBwb3NzaWJsZSBkaXNwb3NhbC5cbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoYXQgY291bGQgYmUgZGlzcG9zZWQgb2ZcbiAgICogQHJldHVybnMgez9Tbm93Zmxha2V9XG4gICAqL1xuICBkaXNwb3NlKG1lc3NhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW5ldmVyIGEgbWVzc2FnZSBpcyBkaXNwb3NlZCBvZi5cbiAgICAgKiBAZXZlbnQgTWVzc2FnZUNvbGxlY3RvciNkaXNwb3NlXG4gICAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoYXQgd2FzIGRpc3Bvc2VkIG9mXG4gICAgICovXG4gICAgcmV0dXJuIG1lc3NhZ2UuY2hhbm5lbC5pZCA9PT0gdGhpcy5jaGFubmVsLmlkID8gbWVzc2FnZS5pZCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGFmdGVyIHVuL2NvbGxlY3Rpb24gdG8gc2VlIGlmIHRoZSBjb2xsZWN0b3IgaXMgZG9uZS5cbiAgICogQHJldHVybnMgez9zdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbmRSZWFzb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5tYXggJiYgdGhpcy5jb2xsZWN0ZWQuc2l6ZSA+PSB0aGlzLm9wdGlvbnMubWF4KSByZXR1cm4gJ2xpbWl0JztcbiAgICBpZiAodGhpcy5vcHRpb25zLm1heFByb2Nlc3NlZCAmJiB0aGlzLnJlY2VpdmVkID09PSB0aGlzLm9wdGlvbnMubWF4UHJvY2Vzc2VkKSByZXR1cm4gJ3Byb2Nlc3NlZExpbWl0JztcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNoZWNraW5nIGlmIHRoZSBjaGFubmVsIGhhcyBiZWVuIGRlbGV0ZWQsIGFuZCBpZiBzbywgc3RvcHMgdGhlIGNvbGxlY3RvciB3aXRoIHRoZSByZWFzb24gJ2NoYW5uZWxEZWxldGUnLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0d1aWxkQ2hhbm5lbH0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0aGF0IHdhcyBkZWxldGVkXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2hhbmRsZUNoYW5uZWxEZWxldGlvbihjaGFubmVsKSB7XG4gICAgaWYgKGNoYW5uZWwuaWQgPT09IHRoaXMuY2hhbm5lbC5pZCkge1xuICAgICAgdGhpcy5zdG9wKCdjaGFubmVsRGVsZXRlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2hlY2tpbmcgaWYgdGhlIGd1aWxkIGhhcyBiZWVuIGRlbGV0ZWQsIGFuZCBpZiBzbywgc3RvcHMgdGhlIGNvbGxlY3RvciB3aXRoIHRoZSByZWFzb24gJ2d1aWxkRGVsZXRlJy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoYXQgd2FzIGRlbGV0ZWRcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfaGFuZGxlR3VpbGREZWxldGlvbihndWlsZCkge1xuICAgIGlmICh0aGlzLmNoYW5uZWwuZ3VpbGQgJiYgZ3VpbGQuaWQgPT09IHRoaXMuY2hhbm5lbC5ndWlsZC5pZCkge1xuICAgICAgdGhpcy5zdG9wKCdndWlsZERlbGV0ZScpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VDb2xsZWN0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgUmFuZ2VFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbWJlZCBpbiBhIG1lc3NhZ2UgKGltYWdlL3ZpZGVvIHByZXZpZXcsIHJpY2ggZW1iZWQsIGV0Yy4pXG4gKi9cbmNsYXNzIE1lc3NhZ2VFbWJlZCB7XG4gIC8qKlxuICAgKiBAbmFtZSBNZXNzYWdlRW1iZWRcbiAgICogQGtpbmQgY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIE1lc3NhZ2VFbWJlZFxuICAgKiBAcGFyYW0ge01lc3NhZ2VFbWJlZHxPYmplY3R9IFtkYXRhPXt9XSBNZXNzYWdlRW1iZWQgdG8gY2xvbmUgb3IgcmF3IGVtYmVkIGRhdGFcbiAgICovXG5cbiAgY29uc3RydWN0b3IoZGF0YSA9IHt9LCBza2lwVmFsaWRhdGlvbiA9IGZhbHNlKSB7XG4gICAgdGhpcy5zZXR1cChkYXRhLCBza2lwVmFsaWRhdGlvbik7XG4gIH1cblxuICBzZXR1cChkYXRhLCBza2lwVmFsaWRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZW1iZWQsIGVpdGhlcjpcbiAgICAgKiAqIGByaWNoYCAtIGEgcmljaCBlbWJlZFxuICAgICAqICogYGltYWdlYCAtIGFuIGltYWdlIGVtYmVkXG4gICAgICogKiBgdmlkZW9gIC0gYSB2aWRlbyBlbWJlZFxuICAgICAqICogYGdpZnZgIC0gYSBnaWZ2IGVtYmVkXG4gICAgICogKiBgYXJ0aWNsZWAgLSBhbiBhcnRpY2xlIGVtYmVkXG4gICAgICogKiBgbGlua2AgLSBhIGxpbmsgZW1iZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IGRhdGEudHlwZSB8fCAncmljaCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBlbWJlZFxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSAndGl0bGUnIGluIGRhdGEgPyBkYXRhLnRpdGxlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGlzIGVtYmVkXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdkZXNjcmlwdGlvbicgaW4gZGF0YSA/IGRhdGEuZGVzY3JpcHRpb24gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFVSTCBvZiB0aGlzIGVtYmVkXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy51cmwgPSAndXJsJyBpbiBkYXRhID8gZGF0YS51cmwgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIG9mIHRoaXMgZW1iZWRcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gJ2NvbG9yJyBpbiBkYXRhID8gVXRpbC5yZXNvbHZlQ29sb3IoZGF0YS5jb2xvcikgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGlzIGVtYmVkXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lc3RhbXAgPSAndGltZXN0YW1wJyBpbiBkYXRhID8gbmV3IERhdGUoZGF0YS50aW1lc3RhbXApLmdldFRpbWUoKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgZmllbGQgb2YgYSBNZXNzYWdlRW1iZWRcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBFbWJlZEZpZWxkXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhpcyBmaWVsZFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhpcyBmaWVsZFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW5saW5lIElmIHRoaXMgZmllbGQgd2lsbCBiZSBkaXNwbGF5ZWQgaW5saW5lXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGRzIG9mIHRoaXMgZW1iZWRcbiAgICAgKiBAdHlwZSB7RW1iZWRGaWVsZFtdfVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgaWYgKGRhdGEuZmllbGRzKSB7XG4gICAgICB0aGlzLmZpZWxkcyA9IHNraXBWYWxpZGF0aW9uID8gZGF0YS5maWVsZHMubWFwKFV0aWwuY2xvbmVPYmplY3QpIDogdGhpcy5jb25zdHJ1Y3Rvci5ub3JtYWxpemVGaWVsZHMoZGF0YS5maWVsZHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHRodW1ibmFpbCBvZiBhIE1lc3NhZ2VFbWJlZFxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IE1lc3NhZ2VFbWJlZFRodW1ibmFpbFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmwgVVJMIGZvciB0aGlzIHRodW1ibmFpbFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm94eVVSTCBQcm94eVVSTCBmb3IgdGhpcyB0aHVtYm5haWxcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGlzIHRodW1ibmFpbFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGlzIHRodW1ibmFpbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRodW1ibmFpbCBvZiB0aGlzIGVtYmVkIChpZiB0aGVyZSBpcyBvbmUpXG4gICAgICogQHR5cGUgez9NZXNzYWdlRW1iZWRUaHVtYm5haWx9XG4gICAgICovXG4gICAgdGhpcy50aHVtYm5haWwgPSBkYXRhLnRodW1ibmFpbFxuICAgICAgPyB7XG4gICAgICAgICAgdXJsOiBkYXRhLnRodW1ibmFpbC51cmwsXG4gICAgICAgICAgcHJveHlVUkw6IGRhdGEudGh1bWJuYWlsLnByb3h5VVJMIHx8IGRhdGEudGh1bWJuYWlsLnByb3h5X3VybCxcbiAgICAgICAgICBoZWlnaHQ6IGRhdGEudGh1bWJuYWlsLmhlaWdodCxcbiAgICAgICAgICB3aWR0aDogZGF0YS50aHVtYm5haWwud2lkdGgsXG4gICAgICAgIH1cbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGltYWdlIG9mIGEgTWVzc2FnZUVtYmVkXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZUVtYmVkSW1hZ2VcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIFVSTCBmb3IgdGhpcyBpbWFnZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm94eVVSTCBQcm94eVVSTCBmb3IgdGhpcyBpbWFnZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoaXMgaW1hZ2VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhpcyBpbWFnZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG9mIHRoaXMgZW1iZWQsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAqIEB0eXBlIHs/TWVzc2FnZUVtYmVkSW1hZ2V9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZSA9IGRhdGEuaW1hZ2VcbiAgICAgID8ge1xuICAgICAgICAgIHVybDogZGF0YS5pbWFnZS51cmwsXG4gICAgICAgICAgcHJveHlVUkw6IGRhdGEuaW1hZ2UucHJveHlVUkwgfHwgZGF0YS5pbWFnZS5wcm94eV91cmwsXG4gICAgICAgICAgaGVpZ2h0OiBkYXRhLmltYWdlLmhlaWdodCxcbiAgICAgICAgICB3aWR0aDogZGF0YS5pbWFnZS53aWR0aCxcbiAgICAgICAgfVxuICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyB0aGUgdmlkZW8gb2YgYSBNZXNzYWdlRW1iZWRcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXNzYWdlRW1iZWRWaWRlb1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmwgVVJMIG9mIHRoaXMgdmlkZW9cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcHJveHlVUkwgUHJveHlVUkwgZm9yIHRoaXMgdmlkZW9cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGlzIHZpZGVvXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoaXMgdmlkZW9cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSB2aWRlbyBvZiB0aGlzIGVtYmVkIChpZiB0aGVyZSBpcyBvbmUpXG4gICAgICogQHR5cGUgez9NZXNzYWdlRW1iZWRWaWRlb31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnZpZGVvID0gZGF0YS52aWRlb1xuICAgICAgPyB7XG4gICAgICAgICAgdXJsOiBkYXRhLnZpZGVvLnVybCxcbiAgICAgICAgICBwcm94eVVSTDogZGF0YS52aWRlby5wcm94eVVSTCB8fCBkYXRhLnZpZGVvLnByb3h5X3VybCxcbiAgICAgICAgICBoZWlnaHQ6IGRhdGEudmlkZW8uaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBkYXRhLnZpZGVvLndpZHRoLFxuICAgICAgICB9XG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBhdXRob3IgZmllbGQgb2YgYSBNZXNzYWdlRW1iZWRcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXNzYWdlRW1iZWRBdXRob3JcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGlzIGF1dGhvclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmwgVVJMIG9mIHRoaXMgYXV0aG9yXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGljb25VUkwgVVJMIG9mIHRoZSBpY29uIGZvciB0aGlzIGF1dGhvclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm94eUljb25VUkwgUHJveGllZCBVUkwgb2YgdGhlIGljb24gZm9yIHRoaXMgYXV0aG9yXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXV0aG9yIG9mIHRoaXMgZW1iZWQgKGlmIHRoZXJlIGlzIG9uZSlcbiAgICAgKiBAdHlwZSB7P01lc3NhZ2VFbWJlZEF1dGhvcn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dGhvciA9IGRhdGEuYXV0aG9yXG4gICAgICA/IHtcbiAgICAgICAgICBuYW1lOiBkYXRhLmF1dGhvci5uYW1lLFxuICAgICAgICAgIHVybDogZGF0YS5hdXRob3IudXJsLFxuICAgICAgICAgIGljb25VUkw6IGRhdGEuYXV0aG9yLmljb25VUkwgfHwgZGF0YS5hdXRob3IuaWNvbl91cmwsXG4gICAgICAgICAgcHJveHlJY29uVVJMOiBkYXRhLmF1dGhvci5wcm94eUljb25VUkwgfHwgZGF0YS5hdXRob3IucHJveHlfaWNvbl91cmwsXG4gICAgICAgIH1cbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHByb3ZpZGVyIG9mIGEgTWVzc2FnZUVtYmVkXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZUVtYmVkUHJvdmlkZXJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGlzIHByb3ZpZGVyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCBVUkwgb2YgdGhpcyBwcm92aWRlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByb3ZpZGVyIG9mIHRoaXMgZW1iZWQgKGlmIHRoZXJlIGlzIG9uZSlcbiAgICAgKiBAdHlwZSB7P01lc3NhZ2VFbWJlZFByb3ZpZGVyfVxuICAgICAqL1xuICAgIHRoaXMucHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyXG4gICAgICA/IHtcbiAgICAgICAgICBuYW1lOiBkYXRhLnByb3ZpZGVyLm5hbWUsXG4gICAgICAgICAgdXJsOiBkYXRhLnByb3ZpZGVyLm5hbWUsXG4gICAgICAgIH1cbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGZvb3RlciBmaWVsZCBvZiBhIE1lc3NhZ2VFbWJlZFxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IE1lc3NhZ2VFbWJlZEZvb3RlclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IG9mIHRoaXMgZm9vdGVyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGljb25VUkwgVVJMIG9mIHRoZSBpY29uIGZvciB0aGlzIGZvb3RlclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm94eUljb25VUkwgUHJveGllZCBVUkwgb2YgdGhlIGljb24gZm9yIHRoaXMgZm9vdGVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9vdGVyIG9mIHRoaXMgZW1iZWRcbiAgICAgKiBAdHlwZSB7P01lc3NhZ2VFbWJlZEZvb3Rlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZvb3RlciA9IGRhdGEuZm9vdGVyXG4gICAgICA/IHtcbiAgICAgICAgICB0ZXh0OiBkYXRhLmZvb3Rlci50ZXh0LFxuICAgICAgICAgIGljb25VUkw6IGRhdGEuZm9vdGVyLmljb25VUkwgfHwgZGF0YS5mb290ZXIuaWNvbl91cmwsXG4gICAgICAgICAgcHJveHlJY29uVVJMOiBkYXRhLmZvb3Rlci5wcm94eUljb25VUkwgfHwgZGF0YS5mb290ZXIucHJveHlfaWNvbl91cmwsXG4gICAgICAgIH1cbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWxlcyBvZiB0aGlzIGVtYmVkXG4gICAgICogQHR5cGUge0FycmF5PEZpbGVPcHRpb25zfHN0cmluZ3xNZXNzYWdlQXR0YWNobWVudD59XG4gICAgICovXG4gICAgdGhpcy5maWxlcyA9IGRhdGEuZmlsZXMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRhdGUgZGlzcGxheWVkIG9uIHRoaXMgZW1iZWRcbiAgICogQHR5cGUgez9EYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkQXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZXN0YW1wID8gbmV3IERhdGUodGhpcy50aW1lc3RhbXApIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaGV4YWRlY2ltYWwgdmVyc2lvbiBvZiB0aGUgZW1iZWQgY29sb3IsIHdpdGggYSBsZWFkaW5nIGhhc2hcbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGhleENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yID8gYCMke3RoaXMuY29sb3IudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDYsICcwJyl9YCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFjY3VtdWxhdGVkIGxlbmd0aCBmb3IgdGhlIGVtYmVkIHRpdGxlLCBkZXNjcmlwdGlvbiwgZmllbGRzIGFuZCBmb290ZXIgdGV4dFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICh0aGlzLnRpdGxlID8gdGhpcy50aXRsZS5sZW5ndGggOiAwKSArXG4gICAgICAodGhpcy5kZXNjcmlwdGlvbiA/IHRoaXMuZGVzY3JpcHRpb24ubGVuZ3RoIDogMCkgK1xuICAgICAgKHRoaXMuZmllbGRzLmxlbmd0aCA+PSAxXG4gICAgICAgID8gdGhpcy5maWVsZHMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2ICsgY3Vyci5uYW1lLmxlbmd0aCArIGN1cnIudmFsdWUubGVuZ3RoLCAwKVxuICAgICAgICA6IDApICtcbiAgICAgICh0aGlzLmZvb3RlciA/IHRoaXMuZm9vdGVyLnRleHQubGVuZ3RoIDogMClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBmaWVsZCB0byB0aGUgZW1iZWQgKG1heCAyNSkuXG4gICAqIEBwYXJhbSB7U3RyaW5nUmVzb2x2YWJsZX0gbmFtZSBUaGUgbmFtZSBvZiB0aGlzIGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nUmVzb2x2YWJsZX0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoaXMgZmllbGRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5saW5lPWZhbHNlXSBJZiB0aGlzIGZpZWxkIHdpbGwgYmUgZGlzcGxheWVkIGlubGluZVxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgYWRkRmllbGQobmFtZSwgdmFsdWUsIGlubGluZSkge1xuICAgIHJldHVybiB0aGlzLmFkZEZpZWxkcyh7IG5hbWUsIHZhbHVlLCBpbmxpbmUgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBmaWVsZHMgdG8gdGhlIGVtYmVkIChtYXggMjUpLlxuICAgKiBAcGFyYW0gey4uLkVtYmVkRmllbGREYXRhfEVtYmVkRmllbGREYXRhW119IGZpZWxkcyBUaGUgZmllbGRzIHRvIGFkZFxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgYWRkRmllbGRzKC4uLmZpZWxkcykge1xuICAgIHRoaXMuZmllbGRzLnB1c2goLi4udGhpcy5jb25zdHJ1Y3Rvci5ub3JtYWxpemVGaWVsZHMoZmllbGRzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcywgcmVwbGFjZXMsIGFuZCBpbnNlcnRzIGZpZWxkcyBpbiB0aGUgZW1iZWQgKG1heCAyNSkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gc3RhcnQgYXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50IFRoZSBudW1iZXIgb2YgZmllbGRzIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0gey4uLkVtYmVkRmllbGREYXRhfEVtYmVkRmllbGREYXRhW119IFtmaWVsZHNdIFRoZSByZXBsYWNpbmcgZmllbGQgb2JqZWN0c1xuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgc3BsaWNlRmllbGRzKGluZGV4LCBkZWxldGVDb3VudCwgLi4uZmllbGRzKSB7XG4gICAgdGhpcy5maWVsZHMuc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCwgLi4udGhpcy5jb25zdHJ1Y3Rvci5ub3JtYWxpemVGaWVsZHMoLi4uZmllbGRzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsZSB0byB1cGxvYWQgYWxvbmdzaWRlIHRoZSBlbWJlZC4gVGhpcyBmaWxlIGNhbiBiZSBhY2Nlc3NlZCB2aWEgYGF0dGFjaG1lbnQ6Ly9maWxlTmFtZS5leHRlbnNpb25gIHdoZW5cbiAgICogc2V0dGluZyBhbiBlbWJlZCBpbWFnZSBvciBhdXRob3IvZm9vdGVyIGljb25zLiBNdWx0aXBsZSBmaWxlcyBjYW4gYmUgYXR0YWNoZWQuXG4gICAqIEBwYXJhbSB7QXJyYXk8RmlsZU9wdGlvbnN8c3RyaW5nfE1lc3NhZ2VBdHRhY2htZW50Pn0gZmlsZXMgRmlsZXMgdG8gYXR0YWNoXG4gICAqIEByZXR1cm5zIHtNZXNzYWdlRW1iZWR9XG4gICAqL1xuICBhdHRhY2hGaWxlcyhmaWxlcykge1xuICAgIHRoaXMuZmlsZXMgPSB0aGlzLmZpbGVzLmNvbmNhdChmaWxlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYXV0aG9yIG9mIHRoaXMgZW1iZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nUmVzb2x2YWJsZX0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXV0aG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaWNvblVSTF0gVGhlIGljb24gVVJMIG9mIHRoZSBhdXRob3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdIFRoZSBVUkwgb2YgdGhlIGF1dGhvclxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgc2V0QXV0aG9yKG5hbWUsIGljb25VUkwsIHVybCkge1xuICAgIHRoaXMuYXV0aG9yID0geyBuYW1lOiBVdGlsLnJlc29sdmVTdHJpbmcobmFtZSksIGljb25VUkwsIHVybCB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoaXMgZW1iZWQuXG4gICAqIEBwYXJhbSB7Q29sb3JSZXNvbHZhYmxlfSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGVtYmVkXG4gICAqIEByZXR1cm5zIHtNZXNzYWdlRW1iZWR9XG4gICAqL1xuICBzZXRDb2xvcihjb2xvcikge1xuICAgIHRoaXMuY29sb3IgPSBVdGlsLnJlc29sdmVDb2xvcihjb2xvcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGVzY3JpcHRpb24gb2YgdGhpcyBlbWJlZC5cbiAgICogQHBhcmFtIHtTdHJpbmdSZXNvbHZhYmxlfSBkZXNjcmlwdGlvbiBUaGUgZGVzY3JpcHRpb25cbiAgICogQHJldHVybnMge01lc3NhZ2VFbWJlZH1cbiAgICovXG4gIHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgZGVzY3JpcHRpb24gPSBVdGlsLnJlc29sdmVTdHJpbmcoZGVzY3JpcHRpb24pO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmb290ZXIgb2YgdGhpcyBlbWJlZC5cbiAgICogQHBhcmFtIHtTdHJpbmdSZXNvbHZhYmxlfSB0ZXh0IFRoZSB0ZXh0IG9mIHRoZSBmb290ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtpY29uVVJMXSBUaGUgaWNvbiBVUkwgb2YgdGhlIGZvb3RlclxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgc2V0Rm9vdGVyKHRleHQsIGljb25VUkwpIHtcbiAgICB0ZXh0ID0gVXRpbC5yZXNvbHZlU3RyaW5nKHRleHQpO1xuICAgIHRoaXMuZm9vdGVyID0geyB0ZXh0LCBpY29uVVJMIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW1hZ2Ugb2YgdGhpcyBlbWJlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBpbWFnZVxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgc2V0SW1hZ2UodXJsKSB7XG4gICAgdGhpcy5pbWFnZSA9IHsgdXJsIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGh1bWJuYWlsIG9mIHRoaXMgZW1iZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgdGh1bWJuYWlsXG4gICAqIEByZXR1cm5zIHtNZXNzYWdlRW1iZWR9XG4gICAqL1xuICBzZXRUaHVtYm5haWwodXJsKSB7XG4gICAgdGhpcy50aHVtYm5haWwgPSB7IHVybCB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGlzIGVtYmVkLlxuICAgKiBAcGFyYW0ge0RhdGV8bnVtYmVyfSBbdGltZXN0YW1wPURhdGUubm93KCldIFRoZSB0aW1lc3RhbXAgb3IgZGF0ZVxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgc2V0VGltZXN0YW1wKHRpbWVzdGFtcCA9IERhdGUubm93KCkpIHtcbiAgICBpZiAodGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSkgdGltZXN0YW1wID0gdGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGlzIGVtYmVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ1Jlc29sdmFibGV9IHRpdGxlIFRoZSB0aXRsZVxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUVtYmVkfVxuICAgKi9cbiAgc2V0VGl0bGUodGl0bGUpIHtcbiAgICB0aXRsZSA9IFV0aWwucmVzb2x2ZVN0cmluZyh0aXRsZSk7XG4gICAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFVSTCBvZiB0aGlzIGVtYmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkxcbiAgICogQHJldHVybnMge01lc3NhZ2VFbWJlZH1cbiAgICovXG4gIHNldFVSTCh1cmwpIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBlbWJlZCB0byBhIHBsYWluIG9iamVjdC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJhdyBkYXRhIG9mIHRoaXMgZW1iZWRcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICB0eXBlOiAncmljaCcsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wID8gbmV3IERhdGUodGhpcy50aW1lc3RhbXApIDogbnVsbCxcbiAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgZmllbGRzOiB0aGlzLmZpZWxkcyxcbiAgICAgIHRodW1ibmFpbDogdGhpcy50aHVtYm5haWwsXG4gICAgICBpbWFnZTogdGhpcy5pbWFnZSxcbiAgICAgIGF1dGhvcjogdGhpcy5hdXRob3JcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLmF1dGhvci5uYW1lLFxuICAgICAgICAgICAgdXJsOiB0aGlzLmF1dGhvci51cmwsXG4gICAgICAgICAgICBpY29uX3VybDogdGhpcy5hdXRob3IuaWNvblVSTCxcbiAgICAgICAgICB9XG4gICAgICAgIDogbnVsbCxcbiAgICAgIGZvb3RlcjogdGhpcy5mb290ZXJcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLmZvb3Rlci50ZXh0LFxuICAgICAgICAgICAgaWNvbl91cmw6IHRoaXMuZm9vdGVyLmljb25VUkwsXG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGZpZWxkIGlucHV0IGFuZCByZXNvbHZlcyBzdHJpbmdzLlxuICAgKiBAcGFyYW0ge1N0cmluZ1Jlc29sdmFibGV9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nUmVzb2x2YWJsZX0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBmaWVsZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmxpbmU9ZmFsc2VdIFNldCB0aGUgZmllbGQgdG8gZGlzcGxheSBpbmxpbmVcbiAgICogQHJldHVybnMge0VtYmVkRmllbGR9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplRmllbGQobmFtZSwgdmFsdWUsIGlubGluZSA9IGZhbHNlKSB7XG4gICAgbmFtZSA9IFV0aWwucmVzb2x2ZVN0cmluZyhuYW1lKTtcbiAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBSYW5nZUVycm9yKCdFTUJFRF9GSUVMRF9OQU1FJyk7XG4gICAgdmFsdWUgPSBVdGlsLnJlc29sdmVTdHJpbmcodmFsdWUpO1xuICAgIGlmICghdmFsdWUpIHRocm93IG5ldyBSYW5nZUVycm9yKCdFTUJFRF9GSUVMRF9WQUxVRScpO1xuICAgIHJldHVybiB7IG5hbWUsIHZhbHVlLCBpbmxpbmUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBFbWJlZEZpZWxkRGF0YVxuICAgKiBAcHJvcGVydHkge1N0cmluZ1Jlc29sdmFibGV9IG5hbWUgVGhlIG5hbWUgb2YgdGhpcyBmaWVsZFxuICAgKiBAcHJvcGVydHkge1N0cmluZ1Jlc29sdmFibGV9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lubGluZV0gSWYgdGhpcyBmaWVsZCB3aWxsIGJlIGRpc3BsYXllZCBpbmxpbmVcbiAgICovXG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgZmllbGQgaW5wdXQgYW5kIHJlc29sdmVzIHN0cmluZ3MuXG4gICAqIEBwYXJhbSAgey4uLkVtYmVkRmllbGREYXRhfEVtYmVkRmllbGREYXRhW119IGZpZWxkcyBGaWVsZHMgdG8gbm9ybWFsaXplXG4gICAqIEByZXR1cm5zIHtFbWJlZEZpZWxkW119XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplRmllbGRzKC4uLmZpZWxkcykge1xuICAgIHJldHVybiBmaWVsZHNcbiAgICAgIC5mbGF0KDIpXG4gICAgICAubWFwKGZpZWxkID0+XG4gICAgICAgIHRoaXMubm9ybWFsaXplRmllbGQoXG4gICAgICAgICAgZmllbGQgJiYgZmllbGQubmFtZSxcbiAgICAgICAgICBmaWVsZCAmJiBmaWVsZC52YWx1ZSxcbiAgICAgICAgICBmaWVsZCAmJiB0eXBlb2YgZmllbGQuaW5saW5lID09PSAnYm9vbGVhbicgPyBmaWVsZC5pbmxpbmUgOiBmYWxzZSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlRW1iZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IHsgQ2hhbm5lbFR5cGVzIH0gPSByZXF1aXJlKCcuLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIG1lbnRpb25zIGluIGEge0BsaW5rIE1lc3NhZ2V9LlxuICovXG5jbGFzcyBNZXNzYWdlTWVudGlvbnMge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB1c2Vycywgcm9sZXMsIGV2ZXJ5b25lLCBjcm9zc3Bvc3RlZENoYW5uZWxzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0aGUgbWVzc2FnZSBpcyBmcm9tXG4gICAgICogQHR5cGUge0NsaWVudH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NsaWVudCcsIHsgdmFsdWU6IG1lc3NhZ2UuY2xpZW50IH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGd1aWxkIHRoZSBtZXNzYWdlIGlzIGluXG4gICAgICogQHR5cGUgez9HdWlsZH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2d1aWxkJywgeyB2YWx1ZTogbWVzc2FnZS5ndWlsZCB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIG1lc3NhZ2UgY29udGVudFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19jb250ZW50JywgeyB2YWx1ZTogbWVzc2FnZS5jb250ZW50IH0pO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBgQGV2ZXJ5b25lYCBvciBgQGhlcmVgIHdlcmUgbWVudGlvbmVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5ldmVyeW9uZSA9IEJvb2xlYW4oZXZlcnlvbmUpO1xuXG4gICAgaWYgKHVzZXJzKSB7XG4gICAgICBpZiAodXNlcnMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnkgdXNlcnMgdGhhdCB3ZXJlIG1lbnRpb25lZFxuICAgICAgICAgKiA8aW5mbz5PcmRlciBhcyByZWNlaXZlZCBmcm9tIHRoZSBBUEksIG5vdCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgbWVzc2FnZSBjb250ZW50PC9pbmZvPlxuICAgICAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIFVzZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VycyA9IG5ldyBDb2xsZWN0aW9uKHVzZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXNlcnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lbnRpb24gb2YgdXNlcnMpIHtcbiAgICAgICAgICBpZiAobWVudGlvbi5tZW1iZXIgJiYgbWVzc2FnZS5ndWlsZCkge1xuICAgICAgICAgICAgbWVzc2FnZS5ndWlsZC5tZW1iZXJzLmFkZChPYmplY3QuYXNzaWduKG1lbnRpb24ubWVtYmVyLCB7IHVzZXI6IG1lbnRpb24gfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS5jbGllbnQudXNlcnMuYWRkKG1lbnRpb24pO1xuICAgICAgICAgIHRoaXMudXNlcnMuc2V0KHVzZXIuaWQsIHVzZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXNlcnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIGlmIChyb2xlcykge1xuICAgICAgaWYgKHJvbGVzIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQW55IHJvbGVzIHRoYXQgd2VyZSBtZW50aW9uZWRcbiAgICAgICAgICogPGluZm8+T3JkZXIgYXMgcmVjZWl2ZWQgZnJvbSB0aGUgQVBJLCBub3QgYXMgdGhleSBhcHBlYXIgaW4gdGhlIG1lc3NhZ2UgY29udGVudDwvaW5mbz5cbiAgICAgICAgICogQHR5cGUge0NvbGxlY3Rpb248U25vd2ZsYWtlLCBSb2xlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9sZXMgPSBuZXcgQ29sbGVjdGlvbihyb2xlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvbGVzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICAgICAgZm9yIChjb25zdCBtZW50aW9uIG9mIHJvbGVzKSB7XG4gICAgICAgICAgY29uc3Qgcm9sZSA9IG1lc3NhZ2UuY2hhbm5lbC5ndWlsZC5yb2xlcy5jYWNoZS5nZXQobWVudGlvbik7XG4gICAgICAgICAgaWYgKHJvbGUpIHRoaXMucm9sZXMuc2V0KHJvbGUuaWQsIHJvbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9sZXMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBtZW1iZXJzIGZvciB7QGxpbmsgTWVzc2FnZU1lbnRpb25zI21lbWJlcnN9XG4gICAgICogQHR5cGUgez9Db2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRNZW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWVtYmVycyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgY2hhbm5lbHMgZm9yIHtAbGluayBNZXNzYWdlTWVudGlvbnMjY2hhbm5lbHN9XG4gICAgICogQHR5cGUgez9Db2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRDaGFubmVsPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NoYW5uZWxzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENyb3NzcG9zdGVkIGNoYW5uZWwgZGF0YS5cbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBDcm9zc3Bvc3RlZENoYW5uZWxcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY2hhbm5lbElEIElEIG9mIHRoZSBtZW50aW9uZWQgY2hhbm5lbFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBndWlsZElEIElEIG9mIHRoZSBndWlsZCB0aGF0IGhhcyB0aGUgY2hhbm5lbFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFR5cGUgb2YgdGhlIGNoYW5uZWxcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hhbm5lbFxuICAgICAqL1xuXG4gICAgaWYgKGNyb3NzcG9zdGVkQ2hhbm5lbHMpIHtcbiAgICAgIGlmIChjcm9zc3Bvc3RlZENoYW5uZWxzIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIGNyb3NzcG9zdGVkIGNoYW5uZWxzXG4gICAgICAgICAqIDxpbmZvPk9yZGVyIGFzIHJlY2VpdmVkIGZyb20gdGhlIEFQSSwgbm90IGFzIHRoZXkgYXBwZWFyIGluIHRoZSBtZXNzYWdlIGNvbnRlbnQ8L2luZm8+XG4gICAgICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgQ3Jvc3Nwb3N0ZWRDaGFubmVsPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3Jvc3Nwb3N0ZWRDaGFubmVscyA9IG5ldyBDb2xsZWN0aW9uKGNyb3NzcG9zdGVkQ2hhbm5lbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jcm9zc3Bvc3RlZENoYW5uZWxzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFR5cGVzID0gT2JqZWN0LmtleXMoQ2hhbm5lbFR5cGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIGNyb3NzcG9zdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gY2hhbm5lbFR5cGVzW2QudHlwZV07XG4gICAgICAgICAgdGhpcy5jcm9zc3Bvc3RlZENoYW5uZWxzLnNldChkLmlkLCB7XG4gICAgICAgICAgICBjaGFubmVsSUQ6IGQuaWQsXG4gICAgICAgICAgICBndWlsZElEOiBkLmd1aWxkX2lkLFxuICAgICAgICAgICAgdHlwZTogdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICd1bmtub3duJyxcbiAgICAgICAgICAgIG5hbWU6IGQubmFtZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyb3NzcG9zdGVkQ2hhbm5lbHMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgbWVtYmVycyB0aGF0IHdlcmUgbWVudGlvbmVkIChvbmx5IGluIHtAbGluayBUZXh0Q2hhbm5lbH1zKVxuICAgKiA8aW5mbz5PcmRlciBhcyByZWNlaXZlZCBmcm9tIHRoZSBBUEksIG5vdCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgbWVzc2FnZSBjb250ZW50PC9pbmZvPlxuICAgKiBAdHlwZSB7P0NvbGxlY3Rpb248U25vd2ZsYWtlLCBHdWlsZE1lbWJlcj59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lbWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuX21lbWJlcnMpIHJldHVybiB0aGlzLl9tZW1iZXJzO1xuICAgIGlmICghdGhpcy5ndWlsZCkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5fbWVtYmVycyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgdGhpcy51c2Vycy5mb3JFYWNoKHVzZXIgPT4ge1xuICAgICAgY29uc3QgbWVtYmVyID0gdGhpcy5ndWlsZC5tZW1iZXIodXNlcik7XG4gICAgICBpZiAobWVtYmVyKSB0aGlzLl9tZW1iZXJzLnNldChtZW1iZXIudXNlci5pZCwgbWVtYmVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbWVtYmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgY2hhbm5lbHMgdGhhdCB3ZXJlIG1lbnRpb25lZFxuICAgKiA8aW5mbz5PcmRlciBhcyB0aGV5IGFwcGVhciBmaXJzdCBpbiB0aGUgbWVzc2FnZSBjb250ZW50PC9pbmZvPlxuICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIEd1aWxkQ2hhbm5lbD59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNoYW5uZWxzKCkge1xuICAgIGlmICh0aGlzLl9jaGFubmVscykgcmV0dXJuIHRoaXMuX2NoYW5uZWxzO1xuICAgIHRoaXMuX2NoYW5uZWxzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICBsZXQgbWF0Y2hlcztcbiAgICB3aGlsZSAoKG1hdGNoZXMgPSB0aGlzLmNvbnN0cnVjdG9yLkNIQU5ORUxTX1BBVFRFUk4uZXhlYyh0aGlzLl9jb250ZW50KSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNoYW4gPSB0aGlzLmNsaWVudC5jaGFubmVscy5jYWNoZS5nZXQobWF0Y2hlc1sxXSk7XG4gICAgICBpZiAoY2hhbikgdGhpcy5fY2hhbm5lbHMuc2V0KGNoYW4uaWQsIGNoYW4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2hhbm5lbHM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgdXNlciwgZ3VpbGQgbWVtYmVyLCByb2xlLCBvciBjaGFubmVsIGlzIG1lbnRpb25lZC5cbiAgICogVGFrZXMgaW50byBhY2NvdW50IHVzZXIgbWVudGlvbnMsIHJvbGUgbWVudGlvbnMsIGFuZCBAZXZlcnlvbmUvQGhlcmUgbWVudGlvbnMuXG4gICAqIEBwYXJhbSB7VXNlclJlc29sdmFibGV8Um9sZVJlc29sdmFibGV8R3VpbGRDaGFubmVsUmVzb2x2YWJsZX0gZGF0YSBVc2VyL1JvbGUvQ2hhbm5lbCB0byBjaGVja1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEaXJlY3Q9ZmFsc2VdIC0gV2hldGhlciB0byBpZ25vcmUgZGlyZWN0IG1lbnRpb25zIHRvIHRoZSBpdGVtXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlUm9sZXM9ZmFsc2VdIC0gV2hldGhlciB0byBpZ25vcmUgcm9sZSBtZW50aW9ucyB0byBhIGd1aWxkIG1lbWJlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUV2ZXJ5b25lPWZhbHNlXSAtIFdoZXRoZXIgdG8gaWdub3JlIGV2ZXJ5b25lL2hlcmUgbWVudGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXMoZGF0YSwgeyBpZ25vcmVEaXJlY3QgPSBmYWxzZSwgaWdub3JlUm9sZXMgPSBmYWxzZSwgaWdub3JlRXZlcnlvbmUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAoIWlnbm9yZUV2ZXJ5b25lICYmIHRoaXMuZXZlcnlvbmUpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IEd1aWxkTWVtYmVyID0gcmVxdWlyZSgnLi9HdWlsZE1lbWJlcicpO1xuICAgIGlmICghaWdub3JlUm9sZXMgJiYgZGF0YSBpbnN0YW5jZW9mIEd1aWxkTWVtYmVyKSB7XG4gICAgICBmb3IgKGNvbnN0IHJvbGUgb2YgdGhpcy5yb2xlcy52YWx1ZXMoKSkgaWYgKGRhdGEucm9sZXMuY2FjaGUuaGFzKHJvbGUuaWQpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlnbm9yZURpcmVjdCkge1xuICAgICAgY29uc3QgaWQgPVxuICAgICAgICB0aGlzLmNsaWVudC51c2Vycy5yZXNvbHZlSUQoZGF0YSkgfHxcbiAgICAgICAgKHRoaXMuZ3VpbGQgJiYgdGhpcy5ndWlsZC5yb2xlcy5yZXNvbHZlSUQoZGF0YSkpIHx8XG4gICAgICAgIHRoaXMuY2xpZW50LmNoYW5uZWxzLnJlc29sdmVJRChkYXRhKTtcblxuICAgICAgcmV0dXJuIHRoaXMudXNlcnMuaGFzKGlkKSB8fCB0aGlzLmNoYW5uZWxzLmhhcyhpZCkgfHwgdGhpcy5yb2xlcy5oYXMoaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gVXRpbC5mbGF0dGVuKHRoaXMsIHtcbiAgICAgIG1lbWJlcnM6IHRydWUsXG4gICAgICBjaGFubmVsczogdHJ1ZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGdsb2JhbGx5IG1hdGNoZXMgYEBldmVyeW9uZWAgYW5kIGBAaGVyZWBcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbk1lc3NhZ2VNZW50aW9ucy5FVkVSWU9ORV9QQVRURVJOID0gL0AoZXZlcnlvbmV8aGVyZSkvZztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBnbG9iYWxseSBtYXRjaGVzIHVzZXIgbWVudGlvbnMgbGlrZSBgPEA4MTQ0MDk2MjQ5NjE3MjAzMj5gXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5NZXNzYWdlTWVudGlvbnMuVVNFUlNfUEFUVEVSTiA9IC88QCE/KFxcZHsxNywxOX0pPi9nO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGdsb2JhbGx5IG1hdGNoZXMgcm9sZSBtZW50aW9ucyBsaWtlIGA8QCYyOTc1Nzc5MTYxMTQ0MDMzMzg+YFxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuTWVzc2FnZU1lbnRpb25zLlJPTEVTX1BBVFRFUk4gPSAvPEAmKFxcZHsxNywxOX0pPi9nO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGdsb2JhbGx5IG1hdGNoZXMgY2hhbm5lbCBtZW50aW9ucyBsaWtlIGA8IzIyMjA3OTg5NTU4MzQ1NzI4MD5gXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5NZXNzYWdlTWVudGlvbnMuQ0hBTk5FTFNfUEFUVEVSTiA9IC88IyhcXGR7MTcsMTl9KT4vZztcblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlTWVudGlvbnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEd1aWxkRW1vamkgPSByZXF1aXJlKCcuL0d1aWxkRW1vamknKTtcbmNvbnN0IFJlYWN0aW9uRW1vamkgPSByZXF1aXJlKCcuL1JlYWN0aW9uRW1vamknKTtcbmNvbnN0IFJlYWN0aW9uVXNlck1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9SZWFjdGlvblVzZXJNYW5hZ2VyJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlYWN0aW9uIHRvIGEgbWVzc2FnZS5cbiAqL1xuY2xhc3MgTWVzc2FnZVJlYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnQgVGhlIGluc3RhbnRpYXRpbmcgY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgbWVzc2FnZSByZWFjdGlvblxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdGhlIHJlYWN0aW9uIHJlZmVycyB0b1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhLCBtZXNzYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0aGF0IGluc3RhbnRpYXRlZCB0aGlzIG1lc3NhZ2UgcmVhY3Rpb25cbiAgICAgKiBAbmFtZSBNZXNzYWdlUmVhY3Rpb24jY2xpZW50XG4gICAgICogQHR5cGUge0NsaWVudH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NsaWVudCcsIHsgdmFsdWU6IGNsaWVudCB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVzc2FnZSB0aGF0IHRoaXMgcmVhY3Rpb24gcmVmZXJzIHRvXG4gICAgICogQHR5cGUge01lc3NhZ2V9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFuYWdlciBvZiB0aGUgdXNlcnMgdGhhdCBoYXZlIGdpdmVuIHRoaXMgcmVhY3Rpb25cbiAgICAgKiBAdHlwZSB7UmVhY3Rpb25Vc2VyTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJzID0gbmV3IFJlYWN0aW9uVXNlck1hbmFnZXIoY2xpZW50LCB1bmRlZmluZWQsIHRoaXMpO1xuXG4gICAgdGhpcy5fZW1vamkgPSBuZXcgUmVhY3Rpb25FbW9qaSh0aGlzLCBkYXRhLmVtb2ppKTtcblxuICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICB9XG5cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgaWYgKHRoaXMuY291bnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBudW1iZXIgb2YgcGVvcGxlIHRoYXQgaGF2ZSBnaXZlbiB0aGUgc2FtZSByZWFjdGlvblxuICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuY291bnQgPSBkYXRhLmNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBoYXMgZ2l2ZW4gdGhpcyByZWFjdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubWUgPSBkYXRhLm1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHVzZXJzIGZyb20gdGhpcyByZWFjdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZVJlYWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIHJlbW92ZSgpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5hcGlcbiAgICAgIC5jaGFubmVscyh0aGlzLm1lc3NhZ2UuY2hhbm5lbC5pZClcbiAgICAgIC5tZXNzYWdlcyh0aGlzLm1lc3NhZ2UuaWQpXG4gICAgICAucmVhY3Rpb25zKHRoaXMuX2Vtb2ppLmlkZW50aWZpZXIpXG4gICAgICAuZGVsZXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGVtb2ppIG9mIHRoaXMgcmVhY3Rpb24sIGVpdGhlciBhbiBHdWlsZEVtb2ppIG9iamVjdCBmb3Iga25vd24gY3VzdG9tIGVtb2ppcywgb3IgYSBSZWFjdGlvbkVtb2ppXG4gICAqIG9iamVjdCB3aGljaCBoYXMgZmV3ZXIgcHJvcGVydGllcy4gV2hhdGV2ZXIgdGhlIHByb3RvdHlwZSBvZiB0aGUgZW1vamksIGl0IHdpbGwgc3RpbGwgaGF2ZVxuICAgKiBgbmFtZWAsIGBpZGAsIGBpZGVudGlmaWVyYCBhbmQgYHRvU3RyaW5nKClgXG4gICAqIEB0eXBlIHtHdWlsZEVtb2ppfFJlYWN0aW9uRW1vaml9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGVtb2ppKCkge1xuICAgIGlmICh0aGlzLl9lbW9qaSBpbnN0YW5jZW9mIEd1aWxkRW1vamkpIHJldHVybiB0aGlzLl9lbW9qaTtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGVtb2ppIGhhcyBiZWNvbWUga25vd24gdG8gdGhlIGNsaWVudFxuICAgIGlmICh0aGlzLl9lbW9qaS5pZCkge1xuICAgICAgY29uc3QgZW1vamlzID0gdGhpcy5tZXNzYWdlLmNsaWVudC5lbW9qaXMuY2FjaGU7XG4gICAgICBpZiAoZW1vamlzLmhhcyh0aGlzLl9lbW9qaS5pZCkpIHtcbiAgICAgICAgY29uc3QgZW1vamkgPSBlbW9qaXMuZ2V0KHRoaXMuX2Vtb2ppLmlkKTtcbiAgICAgICAgdGhpcy5fZW1vamkgPSBlbW9qaTtcbiAgICAgICAgcmV0dXJuIGVtb2ppO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW1vamk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhpcyByZWFjdGlvbiBpcyBhIHBhcnRpYWxcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcnRpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY291bnQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhpcyByZWFjdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZVJlYWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIGZldGNoKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1lc3NhZ2UuZmV0Y2goKTtcbiAgICBjb25zdCBleGlzdGluZyA9IG1lc3NhZ2UucmVhY3Rpb25zLmNhY2hlLmdldCh0aGlzLmVtb2ppLmlkIHx8IHRoaXMuZW1vamkubmFtZSk7XG4gICAgLy8gVGhlIHJlYWN0aW9uIHdvbid0IGdldCBzZXQgd2hlbiBpdCBoYXMgYmVlbiBjb21wbGV0ZWx5IHJlbW92ZWRcbiAgICB0aGlzLl9wYXRjaChleGlzdGluZyB8fCB7IGNvdW50OiAwIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBVdGlsLmZsYXR0ZW4odGhpcywgeyBlbW9qaTogJ2Vtb2ppSUQnLCBtZXNzYWdlOiAnbWVzc2FnZUlEJyB9KTtcbiAgfVxuXG4gIF9hZGQodXNlcikge1xuICAgIGlmICh0aGlzLnBhcnRpYWwpIHJldHVybjtcbiAgICB0aGlzLnVzZXJzLmNhY2hlLnNldCh1c2VyLmlkLCB1c2VyKTtcbiAgICBpZiAoIXRoaXMubWUgfHwgdXNlci5pZCAhPT0gdGhpcy5tZXNzYWdlLmNsaWVudC51c2VyLmlkIHx8IHRoaXMuY291bnQgPT09IDApIHRoaXMuY291bnQrKztcbiAgICBpZiAoIXRoaXMubWUpIHRoaXMubWUgPSB1c2VyLmlkID09PSB0aGlzLm1lc3NhZ2UuY2xpZW50LnVzZXIuaWQ7XG4gIH1cblxuICBfcmVtb3ZlKHVzZXIpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWFsKSByZXR1cm47XG4gICAgdGhpcy51c2Vycy5jYWNoZS5kZWxldGUodXNlci5pZCk7XG4gICAgaWYgKCF0aGlzLm1lIHx8IHVzZXIuaWQgIT09IHRoaXMubWVzc2FnZS5jbGllbnQudXNlci5pZCkgdGhpcy5jb3VudC0tO1xuICAgIGlmICh1c2VyLmlkID09PSB0aGlzLm1lc3NhZ2UuY2xpZW50LnVzZXIuaWQpIHRoaXMubWUgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jb3VudCA8PSAwICYmIHRoaXMudXNlcnMuY2FjaGUuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5tZXNzYWdlLnJlYWN0aW9ucy5jYWNoZS5kZWxldGUodGhpcy5lbW9qaS5pZCB8fCB0aGlzLmVtb2ppLm5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VSZWFjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVGV4dENoYW5uZWwgPSByZXF1aXJlKCcuL1RleHRDaGFubmVsJyk7XG5jb25zdCB7IEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZ3VpbGQgbmV3cyBjaGFubmVsIG9uIERpc2NvcmQuXG4gKiBAZXh0ZW5kcyB7VGV4dENoYW5uZWx9XG4gKi9cbmNsYXNzIE5ld3NDaGFubmVsIGV4dGVuZHMgVGV4dENoYW5uZWwge1xuICBfcGF0Y2goZGF0YSkge1xuICAgIHN1cGVyLl9wYXRjaChkYXRhKTtcblxuICAgIC8vIE5ld3MgY2hhbm5lbHMgZG9uJ3QgaGF2ZSBhIHJhdGUgbGltaXQgcGVyIHVzZXIsIHJlbW92ZSBpdFxuICAgIHRoaXMucmF0ZUxpbWl0UGVyVXNlciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSB0YXJnZXQgdG8gdGhpcyBjaGFubmVsJ3MgZm9sbG93ZXJzLlxuICAgKiBAcGFyYW0ge0d1aWxkQ2hhbm5lbFJlc29sdmFibGV9IGNoYW5uZWwgVGhlIGNoYW5uZWwgd2hlcmUgdGhlIHdlYmhvb2sgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY3JlYXRpbmcgdGhlIHdlYmhvb2tcbiAgICogQHJldHVybnMge1Byb21pc2U8TmV3c0NoYW5uZWw+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAoY2hhbm5lbC50eXBlID09PSAnbmV3cycpIHtcbiAgICogICBjaGFubmVsLmFkZEZvbGxvd2VyKCcyMjIxOTcwMzM5MDg0MzY5OTQnLCAnSW1wb3J0YW50IGFubm91bmNlbWVudHMnKVxuICAgKiAgICAgLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ0FkZGVkIGZvbGxvd2VyJykpXG4gICAqICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIH1cbiAgICovXG4gIGFzeW5jIGFkZEZvbGxvd2VyKGNoYW5uZWwsIHJlYXNvbikge1xuICAgIGNvbnN0IGNoYW5uZWxJRCA9IHRoaXMuZ3VpbGQuY2hhbm5lbHMucmVzb2x2ZUlEKGNoYW5uZWwpO1xuICAgIGlmICghY2hhbm5lbElEKSB0aHJvdyBuZXcgRXJyb3IoJ0dVSUxEX0NIQU5ORUxfUkVTT0xWRScpO1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LmFwaS5jaGFubmVscyh0aGlzLmlkKS5mb2xsb3dlcnMucG9zdCh7IGRhdGE6IHsgd2ViaG9va19jaGFubmVsX2lkOiBjaGFubmVsSUQgfSwgcmVhc29uIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmV3c0NoYW5uZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENoYW5uZWwgPSByZXF1aXJlKCcuL0NoYW5uZWwnKTtcbmNvbnN0IHsgRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBQYXJ0aWFsIEdyb3VwIERNIENoYW5uZWwgb24gRGlzY29yZC5cbiAqIEBleHRlbmRzIHtDaGFubmVsfVxuICovXG5jbGFzcyBQYXJ0aWFsR3JvdXBETUNoYW5uZWwgZXh0ZW5kcyBDaGFubmVsIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhKSB7XG4gICAgc3VwZXIoY2xpZW50LCBkYXRhKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgR3JvdXAgRE0gQ2hhbm5lbFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhhc2ggb2YgdGhlIGNoYW5uZWwgaWNvblxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWNvbiA9IGRhdGEuaWNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVVJMIHRvIHRoaXMgY2hhbm5lbCdzIGljb24uXG4gICAqIEBwYXJhbSB7SW1hZ2VVUkxPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIEltYWdlIFVSTFxuICAgKiBAcmV0dXJucyB7P3N0cmluZ31cbiAgICovXG4gIGljb25VUkwoeyBmb3JtYXQsIHNpemUgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmljb24pIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNkbi5HRE1JY29uKHRoaXMuaWQsIHRoaXMuaWNvbiwgZm9ybWF0LCBzaXplKTtcbiAgfVxuXG4gIGRlbGV0ZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdERUxFVEVfR1JPVVBfRE1fQ0hBTk5FTCcpKTtcbiAgfVxuXG4gIGZldGNoKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ZFVENIX0dST1VQX0RNX0NIQU5ORUwnKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWFsR3JvdXBETUNoYW5uZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJvbGUgPSByZXF1aXJlKCcuL1JvbGUnKTtcbmNvbnN0IHsgVHlwZUVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFBlcm1pc3Npb25zID0gcmVxdWlyZSgnLi4vdXRpbC9QZXJtaXNzaW9ucycpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBwZXJtaXNzaW9uIG92ZXJ3cml0ZSBmb3IgYSByb2xlIG9yIG1lbWJlciBpbiBhIGd1aWxkIGNoYW5uZWwuXG4gKi9cbmNsYXNzIFBlcm1pc3Npb25PdmVyd3JpdGVzIHtcbiAgY29uc3RydWN0b3IoZ3VpbGRDaGFubmVsLCBkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIEd1aWxkQ2hhbm5lbCB0aGlzIG92ZXJ3cml0ZSBpcyBmb3JcbiAgICAgKiBAbmFtZSBQZXJtaXNzaW9uT3ZlcndyaXRlcyNjaGFubmVsXG4gICAgICogQHR5cGUge0d1aWxkQ2hhbm5lbH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NoYW5uZWwnLCB7IHZhbHVlOiBndWlsZENoYW5uZWwgfSk7XG5cbiAgICBpZiAoZGF0YSkgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGlzIG92ZXJ3cml0ZSwgZWl0aGVyIGEgdXNlciBJRCBvciBhIHJvbGUgSURcbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgYSBwZXJtaXNzaW9uIG92ZXJ3cml0ZS4gSXQgY2FuIGJlIG9uZSBvZjpcbiAgICAgKiAqIG1lbWJlclxuICAgICAqICogcm9sZVxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IE92ZXJ3cml0ZVR5cGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgb3ZlcndyaXRlXG4gICAgICogQHR5cGUge092ZXJ3cml0ZVR5cGV9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gZGF0YS50eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBlcm1pc3Npb25zIHRoYXQgYXJlIGRlbmllZCBmb3IgdGhlIHVzZXIgb3Igcm9sZS5cbiAgICAgKiBAdHlwZSB7UmVhZG9ubHk8UGVybWlzc2lvbnM+fVxuICAgICAqL1xuICAgIHRoaXMuZGVueSA9IG5ldyBQZXJtaXNzaW9ucyhkYXRhLmRlbnkpLmZyZWV6ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBlcm1pc3Npb25zIHRoYXQgYXJlIGFsbG93ZWQgZm9yIHRoZSB1c2VyIG9yIHJvbGUuXG4gICAgICogQHR5cGUge1JlYWRvbmx5PFBlcm1pc3Npb25zPn1cbiAgICAgKi9cbiAgICB0aGlzLmFsbG93ID0gbmV3IFBlcm1pc3Npb25zKGRhdGEuYWxsb3cpLmZyZWV6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBwZXJtaXNzaW9uT3ZlcndyaXRlcy5cbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uT3ZlcndyaXRlT3B0aW9uc30gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjcmVhdGluZy9lZGl0aW5nIHRoaXMgb3ZlcndyaXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFBlcm1pc3Npb25PdmVyd3JpdGVzPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gVXBkYXRlIHBlcm1pc3Npb24gb3ZlcndyaXRlc1xuICAgKiBwZXJtaXNzaW9uT3ZlcndyaXRlcy51cGRhdGUoe1xuICAgKiAgIFNFTkRfTUVTU0FHRVM6IGZhbHNlXG4gICAqIH0pXG4gICAqICAgLnRoZW4oY2hhbm5lbCA9PiBjb25zb2xlLmxvZyhjaGFubmVsLnBlcm1pc3Npb25PdmVyd3JpdGVzLmdldChtZXNzYWdlLmF1dGhvci5pZCkpKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHVwZGF0ZShvcHRpb25zLCByZWFzb24pIHtcbiAgICBjb25zdCB7IGFsbG93LCBkZW55IH0gPSB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmVPdmVyd3JpdGVPcHRpb25zKG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jbGllbnQuYXBpXG4gICAgICAuY2hhbm5lbHModGhpcy5jaGFubmVsLmlkKVxuICAgICAgLnBlcm1pc3Npb25zW3RoaXMuaWRdLnB1dCh7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHRoaXMuaWQsIHR5cGU6IHRoaXMudHlwZSwgYWxsb3c6IGFsbG93LmJpdGZpZWxkLCBkZW55OiBkZW55LmJpdGZpZWxkIH0sXG4gICAgICAgIHJlYXNvbixcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoaXMgUGVybWlzc2lvbiBPdmVyd3JpdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGRlbGV0aW5nIHRoaXMgb3ZlcndyaXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFBlcm1pc3Npb25PdmVyd3JpdGVzPn1cbiAgICovXG4gIGRlbGV0ZShyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNsaWVudC5hcGkuY2hhbm5lbHNbdGhpcy5jaGFubmVsLmlkXS5wZXJtaXNzaW9uc1t0aGlzLmlkXS5kZWxldGUoeyByZWFzb24gfSkudGhlbigoKSA9PiB0aGlzKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gVXRpbC5mbGF0dGVuKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBtYXBwaW5nIHBlcm1pc3Npb24gZmxhZ3MgdG8gYHRydWVgIChlbmFibGVkKSwgYG51bGxgICh1bnNldCkgb3IgYGZhbHNlYCAoZGlzYWJsZWQpLlxuICAgKiBgYGBqc1xuICAgKiB7XG4gICAqICAnU0VORF9NRVNTQUdFUyc6IHRydWUsXG4gICAqICAnRU1CRURfTElOS1MnOiBudWxsLFxuICAgKiAgJ0FUVEFDSF9GSUxFUyc6IGZhbHNlLFxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQZXJtaXNzaW9uT3ZlcndyaXRlT3B0aW9uc1xuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gUmVzb2x2ZWRPdmVyd3JpdGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7UGVybWlzc2lvbnN9IGFsbG93IFRoZSBhbGxvd2VkIHBlcm1pc3Npb25zXG4gICAqIEBwcm9wZXJ0eSB7UGVybWlzc2lvbnN9IGRlbnkgVGhlIGRlbmllZCBwZXJtaXNzaW9uc1xuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYml0ZmllbGQgcGVybWlzc2lvbnMgb3ZlcndyaXRlcyBmcm9tIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uT3ZlcndyaXRlT3B0aW9uc30gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdGlhbFBlcm1pc3Npb25zIFRoZSBpbml0aWFsIHBlcm1pc3Npb25zXG4gICAqIEBwYXJhbSB7UGVybWlzc2lvblJlc29sdmFibGV9IGluaXRpYWxQZXJtaXNzaW9ucy5hbGxvdyBJbml0aWFsIGFsbG93ZWQgcGVybWlzc2lvbnNcbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uUmVzb2x2YWJsZX0gaW5pdGlhbFBlcm1pc3Npb25zLmRlbnkgSW5pdGlhbCBkZW5pZWQgcGVybWlzc2lvbnNcbiAgICogQHJldHVybnMge1Jlc29sdmVkT3ZlcndyaXRlT3B0aW9uc31cbiAgICovXG4gIHN0YXRpYyByZXNvbHZlT3ZlcndyaXRlT3B0aW9ucyhvcHRpb25zLCB7IGFsbG93LCBkZW55IH0gPSB7fSkge1xuICAgIGFsbG93ID0gbmV3IFBlcm1pc3Npb25zKGFsbG93KTtcbiAgICBkZW55ID0gbmV3IFBlcm1pc3Npb25zKGRlbnkpO1xuXG4gICAgZm9yIChjb25zdCBbcGVybSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgYWxsb3cuYWRkKFBlcm1pc3Npb25zLkZMQUdTW3Blcm1dKTtcbiAgICAgICAgZGVueS5yZW1vdmUoUGVybWlzc2lvbnMuRkxBR1NbcGVybV0pO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYWxsb3cucmVtb3ZlKFBlcm1pc3Npb25zLkZMQUdTW3Blcm1dKTtcbiAgICAgICAgZGVueS5hZGQoUGVybWlzc2lvbnMuRkxBR1NbcGVybV0pO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBhbGxvdy5yZW1vdmUoUGVybWlzc2lvbnMuRkxBR1NbcGVybV0pO1xuICAgICAgICBkZW55LnJlbW92ZShQZXJtaXNzaW9ucy5GTEFHU1twZXJtXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgYWxsb3csIGRlbnkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmF3IGRhdGEgZm9yIGEgcGVybWlzc2lvbiBvdmVyd3JpdGVcbiAgICogQHR5cGVkZWYge09iamVjdH0gUmF3T3ZlcndyaXRlRGF0YVxuICAgKiBAcHJvcGVydHkge1Nub3dmbGFrZX0gaWQgVGhlIGlkIG9mIHRoZSBvdmVyd3JpdGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFsbG93IFRoZSBwZXJtaXNzaW9ucyB0byBhbGxvd1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVueSBUaGUgcGVybWlzc2lvbnMgdG8gZGVueVxuICAgKiBAcHJvcGVydHkge092ZXJ3cml0ZVR5cGV9IHR5cGUgVGhlIHR5cGUgb2YgdGhpcyBPdmVyd3JpdGVEYXRhXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEYXRhIHRoYXQgY2FuIGJlIHJlc29sdmVkIGludG8ge0BsaW5rIFJhd092ZXJ3cml0ZURhdGF9XG4gICAqIEB0eXBlZGVmIHtQZXJtaXNzaW9uT3ZlcndyaXRlc3xPdmVyd3JpdGVEYXRhfSBPdmVyd3JpdGVSZXNvbHZhYmxlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEYXRhIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgcGVybWlzc2lvbiBvdmVyd3JpdGVcbiAgICogQHR5cGVkZWYge09iamVjdH0gT3ZlcndyaXRlRGF0YVxuICAgKiBAcHJvcGVydHkge0d1aWxkTWVtYmVyUmVzb2x2YWJsZXxSb2xlUmVzb2x2YWJsZX0gaWQgTWVtYmVyIG9yIHJvbGUgdGhpcyBvdmVyd3JpdGUgaXMgZm9yXG4gICAqIEBwcm9wZXJ0eSB7UGVybWlzc2lvblJlc29sdmFibGV9IFthbGxvd10gVGhlIHBlcm1pc3Npb25zIHRvIGFsbG93XG4gICAqIEBwcm9wZXJ0eSB7UGVybWlzc2lvblJlc29sdmFibGV9IFtkZW55XSBUaGUgcGVybWlzc2lvbnMgdG8gZGVueVxuICAgKiBAcHJvcGVydHkge092ZXJ3cml0ZVR5cGV9IFt0eXBlXSBUaGUgdHlwZSBvZiB0aGlzIE92ZXJ3cml0ZURhdGFcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFuIG92ZXJ3cml0ZSBpbnRvIHtAbGluayBSYXdPdmVyd3JpdGVEYXRhfS5cbiAgICogQHBhcmFtIHtPdmVyd3JpdGVSZXNvbHZhYmxlfSBvdmVyd3JpdGUgVGhlIG92ZXJ3cml0ZS1saWtlIGRhdGEgdG8gcmVzb2x2ZVxuICAgKiBAcGFyYW0ge0d1aWxkfSBndWlsZCBUaGUgZ3VpbGQgdG8gcmVzb2x2ZSBmcm9tXG4gICAqIEByZXR1cm5zIHtSYXdPdmVyd3JpdGVEYXRhfVxuICAgKi9cbiAgc3RhdGljIHJlc29sdmUob3ZlcndyaXRlLCBndWlsZCkge1xuICAgIGlmIChvdmVyd3JpdGUgaW5zdGFuY2VvZiB0aGlzKSByZXR1cm4gb3ZlcndyaXRlLnRvSlNPTigpO1xuICAgIGlmICh0eXBlb2Ygb3ZlcndyaXRlLmlkID09PSAnc3RyaW5nJyAmJiBbJ3JvbGUnLCAnbWVtYmVyJ10uaW5jbHVkZXMob3ZlcndyaXRlLnR5cGUpKSB7XG4gICAgICByZXR1cm4geyAuLi5vdmVyd3JpdGUsIGFsbG93OiBQZXJtaXNzaW9ucy5yZXNvbHZlKG92ZXJ3cml0ZS5hbGxvdyksIGRlbnk6IFBlcm1pc3Npb25zLnJlc29sdmUob3ZlcndyaXRlLmRlbnkpIH07XG4gICAgfVxuXG4gICAgY29uc3QgdXNlck9yUm9sZSA9IGd1aWxkLnJvbGVzLnJlc29sdmUob3ZlcndyaXRlLmlkKSB8fCBndWlsZC5jbGllbnQudXNlcnMucmVzb2x2ZShvdmVyd3JpdGUuaWQpO1xuICAgIGlmICghdXNlck9yUm9sZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSU5WQUxJRF9UWVBFJywgJ3BhcmFtZXRlcicsICdVc2VyIG5vciBhIFJvbGUnKTtcbiAgICBjb25zdCB0eXBlID0gdXNlck9yUm9sZSBpbnN0YW5jZW9mIFJvbGUgPyAncm9sZScgOiAnbWVtYmVyJztcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogdXNlck9yUm9sZS5pZCxcbiAgICAgIHR5cGUsXG4gICAgICBhbGxvdzogUGVybWlzc2lvbnMucmVzb2x2ZShvdmVyd3JpdGUuYWxsb3cpLFxuICAgICAgZGVueTogUGVybWlzc2lvbnMucmVzb2x2ZShvdmVyd3JpdGUuZGVueSksXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcm1pc3Npb25PdmVyd3JpdGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFbW9qaSA9IHJlcXVpcmUoJy4vRW1vamknKTtcbmNvbnN0IEFjdGl2aXR5RmxhZ3MgPSByZXF1aXJlKCcuLi91dGlsL0FjdGl2aXR5RmxhZ3MnKTtcbmNvbnN0IHsgQWN0aXZpdHlUeXBlcyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBBY3Rpdml0eSBzZW50IGluIGEgbWVzc2FnZS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1lc3NhZ2VBY3Rpdml0eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYXJ0eUlEXSBJZCBvZiB0aGUgcGFydHkgcmVwcmVzZW50ZWQgaW4gYWN0aXZpdHlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHlwZV0gVHlwZSBvZiBhY3Rpdml0eSBzZW50XG4gKi9cblxuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoaXMgcHJlc2VuY2U6XG4gKiAqICoqYG9ubGluZWAqKiAtIHVzZXIgaXMgb25saW5lXG4gKiAqICoqYGlkbGVgKiogLSB1c2VyIGlzIEFGS1xuICogKiAqKmBvZmZsaW5lYCoqIC0gdXNlciBpcyBvZmZsaW5lIG9yIGludmlzaWJsZVxuICogKiAqKmBkbmRgKiogLSB1c2VyIGlzIGluIERvIE5vdCBEaXN0dXJiXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBQcmVzZW5jZVN0YXR1c1xuICovXG5cbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGlzIHByZXNlbmNlOlxuICogKiAqKmBvbmxpbmVgKiogLSB1c2VyIGlzIG9ubGluZVxuICogKiAqKmBpZGxlYCoqIC0gdXNlciBpcyBBRktcbiAqICogKipgZG5kYCoqIC0gdXNlciBpcyBpbiBEbyBOb3QgRGlzdHVyYlxuICogQHR5cGVkZWYge3N0cmluZ30gQ2xpZW50UHJlc2VuY2VTdGF0dXNcbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB1c2VyJ3MgcHJlc2VuY2UuXG4gKi9cbmNsYXNzIFByZXNlbmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnQgVGhlIGluc3RhbnRpYXRpbmcgY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YT17fV0gVGhlIGRhdGEgZm9yIHRoZSBwcmVzZW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRoYXQgaW5zdGFudGlhdGVkIHRoaXNcbiAgICAgKiBAbmFtZSBQcmVzZW5jZSNjbGllbnRcbiAgICAgKiBAdHlwZSB7Q2xpZW50fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2xpZW50JywgeyB2YWx1ZTogY2xpZW50IH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VyIElEIG9mIHRoaXMgcHJlc2VuY2VcbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMudXNlcklEID0gZGF0YS51c2VyLmlkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGd1aWxkIG9mIHRoaXMgcHJlc2VuY2VcbiAgICAgKiBAdHlwZSB7P0d1aWxkfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpbGQgPSBkYXRhLmd1aWxkIHx8IG51bGw7XG5cbiAgICB0aGlzLnBhdGNoKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB1c2VyIG9mIHRoaXMgcHJlc2VuY2VcbiAgICogQHR5cGUgez9Vc2VyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB1c2VyKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC51c2Vycy5jYWNoZS5nZXQodGhpcy51c2VySUQpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1lbWJlciBvZiB0aGlzIHByZXNlbmNlXG4gICAqIEB0eXBlIHs/R3VpbGRNZW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lbWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ndWlsZC5tZW1iZXJzLmNhY2hlLmdldCh0aGlzLnVzZXJJRCkgfHwgbnVsbDtcbiAgfVxuXG4gIHBhdGNoKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdHVzIG9mIHRoaXMgcHJlc2VuY2VcbiAgICAgKiBAdHlwZSB7UHJlc2VuY2VTdGF0dXN9XG4gICAgICovXG4gICAgdGhpcy5zdGF0dXMgPSBkYXRhLnN0YXR1cyB8fCB0aGlzLnN0YXR1cyB8fCAnb2ZmbGluZSc7XG5cbiAgICBpZiAoZGF0YS5hY3Rpdml0aWVzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBhY3Rpdml0aWVzIG9mIHRoaXMgcHJlc2VuY2VcbiAgICAgICAqIEB0eXBlIHtBY3Rpdml0eVtdfVxuICAgICAgICovXG4gICAgICB0aGlzLmFjdGl2aXRpZXMgPSBkYXRhLmFjdGl2aXRpZXMubWFwKGFjdGl2aXR5ID0+IG5ldyBBY3Rpdml0eSh0aGlzLCBhY3Rpdml0eSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpdml0eSB8fCBkYXRhLmdhbWUpIHtcbiAgICAgIHRoaXMuYWN0aXZpdGllcyA9IFtuZXcgQWN0aXZpdHkodGhpcywgZGF0YS5nYW1lIHx8IGRhdGEuYWN0aXZpdHkpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY3Rpdml0aWVzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRldmljZXMgdGhpcyBwcmVzZW5jZSBpcyBvblxuICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7P0NsaWVudFByZXNlbmNlU3RhdHVzfSB3ZWIgVGhlIGN1cnJlbnQgcHJlc2VuY2UgaW4gdGhlIHdlYiBhcHBsaWNhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7P0NsaWVudFByZXNlbmNlU3RhdHVzfSBtb2JpbGUgVGhlIGN1cnJlbnQgcHJlc2VuY2UgaW4gdGhlIG1vYmlsZSBhcHBsaWNhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7P0NsaWVudFByZXNlbmNlU3RhdHVzfSBkZXNrdG9wIFRoZSBjdXJyZW50IHByZXNlbmNlIGluIHRoZSBkZXNrdG9wIGFwcGxpY2F0aW9uXG4gICAgICovXG4gICAgdGhpcy5jbGllbnRTdGF0dXMgPSBkYXRhLmNsaWVudF9zdGF0dXMgfHwgbnVsbDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2Nsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHRoaXMpLCB0aGlzKTtcbiAgICBpZiAodGhpcy5hY3Rpdml0aWVzKSBjbG9uZS5hY3Rpdml0aWVzID0gdGhpcy5hY3Rpdml0aWVzLm1hcChhY3Rpdml0eSA9PiBhY3Rpdml0eS5fY2xvbmUoKSk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBwcmVzZW5jZSBpcyBlcXVhbCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0ge1ByZXNlbmNlfSBwcmVzZW5jZSBUaGUgcHJlc2VuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKHByZXNlbmNlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMgPT09IHByZXNlbmNlIHx8XG4gICAgICAocHJlc2VuY2UgJiZcbiAgICAgICAgdGhpcy5zdGF0dXMgPT09IHByZXNlbmNlLnN0YXR1cyAmJlxuICAgICAgICB0aGlzLmFjdGl2aXRpZXMubGVuZ3RoID09PSBwcmVzZW5jZS5hY3Rpdml0aWVzLmxlbmd0aCAmJlxuICAgICAgICB0aGlzLmFjdGl2aXRpZXMuZXZlcnkoKGFjdGl2aXR5LCBpbmRleCkgPT4gYWN0aXZpdHkuZXF1YWxzKHByZXNlbmNlLmFjdGl2aXRpZXNbaW5kZXhdKSkgJiZcbiAgICAgICAgdGhpcy5jbGllbnRTdGF0dXMud2ViID09PSBwcmVzZW5jZS5jbGllbnRTdGF0dXMud2ViICYmXG4gICAgICAgIHRoaXMuY2xpZW50U3RhdHVzLm1vYmlsZSA9PT0gcHJlc2VuY2UuY2xpZW50U3RhdHVzLm1vYmlsZSAmJlxuICAgICAgICB0aGlzLmNsaWVudFN0YXR1cy5kZXNrdG9wID09PSBwcmVzZW5jZS5jbGllbnRTdGF0dXMuZGVza3RvcClcbiAgICApO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBVdGlsLmZsYXR0ZW4odGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdGl2aXR5IHRoYXQgaXMgcGFydCBvZiBhIHVzZXIncyBwcmVzZW5jZS5cbiAqL1xuY2xhc3MgQWN0aXZpdHkge1xuICBjb25zdHJ1Y3RvcihwcmVzZW5jZSwgZGF0YSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJlc2VuY2UnLCB7IHZhbHVlOiBwcmVzZW5jZSB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBhY3Rpdml0eSBiZWluZyBwbGF5ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBhY3Rpdml0eSBzdGF0dXNcbiAgICAgKiBAdHlwZSB7QWN0aXZpdHlUeXBlfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IEFjdGl2aXR5VHlwZXNbZGF0YS50eXBlXTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBhY3Rpdml0eSBpcyBiZWluZyBzdHJlYW1lZCwgYSBsaW5rIHRvIHRoZSBzdHJlYW1cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IGRhdGEudXJsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZXRhaWxzIGFib3V0IHRoZSBhY3Rpdml0eVxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3RhdGUgb2YgdGhlIGFjdGl2aXR5XG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IGRhdGEuc3RhdGUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpY2F0aW9uIElEIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFjdGl2aXR5XG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5hcHBsaWNhdGlvbklEID0gZGF0YS5hcHBsaWNhdGlvbl9pZCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGltZXN0YW1wcyBmb3IgdGhlIGFjdGl2aXR5XG4gICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICogQHByb3BlcnR5IHs/RGF0ZX0gc3RhcnQgV2hlbiB0aGUgYWN0aXZpdHkgc3RhcnRlZFxuICAgICAqIEBwcm9wZXJ0eSB7P0RhdGV9IGVuZCBXaGVuIHRoZSBhY3Rpdml0eSB3aWxsIGVuZFxuICAgICAqL1xuICAgIHRoaXMudGltZXN0YW1wcyA9IGRhdGEudGltZXN0YW1wc1xuICAgICAgPyB7XG4gICAgICAgICAgc3RhcnQ6IGRhdGEudGltZXN0YW1wcy5zdGFydCA/IG5ldyBEYXRlKE51bWJlcihkYXRhLnRpbWVzdGFtcHMuc3RhcnQpKSA6IG51bGwsXG4gICAgICAgICAgZW5kOiBkYXRhLnRpbWVzdGFtcHMuZW5kID8gbmV3IERhdGUoTnVtYmVyKGRhdGEudGltZXN0YW1wcy5lbmQpKSA6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBhcnR5IG9mIHRoZSBhY3Rpdml0eVxuICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gaWQgSUQgb2YgdGhlIHBhcnR5XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gc2l6ZSBTaXplIG9mIHRoZSBwYXJ0eSBhcyBgW2N1cnJlbnQsIG1heF1gXG4gICAgICovXG4gICAgdGhpcy5wYXJ0eSA9IGRhdGEucGFydHkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFzc2V0cyBmb3IgcmljaCBwcmVzZW5jZVxuICAgICAqIEB0eXBlIHs/UmljaFByZXNlbmNlQXNzZXRzfVxuICAgICAqL1xuICAgIHRoaXMuYXNzZXRzID0gZGF0YS5hc3NldHMgPyBuZXcgUmljaFByZXNlbmNlQXNzZXRzKHRoaXMsIGRhdGEuYXNzZXRzKSA6IG51bGw7XG5cbiAgICB0aGlzLnN5bmNJRCA9IGRhdGEuc3luY19pZDtcblxuICAgIC8qKlxuICAgICAqIEZsYWdzIHRoYXQgZGVzY3JpYmUgdGhlIGFjdGl2aXR5XG4gICAgICogQHR5cGUge1JlYWRvbmx5PEFjdGl2aXR5RmxhZ3M+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSBuZXcgQWN0aXZpdHlGbGFncyhkYXRhLmZsYWdzKS5mcmVlemUoKTtcblxuICAgIC8qKlxuICAgICAqIEVtb2ppIGZvciBhIGN1c3RvbSBhY3Rpdml0eVxuICAgICAqIEB0eXBlIHs/RW1vaml9XG4gICAgICovXG4gICAgdGhpcy5lbW9qaSA9IGRhdGEuZW1vamkgPyBuZXcgRW1vamkocHJlc2VuY2UuY2xpZW50LCBkYXRhLmVtb2ppKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBkYXRlIG9mIHRoZSBhY3Rpdml0eVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVkVGltZXN0YW1wID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkX2F0KS5nZXRUaW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGFjdGl2aXR5IGlzIGVxdWFsIHRvIGFub3RoZXIgYWN0aXZpdHkuXG4gICAqIEBwYXJhbSB7QWN0aXZpdHl9IGFjdGl2aXR5IFRoZSBhY3Rpdml0eSB0byBjb21wYXJlIHdpdGhcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMoYWN0aXZpdHkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcyA9PT0gYWN0aXZpdHkgfHxcbiAgICAgIChhY3Rpdml0eSAmJiB0aGlzLm5hbWUgPT09IGFjdGl2aXR5Lm5hbWUgJiYgdGhpcy50eXBlID09PSBhY3Rpdml0eS50eXBlICYmIHRoaXMudXJsID09PSBhY3Rpdml0eS51cmwpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgYWN0aXZpdHkgd2FzIGNyZWF0ZWQgYXRcbiAgICogQHR5cGUge0RhdGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5jcmVhdGVkVGltZXN0YW1wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNvbmNhdGVuYXRlZCB3aXRoIGEgc3RyaW5nLCB0aGlzIGF1dG9tYXRpY2FsbHkgcmV0dXJucyB0aGUgYWN0aXZpdGllcycgbmFtZSBpbnN0ZWFkIG9mIHRoZSBBY3Rpdml0eSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgX2Nsb25lKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodGhpcyksIHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXRzIGZvciBhIHJpY2ggcHJlc2VuY2VcbiAqL1xuY2xhc3MgUmljaFByZXNlbmNlQXNzZXRzIHtcbiAgY29uc3RydWN0b3IoYWN0aXZpdHksIGFzc2V0cykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYWN0aXZpdHknLCB7IHZhbHVlOiBhY3Rpdml0eSB9KTtcblxuICAgIC8qKlxuICAgICAqIEhvdmVyIHRleHQgZm9yIHRoZSBsYXJnZSBpbWFnZVxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFyZ2VUZXh0ID0gYXNzZXRzLmxhcmdlX3RleHQgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEhvdmVyIHRleHQgZm9yIHRoZSBzbWFsbCBpbWFnZVxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc21hbGxUZXh0ID0gYXNzZXRzLnNtYWxsX3RleHQgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElEIG9mIHRoZSBsYXJnZSBpbWFnZSBhc3NldFxuICAgICAqIEB0eXBlIHs/U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMubGFyZ2VJbWFnZSA9IGFzc2V0cy5sYXJnZV9pbWFnZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSUQgb2YgdGhlIHNtYWxsIGltYWdlIGFzc2V0XG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5zbWFsbEltYWdlID0gYXNzZXRzLnNtYWxsX2ltYWdlIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgVVJMIG9mIHRoZSBzbWFsbCBpbWFnZSBhc3NldFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBpbWFnZSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvcm1hdF0gRm9ybWF0IG9mIHRoZSBpbWFnZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2l6ZV0gU2l6ZSBvZiB0aGUgaW1hZ2VcbiAgICogQHJldHVybnMgez9zdHJpbmd9IFRoZSBzbWFsbCBpbWFnZSBVUkxcbiAgICovXG4gIHNtYWxsSW1hZ2VVUkwoeyBmb3JtYXQsIHNpemUgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnNtYWxsSW1hZ2UpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmFjdGl2aXR5LnByZXNlbmNlLmNsaWVudC5yZXN0LmNkbi5BcHBBc3NldCh0aGlzLmFjdGl2aXR5LmFwcGxpY2F0aW9uSUQsIHRoaXMuc21hbGxJbWFnZSwge1xuICAgICAgZm9ybWF0LFxuICAgICAgc2l6ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBVUkwgb2YgdGhlIGxhcmdlIGltYWdlIGFzc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGltYWdlIHVybFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9ybWF0XSBGb3JtYXQgb2YgdGhlIGltYWdlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zaXplXSBTaXplIG9mIHRoZSBpbWFnZVxuICAgKiBAcmV0dXJucyB7P3N0cmluZ30gVGhlIGxhcmdlIGltYWdlIFVSTFxuICAgKi9cbiAgbGFyZ2VJbWFnZVVSTCh7IGZvcm1hdCwgc2l6ZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMubGFyZ2VJbWFnZSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKC9ec3BvdGlmeTovLnRlc3QodGhpcy5sYXJnZUltYWdlKSkge1xuICAgICAgcmV0dXJuIGBodHRwczovL2kuc2Nkbi5jby9pbWFnZS8ke3RoaXMubGFyZ2VJbWFnZS5zbGljZSg4KX1gO1xuICAgIH0gZWxzZSBpZiAoL150d2l0Y2g6Ly50ZXN0KHRoaXMubGFyZ2VJbWFnZSkpIHtcbiAgICAgIHJldHVybiBgaHR0cHM6Ly9zdGF0aWMtY2RuLmp0dm53Lm5ldC9wcmV2aWV3cy10dHYvbGl2ZV91c2VyXyR7dGhpcy5sYXJnZUltYWdlLnNsaWNlKDcpfS5wbmdgO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hY3Rpdml0eS5wcmVzZW5jZS5jbGllbnQucmVzdC5jZG4uQXBwQXNzZXQodGhpcy5hY3Rpdml0eS5hcHBsaWNhdGlvbklELCB0aGlzLmxhcmdlSW1hZ2UsIHtcbiAgICAgIGZvcm1hdCxcbiAgICAgIHNpemUsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy5QcmVzZW5jZSA9IFByZXNlbmNlO1xuZXhwb3J0cy5BY3Rpdml0eSA9IEFjdGl2aXR5O1xuZXhwb3J0cy5SaWNoUHJlc2VuY2VBc3NldHMgPSBSaWNoUHJlc2VuY2VBc3NldHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbGxlY3RvciA9IHJlcXVpcmUoJy4vaW50ZXJmYWNlcy9Db2xsZWN0b3InKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IHsgRXZlbnRzIH0gPSByZXF1aXJlKCcuLi91dGlsL0NvbnN0YW50cycpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDb2xsZWN0b3JPcHRpb25zfSBSZWFjdGlvbkNvbGxlY3Rvck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdG90YWwgYW1vdW50IG9mIHJlYWN0aW9ucyB0byBjb2xsZWN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4RW1vamlzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbW9qaXMgdG8gY29sbGVjdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFVzZXJzIFRoZSBtYXhpbXVtIG51bWJlciBvZiB1c2VycyB0byByZWFjdFxuICovXG5cbi8qKlxuICogQ29sbGVjdHMgcmVhY3Rpb25zIG9uIG1lc3NhZ2VzLlxuICogV2lsbCBhdXRvbWF0aWNhbGx5IHN0b3AgaWYgdGhlIG1lc3NhZ2UgKGAnbWVzc2FnZURlbGV0ZSdgKSxcbiAqIGNoYW5uZWwgKGAnY2hhbm5lbERlbGV0ZSdgKSwgb3IgZ3VpbGQgKGAnZ3VpbGREZWxldGUnYCkgYXJlIGRlbGV0ZWQuXG4gKiBAZXh0ZW5kcyB7Q29sbGVjdG9yfVxuICovXG5jbGFzcyBSZWFjdGlvbkNvbGxlY3RvciBleHRlbmRzIENvbGxlY3RvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdXBvbiB3aGljaCB0byBjb2xsZWN0IHJlYWN0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3RvckZpbHRlcn0gZmlsdGVyIFRoZSBmaWx0ZXIgdG8gYXBwbHkgdG8gdGhpcyBjb2xsZWN0b3JcbiAgICogQHBhcmFtIHtSZWFjdGlvbkNvbGxlY3Rvck9wdGlvbnN9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBhcHBseSB0byB0aGlzIGNvbGxlY3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZmlsdGVyLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihtZXNzYWdlLmNsaWVudCwgZmlsdGVyLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXNzYWdlIHVwb24gd2hpY2ggdG8gY29sbGVjdCByZWFjdGlvbnNcbiAgICAgKiBAdHlwZSB7TWVzc2FnZX1cbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHdoaWNoIGhhdmUgcmVhY3RlZCB0byB0aGlzIG1lc3NhZ2VcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJzID0gbmV3IENvbGxlY3Rpb24oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgcmVhY3Rpb25zIGNvbGxlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b3RhbCA9IDA7XG5cbiAgICB0aGlzLmVtcHR5ID0gdGhpcy5lbXB0eS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZUNoYW5uZWxEZWxldGlvbiA9IHRoaXMuX2hhbmRsZUNoYW5uZWxEZWxldGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZUd1aWxkRGVsZXRpb24gPSB0aGlzLl9oYW5kbGVHdWlsZERlbGV0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlTWVzc2FnZURlbGV0aW9uID0gdGhpcy5faGFuZGxlTWVzc2FnZURlbGV0aW9uLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNsaWVudC5pbmNyZW1lbnRNYXhMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsaWVudC5vbihFdmVudHMuTUVTU0FHRV9SRUFDVElPTl9BREQsIHRoaXMuaGFuZGxlQ29sbGVjdCk7XG4gICAgdGhpcy5jbGllbnQub24oRXZlbnRzLk1FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFLCB0aGlzLmhhbmRsZURpc3Bvc2UpO1xuICAgIHRoaXMuY2xpZW50Lm9uKEV2ZW50cy5NRVNTQUdFX1JFQUNUSU9OX1JFTU9WRV9BTEwsIHRoaXMuZW1wdHkpO1xuICAgIHRoaXMuY2xpZW50Lm9uKEV2ZW50cy5NRVNTQUdFX0RFTEVURSwgdGhpcy5faGFuZGxlTWVzc2FnZURlbGV0aW9uKTtcbiAgICB0aGlzLmNsaWVudC5vbihFdmVudHMuQ0hBTk5FTF9ERUxFVEUsIHRoaXMuX2hhbmRsZUNoYW5uZWxEZWxldGlvbik7XG4gICAgdGhpcy5jbGllbnQub24oRXZlbnRzLkdVSUxEX0RFTEVURSwgdGhpcy5faGFuZGxlR3VpbGREZWxldGlvbik7XG5cbiAgICB0aGlzLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAgIHRoaXMuY2xpZW50LnJlbW92ZUxpc3RlbmVyKEV2ZW50cy5NRVNTQUdFX1JFQUNUSU9OX0FERCwgdGhpcy5oYW5kbGVDb2xsZWN0KTtcbiAgICAgIHRoaXMuY2xpZW50LnJlbW92ZUxpc3RlbmVyKEV2ZW50cy5NRVNTQUdFX1JFQUNUSU9OX1JFTU9WRSwgdGhpcy5oYW5kbGVEaXNwb3NlKTtcbiAgICAgIHRoaXMuY2xpZW50LnJlbW92ZUxpc3RlbmVyKEV2ZW50cy5NRVNTQUdFX1JFQUNUSU9OX1JFTU9WRV9BTEwsIHRoaXMuZW1wdHkpO1xuICAgICAgdGhpcy5jbGllbnQucmVtb3ZlTGlzdGVuZXIoRXZlbnRzLk1FU1NBR0VfREVMRVRFLCB0aGlzLl9oYW5kbGVNZXNzYWdlRGVsZXRpb24pO1xuICAgICAgdGhpcy5jbGllbnQucmVtb3ZlTGlzdGVuZXIoRXZlbnRzLkNIQU5ORUxfREVMRVRFLCB0aGlzLl9oYW5kbGVDaGFubmVsRGVsZXRpb24pO1xuICAgICAgdGhpcy5jbGllbnQucmVtb3ZlTGlzdGVuZXIoRXZlbnRzLkdVSUxEX0RFTEVURSwgdGhpcy5faGFuZGxlR3VpbGREZWxldGlvbik7XG4gICAgICB0aGlzLmNsaWVudC5kZWNyZW1lbnRNYXhMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2NvbGxlY3QnLCAocmVhY3Rpb24sIHVzZXIpID0+IHtcbiAgICAgIHRoaXMudG90YWwrKztcbiAgICAgIHRoaXMudXNlcnMuc2V0KHVzZXIuaWQsIHVzZXIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbigncmVtb3ZlJywgKHJlYWN0aW9uLCB1c2VyKSA9PiB7XG4gICAgICB0aGlzLnRvdGFsLS07XG4gICAgICBpZiAoIXRoaXMuY29sbGVjdGVkLnNvbWUociA9PiByLnVzZXJzLmNhY2hlLmhhcyh1c2VyLmlkKSkpIHRoaXMudXNlcnMuZGVsZXRlKHVzZXIuaWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW5jb21pbmcgcmVhY3Rpb24gZm9yIHBvc3NpYmxlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVzc2FnZVJlYWN0aW9ufSByZWFjdGlvbiBUaGUgcmVhY3Rpb24gdG8gcG9zc2libHkgY29sbGVjdFxuICAgKiBAcmV0dXJucyB7P1Nub3dmbGFrZXxzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb2xsZWN0KHJlYWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuZXZlciBhIHJlYWN0aW9uIGlzIGNvbGxlY3RlZC5cbiAgICAgKiBAZXZlbnQgUmVhY3Rpb25Db2xsZWN0b3IjY29sbGVjdFxuICAgICAqIEBwYXJhbSB7TWVzc2FnZVJlYWN0aW9ufSByZWFjdGlvbiBUaGUgcmVhY3Rpb24gdGhhdCB3YXMgY29sbGVjdGVkXG4gICAgICogQHBhcmFtIHtVc2VyfSB1c2VyIFRoZSB1c2VyIHRoYXQgYWRkZWQgdGhlIHJlYWN0aW9uXG4gICAgICovXG4gICAgaWYgKHJlYWN0aW9uLm1lc3NhZ2UuaWQgIT09IHRoaXMubWVzc2FnZS5pZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIFJlYWN0aW9uQ29sbGVjdG9yLmtleShyZWFjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHJlYWN0aW9uIGRlbGV0aW9uIGZvciBwb3NzaWJsZSBkaXNwb3NhbC5cbiAgICogQHBhcmFtIHtNZXNzYWdlUmVhY3Rpb259IHJlYWN0aW9uIFRoZSByZWFjdGlvbiB0byBwb3NzaWJseSBkaXNwb3NlIG9mXG4gICAqIEBwYXJhbSB7VXNlcn0gdXNlciBUaGUgdXNlciB0aGF0IHJlbW92ZWQgdGhlIHJlYWN0aW9uXG4gICAqIEByZXR1cm5zIHs/U25vd2ZsYWtlfHN0cmluZ31cbiAgICovXG4gIGRpc3Bvc2UocmVhY3Rpb24sIHVzZXIpIHtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIHJlYWN0aW9uIGhhZCBhbGwgdGhlIHVzZXJzIHJlbW92ZWQgYW5kIHRoZSBgZGlzcG9zZWAgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgICAqIEBldmVudCBSZWFjdGlvbkNvbGxlY3RvciNkaXNwb3NlXG4gICAgICogQHBhcmFtIHtNZXNzYWdlUmVhY3Rpb259IHJlYWN0aW9uIFRoZSByZWFjdGlvbiB0aGF0IHdhcyBkaXNwb3NlZCBvZlxuICAgICAqIEBwYXJhbSB7VXNlcn0gdXNlciBUaGUgdXNlciB0aGF0IHJlbW92ZWQgdGhlIHJlYWN0aW9uXG4gICAgICovXG4gICAgaWYgKHJlYWN0aW9uLm1lc3NhZ2UuaWQgIT09IHRoaXMubWVzc2FnZS5pZCkgcmV0dXJuIG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIHJlYWN0aW9uIGhhZCBvbmUgdXNlciByZW1vdmVkIGFuZCB0aGUgYGRpc3Bvc2VgIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAZXZlbnQgUmVhY3Rpb25Db2xsZWN0b3IjcmVtb3ZlXG4gICAgICogQHBhcmFtIHtNZXNzYWdlUmVhY3Rpb259IHJlYWN0aW9uIFRoZSByZWFjdGlvbiB0aGF0IHdhcyByZW1vdmVkXG4gICAgICogQHBhcmFtIHtVc2VyfSB1c2VyIFRoZSB1c2VyIHRoYXQgcmVtb3ZlZCB0aGUgcmVhY3Rpb25cbiAgICAgKi9cbiAgICBpZiAodGhpcy5jb2xsZWN0ZWQuaGFzKFJlYWN0aW9uQ29sbGVjdG9yLmtleShyZWFjdGlvbikpICYmIHRoaXMudXNlcnMuaGFzKHVzZXIuaWQpKSB7XG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZScsIHJlYWN0aW9uLCB1c2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWN0aW9uLmNvdW50ID8gbnVsbCA6IFJlYWN0aW9uQ29sbGVjdG9yLmtleShyZWFjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRW1wdGllcyB0aGlzIHJlYWN0aW9uIGNvbGxlY3Rvci5cbiAgICovXG4gIGVtcHR5KCkge1xuICAgIHRoaXMudG90YWwgPSAwO1xuICAgIHRoaXMuY29sbGVjdGVkLmNsZWFyKCk7XG4gICAgdGhpcy51c2Vycy5jbGVhcigpO1xuICAgIHRoaXMuY2hlY2tFbmQoKTtcbiAgfVxuXG4gIGVuZFJlYXNvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm1heCAmJiB0aGlzLnRvdGFsID49IHRoaXMub3B0aW9ucy5tYXgpIHJldHVybiAnbGltaXQnO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RW1vamlzICYmIHRoaXMuY29sbGVjdGVkLnNpemUgPj0gdGhpcy5vcHRpb25zLm1heEVtb2ppcykgcmV0dXJuICdlbW9qaUxpbWl0JztcbiAgICBpZiAodGhpcy5vcHRpb25zLm1heFVzZXJzICYmIHRoaXMudXNlcnMuc2l6ZSA+PSB0aGlzLm9wdGlvbnMubWF4VXNlcnMpIHJldHVybiAndXNlckxpbWl0JztcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNoZWNraW5nIGlmIHRoZSBtZXNzYWdlIGhhcyBiZWVuIGRlbGV0ZWQsIGFuZCBpZiBzbywgc3RvcHMgdGhlIGNvbGxlY3RvciB3aXRoIHRoZSByZWFzb24gJ21lc3NhZ2VEZWxldGUnLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdGhhdCB3YXMgZGVsZXRlZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9oYW5kbGVNZXNzYWdlRGVsZXRpb24obWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLmlkID09PSB0aGlzLm1lc3NhZ2UuaWQpIHtcbiAgICAgIHRoaXMuc3RvcCgnbWVzc2FnZURlbGV0ZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNoZWNraW5nIGlmIHRoZSBjaGFubmVsIGhhcyBiZWVuIGRlbGV0ZWQsIGFuZCBpZiBzbywgc3RvcHMgdGhlIGNvbGxlY3RvciB3aXRoIHRoZSByZWFzb24gJ2NoYW5uZWxEZWxldGUnLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0d1aWxkQ2hhbm5lbH0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0aGF0IHdhcyBkZWxldGVkXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2hhbmRsZUNoYW5uZWxEZWxldGlvbihjaGFubmVsKSB7XG4gICAgaWYgKGNoYW5uZWwuaWQgPT09IHRoaXMubWVzc2FnZS5jaGFubmVsLmlkKSB7XG4gICAgICB0aGlzLnN0b3AoJ2NoYW5uZWxEZWxldGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjaGVja2luZyBpZiB0aGUgZ3VpbGQgaGFzIGJlZW4gZGVsZXRlZCwgYW5kIGlmIHNvLCBzdG9wcyB0aGUgY29sbGVjdG9yIHdpdGggdGhlIHJlYXNvbiAnZ3VpbGREZWxldGUnLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0d1aWxkfSBndWlsZCBUaGUgZ3VpbGQgdGhhdCB3YXMgZGVsZXRlZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9oYW5kbGVHdWlsZERlbGV0aW9uKGd1aWxkKSB7XG4gICAgaWYgKHRoaXMubWVzc2FnZS5ndWlsZCAmJiBndWlsZC5pZCA9PT0gdGhpcy5tZXNzYWdlLmd1aWxkLmlkKSB7XG4gICAgICB0aGlzLnN0b3AoJ2d1aWxkRGVsZXRlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbGxlY3RvciBrZXkgZm9yIGEgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVzc2FnZVJlYWN0aW9ufSByZWFjdGlvbiBUaGUgbWVzc2FnZSByZWFjdGlvbiB0byBnZXQgdGhlIGtleSBmb3JcbiAgICogQHJldHVybnMge1Nub3dmbGFrZXxzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMga2V5KHJlYWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlYWN0aW9uLmVtb2ppLmlkIHx8IHJlYWN0aW9uLmVtb2ppLm5hbWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdGlvbkNvbGxlY3RvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRW1vamkgPSByZXF1aXJlKCcuL0Vtb2ppJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGxpbWl0ZWQgZW1vamkgc2V0IHVzZWQgZm9yIGJvdGggY3VzdG9tIGFuZCB1bmljb2RlIGVtb2ppcy4gQ3VzdG9tIGVtb2ppc1xuICogd2lsbCB1c2UgdGhpcyBjbGFzcyBvcHBvc2VkIHRvIHRoZSBFbW9qaSBjbGFzcyB3aGVuIHRoZSBjbGllbnQgZG9lc24ndCBrbm93IGVub3VnaFxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlbS5cbiAqIEBleHRlbmRzIHtFbW9qaX1cbiAqL1xuY2xhc3MgUmVhY3Rpb25FbW9qaSBleHRlbmRzIEVtb2ppIHtcbiAgY29uc3RydWN0b3IocmVhY3Rpb24sIGVtb2ppKSB7XG4gICAgc3VwZXIocmVhY3Rpb24ubWVzc2FnZS5jbGllbnQsIGVtb2ppKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVzc2FnZSByZWFjdGlvbiB0aGlzIGVtb2ppIHJlZmVycyB0b1xuICAgICAqIEB0eXBlIHtNZXNzYWdlUmVhY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5yZWFjdGlvbiA9IHJlYWN0aW9uO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBVdGlsLmZsYXR0ZW4odGhpcywgeyBpZGVudGlmaWVyOiB0cnVlIH0pO1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0aW9uRW1vamk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbmNvbnN0IHsgRXJyb3IsIFR5cGVFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBQZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4uL3V0aWwvUGVybWlzc2lvbnMnKTtcbmNvbnN0IFNub3dmbGFrZSA9IHJlcXVpcmUoJy4uL3V0aWwvU25vd2ZsYWtlJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJvbGUgb24gRGlzY29yZC5cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBSb2xlIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50IFRoZSBpbnN0YW50aWF0aW5nIGNsaWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJvbGVcbiAgICogQHBhcmFtIHtHdWlsZH0gZ3VpbGQgVGhlIGd1aWxkIHRoZSByb2xlIGlzIHBhcnQgb2ZcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgZGF0YSwgZ3VpbGQpIHtcbiAgICBzdXBlcihjbGllbnQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGd1aWxkIHRoYXQgdGhlIHJvbGUgYmVsb25ncyB0b1xuICAgICAqIEB0eXBlIHtHdWlsZH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aWxkID0gZ3VpbGQ7XG5cbiAgICBpZiAoZGF0YSkgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgcm9sZSAodW5pcXVlIHRvIHRoZSBndWlsZCBpdCBpcyBwYXJ0IG9mKVxuICAgICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcm9sZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgMTAgY29sb3Igb2YgdGhlIHJvbGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdXNlcnMgdGhhdCBhcmUgcGFydCBvZiB0aGlzIHJvbGUgd2lsbCBhcHBlYXIgaW4gYSBzZXBhcmF0ZSBjYXRlZ29yeSBpbiB0aGUgdXNlcnMgbGlzdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaG9pc3QgPSBkYXRhLmhvaXN0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhdyBwb3NpdGlvbiBvZiB0aGUgcm9sZSBmcm9tIHRoZSBBUElcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmF3UG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBlcm1pc3Npb25zIG9mIHRoZSByb2xlXG4gICAgICogQHR5cGUge1JlYWRvbmx5PFBlcm1pc3Npb25zPn1cbiAgICAgKi9cbiAgICB0aGlzLnBlcm1pc3Npb25zID0gbmV3IFBlcm1pc3Npb25zKGRhdGEucGVybWlzc2lvbnMpLmZyZWV6ZSgpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIHJvbGUgaXMgbWFuYWdlZCBieSBhbiBleHRlcm5hbCBzZXJ2aWNlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tYW5hZ2VkID0gZGF0YS5tYW5hZ2VkO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIHJvbGUgY2FuIGJlIG1lbnRpb25lZCBieSBhbnlvbmVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1lbnRpb25hYmxlID0gZGF0YS5tZW50aW9uYWJsZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJvbGUgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgdGhlIHJvbGUgd2FzIGNyZWF0ZWQgYXRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZFRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gU25vd2ZsYWtlLmRlY29uc3RydWN0KHRoaXMuaWQpLnRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgcm9sZSB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZEF0KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmNyZWF0ZWRUaW1lc3RhbXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBoZXhhZGVjaW1hbCB2ZXJzaW9uIG9mIHRoZSByb2xlIGNvbG9yLCB3aXRoIGEgbGVhZGluZyBoYXNodGFnXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGhleENvbG9yKCkge1xuICAgIHJldHVybiBgIyR7dGhpcy5jb2xvci50b1N0cmluZygxNikucGFkU3RhcnQoNiwgJzAnKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWNoZWQgZ3VpbGQgbWVtYmVycyB0aGF0IGhhdmUgdGhpcyByb2xlXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRNZW1iZXI+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmd1aWxkLm1lbWJlcnMuY2FjaGUuZmlsdGVyKG0gPT4gbS5yb2xlcy5jYWNoZS5oYXModGhpcy5pZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJvbGUgaXMgZWRpdGFibGUgYnkgdGhlIGNsaWVudCB1c2VyXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBlZGl0YWJsZSgpIHtcbiAgICBpZiAodGhpcy5tYW5hZ2VkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY2xpZW50TWVtYmVyID0gdGhpcy5ndWlsZC5tZW1iZXIodGhpcy5jbGllbnQudXNlcik7XG4gICAgaWYgKCFjbGllbnRNZW1iZXIucGVybWlzc2lvbnMuaGFzKFBlcm1pc3Npb25zLkZMQUdTLk1BTkFHRV9ST0xFUykpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY2xpZW50TWVtYmVyLnJvbGVzLmhpZ2hlc3QuY29tcGFyZVBvc2l0aW9uVG8odGhpcykgPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgcm9sZSBpbiB0aGUgcm9sZSBtYW5hZ2VyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHNvcnRlZCA9IHRoaXMuZ3VpbGQuX3NvcnRlZFJvbGVzKCk7XG4gICAgcmV0dXJuIHNvcnRlZC5hcnJheSgpLmluZGV4T2Yoc29ydGVkLmdldCh0aGlzLmlkKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyByb2xlJ3MgcG9zaXRpb24gdG8gYW5vdGhlciByb2xlJ3MuXG4gICAqIEBwYXJhbSB7Um9sZVJlc29sdmFibGV9IHJvbGUgUm9sZSB0byBjb21wYXJlIHRvIHRoaXMgb25lXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IE5lZ2F0aXZlIG51bWJlciBpZiB0aGlzIHJvbGUncyBwb3NpdGlvbiBpcyBsb3dlciAob3RoZXIgcm9sZSdzIGlzIGhpZ2hlciksXG4gICAqIHBvc2l0aXZlIG51bWJlciBpZiB0aGlzIG9uZSBpcyBoaWdoZXIgKG90aGVyJ3MgaXMgbG93ZXIpLCAwIGlmIGVxdWFsXG4gICAqL1xuICBjb21wYXJlUG9zaXRpb25Ubyhyb2xlKSB7XG4gICAgcm9sZSA9IHRoaXMuZ3VpbGQucm9sZXMucmVzb2x2ZShyb2xlKTtcbiAgICBpZiAoIXJvbGUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lOVkFMSURfVFlQRScsICdyb2xlJywgJ1JvbGUgbm9yIGEgU25vd2ZsYWtlJyk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29tcGFyZVBvc2l0aW9ucyh0aGlzLCByb2xlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSBmb3IgYSByb2xlLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBSb2xlRGF0YVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIFRoZSBuYW1lIG9mIHRoZSByb2xlXG4gICAqIEBwcm9wZXJ0eSB7Q29sb3JSZXNvbHZhYmxlfSBbY29sb3JdIFRoZSBjb2xvciBvZiB0aGUgcm9sZSwgZWl0aGVyIGEgaGV4IHN0cmluZyBvciBhIGJhc2UgMTAgbnVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hvaXN0XSBXaGV0aGVyIG9yIG5vdCB0aGUgcm9sZSBzaG91bGQgYmUgaG9pc3RlZFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3Bvc2l0aW9uXSBUaGUgcG9zaXRpb24gb2YgdGhlIHJvbGVcbiAgICogQHByb3BlcnR5IHtQZXJtaXNzaW9uUmVzb2x2YWJsZX0gW3Blcm1pc3Npb25zXSBUaGUgcGVybWlzc2lvbnMgb2YgdGhlIHJvbGVcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbbWVudGlvbmFibGVdIFdoZXRoZXIgb3Igbm90IHRoZSByb2xlIHNob3VsZCBiZSBtZW50aW9uYWJsZVxuICAgKi9cblxuICAvKipcbiAgICogRWRpdHMgdGhlIHJvbGUuXG4gICAqIEBwYXJhbSB7Um9sZURhdGF9IGRhdGEgVGhlIG5ldyBkYXRhIGZvciB0aGUgcm9sZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBlZGl0aW5nIHRoaXMgcm9sZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSb2xlPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gRWRpdCBhIHJvbGVcbiAgICogcm9sZS5lZGl0KHsgbmFtZTogJ25ldyByb2xlJyB9KVxuICAgKiAgIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYEVkaXRlZCByb2xlIG5hbWUgdG8gJHt1cGRhdGVkLm5hbWV9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgYXN5bmMgZWRpdChkYXRhLCByZWFzb24pIHtcbiAgICBpZiAodHlwZW9mIGRhdGEucGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSBkYXRhLnBlcm1pc3Npb25zID0gUGVybWlzc2lvbnMucmVzb2x2ZShkYXRhLnBlcm1pc3Npb25zKTtcbiAgICBlbHNlIGRhdGEucGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zLmJpdGZpZWxkO1xuICAgIGlmICh0eXBlb2YgZGF0YS5wb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGF3YWl0IFV0aWwuc2V0UG9zaXRpb24oXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGRhdGEucG9zaXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLmd1aWxkLl9zb3J0ZWRSb2xlcygpLFxuICAgICAgICB0aGlzLmNsaWVudC5hcGkuZ3VpbGRzKHRoaXMuZ3VpbGQuaWQpLnJvbGVzLFxuICAgICAgICByZWFzb24sXG4gICAgICApLnRoZW4odXBkYXRlZFJvbGVzID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuYWN0aW9ucy5HdWlsZFJvbGVzUG9zaXRpb25VcGRhdGUuaGFuZGxlKHtcbiAgICAgICAgICBndWlsZF9pZDogdGhpcy5ndWlsZC5pZCxcbiAgICAgICAgICByb2xlczogdXBkYXRlZFJvbGVzLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpLmd1aWxkc1t0aGlzLmd1aWxkLmlkXS5yb2xlc1t0aGlzLmlkXVxuICAgICAgLnBhdGNoKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSB8fCB0aGlzLm5hbWUsXG4gICAgICAgICAgY29sb3I6IGRhdGEuY29sb3IgIT09IG51bGwgPyBVdGlsLnJlc29sdmVDb2xvcihkYXRhLmNvbG9yIHx8IHRoaXMuY29sb3IpIDogbnVsbCxcbiAgICAgICAgICBob2lzdDogdHlwZW9mIGRhdGEuaG9pc3QgIT09ICd1bmRlZmluZWQnID8gZGF0YS5ob2lzdCA6IHRoaXMuaG9pc3QsXG4gICAgICAgICAgcGVybWlzc2lvbnM6IGRhdGEucGVybWlzc2lvbnMsXG4gICAgICAgICAgbWVudGlvbmFibGU6IHR5cGVvZiBkYXRhLm1lbnRpb25hYmxlICE9PSAndW5kZWZpbmVkJyA/IGRhdGEubWVudGlvbmFibGUgOiB0aGlzLm1lbnRpb25hYmxlLFxuICAgICAgICB9LFxuICAgICAgICByZWFzb24sXG4gICAgICB9KVxuICAgICAgLnRoZW4ocm9sZSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gdGhpcy5fY2xvbmUoKTtcbiAgICAgICAgY2xvbmUuX3BhdGNoKHJvbGUpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGBjaGFubmVsLnBlcm1pc3Npb25zRm9yKHJvbGUpYC4gUmV0dXJucyBwZXJtaXNzaW9ucyBmb3IgYSByb2xlIGluIGEgZ3VpbGQgY2hhbm5lbCxcbiAgICogdGFraW5nIGludG8gYWNjb3VudCBwZXJtaXNzaW9uIG92ZXJ3cml0ZXMuXG4gICAqIEBwYXJhbSB7Q2hhbm5lbFJlc29sdmFibGV9IGNoYW5uZWwgVGhlIGd1aWxkIGNoYW5uZWwgdG8gdXNlIGFzIGNvbnRleHRcbiAgICogQHJldHVybnMge1JlYWRvbmx5PFBlcm1pc3Npb25zPn1cbiAgICovXG4gIHBlcm1pc3Npb25zSW4oY2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSB0aGlzLmd1aWxkLmNoYW5uZWxzLnJlc29sdmUoY2hhbm5lbCk7XG4gICAgaWYgKCFjaGFubmVsKSB0aHJvdyBuZXcgRXJyb3IoJ0dVSUxEX0NIQU5ORUxfUkVTT0xWRScpO1xuICAgIHJldHVybiBjaGFubmVsLnJvbGVQZXJtaXNzaW9ucyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IG5hbWUgZm9yIHRoZSByb2xlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmV3IG5hbWUgb2YgdGhlIHJvbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIHJvbGUncyBuYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJvbGU+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIG5hbWUgb2YgdGhlIHJvbGVcbiAgICogcm9sZS5zZXROYW1lKCduZXcgcm9sZScpXG4gICAqICAgLnRoZW4odXBkYXRlZCA9PiBjb25zb2xlLmxvZyhgVXBkYXRlZCByb2xlIG5hbWUgdG8gJHt1cGRhdGVkLm5hbWV9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgc2V0TmFtZShuYW1lLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgbmFtZSB9LCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgY29sb3IgZm9yIHRoZSByb2xlLlxuICAgKiBAcGFyYW0ge0NvbG9yUmVzb2x2YWJsZX0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSByb2xlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSByb2xlJ3MgY29sb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8Um9sZT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNldCB0aGUgY29sb3Igb2YgYSByb2xlXG4gICAqIHJvbGUuc2V0Q29sb3IoJyNGRjAwMDAnKVxuICAgKiAgIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFNldCBjb2xvciBvZiByb2xlIHRvICR7dXBkYXRlZC5jb2xvcn1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRDb2xvcihjb2xvciwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IGNvbG9yIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcm9sZSBzaG91bGQgYmUgaG9pc3RlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBob2lzdCBXaGV0aGVyIG9yIG5vdCB0byBob2lzdCB0aGUgcm9sZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBzZXR0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSByb2xlIHNob3VsZCBiZSBob2lzdGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJvbGU+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIGhvaXN0IG9mIHRoZSByb2xlXG4gICAqIHJvbGUuc2V0SG9pc3QodHJ1ZSlcbiAgICogICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKGBSb2xlIGhvaXN0ZWQ6ICR7dXBkYXRlZC5ob2lzdH1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRIb2lzdChob2lzdCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IGhvaXN0IH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGVybWlzc2lvbnMgb2YgdGhlIHJvbGUuXG4gICAqIEBwYXJhbSB7UGVybWlzc2lvblJlc29sdmFibGV9IHBlcm1pc3Npb25zIFRoZSBwZXJtaXNzaW9ucyBvZiB0aGUgcm9sZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgcm9sZSdzIHBlcm1pc3Npb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJvbGU+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIHBlcm1pc3Npb25zIG9mIHRoZSByb2xlXG4gICAqIHJvbGUuc2V0UGVybWlzc2lvbnMoWydLSUNLX01FTUJFUlMnLCAnQkFOX01FTUJFUlMnXSlcbiAgICogICAudGhlbih1cGRhdGVkID0+IGNvbnNvbGUubG9nKGBVcGRhdGVkIHBlcm1pc3Npb25zIHRvICR7dXBkYXRlZC5wZXJtaXNzaW9ucy5iaXRmaWVsZH1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFJlbW92ZSBhbGwgcGVybWlzc2lvbnMgZnJvbSBhIHJvbGVcbiAgICogcm9sZS5zZXRQZXJtaXNzaW9ucygwKVxuICAgKiAgIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFVwZGF0ZWQgcGVybWlzc2lvbnMgdG8gJHt1cGRhdGVkLnBlcm1pc3Npb25zLmJpdGZpZWxkfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgcGVybWlzc2lvbnMgfSwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhpcyByb2xlIGlzIG1lbnRpb25hYmxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG1lbnRpb25hYmxlIFdoZXRoZXIgdGhpcyByb2xlIHNob3VsZCBiZSBtZW50aW9uYWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBzZXR0aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgcm9sZSBzaG91bGQgYmUgbWVudGlvbmFibGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Um9sZT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE1ha2UgdGhlIHJvbGUgbWVudGlvbmFibGVcbiAgICogcm9sZS5zZXRNZW50aW9uYWJsZSh0cnVlKVxuICAgKiAgIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFJvbGUgdXBkYXRlZCAke3VwZGF0ZWQubmFtZX1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRNZW50aW9uYWJsZShtZW50aW9uYWJsZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IG1lbnRpb25hYmxlIH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHJvbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIHJvbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciBzZXR0aW5nIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVsYXRpdmU9ZmFsc2VdIENoYW5nZSB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgcG9zaXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8Um9sZT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHJvbGVcbiAgICogcm9sZS5zZXRQb3NpdGlvbigxKVxuICAgKiAgIC50aGVuKHVwZGF0ZWQgPT4gY29uc29sZS5sb2coYFJvbGUgcG9zaXRpb246ICR7dXBkYXRlZC5wb3NpdGlvbn1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZXRQb3NpdGlvbihwb3NpdGlvbiwgeyByZWxhdGl2ZSwgcmVhc29uIH0gPSB7fSkge1xuICAgIHJldHVybiBVdGlsLnNldFBvc2l0aW9uKFxuICAgICAgdGhpcyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB0aGlzLmd1aWxkLl9zb3J0ZWRSb2xlcygpLFxuICAgICAgdGhpcy5jbGllbnQuYXBpLmd1aWxkcyh0aGlzLmd1aWxkLmlkKS5yb2xlcyxcbiAgICAgIHJlYXNvbixcbiAgICApLnRoZW4odXBkYXRlZFJvbGVzID0+IHtcbiAgICAgIHRoaXMuY2xpZW50LmFjdGlvbnMuR3VpbGRSb2xlc1Bvc2l0aW9uVXBkYXRlLmhhbmRsZSh7XG4gICAgICAgIGd1aWxkX2lkOiB0aGlzLmd1aWxkLmlkLFxuICAgICAgICByb2xlczogdXBkYXRlZFJvbGVzLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSByb2xlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBkZWxldGluZyB0aGlzIHJvbGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Um9sZT59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIERlbGV0ZSBhIHJvbGVcbiAgICogcm9sZS5kZWxldGUoJ1RoZSByb2xlIG5lZWRlZCB0byBnbycpXG4gICAqICAgLnRoZW4oZGVsZXRlZCA9PiBjb25zb2xlLmxvZyhgRGVsZXRlZCByb2xlICR7ZGVsZXRlZC5uYW1lfWApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGRlbGV0ZShyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpLmd1aWxkc1t0aGlzLmd1aWxkLmlkXS5yb2xlc1t0aGlzLmlkXS5kZWxldGUoeyByZWFzb24gfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmNsaWVudC5hY3Rpb25zLkd1aWxkUm9sZURlbGV0ZS5oYW5kbGUoeyBndWlsZF9pZDogdGhpcy5ndWlsZC5pZCwgcm9sZV9pZDogdGhpcy5pZCB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyByb2xlIGVxdWFscyBhbm90aGVyIHJvbGUuIEl0IGNvbXBhcmVzIGFsbCBwcm9wZXJ0aWVzLCBzbyBmb3IgbW9zdCBvcGVyYXRpb25zXG4gICAqIGl0IGlzIGFkdmlzYWJsZSB0byBqdXN0IGNvbXBhcmUgYHJvbGUuaWQgPT09IHJvbGUyLmlkYCBhcyBpdCBpcyBtdWNoIGZhc3RlciBhbmQgaXMgb2Z0ZW5cbiAgICogd2hhdCBtb3N0IHVzZXJzIG5lZWQuXG4gICAqIEBwYXJhbSB7Um9sZX0gcm9sZSBSb2xlIHRvIGNvbXBhcmUgd2l0aFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhyb2xlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJvbGUgJiZcbiAgICAgIHRoaXMuaWQgPT09IHJvbGUuaWQgJiZcbiAgICAgIHRoaXMubmFtZSA9PT0gcm9sZS5uYW1lICYmXG4gICAgICB0aGlzLmNvbG9yID09PSByb2xlLmNvbG9yICYmXG4gICAgICB0aGlzLmhvaXN0ID09PSByb2xlLmhvaXN0ICYmXG4gICAgICB0aGlzLnBvc2l0aW9uID09PSByb2xlLnBvc2l0aW9uICYmXG4gICAgICB0aGlzLnBlcm1pc3Npb25zLmJpdGZpZWxkID09PSByb2xlLnBlcm1pc3Npb25zLmJpdGZpZWxkICYmXG4gICAgICB0aGlzLm1hbmFnZWQgPT09IHJvbGUubWFuYWdlZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIHJvbGUncyBtZW50aW9uIGluc3RlYWQgb2YgdGhlIFJvbGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBMb2dzOiBSb2xlOiA8QCYxMjM0NTY3ODkwMTIzNDU2Nzg+XG4gICAqIGNvbnNvbGUubG9nKGBSb2xlOiAke3JvbGV9YCk7XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy5pZCA9PT0gdGhpcy5ndWlsZC5pZCkgcmV0dXJuICdAZXZlcnlvbmUnO1xuICAgIHJldHVybiBgPEAmJHt0aGlzLmlkfT5gO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oeyBjcmVhdGVkVGltZXN0YW1wOiB0cnVlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoZSBwb3NpdGlvbnMgb2YgdHdvIHJvbGVzLlxuICAgKiBAcGFyYW0ge1JvbGV9IHJvbGUxIEZpcnN0IHJvbGUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0ge1JvbGV9IHJvbGUyIFNlY29uZCByb2xlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybnMge251bWJlcn0gTmVnYXRpdmUgbnVtYmVyIGlmIHRoZSBmaXJzdCByb2xlJ3MgcG9zaXRpb24gaXMgbG93ZXIgKHNlY29uZCByb2xlJ3MgaXMgaGlnaGVyKSxcbiAgICogcG9zaXRpdmUgbnVtYmVyIGlmIHRoZSBmaXJzdCdzIGlzIGhpZ2hlciAoc2Vjb25kJ3MgaXMgbG93ZXIpLCAwIGlmIGVxdWFsXG4gICAqL1xuICBzdGF0aWMgY29tcGFyZVBvc2l0aW9ucyhyb2xlMSwgcm9sZTIpIHtcbiAgICBpZiAocm9sZTEucG9zaXRpb24gPT09IHJvbGUyLnBvc2l0aW9uKSByZXR1cm4gcm9sZTIuaWQgLSByb2xlMS5pZDtcbiAgICByZXR1cm4gcm9sZTEucG9zaXRpb24gLSByb2xlMi5wb3NpdGlvbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEd1aWxkQ2hhbm5lbCA9IHJlcXVpcmUoJy4vR3VpbGRDaGFubmVsJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGd1aWxkIHN0b3JlIGNoYW5uZWwgb24gRGlzY29yZC5cbiAqIEBleHRlbmRzIHtHdWlsZENoYW5uZWx9XG4gKi9cbmNsYXNzIFN0b3JlQ2hhbm5lbCBleHRlbmRzIEd1aWxkQ2hhbm5lbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGd1aWxkIFRoZSBndWlsZCB0aGUgc3RvcmUgY2hhbm5lbCBpcyBwYXJ0IG9mXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHN0b3JlIGNoYW5uZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGd1aWxkLCBkYXRhKSB7XG4gICAgc3VwZXIoZ3VpbGQsIGRhdGEpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGd1aWxkIGNvbnNpZGVycyB0aGlzIGNoYW5uZWwgTlNGV1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMubnNmdyA9IEJvb2xlYW4oZGF0YS5uc2Z3KTtcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgc3VwZXIuX3BhdGNoKGRhdGEpO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhLm5zZncgIT09ICd1bmRlZmluZWQnKSB0aGlzLm5zZncgPSBCb29sZWFuKGRhdGEubnNmdyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZUNoYW5uZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbmNvbnN0IFRlYW1NZW1iZXIgPSByZXF1aXJlKCcuL1RlYW1NZW1iZXInKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IFNub3dmbGFrZSA9IHJlcXVpcmUoJy4uL3V0aWwvU25vd2ZsYWtlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIENsaWVudCBPQXV0aDIgQXBwbGljYXRpb24gVGVhbS5cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBUZWFtIGV4dGVuZHMgQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgZGF0YSkge1xuICAgIHN1cGVyKGNsaWVudCk7XG4gICAgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgVGVhbVxuICAgICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgVGVhbVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFRlYW0ncyBpY29uIGhhc2hcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmljb24gPSBkYXRhLmljb24gfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBUZWFtJ3Mgb3duZXIgaWRcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm93bmVySUQgPSBkYXRhLm93bmVyX3VzZXJfaWQgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBUZWFtJ3MgbWVtYmVyc1xuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgVGVhbU1lbWJlcj59XG4gICAgICovXG4gICAgdGhpcy5tZW1iZXJzID0gbmV3IENvbGxlY3Rpb24oKTtcblxuICAgIGZvciAoY29uc3QgbWVtYmVyRGF0YSBvZiBkYXRhLm1lbWJlcnMpIHtcbiAgICAgIGNvbnN0IG1lbWJlciA9IG5ldyBUZWFtTWVtYmVyKHRoaXMsIG1lbWJlckRhdGEpO1xuICAgICAgdGhpcy5tZW1iZXJzLnNldChtZW1iZXIuaWQsIG1lbWJlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvd25lciBvZiB0aGlzIHRlYW1cbiAgICogQHR5cGUgez9UZWFtTWVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBvd25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmdldCh0aGlzLm93bmVySUQpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCB0aGUgdGVhbSB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkVGltZXN0YW1wKCkge1xuICAgIHJldHVybiBTbm93Zmxha2UuZGVjb25zdHJ1Y3QodGhpcy5pZCkudGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSB0ZWFtIHdhcyBjcmVhdGVkIGF0XG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkQXQoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuY3JlYXRlZFRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogQSBsaW5rIHRvIHRoZSB0ZWFtcydzIGljb24uXG4gICAqIEBwYXJhbSB7SW1hZ2VVUkxPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIEltYWdlIFVSTFxuICAgKiBAcmV0dXJucyB7P3N0cmluZ30gVVJMIHRvIHRoZSBpY29uXG4gICAqL1xuICBpY29uVVJMKHsgZm9ybWF0LCBzaXplIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pY29uKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jZG4uVGVhbUljb24odGhpcy5pZCwgdGhpcy5pY29uLCB7IGZvcm1hdCwgc2l6ZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNvbmNhdGVuYXRlZCB3aXRoIGEgc3RyaW5nLCB0aGlzIGF1dG9tYXRpY2FsbHkgcmV0dXJucyB0aGUgVGVhbSdzIG5hbWUgaW5zdGVhZCBvZiB0aGVcbiAgICogVGVhbSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExvZ3M6IFRlYW0gbmFtZTogTXkgVGVhbVxuICAgKiBjb25zb2xlLmxvZyhgVGVhbSBuYW1lOiAke3RlYW19YCk7XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oeyBjcmVhdGVkVGltZXN0YW1wOiB0cnVlIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVhbTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuY29uc3QgeyBNZW1iZXJzaGlwU3RhdGVzIH0gPSByZXF1aXJlKCcuLi91dGlsL0NvbnN0YW50cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBDbGllbnQgT0F1dGgyIEFwcGxpY2F0aW9uIFRlYW0gTWVtYmVyLlxuICogQGV4dGVuZHMge0Jhc2V9XG4gKi9cbmNsYXNzIFRlYW1NZW1iZXIgZXh0ZW5kcyBCYXNlIHtcbiAgY29uc3RydWN0b3IodGVhbSwgZGF0YSkge1xuICAgIHN1cGVyKHRlYW0uY2xpZW50KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBUZWFtIHRoaXMgbWVtYmVyIGlzIHBhcnQgb2ZcbiAgICAgKiBAdHlwZSB7VGVhbX1cbiAgICAgKi9cbiAgICB0aGlzLnRlYW0gPSB0ZWFtO1xuXG4gICAgdGhpcy5fcGF0Y2goZGF0YSk7XG4gIH1cblxuICBfcGF0Y2goZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwZXJtaXNzaW9ucyB0aGlzIFRlYW0gTWVtYmVyIGhhcyB3aXRoIHJlZ2FyZCB0byB0aGUgdGVhbVxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLnBlcm1pc3Npb25zID0gZGF0YS5wZXJtaXNzaW9ucztcblxuICAgIC8qKlxuICAgICAqIFRoZSBwZXJtaXNzaW9ucyB0aGlzIFRlYW0gTWVtYmVyIGhhcyB3aXRoIHJlZ2FyZCB0byB0aGUgdGVhbVxuICAgICAqIEB0eXBlIHtNZW1iZXJzaGlwU3RhdGVzfVxuICAgICAqL1xuICAgIHRoaXMubWVtYmVyc2hpcFN0YXRlID0gTWVtYmVyc2hpcFN0YXRlc1tkYXRhLm1lbWJlcnNoaXBfc3RhdGVdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVzZXIgZm9yIHRoaXMgVGVhbSBNZW1iZXJcbiAgICAgKiBAdHlwZSB7VXNlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXIgPSB0aGlzLmNsaWVudC51c2Vycy5hZGQoZGF0YS51c2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFRlYW0gTWVtYmVyXG4gICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXIuaWQ7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIHRlYW0gbWVtYmVycydzIG1lbnRpb24gaW5zdGVhZCBvZiB0aGVcbiAgICogVGVhbU1lbWJlciBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExvZ3M6IFRlYW0gTWVtYmVyJ3MgbWVudGlvbjogPEAxMjM0NTY3ODkwMTIzNDU2Nzg+XG4gICAqIGNvbnNvbGUubG9nKGBUZWFtIE1lbWJlcidzIG1lbnRpb246ICR7dGVhbU1lbWJlcn1gKTtcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXIudG9TdHJpbmcoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlYW1NZW1iZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEd1aWxkQ2hhbm5lbCA9IHJlcXVpcmUoJy4vR3VpbGRDaGFubmVsJyk7XG5jb25zdCBXZWJob29rID0gcmVxdWlyZSgnLi9XZWJob29rJyk7XG5jb25zdCBUZXh0QmFzZWRDaGFubmVsID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzL1RleHRCYXNlZENoYW5uZWwnKTtcbmNvbnN0IE1lc3NhZ2VNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvTWVzc2FnZU1hbmFnZXInKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IERhdGFSZXNvbHZlciA9IHJlcXVpcmUoJy4uL3V0aWwvRGF0YVJlc29sdmVyJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGd1aWxkIHRleHQgY2hhbm5lbCBvbiBEaXNjb3JkLlxuICogQGV4dGVuZHMge0d1aWxkQ2hhbm5lbH1cbiAqIEBpbXBsZW1lbnRzIHtUZXh0QmFzZWRDaGFubmVsfVxuICovXG5jbGFzcyBUZXh0Q2hhbm5lbCBleHRlbmRzIEd1aWxkQ2hhbm5lbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0d1aWxkfSBndWlsZCBUaGUgZ3VpbGQgdGhlIHRleHQgY2hhbm5lbCBpcyBwYXJ0IG9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgdGV4dCBjaGFubmVsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihndWlsZCwgZGF0YSkge1xuICAgIHN1cGVyKGd1aWxkLCBkYXRhKTtcbiAgICAvKipcbiAgICAgKiBBIG1hbmFnZXIgb2YgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhpcyBjaGFubmVsXG4gICAgICogQHR5cGUge01lc3NhZ2VNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZU1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ3VpbGQgY29uc2lkZXJzIHRoaXMgY2hhbm5lbCBOU0ZXXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5uc2Z3ID0gQm9vbGVhbihkYXRhLm5zZncpO1xuICAgIHRoaXMuX3R5cGluZyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgc3VwZXIuX3BhdGNoKGRhdGEpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvcGljIG9mIHRoZSB0ZXh0IGNoYW5uZWxcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRvcGljID0gZGF0YS50b3BpYztcblxuICAgIGlmICh0eXBlb2YgZGF0YS5uc2Z3ICE9PSAndW5kZWZpbmVkJykgdGhpcy5uc2Z3ID0gQm9vbGVhbihkYXRhLm5zZncpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBsYXN0IG1lc3NhZ2Ugc2VudCBpbiB0aGlzIGNoYW5uZWwsIGlmIG9uZSB3YXMgc2VudFxuICAgICAqIEB0eXBlIHs/U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMubGFzdE1lc3NhZ2VJRCA9IGRhdGEubGFzdF9tZXNzYWdlX2lkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhdGVsaW1pdCBwZXIgdXNlciBmb3IgdGhpcyBjaGFubmVsIGluIHNlY29uZHNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmF0ZUxpbWl0UGVyVXNlciA9IGRhdGEucmF0ZV9saW1pdF9wZXJfdXNlciB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBsYXN0IHBpbm5lZCBtZXNzYWdlIHdhcyBwaW5uZWQsIGlmIHRoZXJlIHdhcyBvbmVcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQaW5UaW1lc3RhbXAgPSBkYXRhLmxhc3RfcGluX3RpbWVzdGFtcCA/IG5ldyBEYXRlKGRhdGEubGFzdF9waW5fdGltZXN0YW1wKS5nZXRUaW1lKCkgOiBudWxsO1xuXG4gICAgaWYgKGRhdGEubWVzc2FnZXMpIGZvciAoY29uc3QgbWVzc2FnZSBvZiBkYXRhLm1lc3NhZ2VzKSB0aGlzLm1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYXRlIGxpbWl0IHBlciB1c2VyIGZvciB0aGlzIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYXRlTGltaXRQZXJVc2VyIFRoZSBuZXcgcmF0ZWxpbWl0IGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgY2hhbmdpbmcgdGhlIGNoYW5uZWwncyByYXRlbGltaXRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRleHRDaGFubmVsPn1cbiAgICovXG4gIHNldFJhdGVMaW1pdFBlclVzZXIocmF0ZUxpbWl0UGVyVXNlciwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IHJhdGVMaW1pdFBlclVzZXIgfSwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhpcyBjaGFubmVsIGlzIGZsYWdnZWQgYXMgTlNGVy5cbiAgICogQHBhcmFtIHtib29sZWFufSBuc2Z3IFdoZXRoZXIgdGhlIGNoYW5uZWwgc2hvdWxkIGJlIGNvbnNpZGVyZWQgTlNGV1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBjaGFuZ2luZyB0aGUgY2hhbm5lbCdzIE5TRlcgZmxhZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUZXh0Q2hhbm5lbD59XG4gICAqL1xuICBzZXROU0ZXKG5zZncsIHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXQoeyBuc2Z3IH0sIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgd2ViaG9va3MgZm9yIHRoZSBjaGFubmVsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uPFNub3dmbGFrZSwgV2ViaG9vaz4+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGZXRjaCB3ZWJob29rc1xuICAgKiBjaGFubmVsLmZldGNoV2ViaG9va3MoKVxuICAgKiAgIC50aGVuKGhvb2tzID0+IGNvbnNvbGUubG9nKGBUaGlzIGNoYW5uZWwgaGFzICR7aG9va3Muc2l6ZX0gaG9va3NgKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBmZXRjaFdlYmhvb2tzKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGkuY2hhbm5lbHNbdGhpcy5pZF0ud2ViaG9va3MuZ2V0KCkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGhvb2tzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICAgIGZvciAoY29uc3QgaG9vayBvZiBkYXRhKSBob29rcy5zZXQoaG9vay5pZCwgbmV3IFdlYmhvb2sodGhpcy5jbGllbnQsIGhvb2spKTtcbiAgICAgIHJldHVybiBob29rcztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgd2ViaG9vayBmb3IgdGhlIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB3ZWJob29rXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIHdlYmhvb2tcbiAgICogQHBhcmFtIHtCdWZmZXJSZXNvbHZhYmxlfEJhc2U2NFJlc29sdmFibGV9IFtvcHRpb25zLmF2YXRhcl0gQXZhdGFyIGZvciB0aGUgd2ViaG9va1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVhc29uXSBSZWFzb24gZm9yIGNyZWF0aW5nIHRoZSB3ZWJob29rXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2s+fSB3ZWJob29rIFRoZSBjcmVhdGVkIHdlYmhvb2tcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIGEgd2ViaG9vayBmb3IgdGhlIGN1cnJlbnQgY2hhbm5lbFxuICAgKiBjaGFubmVsLmNyZWF0ZVdlYmhvb2soJ1NuZWsnLCB7XG4gICAqICAgYXZhdGFyOiAnaHR0cHM6Ly9pLmltZ3VyLmNvbS9tSThYY3BHLmpwZycsXG4gICAqICAgcmVhc29uOiAnTmVlZGVkIGEgY29vbCBuZXcgV2ViaG9vaydcbiAgICogfSlcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcilcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVdlYmhvb2sobmFtZSwgeyBhdmF0YXIsIHJlYXNvbiB9ID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGF2YXRhciA9PT0gJ3N0cmluZycgJiYgIWF2YXRhci5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICBhdmF0YXIgPSBhd2FpdCBEYXRhUmVzb2x2ZXIucmVzb2x2ZUltYWdlKGF2YXRhcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGkuY2hhbm5lbHNbdGhpcy5pZF0ud2ViaG9va3NcbiAgICAgIC5wb3N0KHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXZhdGFyLFxuICAgICAgICB9LFxuICAgICAgICByZWFzb24sXG4gICAgICB9KVxuICAgICAgLnRoZW4oZGF0YSA9PiBuZXcgV2ViaG9vayh0aGlzLmNsaWVudCwgZGF0YSkpO1xuICB9XG5cbiAgLy8gVGhlc2UgYXJlIGhlcmUgb25seSBmb3IgZG9jdW1lbnRhdGlvbiBwdXJwb3NlcyAtIHRoZXkgYXJlIGltcGxlbWVudGVkIGJ5IFRleHRCYXNlZENoYW5uZWxcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHktZnVuY3Rpb24gKi9cbiAgZ2V0IGxhc3RNZXNzYWdlKCkge31cbiAgZ2V0IGxhc3RQaW5BdCgpIHt9XG4gIHNlbmQoKSB7fVxuICBzdGFydFR5cGluZygpIHt9XG4gIHN0b3BUeXBpbmcoKSB7fVxuICBnZXQgdHlwaW5nKCkge31cbiAgZ2V0IHR5cGluZ0NvdW50KCkge31cbiAgY3JlYXRlTWVzc2FnZUNvbGxlY3RvcigpIHt9XG4gIGF3YWl0TWVzc2FnZXMoKSB7fVxuICBidWxrRGVsZXRlKCkge31cbn1cblxuVGV4dEJhc2VkQ2hhbm5lbC5hcHBseVRvQ2xhc3MoVGV4dENoYW5uZWwsIHRydWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRDaGFubmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5jb25zdCBUZXh0QmFzZWRDaGFubmVsID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzL1RleHRCYXNlZENoYW5uZWwnKTtcbmNvbnN0IHsgRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgU25vd2ZsYWtlID0gcmVxdWlyZSgnLi4vdXRpbC9Tbm93Zmxha2UnKTtcbmNvbnN0IFVzZXJGbGFncyA9IHJlcXVpcmUoJy4uL3V0aWwvVXNlckZsYWdzJyk7XG5cbmxldCBTdHJ1Y3R1cmVzO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB1c2VyIG9uIERpc2NvcmQuXG4gKiBAaW1wbGVtZW50cyB7VGV4dEJhc2VkQ2hhbm5lbH1cbiAqIEBleHRlbmRzIHtCYXNlfVxuICovXG5jbGFzcyBVc2VyIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50IFRoZSBpbnN0YW50aWF0aW5nIGNsaWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHVzZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgZGF0YSkge1xuICAgIHN1cGVyKGNsaWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHVzZXJcbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuXG4gICAgdGhpcy5zeXN0ZW0gPSBudWxsO1xuICAgIHRoaXMubG9jYWxlID0gbnVsbDtcbiAgICB0aGlzLmZsYWdzID0gbnVsbDtcblxuICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICB9XG5cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICBpZiAoJ3VzZXJuYW1lJyBpbiBkYXRhKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB1c2VybmFtZSBvZiB0aGUgdXNlclxuICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudXNlcm5hbWUgPSBkYXRhLnVzZXJuYW1lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMudXNlcm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnVzZXJuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ2JvdCcgaW4gZGF0YSB8fCB0eXBlb2YgdGhpcy5ib3QgIT09ICdib29sZWFuJykge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyBhIGJvdFxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuYm90ID0gQm9vbGVhbihkYXRhLmJvdCk7XG4gICAgfVxuXG4gICAgaWYgKCdkaXNjcmltaW5hdG9yJyBpbiBkYXRhKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgZGlzY3JpbWluYXRvciBiYXNlZCBvbiB1c2VybmFtZSBmb3IgdGhlIHVzZXJcbiAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAgICovXG4gICAgICB0aGlzLmRpc2NyaW1pbmF0b3IgPSBkYXRhLmRpc2NyaW1pbmF0b3I7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kaXNjcmltaW5hdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5kaXNjcmltaW5hdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ2F2YXRhcicgaW4gZGF0YSkge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIncyBhdmF0YXJcbiAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAgICovXG4gICAgICB0aGlzLmF2YXRhciA9IGRhdGEuYXZhdGFyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuYXZhdGFyICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5hdmF0YXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnc3lzdGVtJyBpbiBkYXRhKSB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaXMgYW4gT2ZmaWNpYWwgRGlzY29yZCBTeXN0ZW0gdXNlciAocGFydCBvZiB0aGUgdXJnZW50IG1lc3NhZ2Ugc3lzdGVtKVxuICAgICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAgICovXG4gICAgICB0aGlzLnN5c3RlbSA9IEJvb2xlYW4oZGF0YS5zeXN0ZW0pO1xuICAgIH1cblxuICAgIGlmICgnbG9jYWxlJyBpbiBkYXRhKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBsb2NhbGUgb2YgdGhlIHVzZXIncyBjbGllbnQgKElTTyA2MzktMSlcbiAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAgICovXG4gICAgICB0aGlzLmxvY2FsZSA9IGRhdGEubG9jYWxlO1xuICAgIH1cblxuICAgIGlmICgncHVibGljX2ZsYWdzJyBpbiBkYXRhKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmbGFncyBmb3IgdGhpcyB1c2VyXG4gICAgICAgKiBAdHlwZSB7P1VzZXJGbGFnc31cbiAgICAgICAqL1xuICAgICAgdGhpcy5mbGFncyA9IG5ldyBVc2VyRmxhZ3MoZGF0YS5wdWJsaWNfZmxhZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgbGFzdCBtZXNzYWdlIHNlbnQgYnkgdGhlIHVzZXIsIGlmIG9uZSB3YXMgc2VudFxuICAgICAqIEB0eXBlIHs/U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMubGFzdE1lc3NhZ2VJRCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGNoYW5uZWwgZm9yIHRoZSBsYXN0IG1lc3NhZ2Ugc2VudCBieSB0aGUgdXNlciwgaWYgb25lIHdhcyBzZW50XG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5sYXN0TWVzc2FnZUNoYW5uZWxJRCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIFVzZXIgaXMgYSBwYXJ0aWFsXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwYXJ0aWFsKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy51c2VybmFtZSAhPT0gJ3N0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCB0aGUgdXNlciB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkVGltZXN0YW1wKCkge1xuICAgIHJldHVybiBTbm93Zmxha2UuZGVjb25zdHJ1Y3QodGhpcy5pZCkudGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSB1c2VyIHdhcyBjcmVhdGVkIGF0XG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkQXQoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuY3JlYXRlZFRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE1lc3NhZ2Ugb2JqZWN0IG9mIHRoZSBsYXN0IG1lc3NhZ2Ugc2VudCBieSB0aGUgdXNlciwgaWYgb25lIHdhcyBzZW50XG4gICAqIEB0eXBlIHs/TWVzc2FnZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGFzdE1lc3NhZ2UoKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2xpZW50LmNoYW5uZWxzLmNhY2hlLmdldCh0aGlzLmxhc3RNZXNzYWdlQ2hhbm5lbElEKTtcbiAgICByZXR1cm4gKGNoYW5uZWwgJiYgY2hhbm5lbC5tZXNzYWdlcy5jYWNoZS5nZXQodGhpcy5sYXN0TWVzc2FnZUlEKSkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyB1c2VyXG4gICAqIEB0eXBlIHtQcmVzZW5jZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJlc2VuY2UoKSB7XG4gICAgZm9yIChjb25zdCBndWlsZCBvZiB0aGlzLmNsaWVudC5ndWlsZHMuY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGlmIChndWlsZC5wcmVzZW5jZXMuY2FjaGUuaGFzKHRoaXMuaWQpKSByZXR1cm4gZ3VpbGQucHJlc2VuY2VzLmNhY2hlLmdldCh0aGlzLmlkKTtcbiAgICB9XG4gICAgaWYgKCFTdHJ1Y3R1cmVzKSBTdHJ1Y3R1cmVzID0gcmVxdWlyZSgnLi4vdXRpbC9TdHJ1Y3R1cmVzJyk7XG4gICAgY29uc3QgUHJlc2VuY2UgPSBTdHJ1Y3R1cmVzLmdldCgnUHJlc2VuY2UnKTtcbiAgICByZXR1cm4gbmV3IFByZXNlbmNlKHRoaXMuY2xpZW50LCB7IHVzZXI6IHsgaWQ6IHRoaXMuaWQgfSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGxpbmsgdG8gdGhlIHVzZXIncyBhdmF0YXIuXG4gICAqIEBwYXJhbSB7SW1hZ2VVUkxPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIEltYWdlIFVSTFxuICAgKiBAcmV0dXJucyB7P3N0cmluZ31cbiAgICovXG4gIGF2YXRhclVSTCh7IGZvcm1hdCwgc2l6ZSwgZHluYW1pYyB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuYXZhdGFyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jZG4uQXZhdGFyKHRoaXMuaWQsIHRoaXMuYXZhdGFyLCBmb3JtYXQsIHNpemUsIGR5bmFtaWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbGluayB0byB0aGUgdXNlcidzIGRlZmF1bHQgYXZhdGFyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlZmF1bHRBdmF0YXJVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2RuLkRlZmF1bHRBdmF0YXIodGhpcy5kaXNjcmltaW5hdG9yICUgNSk7XG4gIH1cblxuICAvKipcbiAgICogQSBsaW5rIHRvIHRoZSB1c2VyJ3MgYXZhdGFyIGlmIHRoZXkgaGF2ZSBvbmUuXG4gICAqIE90aGVyd2lzZSBhIGxpbmsgdG8gdGhlaXIgZGVmYXVsdCBhdmF0YXIgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtJbWFnZVVSTE9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgSW1hZ2UgVVJMXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBkaXNwbGF5QXZhdGFyVVJMKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5hdmF0YXJVUkwob3B0aW9ucykgfHwgdGhpcy5kZWZhdWx0QXZhdGFyVVJMO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBEaXNjb3JkIFwidGFnXCIgKGUuZy4gYGh5ZHJhYm9sdCMwMDAxYCkgZm9yIHRoaXMgdXNlclxuICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdGFnKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy51c2VybmFtZSA9PT0gJ3N0cmluZycgPyBgJHt0aGlzLnVzZXJuYW1lfSMke3RoaXMuZGlzY3JpbWluYXRvcn1gIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBpcyB0eXBpbmcgaW4gYSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge0NoYW5uZWxSZXNvbHZhYmxlfSBjaGFubmVsIFRoZSBjaGFubmVsIHRvIGNoZWNrIGluXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdHlwaW5nSW4oY2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSB0aGlzLmNsaWVudC5jaGFubmVscy5yZXNvbHZlKGNoYW5uZWwpO1xuICAgIHJldHVybiBjaGFubmVsLl90eXBpbmcuaGFzKHRoaXMuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRpbWUgdGhhdCB0aGUgdXNlciBzdGFydGVkIHR5cGluZy5cbiAgICogQHBhcmFtIHtDaGFubmVsUmVzb2x2YWJsZX0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBnZXQgdGhlIHRpbWUgaW5cbiAgICogQHJldHVybnMgez9EYXRlfVxuICAgKi9cbiAgdHlwaW5nU2luY2VJbihjaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IHRoaXMuY2xpZW50LmNoYW5uZWxzLnJlc29sdmUoY2hhbm5lbCk7XG4gICAgcmV0dXJuIGNoYW5uZWwuX3R5cGluZy5oYXModGhpcy5pZCkgPyBuZXcgRGF0ZShjaGFubmVsLl90eXBpbmcuZ2V0KHRoaXMuaWQpLnNpbmNlKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYW1vdW50IG9mIHRpbWUgdGhlIHVzZXIgaGFzIGJlZW4gdHlwaW5nIGluIGEgY2hhbm5lbCBmb3IgKGluIG1pbGxpc2Vjb25kcyksIG9yIC0xIGlmIHRoZXkncmUgbm90IHR5cGluZy5cbiAgICogQHBhcmFtIHtDaGFubmVsUmVzb2x2YWJsZX0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byBnZXQgdGhlIHRpbWUgaW5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHR5cGluZ0R1cmF0aW9uSW4oY2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSB0aGlzLmNsaWVudC5jaGFubmVscy5yZXNvbHZlKGNoYW5uZWwpO1xuICAgIHJldHVybiBjaGFubmVsLl90eXBpbmcuaGFzKHRoaXMuaWQpID8gY2hhbm5lbC5fdHlwaW5nLmdldCh0aGlzLmlkKS5lbGFwc2VkVGltZSA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBETSBiZXR3ZWVuIHRoZSBjbGllbnQncyB1c2VyIGFuZCB0aGlzIHVzZXJcbiAgICogQHR5cGUgez9ETUNoYW5uZWx9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRtQ2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuY2hhbm5lbHMuY2FjaGUuZmluZChjID0+IGMudHlwZSA9PT0gJ2RtJyAmJiBjLnJlY2lwaWVudC5pZCA9PT0gdGhpcy5pZCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRE0gY2hhbm5lbCBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gV2hldGhlciB0byBza2lwIHRoZSBjYWNoZSBjaGVjayBhbmQgcmVxdWVzdCB0aGUgQVBJXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERNQ2hhbm5lbD59XG4gICAqL1xuICBhc3luYyBjcmVhdGVETShmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgY29uc3QgeyBkbUNoYW5uZWwgfSA9IHRoaXM7XG4gICAgICBpZiAoZG1DaGFubmVsICYmICFkbUNoYW5uZWwucGFydGlhbCkgcmV0dXJuIGRtQ2hhbm5lbDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuYXBpLnVzZXJzKHRoaXMuY2xpZW50LnVzZXIuaWQpLmNoYW5uZWxzLnBvc3Qoe1xuICAgICAgZGF0YToge1xuICAgICAgICByZWNpcGllbnRfaWQ6IHRoaXMuaWQsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hY3Rpb25zLkNoYW5uZWxDcmVhdGUuaGFuZGxlKGRhdGEpLmNoYW5uZWw7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIERNIGNoYW5uZWwgKGlmIG9uZSBleGlzdHMpIGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIHVzZXIuIFJlc29sdmVzIHdpdGggdGhlIGNoYW5uZWwgaWYgc3VjY2Vzc2Z1bC5cbiAgICogQHJldHVybnMge1Byb21pc2U8RE1DaGFubmVsPn1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZURNKCkge1xuICAgIGNvbnN0IHsgZG1DaGFubmVsIH0gPSB0aGlzO1xuICAgIGlmICghZG1DaGFubmVsKSB0aHJvdyBuZXcgRXJyb3IoJ1VTRVJfTk9fRE1DSEFOTkVMJyk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LmFwaS5jaGFubmVscyhkbUNoYW5uZWwuaWQpLmRlbGV0ZSgpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hY3Rpb25zLkNoYW5uZWxEZWxldGUuaGFuZGxlKGRhdGEpLmNoYW5uZWw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB1c2VyIGlzIGVxdWFsIHRvIGFub3RoZXIuIEl0IGNvbXBhcmVzIElELCB1c2VybmFtZSwgZGlzY3JpbWluYXRvciwgYXZhdGFyLCBhbmQgYm90IGZsYWdzLlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byBjb21wYXJlIGVxdWFsaXR5IGJ5IHVzaW5nIGB1c2VyLmlkID09PSB1c2VyMi5pZGAgdW5sZXNzIHlvdSB3YW50IHRvIGNvbXBhcmUgYWxsIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7VXNlcn0gdXNlciBVc2VyIHRvIGNvbXBhcmUgd2l0aFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyh1c2VyKSB7XG4gICAgbGV0IGVxdWFsID1cbiAgICAgIHVzZXIgJiZcbiAgICAgIHRoaXMuaWQgPT09IHVzZXIuaWQgJiZcbiAgICAgIHRoaXMudXNlcm5hbWUgPT09IHVzZXIudXNlcm5hbWUgJiZcbiAgICAgIHRoaXMuZGlzY3JpbWluYXRvciA9PT0gdXNlci5kaXNjcmltaW5hdG9yICYmXG4gICAgICB0aGlzLmF2YXRhciA9PT0gdXNlci5hdmF0YXI7XG5cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyB0aGlzIHVzZXIncyBmbGFncy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgY2hlY2sgYW5kIHJlcXVlc3QgdGhlIEFQXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJGbGFncz59XG4gICAqL1xuICBhc3luYyBmZXRjaEZsYWdzKGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmJiAhZm9yY2UpIHJldHVybiB0aGlzLmZsYWdzO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkudXNlcnModGhpcy5pZCkuZ2V0KCk7XG4gICAgdGhpcy5fcGF0Y2goZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ3M7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyB0aGlzIHVzZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIGNoZWNrIGFuZCByZXF1ZXN0IHRoZSBBUFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyPn1cbiAgICovXG4gIGZldGNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQudXNlcnMuZmV0Y2godGhpcy5pZCwgdHJ1ZSwgZm9yY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gY29uY2F0ZW5hdGVkIHdpdGggYSBzdHJpbmcsIHRoaXMgYXV0b21hdGljYWxseSByZXR1cm5zIHRoZSB1c2VyJ3MgbWVudGlvbiBpbnN0ZWFkIG9mIHRoZSBVc2VyIG9iamVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gTG9nczogSGVsbG8gZnJvbSA8QDEyMzQ1Njc4OTAxMjM0NTY3OD4hXG4gICAqIGNvbnNvbGUubG9nKGBIZWxsbyBmcm9tICR7dXNlcn0hYCk7XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYDxAJHt0aGlzLmlkfT5gO1xuICB9XG5cbiAgdG9KU09OKC4uLnByb3BzKSB7XG4gICAgY29uc3QganNvbiA9IHN1cGVyLnRvSlNPTihcbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZFRpbWVzdGFtcDogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdEF2YXRhclVSTDogdHJ1ZSxcbiAgICAgICAgdGFnOiB0cnVlLFxuICAgICAgICBsYXN0TWVzc2FnZTogZmFsc2UsXG4gICAgICAgIGxhc3RNZXNzYWdlSUQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIC4uLnByb3BzLFxuICAgICk7XG4gICAganNvbi5hdmF0YXJVUkwgPSB0aGlzLmF2YXRhclVSTCgpO1xuICAgIGpzb24uZGlzcGxheUF2YXRhclVSTCA9IHRoaXMuZGlzcGxheUF2YXRhclVSTCgpO1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgLy8gVGhlc2UgYXJlIGhlcmUgb25seSBmb3IgZG9jdW1lbnRhdGlvbiBwdXJwb3NlcyAtIHRoZXkgYXJlIGltcGxlbWVudGVkIGJ5IFRleHRCYXNlZENoYW5uZWxcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHktZnVuY3Rpb24gKi9cbiAgc2VuZCgpIHt9XG59XG5cblRleHRCYXNlZENoYW5uZWwuYXBwbHlUb0NsYXNzKFVzZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEd1aWxkQ2hhbm5lbCA9IHJlcXVpcmUoJy4vR3VpbGRDaGFubmVsJyk7XG5jb25zdCB7IEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL0NvbGxlY3Rpb24nKTtcbmNvbnN0IHsgYnJvd3NlciB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IFBlcm1pc3Npb25zID0gcmVxdWlyZSgnLi4vdXRpbC9QZXJtaXNzaW9ucycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBndWlsZCB2b2ljZSBjaGFubmVsIG9uIERpc2NvcmQuXG4gKiBAZXh0ZW5kcyB7R3VpbGRDaGFubmVsfVxuICovXG5jbGFzcyBWb2ljZUNoYW5uZWwgZXh0ZW5kcyBHdWlsZENoYW5uZWwge1xuICBfcGF0Y2goZGF0YSkge1xuICAgIHN1cGVyLl9wYXRjaChkYXRhKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYml0cmF0ZSBvZiB0aGlzIHZvaWNlIGNoYW5uZWxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB1c2VycyBhbGxvd2VkIGluIHRoaXMgY2hhbm5lbCAtIDAgbWVhbnMgdW5saW1pdGVkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51c2VyTGltaXQgPSBkYXRhLnVzZXJfbGltaXQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1lbWJlcnMgaW4gdGhpcyB2b2ljZSBjaGFubmVsXG4gICAqIEB0eXBlIHtDb2xsZWN0aW9uPFNub3dmbGFrZSwgR3VpbGRNZW1iZXI+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtZW1iZXJzKCkge1xuICAgIGNvbnN0IGNvbGwgPSBuZXcgQ29sbGVjdGlvbigpO1xuICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5ndWlsZC52b2ljZVN0YXRlcy5jYWNoZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKHN0YXRlLmNoYW5uZWxJRCA9PT0gdGhpcy5pZCAmJiBzdGF0ZS5tZW1iZXIpIHtcbiAgICAgICAgY29sbC5zZXQoc3RhdGUuaWQsIHN0YXRlLm1lbWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdm9pY2UgY2hhbm5lbCBpcyBmdWxsXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBmdWxsKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXJMaW1pdCA+IDAgJiYgdGhpcy5tZW1iZXJzLnNpemUgPj0gdGhpcy51c2VyTGltaXQ7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY2hhbm5lbCBpcyBkZWxldGFibGUgYnkgdGhlIGNsaWVudCB1c2VyXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkZWxldGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0YWJsZSAmJiB0aGlzLnBlcm1pc3Npb25zRm9yKHRoaXMuY2xpZW50LnVzZXIpLmhhcyhQZXJtaXNzaW9ucy5GTEFHUy5DT05ORUNULCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY2hhbm5lbCBpcyBlZGl0YWJsZSBieSB0aGUgY2xpZW50IHVzZXJcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGVkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZWFibGUgJiYgdGhpcy5wZXJtaXNzaW9uc0Zvcih0aGlzLmNsaWVudC51c2VyKS5oYXMoUGVybWlzc2lvbnMuRkxBR1MuQ09OTkVDVCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNoYW5uZWwgaXMgam9pbmFibGUgYnkgdGhlIGNsaWVudCB1c2VyXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBqb2luYWJsZSgpIHtcbiAgICBpZiAoYnJvd3NlcikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdGhpcy52aWV3YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdGhpcy5wZXJtaXNzaW9uc0Zvcih0aGlzLmNsaWVudC51c2VyKS5oYXMoUGVybWlzc2lvbnMuRkxBR1MuQ09OTkVDVCwgZmFsc2UpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuZnVsbCAmJiAhdGhpcy5wZXJtaXNzaW9uc0Zvcih0aGlzLmNsaWVudC51c2VyKS5oYXMoUGVybWlzc2lvbnMuRkxBR1MuTU9WRV9NRU1CRVJTLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGNsaWVudCBoYXMgcGVybWlzc2lvbiB0byBzZW5kIGF1ZGlvIHRvIHRoZSB2b2ljZSBjaGFubmVsXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzcGVha2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVybWlzc2lvbnNGb3IodGhpcy5jbGllbnQudXNlcikuaGFzKFBlcm1pc3Npb25zLkZMQUdTLlNQRUFLLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYml0cmF0ZSBvZiB0aGUgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHJhdGUgVGhlIG5ldyBiaXRyYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSBjaGFubmVsJ3MgYml0cmF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWb2ljZUNoYW5uZWw+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZXQgdGhlIGJpdHJhdGUgb2YgYSB2b2ljZSBjaGFubmVsXG4gICAqIHZvaWNlQ2hhbm5lbC5zZXRCaXRyYXRlKDQ4MDAwKVxuICAgKiAgIC50aGVuKHZjID0+IGNvbnNvbGUubG9nKGBTZXQgYml0cmF0ZSB0byAke3ZjLmJpdHJhdGV9YnBzIGZvciAke3ZjLm5hbWV9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgc2V0Qml0cmF0ZShiaXRyYXRlLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0KHsgYml0cmF0ZSB9LCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVzZXIgbGltaXQgb2YgdGhlIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB1c2VyTGltaXQgVGhlIG5ldyB1c2VyIGxpbWl0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIGNoYW5naW5nIHRoZSB1c2VyIGxpbWl0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZvaWNlQ2hhbm5lbD59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNldCB0aGUgdXNlciBsaW1pdCBvZiBhIHZvaWNlIGNoYW5uZWxcbiAgICogdm9pY2VDaGFubmVsLnNldFVzZXJMaW1pdCg0MilcbiAgICogICAudGhlbih2YyA9PiBjb25zb2xlLmxvZyhgU2V0IHVzZXIgbGltaXQgdG8gJHt2Yy51c2VyTGltaXR9IGZvciAke3ZjLm5hbWV9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgc2V0VXNlckxpbWl0KHVzZXJMaW1pdCwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdCh7IHVzZXJMaW1pdCB9LCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGpvaW4gdGhpcyB2b2ljZSBjaGFubmVsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWb2ljZUNvbm5lY3Rpb24+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBKb2luIGEgdm9pY2UgY2hhbm5lbFxuICAgKiB2b2ljZUNoYW5uZWwuam9pbigpXG4gICAqICAgLnRoZW4oY29ubmVjdGlvbiA9PiBjb25zb2xlLmxvZygnQ29ubmVjdGVkIScpKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGpvaW4oKSB7XG4gICAgaWYgKGJyb3dzZXIpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1ZPSUNFX05PX0JST1dTRVInKSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnZvaWNlLmpvaW5DaGFubmVsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExlYXZlcyB0aGlzIHZvaWNlIGNoYW5uZWwuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExlYXZlIGEgdm9pY2UgY2hhbm5lbFxuICAgKiB2b2ljZUNoYW5uZWwubGVhdmUoKTtcbiAgICovXG4gIGxlYXZlKCkge1xuICAgIGlmIChicm93c2VyKSByZXR1cm47XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuY2xpZW50LnZvaWNlLmNvbm5lY3Rpb25zLmdldCh0aGlzLmd1aWxkLmlkKTtcbiAgICBpZiAoY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNoYW5uZWwuaWQgPT09IHRoaXMuaWQpIGNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVm9pY2VDaGFubmVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIERpc2NvcmQgdm9pY2UgcmVnaW9uIGZvciBndWlsZHMuXG4gKi9cbmNsYXNzIFZvaWNlUmVnaW9uIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgcmVnaW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gZGF0YS5pZDtcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIHJlZ2lvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVnaW9uIGlzIFZJUC1vbmx5XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52aXAgPSBkYXRhLnZpcDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlZ2lvbiBpcyBkZXByZWNhdGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kZXByZWNhdGVkID0gZGF0YS5kZXByZWNhdGVkO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVnaW9uIGlzIG9wdGltYWxcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGltYWwgPSBkYXRhLm9wdGltYWw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZWdpb24gaXMgY3VzdG9tXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jdXN0b20gPSBkYXRhLmN1c3RvbTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gVXRpbC5mbGF0dGVuKHRoaXMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVm9pY2VSZWdpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbmNvbnN0IHsgRXJyb3IsIFR5cGVFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCB7IGJyb3dzZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWwvQ29uc3RhbnRzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdm9pY2Ugc3RhdGUgZm9yIGEgR3VpbGQgTWVtYmVyLlxuICovXG5jbGFzcyBWb2ljZVN0YXRlIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0d1aWxkfSBndWlsZCBUaGUgZ3VpbGQgdGhlIHZvaWNlIHN0YXRlIGlzIHBhcnQgb2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSB2b2ljZSBzdGF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZ3VpbGQsIGRhdGEpIHtcbiAgICBzdXBlcihndWlsZC5jbGllbnQpO1xuICAgIC8qKlxuICAgICAqIFRoZSBndWlsZCBvZiB0aGlzIHZvaWNlIHN0YXRlXG4gICAgICogQHR5cGUge0d1aWxkfVxuICAgICAqL1xuICAgIHRoaXMuZ3VpbGQgPSBndWlsZDtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIG1lbWJlciBvZiB0aGlzIHZvaWNlIHN0YXRlXG4gICAgICogQHR5cGUge1Nub3dmbGFrZX1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gZGF0YS51c2VyX2lkO1xuICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICB9XG5cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgbWVtYmVyIGlzIGRlYWZlbmVkIHNlcnZlci13aWRlXG4gICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VydmVyRGVhZiA9ICdkZWFmJyBpbiBkYXRhID8gZGF0YS5kZWFmIDogbnVsbDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgbWVtYmVyIGlzIG11dGVkIHNlcnZlci13aWRlXG4gICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VydmVyTXV0ZSA9ICdtdXRlJyBpbiBkYXRhID8gZGF0YS5tdXRlIDogbnVsbDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgbWVtYmVyIGlzIHNlbGYtZGVhZmVuZWRcbiAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zZWxmRGVhZiA9ICdzZWxmX2RlYWYnIGluIGRhdGEgPyBkYXRhLnNlbGZfZGVhZiA6IG51bGw7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIG1lbWJlciBpcyBzZWxmLW11dGVkXG4gICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VsZk11dGUgPSAnc2VsZl9tdXRlJyBpbiBkYXRhID8gZGF0YS5zZWxmX211dGUgOiBudWxsO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBtZW1iZXIncyBjYW1lcmEgaXMgZW5hYmxlZFxuICAgICAqIEB0eXBlIHs/Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNlbGZWaWRlbyA9ICdzZWxmX3ZpZGVvJyBpbiBkYXRhID8gZGF0YS5zZWxmX3ZpZGVvIDogbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2Vzc2lvbiBJRCBvZiB0aGlzIG1lbWJlcidzIGNvbm5lY3Rpb25cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNlc3Npb25JRCA9ICdzZXNzaW9uX2lkJyBpbiBkYXRhID8gZGF0YS5zZXNzaW9uX2lkIDogbnVsbDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgbWVtYmVyIGlzIHN0cmVhbWluZyB1c2luZyBcIkdvIExpdmVcIlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtaW5nID0gZGF0YS5zZWxmX3N0cmVhbSB8fCBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHZvaWNlIGNoYW5uZWwgdGhhdCB0aGlzIG1lbWJlciBpcyBpblxuICAgICAqIEB0eXBlIHs/U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuY2hhbm5lbElEID0gZGF0YS5jaGFubmVsX2lkIHx8IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1lbWJlciB0aGF0IHRoaXMgdm9pY2Ugc3RhdGUgYmVsb25ncyB0b1xuICAgKiBAdHlwZSB7P0d1aWxkTWVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtZW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3VpbGQubWVtYmVycy5jYWNoZS5nZXQodGhpcy5pZCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2hhbm5lbCB0aGF0IHRoZSBtZW1iZXIgaXMgY29ubmVjdGVkIHRvXG4gICAqIEB0eXBlIHs/Vm9pY2VDaGFubmVsfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjaGFubmVsKCkge1xuICAgIHJldHVybiB0aGlzLmd1aWxkLmNoYW5uZWxzLmNhY2hlLmdldCh0aGlzLmNoYW5uZWxJRCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIGlzIGEgdm9pY2Ugc3RhdGUgb2YgdGhlIGNsaWVudCB1c2VyLCB0aGVuIHRoaXMgd2lsbCByZWZlciB0byB0aGUgYWN0aXZlIFZvaWNlQ29ubmVjdGlvbiBmb3IgdGhpcyBndWlsZFxuICAgKiBAdHlwZSB7P1ZvaWNlQ29ubmVjdGlvbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY29ubmVjdGlvbigpIHtcbiAgICBpZiAoYnJvd3NlciB8fCB0aGlzLmlkICE9PSB0aGlzLmNsaWVudC51c2VyLmlkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQudm9pY2UuY29ubmVjdGlvbnMuZ2V0KHRoaXMuZ3VpbGQuaWQpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIG1lbWJlciBpcyBlaXRoZXIgc2VsZi1kZWFmZW5lZCBvciBzZXJ2ZXItZGVhZmVuZWRcbiAgICogQHR5cGUgez9ib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkZWFmKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZlckRlYWYgfHwgdGhpcy5zZWxmRGVhZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgbWVtYmVyIGlzIGVpdGhlciBzZWxmLW11dGVkIG9yIHNlcnZlci1tdXRlZFxuICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG11dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyTXV0ZSB8fCB0aGlzLnNlbGZNdXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBtZW1iZXIgaXMgY3VycmVudGx5IHNwZWFraW5nLiBBIGJvb2xlYW4gaWYgdGhlIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSAoYWthXG4gICAqIHRoZSBib3QgaXMgY29ubmVjdGVkIHRvIGFueSB2b2ljZSBjaGFubmVsIGluIHRoZSBndWlsZCksIG90aGVyd2lzZSB0aGlzIGlzIG51bGxcbiAgICogQHR5cGUgez9ib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzcGVha2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsICYmIHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uID8gQm9vbGVhbih0aGlzLmNoYW5uZWwuY29ubmVjdGlvbi5fc3BlYWtpbmcuZ2V0KHRoaXMuaWQpKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogTXV0ZXMvdW5tdXRlcyB0aGUgbWVtYmVyIG9mIHRoaXMgdm9pY2Ugc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0ZSBXaGV0aGVyIG9yIG5vdCB0aGUgbWVtYmVyIHNob3VsZCBiZSBtdXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBtdXRpbmcgb3IgdW5tdXRpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRNZW1iZXI+fVxuICAgKi9cbiAgc2V0TXV0ZShtdXRlLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXIgPyB0aGlzLm1lbWJlci5lZGl0KHsgbXV0ZSB9LCByZWFzb24pIDogUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdWT0lDRV9TVEFURV9VTkNBQ0hFRF9NRU1CRVInKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVhZmVucy91bmRlYWZlbnMgdGhlIG1lbWJlciBvZiB0aGlzIHZvaWNlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlYWYgV2hldGhlciBvciBub3QgdGhlIG1lbWJlciBzaG91bGQgYmUgZGVhZmVuZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgZGVhZmVuaW5nIG9yIHVuZGVhZmVuaW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEd1aWxkTWVtYmVyPn1cbiAgICovXG4gIHNldERlYWYoZGVhZiwgcmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtYmVyID8gdGhpcy5tZW1iZXIuZWRpdCh7IGRlYWYgfSwgcmVhc29uKSA6IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVk9JQ0VfU1RBVEVfVU5DQUNIRURfTUVNQkVSJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpY2tzIHRoZSBtZW1iZXIgZnJvbSB0aGUgdm9pY2UgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3Iga2lja2luZyBtZW1iZXIgZnJvbSB0aGUgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHdWlsZE1lbWJlcj59XG4gICAqL1xuICBraWNrKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwobnVsbCwgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgbWVtYmVyIHRvIGEgZGlmZmVyZW50IGNoYW5uZWwsIG9yIGRpc2Nvbm5lY3RzIHRoZW0gZnJvbSB0aGUgb25lIHRoZXkncmUgaW4uXG4gICAqIEBwYXJhbSB7Q2hhbm5lbFJlc29sdmFibGV8bnVsbH0gW2NoYW5uZWxdIENoYW5uZWwgdG8gbW92ZSB0aGUgbWVtYmVyIHRvLCBvciBgbnVsbGAgaWYgeW91IHdhbnQgdG8gZGlzY29ubmVjdCB0aGVtXG4gICAqIGZyb20gdm9pY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uXSBSZWFzb24gZm9yIG1vdmluZyBtZW1iZXIgdG8gYW5vdGhlciBjaGFubmVsIG9yIGRpc2Nvbm5lY3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8R3VpbGRNZW1iZXI+fVxuICAgKi9cbiAgc2V0Q2hhbm5lbChjaGFubmVsLCByZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJcbiAgICAgID8gdGhpcy5tZW1iZXIuZWRpdCh7IGNoYW5uZWwgfSwgcmVhc29uKVxuICAgICAgOiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1ZPSUNFX1NUQVRFX1VOQ0FDSEVEX01FTUJFUicpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxmLW11dGVzL3VubXV0ZXMgdGhlIGJvdCBmb3IgdGhpcyB2b2ljZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBtdXRlIFdoZXRoZXIgb3Igbm90IHRoZSBib3Qgc2hvdWxkIGJlIHNlbGYtbXV0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHRydWUgaWYgdGhlIHZvaWNlIHN0YXRlIHdhcyBzdWNjZXNzZnVsbHkgdXBkYXRlZCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAqL1xuICBhc3luYyBzZXRTZWxmTXV0ZShtdXRlKSB7XG4gICAgaWYgKHRoaXMuaWQgIT09IHRoaXMuY2xpZW50LnVzZXIuaWQpIHRocm93IG5ldyBFcnJvcignVk9JQ0VfU1RBVEVfTk9UX09XTicpO1xuICAgIGlmICh0eXBlb2YgbXV0ZSAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdWT0lDRV9TVEFURV9JTlZBTElEX1RZUEUnLCAnbXV0ZScpO1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5zZWxmTXV0ZSA9IG11dGU7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRWb2ljZVN0YXRlVXBkYXRlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2VsZi1kZWFmZW5zL3VuZGVhZmVucyB0aGUgYm90IGZvciB0aGlzIHZvaWNlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlYWYgV2hldGhlciBvciBub3QgdGhlIGJvdCBzaG91bGQgYmUgc2VsZi1kZWFmZW5lZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdHJ1ZSBpZiB0aGUgdm9pY2Ugc3RhdGUgd2FzIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLCBvdGhlcndpc2UgZmFsc2VcbiAgICovXG4gIGFzeW5jIHNldFNlbGZEZWFmKGRlYWYpIHtcbiAgICBpZiAodGhpcy5pZCAhPT0gdGhpcy5jbGllbnQudXNlci5pZCkgcmV0dXJuIG5ldyBFcnJvcignVk9JQ0VfU1RBVEVfTk9UX09XTicpO1xuICAgIGlmICh0eXBlb2YgZGVhZiAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbmV3IFR5cGVFcnJvcignVk9JQ0VfU1RBVEVfSU5WQUxJRF9UWVBFJywgJ2RlYWYnKTtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuc2VsZkRlYWYgPSBkZWFmO1xuICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kVm9pY2VTdGF0ZVVwZGF0ZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oe1xuICAgICAgaWQ6IHRydWUsXG4gICAgICBzZXJ2ZXJEZWFmOiB0cnVlLFxuICAgICAgc2VydmVyTXV0ZTogdHJ1ZSxcbiAgICAgIHNlbGZEZWFmOiB0cnVlLFxuICAgICAgc2VsZk11dGU6IHRydWUsXG4gICAgICBzZXNzaW9uSUQ6IHRydWUsXG4gICAgICBjaGFubmVsSUQ6ICdjaGFubmVsJyxcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZvaWNlU3RhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFQSU1lc3NhZ2UgPSByZXF1aXJlKCcuL0FQSU1lc3NhZ2UnKTtcbmNvbnN0IENoYW5uZWwgPSByZXF1aXJlKCcuL0NoYW5uZWwnKTtcbmNvbnN0IHsgV2ViaG9va1R5cGVzIH0gPSByZXF1aXJlKCcuLi91dGlsL0NvbnN0YW50cycpO1xuY29uc3QgRGF0YVJlc29sdmVyID0gcmVxdWlyZSgnLi4vdXRpbC9EYXRhUmVzb2x2ZXInKTtcbmNvbnN0IFNub3dmbGFrZSA9IHJlcXVpcmUoJy4uL3V0aWwvU25vd2ZsYWtlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHdlYmhvb2suXG4gKi9cbmNsYXNzIFdlYmhvb2sge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRoYXQgaW5zdGFudGlhdGVkIHRoZSB3ZWJob29rXG4gICAgICogQG5hbWUgV2ViaG9vayNjbGllbnRcbiAgICAgKiBAdHlwZSB7Q2xpZW50fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2xpZW50JywgeyB2YWx1ZTogY2xpZW50IH0pO1xuICAgIGlmIChkYXRhKSB0aGlzLl9wYXRjaChkYXRhKTtcbiAgfVxuXG4gIF9wYXRjaChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHdlYmhvb2tcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b2tlbiBmb3IgdGhlIHdlYmhvb2tcbiAgICAgKiBAbmFtZSBXZWJob29rI3Rva2VuXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0b2tlbicsIHsgdmFsdWU6IGRhdGEudG9rZW4gfHwgbnVsbCwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhdmF0YXIgZm9yIHRoZSB3ZWJob29rXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hdmF0YXIgPSBkYXRhLmF2YXRhcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgd2ViaG9va1xuICAgICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgd2ViaG9va1xuICAgICAqIEB0eXBlIHtXZWJob29rVHlwZXN9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gV2ViaG9va1R5cGVzW2RhdGEudHlwZV07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3VpbGQgdGhlIHdlYmhvb2sgYmVsb25ncyB0b1xuICAgICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5ndWlsZElEID0gZGF0YS5ndWlsZF9pZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjaGFubmVsIHRoZSB3ZWJob29rIGJlbG9uZ3MgdG9cbiAgICAgKiBAdHlwZSB7U25vd2ZsYWtlfVxuICAgICAqL1xuICAgIHRoaXMuY2hhbm5lbElEID0gZGF0YS5jaGFubmVsX2lkO1xuXG4gICAgaWYgKGRhdGEudXNlcikge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgb3duZXIgb2YgdGhlIHdlYmhvb2tcbiAgICAgICAqIEB0eXBlIHs/VXNlcnxPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHRoaXMub3duZXIgPSB0aGlzLmNsaWVudC51c2VycyA/IHRoaXMuY2xpZW50LnVzZXJzLmNhY2hlLmdldChkYXRhLnVzZXIuaWQpIDogZGF0YS51c2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm93bmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byBzZW5kLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBXZWJob29rTWVzc2FnZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1c2VybmFtZT10aGlzLm5hbWVdIFVzZXJuYW1lIG92ZXJyaWRlIGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2F2YXRhclVSTF0gQXZhdGFyIFVSTCBvdmVycmlkZSBmb3IgdGhlIG1lc3NhZ2VcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbdHRzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0aGUgbWVzc2FnZSBzaG91bGQgYmUgc3Bva2VuIGFsb3VkXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbm9uY2U9JyddIFRoZSBub25jZSBmb3IgdGhlIG1lc3NhZ2VcbiAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gW2VtYmVkc10gQW4gYXJyYXkgb2YgZW1iZWRzIGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcHJvcGVydHkge01lc3NhZ2VNZW50aW9uT3B0aW9uc30gW2FsbG93ZWRNZW50aW9uc10gV2hpY2ggbWVudGlvbnMgc2hvdWxkIGJlIHBhcnNlZCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICogKHNlZSBbaGVyZV0oaHR0cHM6Ly9kaXNjb3JkLmNvbS9kZXZlbG9wZXJzL2RvY3MvcmVzb3VyY2VzL2NoYW5uZWwjZW1iZWQtb2JqZWN0KSBmb3IgbW9yZSBkZXRhaWxzKVxuICAgKiBAcHJvcGVydHkge0Rpc2FibGVNZW50aW9uVHlwZX0gW2Rpc2FibGVNZW50aW9ucz10aGlzLmNsaWVudC5vcHRpb25zLmRpc2FibGVNZW50aW9uc10gV2hldGhlciBvciBub3QgYWxsIG1lbnRpb25zIG9yXG4gICAqIGV2ZXJ5b25lL2hlcmUgbWVudGlvbnMgc2hvdWxkIGJlIHNhbml0aXplZCB0byBwcmV2ZW50IHVuZXhwZWN0ZWQgbWVudGlvbnNcbiAgICogQHByb3BlcnR5IHtGaWxlT3B0aW9uc1tdfHN0cmluZ1tdfSBbZmlsZXNdIEZpbGVzIHRvIHNlbmQgd2l0aCB0aGUgbWVzc2FnZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ3xib29sZWFufSBbY29kZV0gTGFuZ3VhZ2UgZm9yIG9wdGlvbmFsIGNvZGVibG9jayBmb3JtYXR0aW5nIHRvIGFwcGx5XG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxTcGxpdE9wdGlvbnN9IFtzcGxpdD1mYWxzZV0gV2hldGhlciBvciBub3QgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIHNwbGl0IGludG8gbXVsdGlwbGUgbWVzc2FnZXMgaWZcbiAgICogaXQgZXhjZWVkcyB0aGUgY2hhcmFjdGVyIGxpbWl0LiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHRoZXNlIGFyZSB0aGUgb3B0aW9ucyBmb3Igc3BsaXR0aW5nIHRoZSBtZXNzYWdlLlxuICAgKi9cblxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIHdpdGggdGhpcyB3ZWJob29rLlxuICAgKiBAcGFyYW0ge1N0cmluZ1Jlc29sdmFibGV8QVBJTWVzc2FnZX0gW2NvbnRlbnQ9JyddIFRoZSBjb250ZW50IHRvIHNlbmRcbiAgICogQHBhcmFtIHtXZWJob29rTWVzc2FnZU9wdGlvbnN8TWVzc2FnZUFkZGl0aW9uc30gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIHByb3ZpZGVcbiAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZXxPYmplY3Q+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZW5kIGEgYmFzaWMgbWVzc2FnZVxuICAgKiB3ZWJob29rLnNlbmQoJ2hlbGxvIScpXG4gICAqICAgLnRoZW4obWVzc2FnZSA9PiBjb25zb2xlLmxvZyhgU2VudCBtZXNzYWdlOiAke21lc3NhZ2UuY29udGVudH1gKSlcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNlbmQgYSByZW1vdGUgZmlsZVxuICAgKiB3ZWJob29rLnNlbmQoe1xuICAgKiAgIGZpbGVzOiBbJ2h0dHBzOi8vY2RuLmRpc2NvcmRhcHAuY29tL2ljb25zLzIyMjA3ODEwODk3NzU5NDM2OC82ZTEwMTliMzE3OWQ3MTA0NmU0NjNhNzU5MTVlNzI0NC5wbmc/c2l6ZT0yMDQ4J11cbiAgICogfSlcbiAgICogICAudGhlbihjb25zb2xlLmxvZylcbiAgICogICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNlbmQgYSBsb2NhbCBmaWxlXG4gICAqIHdlYmhvb2suc2VuZCh7XG4gICAqICAgZmlsZXM6IFt7XG4gICAqICAgICBhdHRhY2htZW50OiAnZW50aXJlL3BhdGgvdG8vZmlsZS5qcGcnLFxuICAgKiAgICAgbmFtZTogJ2ZpbGUuanBnJ1xuICAgKiAgIH1dXG4gICAqIH0pXG4gICAqICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZW5kIGFuIGVtYmVkIHdpdGggYSBsb2NhbCBpbWFnZSBpbnNpZGVcbiAgICogd2ViaG9vay5zZW5kKCdUaGlzIGlzIGFuIGVtYmVkJywge1xuICAgKiAgIGVtYmVkczogW3tcbiAgICogICAgIHRodW1ibmFpbDoge1xuICAgKiAgICAgICAgICB1cmw6ICdhdHRhY2htZW50Oi8vZmlsZS5qcGcnXG4gICAqICAgICAgIH1cbiAgICogICAgfV0sXG4gICAqICAgIGZpbGVzOiBbe1xuICAgKiAgICAgICBhdHRhY2htZW50OiAnZW50aXJlL3BhdGgvdG8vZmlsZS5qcGcnLFxuICAgKiAgICAgICBuYW1lOiAnZmlsZS5qcGcnXG4gICAqICAgIH1dXG4gICAqIH0pXG4gICAqICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKi9cbiAgYXN5bmMgc2VuZChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgbGV0IGFwaU1lc3NhZ2U7XG5cbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFQSU1lc3NhZ2UpIHtcbiAgICAgIGFwaU1lc3NhZ2UgPSBjb250ZW50LnJlc29sdmVEYXRhKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaU1lc3NhZ2UgPSBBUElNZXNzYWdlLmNyZWF0ZSh0aGlzLCBjb250ZW50LCBvcHRpb25zKS5yZXNvbHZlRGF0YSgpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXBpTWVzc2FnZS5kYXRhLmNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhcGlNZXNzYWdlLnNwbGl0KCkubWFwKHRoaXMuc2VuZC5iaW5kKHRoaXMpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhLCBmaWxlcyB9ID0gYXdhaXQgYXBpTWVzc2FnZS5yZXNvbHZlRmlsZXMoKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAud2ViaG9va3ModGhpcy5pZCwgdGhpcy50b2tlbilcbiAgICAgIC5wb3N0KHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIHF1ZXJ5OiB7IHdhaXQ6IHRydWUgfSxcbiAgICAgICAgYXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgICAgLnRoZW4oZCA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNsaWVudC5jaGFubmVscyA/IHRoaXMuY2xpZW50LmNoYW5uZWxzLmNhY2hlLmdldChkLmNoYW5uZWxfaWQpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gY2hhbm5lbC5tZXNzYWdlcy5hZGQoZCwgZmFsc2UpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSByYXcgc2xhY2sgbWVzc2FnZSB3aXRoIHRoaXMgd2ViaG9vay5cbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHkgVGhlIHJhdyBib2R5IHRvIHNlbmRcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNlbmQgYSBzbGFjayBtZXNzYWdlXG4gICAqIHdlYmhvb2suc2VuZFNsYWNrTWVzc2FnZSh7XG4gICAqICAgJ3VzZXJuYW1lJzogJ1d1bXB1cycsXG4gICAqICAgJ2F0dGFjaG1lbnRzJzogW3tcbiAgICogICAgICdwcmV0ZXh0JzogJ3RoaXMgbG9va3MgcHJldHR5IGNvb2wnLFxuICAgKiAgICAgJ2NvbG9yJzogJyNGMEYnLFxuICAgKiAgICAgJ2Zvb3Rlcl9pY29uJzogJ2h0dHA6Ly9zbmVrLnMzLmFtYXpvbmF3cy5jb20vdG9wU25lay5wbmcnLFxuICAgKiAgICAgJ2Zvb3Rlcic6ICdQb3dlcmVkIGJ5IHNuZWtzJyxcbiAgICogICAgICd0cyc6IERhdGUubm93KCkgLyAxMDAwXG4gICAqICAgfV1cbiAgICogfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAqL1xuICBzZW5kU2xhY2tNZXNzYWdlKGJvZHkpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuYXBpXG4gICAgICAud2ViaG9va3ModGhpcy5pZCwgdGhpcy50b2tlbilcbiAgICAgIC5zbGFjay5wb3N0KHtcbiAgICAgICAgcXVlcnk6IHsgd2FpdDogdHJ1ZSB9LFxuICAgICAgICBhdXRoOiBmYWxzZSxcbiAgICAgICAgZGF0YTogYm9keSxcbiAgICAgIH0pXG4gICAgICAudGhlbihkYXRhID0+IGRhdGEudG9TdHJpbmcoKSA9PT0gJ29rJyk7XG4gIH1cblxuICAvKipcbiAgICogRWRpdHMgdGhlIHdlYmhvb2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWU9dGhpcy5uYW1lXSBOZXcgbmFtZSBmb3IgdGhpcyB3ZWJob29rXG4gICAqIEBwYXJhbSB7QnVmZmVyUmVzb2x2YWJsZX0gW29wdGlvbnMuYXZhdGFyXSBOZXcgYXZhdGFyIGZvciB0aGlzIHdlYmhvb2tcbiAgICogQHBhcmFtIHtDaGFubmVsUmVzb2x2YWJsZX0gW29wdGlvbnMuY2hhbm5lbF0gTmV3IGNoYW5uZWwgZm9yIHRoaXMgd2ViaG9va1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBlZGl0aW5nIHRoaXMgd2ViaG9va1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rPn1cbiAgICovXG4gIGFzeW5jIGVkaXQoeyBuYW1lID0gdGhpcy5uYW1lLCBhdmF0YXIsIGNoYW5uZWwgfSwgcmVhc29uKSB7XG4gICAgaWYgKGF2YXRhciAmJiB0eXBlb2YgYXZhdGFyID09PSAnc3RyaW5nJyAmJiAhYXZhdGFyLnN0YXJ0c1dpdGgoJ2RhdGE6JykpIHtcbiAgICAgIGF2YXRhciA9IGF3YWl0IERhdGFSZXNvbHZlci5yZXNvbHZlSW1hZ2UoYXZhdGFyKTtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWwpIGNoYW5uZWwgPSBjaGFubmVsIGluc3RhbmNlb2YgQ2hhbm5lbCA/IGNoYW5uZWwuaWQgOiBjaGFubmVsO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5hcGkud2ViaG9va3ModGhpcy5pZCwgY2hhbm5lbCA/IHVuZGVmaW5lZCA6IHRoaXMudG9rZW4pLnBhdGNoKHtcbiAgICAgIGRhdGE6IHsgbmFtZSwgYXZhdGFyLCBjaGFubmVsX2lkOiBjaGFubmVsIH0sXG4gICAgICByZWFzb24sXG4gICAgfSk7XG5cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5hdmF0YXIgPSBkYXRhLmF2YXRhcjtcbiAgICB0aGlzLmNoYW5uZWxJRCA9IGRhdGEuY2hhbm5lbF9pZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB3ZWJob29rLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gUmVhc29uIGZvciBkZWxldGluZyB0aGlzIHdlYmhvb2tcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBkZWxldGUocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaS53ZWJob29rcyh0aGlzLmlkLCB0aGlzLnRva2VuKS5kZWxldGUoeyByZWFzb24gfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgdGhlIHdlYmhvb2sgd2FzIGNyZWF0ZWQgYXRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZFRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gU25vd2ZsYWtlLmRlY29uc3RydWN0KHRoaXMuaWQpLnRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgd2ViaG9vayB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3JlYXRlZEF0KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmNyZWF0ZWRUaW1lc3RhbXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB1cmwgb2YgdGhpcyB3ZWJob29rXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQub3B0aW9ucy5odHRwLmFwaSArIHRoaXMuY2xpZW50LmFwaS53ZWJob29rcyh0aGlzLmlkLCB0aGlzLnRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGxpbmsgdG8gdGhlIHdlYmhvb2sncyBhdmF0YXIuXG4gICAqIEBwYXJhbSB7SW1hZ2VVUkxPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIEltYWdlIFVSTFxuICAgKiBAcmV0dXJucyB7P3N0cmluZ31cbiAgICovXG4gIGF2YXRhclVSTCh7IGZvcm1hdCwgc2l6ZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuYXZhdGFyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jZG4uQXZhdGFyKHRoaXMuaWQsIHRoaXMuYXZhdGFyLCBmb3JtYXQsIHNpemUpO1xuICB9XG5cbiAgc3RhdGljIGFwcGx5VG9DbGFzcyhzdHJ1Y3R1cmUpIHtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgWydzZW5kJywgJ3NlbmRTbGFja01lc3NhZ2UnLCAnZWRpdCcsICdkZWxldGUnLCAnY3JlYXRlZFRpbWVzdGFtcCcsICdjcmVhdGVkQXQnLCAndXJsJ10pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHJ1Y3R1cmUucHJvdG90eXBlLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdlYmhvb2sucHJvdG90eXBlLCBwcm9wKSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViaG9vaztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBDbGllbnRBcHBsaWNhdGlvbkFzc2V0VHlwZXMsIEVuZHBvaW50cyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IFNub3dmbGFrZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvU25vd2ZsYWtlJyk7XG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xuXG5jb25zdCBBc3NldFR5cGVzID0gT2JqZWN0LmtleXMoQ2xpZW50QXBwbGljYXRpb25Bc3NldFR5cGVzKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIE9BdXRoMiBBcHBsaWNhdGlvbi5cbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBBcHBsaWNhdGlvbiBleHRlbmRzIEJhc2Uge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGRhdGEpIHtcbiAgICBzdXBlcihjbGllbnQpO1xuICAgIHRoaXMuX3BhdGNoKGRhdGEpO1xuICB9XG5cbiAgX3BhdGNoKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGFwcFxuICAgICAqIEB0eXBlIHtTbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYXBwXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwJ3MgZGVzY3JpcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkYXRhLmRlc2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcCdzIGljb24gaGFzaFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pY29uID0gZGF0YS5pY29uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgdGhlIGFwcCB3YXMgY3JlYXRlZCBhdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjcmVhdGVkVGltZXN0YW1wKCkge1xuICAgIHJldHVybiBTbm93Zmxha2UuZGVjb25zdHJ1Y3QodGhpcy5pZCkudGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBhcHAgd2FzIGNyZWF0ZWQgYXRcbiAgICogQHR5cGUge0RhdGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5jcmVhdGVkVGltZXN0YW1wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGxpbmsgdG8gdGhlIGFwcGxpY2F0aW9uJ3MgaWNvbi5cbiAgICogQHBhcmFtIHtJbWFnZVVSTE9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgSW1hZ2UgVVJMXG4gICAqIEByZXR1cm5zIHs/c3RyaW5nfSBVUkwgdG8gdGhlIGljb25cbiAgICovXG4gIGljb25VUkwoeyBmb3JtYXQsIHNpemUgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmljb24pIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXN0LmNkbi5BcHBJY29uKHRoaXMuaWQsIHRoaXMuaWNvbiwgeyBmb3JtYXQsIHNpemUgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBsaW5rIHRvIHRoaXMgYXBwbGljYXRpb24ncyBjb3ZlciBpbWFnZS5cbiAgICogQHBhcmFtIHtJbWFnZVVSTE9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgSW1hZ2UgVVJMXG4gICAqIEByZXR1cm5zIHs/c3RyaW5nfSBVUkwgdG8gdGhlIGNvdmVyIGltYWdlXG4gICAqL1xuICBjb3ZlckltYWdlKHsgZm9ybWF0LCBzaXplIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5jb3ZlcikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIEVuZHBvaW50cy5DRE4odGhpcy5jbGllbnQub3B0aW9ucy5odHRwLmNkbikuQXBwSWNvbih0aGlzLmlkLCB0aGlzLmNvdmVyLCB7IGZvcm1hdCwgc2l6ZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NldCBkYXRhLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBBcHBsaWNhdGlvbkFzc2V0XG4gICAqIEBwcm9wZXJ0eSB7U25vd2ZsYWtlfSBpZCBUaGUgYXNzZXQgSURcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIGFzc2V0IG5hbWVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGFzc2V0IHR5cGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNsaWVudHMgcmljaCBwcmVzZW5jZSBhc3NldHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PEFwcGxpY2F0aW9uQXNzZXQ+Pn1cbiAgICovXG4gIGZldGNoQXNzZXRzKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5hcGkub2F1dGgyXG4gICAgICAuYXBwbGljYXRpb25zKHRoaXMuaWQpXG4gICAgICAuYXNzZXRzLmdldCgpXG4gICAgICAudGhlbihhc3NldHMgPT5cbiAgICAgICAgYXNzZXRzLm1hcChhID0+ICh7XG4gICAgICAgICAgaWQ6IGEuaWQsXG4gICAgICAgICAgbmFtZTogYS5uYW1lLFxuICAgICAgICAgIHR5cGU6IEFzc2V0VHlwZXNbYS50eXBlIC0gMV0sXG4gICAgICAgIH0pKSxcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjb25jYXRlbmF0ZWQgd2l0aCBhIHN0cmluZywgdGhpcyBhdXRvbWF0aWNhbGx5IHJldHVybnMgdGhlIGFwcGxpY2F0aW9uJ3MgbmFtZSBpbnN0ZWFkIG9mIHRoZVxuICAgKiBPYXV0aDJBcHBsaWNhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIExvZ3M6IEFwcGxpY2F0aW9uIG5hbWU6IE15IEFwcFxuICAgKiBjb25zb2xlLmxvZyhgQXBwbGljYXRpb24gbmFtZTogJHthcHBsaWNhdGlvbn1gKTtcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSlNPTih7IGNyZWF0ZWRUaW1lc3RhbXA6IHRydWUgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBcHBsaWNhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Db2xsZWN0aW9uJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9VdGlsJyk7XG5cbi8qKlxuICogRmlsdGVyIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvbGxlY3Rvci5cbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gQ29sbGVjdG9yRmlsdGVyXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQW55IGFyZ3VtZW50cyByZWNlaXZlZCBieSB0aGUgbGlzdGVuZXJcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gY29sbGVjdGlvbiBUaGUgaXRlbXMgY29sbGVjdGVkIGJ5IHRoaXMgY29sbGVjdG9yXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxQcm9taXNlPGJvb2xlYW4+fVxuICovXG5cbi8qKlxuICogT3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBjb2xsZWN0b3IuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xsZWN0b3JPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbWVdIEhvdyBsb25nIHRvIHJ1biB0aGUgY29sbGVjdG9yIGZvciBpbiBtaWxsaXNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaWRsZV0gSG93IGxvbmcgdG8gc3RvcCB0aGUgY29sbGVjdG9yIGFmdGVyIGluYWN0aXZpdHkgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNwb3NlPWZhbHNlXSBXaGV0aGVyIHRvIGRpc3Bvc2UgZGF0YSB3aGVuIGl0J3MgZGVsZXRlZFxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIGRlZmluaW5nIGEgbmV3IENvbGxlY3Rvci5cbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBDb2xsZWN0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGZpbHRlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgdGhhdCBpbnN0YW50aWF0ZWQgdGhpcyBDb2xsZWN0b3JcbiAgICAgKiBAbmFtZSBDb2xsZWN0b3IjY2xpZW50XG4gICAgICogQHR5cGUge0NsaWVudH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NsaWVudCcsIHsgdmFsdWU6IGNsaWVudCB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWx0ZXIgYXBwbGllZCB0byB0aGlzIGNvbGxlY3RvclxuICAgICAqIEB0eXBlIHtDb2xsZWN0b3JGaWx0ZXJ9XG4gICAgICovXG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBvZiB0aGlzIGNvbGxlY3RvclxuICAgICAqIEB0eXBlIHtDb2xsZWN0b3JPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbXMgY29sbGVjdGVkIGJ5IHRoaXMgY29sbGVjdG9yXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5jb2xsZWN0ZWQgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNvbGxlY3RvciBoYXMgZmluaXNoZWQgY29sbGVjdGluZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgZm9yIGNsZWFudXBcbiAgICAgKiBAdHlwZSB7P1RpbWVvdXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgZm9yIGNsZWFudXAgZHVlIHRvIGluYWN0aXZpdHlcbiAgICAgKiBAdHlwZSB7P1RpbWVvdXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pZGxldGltZW91dCA9IG51bGw7XG5cbiAgICB0aGlzLmhhbmRsZUNvbGxlY3QgPSB0aGlzLmhhbmRsZUNvbGxlY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZURpc3Bvc2UgPSB0aGlzLmhhbmRsZURpc3Bvc2UuYmluZCh0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLnRpbWUpIHRoaXMuX3RpbWVvdXQgPSB0aGlzLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RvcCgndGltZScpLCBvcHRpb25zLnRpbWUpO1xuICAgIGlmIChvcHRpb25zLmlkbGUpIHRoaXMuX2lkbGV0aW1lb3V0ID0gdGhpcy5jbGllbnQuc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0b3AoJ2lkbGUnKSwgb3B0aW9ucy5pZGxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gaGFuZGxlIGFuIGV2ZW50IGFzIGEgY29sbGVjdGFibGUgZWxlbWVudC4gQWNjZXB0cyBhbnkgZXZlbnQgZGF0YSBhcyBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIGFyZ3VtZW50cyBlbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lclxuICAgKiBAZW1pdHMgQ29sbGVjdG9yI2NvbGxlY3RcbiAgICovXG4gIGFzeW5jIGhhbmRsZUNvbGxlY3QoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbGxlY3QgPSB0aGlzLmNvbGxlY3QoLi4uYXJncyk7XG5cbiAgICBpZiAoY29sbGVjdCAmJiAoYXdhaXQgdGhpcy5maWx0ZXIoLi4uYXJncywgdGhpcy5jb2xsZWN0ZWQpKSkge1xuICAgICAgdGhpcy5jb2xsZWN0ZWQuc2V0KGNvbGxlY3QsIGFyZ3NbMF0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXR0ZWQgd2hlbmV2ZXIgYW4gZWxlbWVudCBpcyBjb2xsZWN0ZWQuXG4gICAgICAgKiBAZXZlbnQgQ29sbGVjdG9yI2NvbGxlY3RcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBUaGUgYXJndW1lbnRzIGVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1pdCgnY29sbGVjdCcsIC4uLmFyZ3MpO1xuXG4gICAgICBpZiAodGhpcy5faWRsZXRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQuY2xlYXJUaW1lb3V0KHRoaXMuX2lkbGV0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5faWRsZXRpbWVvdXQgPSB0aGlzLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RvcCgnaWRsZScpLCB0aGlzLm9wdGlvbnMuaWRsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFbmQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gcmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbi4gQWNjZXB0cyBhbnkgZXZlbnQgZGF0YSBhcyBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIGFyZ3VtZW50cyBlbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lclxuICAgKiBAZW1pdHMgQ29sbGVjdG9yI2Rpc3Bvc2VcbiAgICovXG4gIGhhbmRsZURpc3Bvc2UoLi4uYXJncykge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3Bvc2UpIHJldHVybjtcblxuICAgIGNvbnN0IGRpc3Bvc2UgPSB0aGlzLmRpc3Bvc2UoLi4uYXJncyk7XG4gICAgaWYgKCFkaXNwb3NlIHx8ICF0aGlzLmZpbHRlciguLi5hcmdzKSB8fCAhdGhpcy5jb2xsZWN0ZWQuaGFzKGRpc3Bvc2UpKSByZXR1cm47XG4gICAgdGhpcy5jb2xsZWN0ZWQuZGVsZXRlKGRpc3Bvc2UpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuZXZlciBhbiBlbGVtZW50IGlzIGRpc3Bvc2VkIG9mLlxuICAgICAqIEBldmVudCBDb2xsZWN0b3IjZGlzcG9zZVxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBUaGUgYXJndW1lbnRzIGVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyXG4gICAgICovXG4gICAgdGhpcy5lbWl0KCdkaXNwb3NlJywgLi4uYXJncyk7XG4gICAgdGhpcy5jaGVja0VuZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV4dCBjb2xsZWN0ZWQgZWxlbWVudDtcbiAgICogcmVqZWN0cyB3aXRoIGNvbGxlY3RlZCBlbGVtZW50cyBpZiB0aGUgY29sbGVjdG9yIGZpbmlzaGVzIHdpdGhvdXQgcmVjZWl2aW5nIGEgbmV4dCBlbGVtZW50XG4gICAqIEB0eXBlIHtQcm9taXNlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICByZWplY3QodGhpcy5jb2xsZWN0ZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NvbGxlY3QnLCBvbkNvbGxlY3QpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvbkNvbGxlY3QgPSBpdGVtID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgb25FbmQgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KHRoaXMuY29sbGVjdGVkKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCdjb2xsZWN0Jywgb25Db2xsZWN0KTtcbiAgICAgIHRoaXMub24oJ2VuZCcsIG9uRW5kKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGlzIGNvbGxlY3RvciBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbj0ndXNlciddIFRoZSByZWFzb24gdGhpcyBjb2xsZWN0b3IgaXMgZW5kaW5nXG4gICAqIEBlbWl0cyBDb2xsZWN0b3IjZW5kXG4gICAqL1xuICBzdG9wKHJlYXNvbiA9ICd1c2VyJykge1xuICAgIGlmICh0aGlzLmVuZGVkKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgICAgdGhpcy5jbGllbnQuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pZGxldGltZW91dCkge1xuICAgICAgdGhpcy5jbGllbnQuY2xlYXJUaW1lb3V0KHRoaXMuX2lkbGV0aW1lb3V0KTtcbiAgICAgIHRoaXMuX2lkbGV0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGNvbGxlY3RvciBpcyBmaW5pc2hlZCBjb2xsZWN0aW5nLlxuICAgICAqIEBldmVudCBDb2xsZWN0b3IjZW5kXG4gICAgICogQHBhcmFtIHtDb2xsZWN0aW9ufSBjb2xsZWN0ZWQgVGhlIGVsZW1lbnRzIGNvbGxlY3RlZCBieSB0aGUgY29sbGVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBUaGUgcmVhc29uIHRoZSBjb2xsZWN0b3IgZW5kZWRcbiAgICAgKi9cbiAgICB0aGlzLmVtaXQoJ2VuZCcsIHRoaXMuY29sbGVjdGVkLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY29sbGVjdG9ycyB0aW1lb3V0IGFuZCBpZGxlIHRpbWVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbWVdIEhvdyBsb25nIHRvIHJ1biB0aGUgY29sbGVjdG9yIGZvciBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmlkbGVdIEhvdyBsb25nIHRvIHN0b3AgdGhlIGNvbGxlY3RvciBhZnRlciBpbmFjdGl2aXR5IGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgcmVzZXRUaW1lcih7IHRpbWUsIGlkbGUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgIHRoaXMuY2xpZW50LmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSB0aGlzLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RvcCgndGltZScpLCB0aW1lIHx8IHRoaXMub3B0aW9ucy50aW1lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lkbGV0aW1lb3V0KSB7XG4gICAgICB0aGlzLmNsaWVudC5jbGVhclRpbWVvdXQodGhpcy5faWRsZXRpbWVvdXQpO1xuICAgICAgdGhpcy5faWRsZXRpbWVvdXQgPSB0aGlzLmNsaWVudC5zZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RvcCgnaWRsZScpLCBpZGxlIHx8IHRoaXMub3B0aW9ucy5pZGxlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNvbGxlY3RvciBzaG91bGQgZW5kLCBhbmQgaWYgc28sIGVuZHMgaXQuXG4gICAqL1xuICBjaGVja0VuZCgpIHtcbiAgICBjb25zdCByZWFzb24gPSB0aGlzLmVuZFJlYXNvbigpO1xuICAgIGlmIChyZWFzb24pIHRoaXMuc3RvcChyZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBjb2xsZWN0b3JzIHRvIGJlIGNvbnN1bWVkIHdpdGggZm9yLWF3YWl0LW9mIGxvb3BzXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0YXRlbWVudHMvZm9yLWF3YWl0Li4ub2Z9XG4gICAqL1xuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGNvbnN0IG9uQ29sbGVjdCA9IGl0ZW0gPT4gcXVldWUucHVzaChpdGVtKTtcbiAgICB0aGlzLm9uKCdjb2xsZWN0Jywgb25Db2xsZWN0KTtcblxuICAgIHRyeSB7XG4gICAgICB3aGlsZSAocXVldWUubGVuZ3RoIHx8ICF0aGlzLmVuZGVkKSB7XG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB5aWVsZCBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjb2xsZWN0JywgdGljayk7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHRpY2spO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NvbGxlY3QnLCB0aWNrKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2VuZCcsIHRpY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NvbGxlY3QnLCBvbkNvbGxlY3QpO1xuICAgIH1cbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gVXRpbC5mbGF0dGVuKHRoaXMpO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHktZnVuY3Rpb24sIHZhbGlkLWpzZG9jICovXG4gIC8qKlxuICAgKiBIYW5kbGVzIGluY29taW5nIGV2ZW50cyBmcm9tIHRoZSBgaGFuZGxlQ29sbGVjdGAgZnVuY3Rpb24uIFJldHVybnMgbnVsbCBpZiB0aGUgZXZlbnQgc2hvdWxkIG5vdFxuICAgKiBiZSBjb2xsZWN0ZWQsIG9yIHJldHVybnMgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgc3RvcmVkLlxuICAgKiBAc2VlIENvbGxlY3RvciNoYW5kbGVDb2xsZWN0XG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBbnkgYXJncyB0aGUgZXZlbnQgbGlzdGVuZXIgZW1pdHNcbiAgICogQHJldHVybnMgez97a2V5LCB2YWx1ZX19IERhdGEgdG8gaW5zZXJ0IGludG8gY29sbGVjdGlvbiwgaWYgYW55XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgY29sbGVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW5jb21pbmcgZXZlbnRzIGZyb20gdGhlIGBoYW5kbGVEaXNwb3NlYC4gUmV0dXJucyBudWxsIGlmIHRoZSBldmVudCBzaG91bGQgbm90XG4gICAqIGJlIGRpc3Bvc2VkLCBvciByZXR1cm5zIHRoZSBrZXkgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICogQHNlZSBDb2xsZWN0b3IjaGFuZGxlRGlzcG9zZVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQW55IGFyZ3MgdGhlIGV2ZW50IGxpc3RlbmVyIGVtaXRzXG4gICAqIEByZXR1cm5zIHs/Kn0gS2V5IHRvIHJlbW92ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLCBpZiBhbnlcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBkaXNwb3NlKCkge31cblxuICAvKipcbiAgICogVGhlIHJlYXNvbiB0aGlzIGNvbGxlY3RvciBoYXMgZW5kZWQgb3Igd2lsbCBlbmQgd2l0aC5cbiAgICogQHJldHVybnMgez9zdHJpbmd9IFJlYXNvbiB0byBlbmQgdGhlIGNvbGxlY3RvciwgaWYgYW55XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZW5kUmVhc29uKCkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eS1mdW5jdGlvbiwgdmFsaWQtanNkb2MgKi9cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9vcmRlciAqL1xuY29uc3QgTWVzc2FnZUNvbGxlY3RvciA9IHJlcXVpcmUoJy4uL01lc3NhZ2VDb2xsZWN0b3InKTtcbmNvbnN0IEFQSU1lc3NhZ2UgPSByZXF1aXJlKCcuLi9BUElNZXNzYWdlJyk7XG5jb25zdCBTbm93Zmxha2UgPSByZXF1aXJlKCcuLi8uLi91dGlsL1Nub3dmbGFrZScpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ29sbGVjdGlvbicpO1xuY29uc3QgeyBSYW5nZUVycm9yLCBUeXBlRXJyb3IgfSA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgY2xhc3NlcyB0aGF0IGhhdmUgdGV4dC1jaGFubmVsLWxpa2UgZmVhdHVyZXMuXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFRleHRCYXNlZENoYW5uZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBBIG1hbmFnZXIgb2YgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhpcyBjaGFubmVsXG4gICAgICogQHR5cGUge01lc3NhZ2VNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZU1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGxhc3QgbWVzc2FnZSBpbiB0aGUgY2hhbm5lbCwgaWYgb25lIHdhcyBzZW50XG4gICAgICogQHR5cGUgez9Tbm93Zmxha2V9XG4gICAgICovXG4gICAgdGhpcy5sYXN0TWVzc2FnZUlEID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lc3RhbXAgd2hlbiB0aGUgbGFzdCBwaW5uZWQgbWVzc2FnZSB3YXMgcGlubmVkLCBpZiB0aGVyZSB3YXMgb25lXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0UGluVGltZXN0YW1wID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgTWVzc2FnZSBvYmplY3Qgb2YgdGhlIGxhc3QgbWVzc2FnZSBpbiB0aGUgY2hhbm5lbCwgaWYgb25lIHdhcyBzZW50XG4gICAqIEB0eXBlIHs/TWVzc2FnZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGFzdE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuY2FjaGUuZ2V0KHRoaXMubGFzdE1lc3NhZ2VJRCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGF0ZSB3aGVuIHRoZSBsYXN0IHBpbm5lZCBtZXNzYWdlIHdhcyBwaW5uZWQsIGlmIHRoZXJlIHdhcyBvbmVcbiAgICogQHR5cGUgez9EYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsYXN0UGluQXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFBpblRpbWVzdGFtcCA/IG5ldyBEYXRlKHRoaXMubGFzdFBpblRpbWVzdGFtcCkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgcHJvdmlkZWQgd2hlbiBzZW5kaW5nIG9yIGVkaXRpbmcgYSBtZXNzYWdlLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXNzYWdlT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0dHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRoZSBtZXNzYWdlIHNob3VsZCBiZSBzcG9rZW4gYWxvdWRcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtub25jZT0nJ10gVGhlIG5vbmNlIGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbnRlbnQ9JyddIFRoZSBjb250ZW50IGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcHJvcGVydHkge01lc3NhZ2VFbWJlZHxPYmplY3R9IFtlbWJlZF0gQW4gZW1iZWQgZm9yIHRoZSBtZXNzYWdlXG4gICAqIChzZWUgW2hlcmVdKGh0dHBzOi8vZGlzY29yZC5jb20vZGV2ZWxvcGVycy9kb2NzL3Jlc291cmNlcy9jaGFubmVsI2VtYmVkLW9iamVjdCkgZm9yIG1vcmUgZGV0YWlscylcbiAgICogQHByb3BlcnR5IHtNZXNzYWdlTWVudGlvbk9wdGlvbnN9IFthbGxvd2VkTWVudGlvbnNdIFdoaWNoIG1lbnRpb25zIHNob3VsZCBiZSBwYXJzZWQgZnJvbSB0aGUgbWVzc2FnZSBjb250ZW50XG4gICAqIEBwcm9wZXJ0eSB7RGlzYWJsZU1lbnRpb25UeXBlfSBbZGlzYWJsZU1lbnRpb25zPXRoaXMuY2xpZW50Lm9wdGlvbnMuZGlzYWJsZU1lbnRpb25zXSBXaGV0aGVyIG9yIG5vdCBhbGwgbWVudGlvbnMgb3JcbiAgICogZXZlcnlvbmUvaGVyZSBtZW50aW9ucyBzaG91bGQgYmUgc2FuaXRpemVkIHRvIHByZXZlbnQgdW5leHBlY3RlZCBtZW50aW9uc1xuICAgKiBAcHJvcGVydHkge0ZpbGVPcHRpb25zW118QnVmZmVyUmVzb2x2YWJsZVtdfSBbZmlsZXNdIEZpbGVzIHRvIHNlbmQgd2l0aCB0aGUgbWVzc2FnZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ3xib29sZWFufSBbY29kZV0gTGFuZ3VhZ2UgZm9yIG9wdGlvbmFsIGNvZGVibG9jayBmb3JtYXR0aW5nIHRvIGFwcGx5XG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxTcGxpdE9wdGlvbnN9IFtzcGxpdD1mYWxzZV0gV2hldGhlciBvciBub3QgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIHNwbGl0IGludG8gbXVsdGlwbGUgbWVzc2FnZXMgaWZcbiAgICogaXQgZXhjZWVkcyB0aGUgY2hhcmFjdGVyIGxpbWl0LiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHRoZXNlIGFyZSB0aGUgb3B0aW9ucyBmb3Igc3BsaXR0aW5nIHRoZSBtZXNzYWdlXG4gICAqIEBwcm9wZXJ0eSB7VXNlclJlc29sdmFibGV9IFtyZXBseV0gVXNlciB0byByZXBseSB0byAocHJlZml4ZXMgdGhlIG1lc3NhZ2Ugd2l0aCBhIG1lbnRpb24sIGV4Y2VwdCBpbiBETXMpXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHByb3ZpZGVkIHRvIGNvbnRyb2wgcGFyc2luZyBvZiBtZW50aW9ucyBieSBEaXNjb3JkXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1lc3NhZ2VNZW50aW9uT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge01lc3NhZ2VNZW50aW9uVHlwZXNbXX0gW3BhcnNlXSBUeXBlcyBvZiBtZW50aW9ucyB0byBiZSBwYXJzZWRcbiAgICogQHByb3BlcnR5IHtTbm93Zmxha2VbXX0gW3VzZXJzXSBTbm93Zmxha2VzIG9mIFVzZXJzIHRvIGJlIHBhcnNlZCBhcyBtZW50aW9uc1xuICAgKiBAcHJvcGVydHkge1Nub3dmbGFrZVtdfSBbcm9sZXNdIFNub3dmbGFrZXMgb2YgUm9sZXMgdG8gYmUgcGFyc2VkIGFzIG1lbnRpb25zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUeXBlcyBvZiBtZW50aW9ucyB0byBlbmFibGUgaW4gTWVzc2FnZU1lbnRpb25PcHRpb25zLlxuICAgKiAtIGByb2xlc2BcbiAgICogLSBgdXNlcnNgXG4gICAqIC0gYGV2ZXJ5b25lYFxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBNZXNzYWdlTWVudGlvblR5cGVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBtZW50aW9ucyB0byBkaXNhYmxlLlxuICAgKiAtIGBub25lYFxuICAgKiAtIGBhbGxgXG4gICAqIC0gYGV2ZXJ5b25lYFxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBEaXNhYmxlTWVudGlvblR5cGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7QnVmZmVyUmVzb2x2YWJsZX0gYXR0YWNobWVudCBGaWxlIHRvIGF0dGFjaFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWU9J2ZpbGUuanBnJ10gRmlsZW5hbWUgb2YgdGhlIGF0dGFjaG1lbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIHNwbGl0dGluZyBhIG1lc3NhZ2UuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFNwbGl0T3B0aW9uc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gW21heExlbmd0aD0yMDAwXSBNYXhpbXVtIGNoYXJhY3RlciBsZW5ndGggcGVyIG1lc3NhZ2UgcGllY2VcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjaGFyPSdcXG4nXSBDaGFyYWN0ZXIgdG8gc3BsaXQgdGhlIG1lc3NhZ2Ugd2l0aFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ByZXBlbmQ9JyddIFRleHQgdG8gcHJlcGVuZCB0byBldmVyeSBwaWVjZSBleGNlcHQgdGhlIGZpcnN0XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXBwZW5kPScnXSBUZXh0IHRvIGFwcGVuZCB0byBldmVyeSBwaWVjZSBleGNlcHQgdGhlIGxhc3RcbiAgICovXG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGlzIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7U3RyaW5nUmVzb2x2YWJsZXxBUElNZXNzYWdlfSBbY29udGVudD0nJ10gVGhlIGNvbnRlbnQgdG8gc2VuZFxuICAgKiBAcGFyYW0ge01lc3NhZ2VPcHRpb25zfE1lc3NhZ2VBZGRpdGlvbnN9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBwcm92aWRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2V8TWVzc2FnZVtdPn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2VuZCBhIGJhc2ljIG1lc3NhZ2VcbiAgICogY2hhbm5lbC5zZW5kKCdoZWxsbyEnKVxuICAgKiAgIC50aGVuKG1lc3NhZ2UgPT4gY29uc29sZS5sb2coYFNlbnQgbWVzc2FnZTogJHttZXNzYWdlLmNvbnRlbnR9YCkpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZW5kIGEgcmVtb3RlIGZpbGVcbiAgICogY2hhbm5lbC5zZW5kKHtcbiAgICogICBmaWxlczogWydodHRwczovL2Nkbi5kaXNjb3JkYXBwLmNvbS9pY29ucy8yMjIwNzgxMDg5Nzc1OTQzNjgvNmUxMDE5YjMxNzlkNzEwNDZlNDYzYTc1OTE1ZTcyNDQucG5nP3NpemU9MjA0OCddXG4gICAqIH0pXG4gICAqICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTZW5kIGEgbG9jYWwgZmlsZVxuICAgKiBjaGFubmVsLnNlbmQoe1xuICAgKiAgIGZpbGVzOiBbe1xuICAgKiAgICAgYXR0YWNobWVudDogJ2VudGlyZS9wYXRoL3RvL2ZpbGUuanBnJyxcbiAgICogICAgIG5hbWU6ICdmaWxlLmpwZydcbiAgICogICB9XVxuICAgKiB9KVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2VuZCBhbiBlbWJlZCB3aXRoIGEgbG9jYWwgaW1hZ2UgaW5zaWRlXG4gICAqIGNoYW5uZWwuc2VuZCgnVGhpcyBpcyBhbiBlbWJlZCcsIHtcbiAgICogICBlbWJlZDoge1xuICAgKiAgICAgdGh1bWJuYWlsOiB7XG4gICAqICAgICAgICAgIHVybDogJ2F0dGFjaG1lbnQ6Ly9maWxlLmpwZydcbiAgICogICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICBmaWxlczogW3tcbiAgICogICAgICAgYXR0YWNobWVudDogJ2VudGlyZS9wYXRoL3RvL2ZpbGUuanBnJyxcbiAgICogICAgICAgbmFtZTogJ2ZpbGUuanBnJ1xuICAgKiAgICB9XVxuICAgKiB9KVxuICAgKiAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGFzeW5jIHNlbmQoY29udGVudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IFVzZXIgPSByZXF1aXJlKCcuLi9Vc2VyJyk7XG4gICAgY29uc3QgR3VpbGRNZW1iZXIgPSByZXF1aXJlKCcuLi9HdWlsZE1lbWJlcicpO1xuXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBVc2VyIHx8IHRoaXMgaW5zdGFuY2VvZiBHdWlsZE1lbWJlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRE0oKS50aGVuKGRtID0+IGRtLnNlbmQoY29udGVudCwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGxldCBhcGlNZXNzYWdlO1xuXG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBUElNZXNzYWdlKSB7XG4gICAgICBhcGlNZXNzYWdlID0gY29udGVudC5yZXNvbHZlRGF0YSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGlNZXNzYWdlID0gQVBJTWVzc2FnZS5jcmVhdGUodGhpcywgY29udGVudCwgb3B0aW9ucykucmVzb2x2ZURhdGEoKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFwaU1lc3NhZ2UuZGF0YS5jb250ZW50KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXBpTWVzc2FnZS5zcGxpdCgpLm1hcCh0aGlzLnNlbmQuYmluZCh0aGlzKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSwgZmlsZXMgfSA9IGF3YWl0IGFwaU1lc3NhZ2UucmVzb2x2ZUZpbGVzKCk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmFwaS5jaGFubmVsc1t0aGlzLmlkXS5tZXNzYWdlc1xuICAgICAgLnBvc3QoeyBkYXRhLCBmaWxlcyB9KVxuICAgICAgLnRoZW4oZCA9PiB0aGlzLmNsaWVudC5hY3Rpb25zLk1lc3NhZ2VDcmVhdGUuaGFuZGxlKGQpLm1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhIHR5cGluZyBpbmRpY2F0b3IgaW4gdGhlIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnQ9MV0gVGhlIG51bWJlciBvZiB0aW1lcyBzdGFydFR5cGluZyBzaG91bGQgYmUgY29uc2lkZXJlZCB0byBoYXZlIGJlZW4gY2FsbGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXNvbHZlcyBvbmNlIHRoZSBib3Qgc3RvcHMgdHlwaW5nIGdyYWNlZnVsbHksIG9yIHJlamVjdHMgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAgICogQGV4YW1wbGVcbiAgICogLy8gU3RhcnQgdHlwaW5nIGluIGEgY2hhbm5lbCwgb3IgaW5jcmVhc2UgdGhlIHR5cGluZyBjb3VudCBieSBvbmVcbiAgICogY2hhbm5lbC5zdGFydFR5cGluZygpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTdGFydCB0eXBpbmcgaW4gYSBjaGFubmVsIHdpdGggYSB0eXBpbmcgY291bnQgb2YgZml2ZSwgb3Igc2V0IGl0IHRvIGZpdmVcbiAgICogY2hhbm5lbC5zdGFydFR5cGluZyg1KTtcbiAgICovXG4gIHN0YXJ0VHlwaW5nKGNvdW50KSB7XG4gICAgaWYgKHR5cGVvZiBjb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY291bnQgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVFlQSU5HX0NPVU5UJyk7XG4gICAgaWYgKHRoaXMuY2xpZW50LnVzZXIuX3R5cGluZy5oYXModGhpcy5pZCkpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jbGllbnQudXNlci5fdHlwaW5nLmdldCh0aGlzLmlkKTtcbiAgICAgIGVudHJ5LmNvdW50ID0gY291bnQgfHwgZW50cnkuY291bnQgKyAxO1xuICAgICAgcmV0dXJuIGVudHJ5LnByb21pc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cnkgPSB7fTtcbiAgICBlbnRyeS5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLmNsaWVudC5hcGkuY2hhbm5lbHNbdGhpcy5pZF0udHlwaW5nO1xuICAgICAgT2JqZWN0LmFzc2lnbihlbnRyeSwge1xuICAgICAgICBjb3VudDogY291bnQgfHwgMSxcbiAgICAgICAgaW50ZXJ2YWw6IHRoaXMuY2xpZW50LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBlbmRwb2ludC5wb3N0KCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuY2xlYXJJbnRlcnZhbChlbnRyeS5pbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC51c2VyLl90eXBpbmcuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgOTAwMCksXG4gICAgICAgIHJlc29sdmUsXG4gICAgICB9KTtcbiAgICAgIGVuZHBvaW50LnBvc3QoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50LmNsZWFySW50ZXJ2YWwoZW50cnkuaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmNsaWVudC51c2VyLl90eXBpbmcuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNsaWVudC51c2VyLl90eXBpbmcuc2V0KHRoaXMuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZW50cnkucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdHlwaW5nIGluZGljYXRvciBpbiB0aGUgY2hhbm5lbC5cbiAgICogVGhlIGluZGljYXRvciB3aWxsIG9ubHkgc3RvcCBpZiB0aGlzIGlzIGNhbGxlZCBhcyBtYW55IHRpbWVzIGFzIHN0YXJ0VHlwaW5nKCkuXG4gICAqIDxpbmZvPkl0IGNhbiB0YWtlIGEgZmV3IHNlY29uZHMgZm9yIHRoZSBjbGllbnQgdXNlciB0byBzdG9wIHR5cGluZy48L2luZm8+XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byByZXNldCB0aGUgY2FsbCBjb3VudCBhbmQgZm9yY2UgdGhlIGluZGljYXRvciB0byBzdG9wXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFJlZHVjZSB0aGUgdHlwaW5nIGNvdW50IGJ5IG9uZSBhbmQgc3RvcCB0eXBpbmcgaWYgaXQgcmVhY2hlZCAwXG4gICAqIGNoYW5uZWwuc3RvcFR5cGluZygpO1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGb3JjZSB0eXBpbmcgdG8gZnVsbHkgc3RvcCByZWdhcmRsZXNzIG9mIHR5cGluZyBjb3VudFxuICAgKiBjaGFubmVsLnN0b3BUeXBpbmcodHJ1ZSk7XG4gICAqL1xuICBzdG9wVHlwaW5nKGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5jbGllbnQudXNlci5fdHlwaW5nLmhhcyh0aGlzLmlkKSkge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmNsaWVudC51c2VyLl90eXBpbmcuZ2V0KHRoaXMuaWQpO1xuICAgICAgZW50cnkuY291bnQtLTtcbiAgICAgIGlmIChlbnRyeS5jb3VudCA8PSAwIHx8IGZvcmNlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmNsZWFySW50ZXJ2YWwoZW50cnkuaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmNsaWVudC51c2VyLl90eXBpbmcuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICBlbnRyeS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0eXBpbmcgaW5kaWNhdG9yIGlzIGJlaW5nIHNob3duIGluIHRoZSBjaGFubmVsXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0eXBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnVzZXIuX3R5cGluZy5oYXModGhpcy5pZCk7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIHRpbWVzIGBzdGFydFR5cGluZ2AgaGFzIGJlZW4gY2FsbGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHR5cGluZ0NvdW50KCkge1xuICAgIGlmICh0aGlzLmNsaWVudC51c2VyLl90eXBpbmcuaGFzKHRoaXMuaWQpKSByZXR1cm4gdGhpcy5jbGllbnQudXNlci5fdHlwaW5nLmdldCh0aGlzLmlkKS5jb3VudDtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTWVzc2FnZSBDb2xsZWN0b3IuXG4gICAqIEBwYXJhbSB7Q29sbGVjdG9yRmlsdGVyfSBmaWx0ZXIgVGhlIGZpbHRlciB0byBjcmVhdGUgdGhlIGNvbGxlY3RvciB3aXRoXG4gICAqIEBwYXJhbSB7TWVzc2FnZUNvbGxlY3Rvck9wdGlvbnN9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBjb2xsZWN0b3JcbiAgICogQHJldHVybnMge01lc3NhZ2VDb2xsZWN0b3J9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBhIG1lc3NhZ2UgY29sbGVjdG9yXG4gICAqIGNvbnN0IGZpbHRlciA9IG0gPT4gbS5jb250ZW50LmluY2x1ZGVzKCdkaXNjb3JkJyk7XG4gICAqIGNvbnN0IGNvbGxlY3RvciA9IGNoYW5uZWwuY3JlYXRlTWVzc2FnZUNvbGxlY3RvcihmaWx0ZXIsIHsgdGltZTogMTUwMDAgfSk7XG4gICAqIGNvbGxlY3Rvci5vbignY29sbGVjdCcsIG0gPT4gY29uc29sZS5sb2coYENvbGxlY3RlZCAke20uY29udGVudH1gKSk7XG4gICAqIGNvbGxlY3Rvci5vbignZW5kJywgY29sbGVjdGVkID0+IGNvbnNvbGUubG9nKGBDb2xsZWN0ZWQgJHtjb2xsZWN0ZWQuc2l6ZX0gaXRlbXNgKSk7XG4gICAqL1xuICBjcmVhdGVNZXNzYWdlQ29sbGVjdG9yKGZpbHRlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQ29sbGVjdG9yKHRoaXMsIGZpbHRlciwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBDb2xsZWN0b3JPcHRpb25zLCBidXQgYSBmZXcgbW9yZTpcbiAgICogQHR5cGVkZWYge01lc3NhZ2VDb2xsZWN0b3JPcHRpb25zfSBBd2FpdE1lc3NhZ2VzT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbZXJyb3JzXSBTdG9wL2VuZCByZWFzb25zIHRoYXQgY2F1c2UgdGhlIHByb21pc2UgdG8gcmVqZWN0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBTaW1pbGFyIHRvIGNyZWF0ZU1lc3NhZ2VDb2xsZWN0b3IgYnV0IGluIHByb21pc2UgZm9ybS5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGNvbGxlY3Rpb24gb2YgbWVzc2FnZXMgdGhhdCBwYXNzIHRoZSBzcGVjaWZpZWQgZmlsdGVyLlxuICAgKiBAcGFyYW0ge0NvbGxlY3RvckZpbHRlcn0gZmlsdGVyIFRoZSBmaWx0ZXIgZnVuY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7QXdhaXRNZXNzYWdlc09wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGludGVybmFsIGNvbGxlY3RvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uPFNub3dmbGFrZSwgTWVzc2FnZT4+fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBBd2FpdCAhdm90ZSBtZXNzYWdlc1xuICAgKiBjb25zdCBmaWx0ZXIgPSBtID0+IG0uY29udGVudC5zdGFydHNXaXRoKCchdm90ZScpO1xuICAgKiAvLyBFcnJvcnM6IFsndGltZSddIHRyZWF0cyBlbmRpbmcgYmVjYXVzZSBvZiB0aGUgdGltZSBsaW1pdCBhcyBhbiBlcnJvclxuICAgKiBjaGFubmVsLmF3YWl0TWVzc2FnZXMoZmlsdGVyLCB7IG1heDogNCwgdGltZTogNjAwMDAsIGVycm9yczogWyd0aW1lJ10gfSlcbiAgICogICAudGhlbihjb2xsZWN0ZWQgPT4gY29uc29sZS5sb2coY29sbGVjdGVkLnNpemUpKVxuICAgKiAgIC5jYXRjaChjb2xsZWN0ZWQgPT4gY29uc29sZS5sb2coYEFmdGVyIGEgbWludXRlLCBvbmx5ICR7Y29sbGVjdGVkLnNpemV9IG91dCBvZiA0IHZvdGVkLmApKTtcbiAgICovXG4gIGF3YWl0TWVzc2FnZXMoZmlsdGVyLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdG9yID0gdGhpcy5jcmVhdGVNZXNzYWdlQ29sbGVjdG9yKGZpbHRlciwgb3B0aW9ucyk7XG4gICAgICBjb2xsZWN0b3Iub25jZSgnZW5kJywgKGNvbGxlY3Rpb24sIHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuaW5jbHVkZXMocmVhc29uKSkge1xuICAgICAgICAgIHJlamVjdChjb2xsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWxrIGRlbGV0ZXMgZ2l2ZW4gbWVzc2FnZXMgdGhhdCBhcmUgbmV3ZXIgdGhhbiB0d28gd2Vla3MuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbjxTbm93Zmxha2UsIE1lc3NhZ2U+fE1lc3NhZ2VSZXNvbHZhYmxlW118bnVtYmVyfSBtZXNzYWdlc1xuICAgKiBNZXNzYWdlcyBvciBudW1iZXIgb2YgbWVzc2FnZXMgdG8gZGVsZXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZpbHRlck9sZD1mYWxzZV0gRmlsdGVyIG1lc3NhZ2VzIHRvIHJlbW92ZSB0aG9zZSB3aGljaCBhcmUgb2xkZXIgdGhhbiB0d28gd2Vla3MgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb2xsZWN0aW9uPFNub3dmbGFrZSwgTWVzc2FnZT4+fSBEZWxldGVkIG1lc3NhZ2VzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEJ1bGsgZGVsZXRlIG1lc3NhZ2VzXG4gICAqIGNoYW5uZWwuYnVsa0RlbGV0ZSg1KVxuICAgKiAgIC50aGVuKG1lc3NhZ2VzID0+IGNvbnNvbGUubG9nKGBCdWxrIGRlbGV0ZWQgJHttZXNzYWdlcy5zaXplfSBtZXNzYWdlc2ApKVxuICAgKiAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICovXG4gIGFzeW5jIGJ1bGtEZWxldGUobWVzc2FnZXMsIGZpbHRlck9sZCA9IGZhbHNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXMpIHx8IG1lc3NhZ2VzIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgbGV0IG1lc3NhZ2VJRHMgPSBtZXNzYWdlcyBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyBtZXNzYWdlcy5rZXlBcnJheSgpIDogbWVzc2FnZXMubWFwKG0gPT4gbS5pZCB8fCBtKTtcbiAgICAgIGlmIChmaWx0ZXJPbGQpIHtcbiAgICAgICAgbWVzc2FnZUlEcyA9IG1lc3NhZ2VJRHMuZmlsdGVyKGlkID0+IERhdGUubm93KCkgLSBTbm93Zmxha2UuZGVjb25zdHJ1Y3QoaWQpLmRhdGUuZ2V0VGltZSgpIDwgMTIwOTYwMDAwMCk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZUlEcy5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQ29sbGVjdGlvbigpO1xuICAgICAgaWYgKG1lc3NhZ2VJRHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmFwaS5jaGFubmVscyh0aGlzLmlkKS5tZXNzYWdlcyhtZXNzYWdlSURzWzBdKS5kZWxldGUoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuY2xpZW50LmFjdGlvbnMuTWVzc2FnZURlbGV0ZS5nZXRNZXNzYWdlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IG1lc3NhZ2VJRHNbMF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWVzc2FnZSA/IG5ldyBDb2xsZWN0aW9uKFtbbWVzc2FnZS5pZCwgbWVzc2FnZV1dKSA6IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5hcGkuY2hhbm5lbHNbdGhpcy5pZF0ubWVzc2FnZXNbJ2J1bGstZGVsZXRlJ10ucG9zdCh7IGRhdGE6IHsgbWVzc2FnZXM6IG1lc3NhZ2VJRHMgfSB9KTtcbiAgICAgIHJldHVybiBtZXNzYWdlSURzLnJlZHVjZShcbiAgICAgICAgKGNvbCwgaWQpID0+XG4gICAgICAgICAgY29sLnNldChcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuYWN0aW9ucy5NZXNzYWdlRGVsZXRlQnVsay5nZXRNZXNzYWdlKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICksXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uKCksXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKG1lc3NhZ2VzKSkge1xuICAgICAgY29uc3QgbXNncyA9IGF3YWl0IHRoaXMubWVzc2FnZXMuZmV0Y2goeyBsaW1pdDogbWVzc2FnZXMgfSk7XG4gICAgICByZXR1cm4gdGhpcy5idWxrRGVsZXRlKG1zZ3MsIGZpbHRlck9sZCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01FU1NBR0VfQlVMS19ERUxFVEVfVFlQRScpO1xuICB9XG5cbiAgc3RhdGljIGFwcGx5VG9DbGFzcyhzdHJ1Y3R1cmUsIGZ1bGwgPSBmYWxzZSwgaWdub3JlID0gW10pIHtcbiAgICBjb25zdCBwcm9wcyA9IFsnc2VuZCddO1xuICAgIGlmIChmdWxsKSB7XG4gICAgICBwcm9wcy5wdXNoKFxuICAgICAgICAnbGFzdE1lc3NhZ2UnLFxuICAgICAgICAnbGFzdFBpbkF0JyxcbiAgICAgICAgJ2J1bGtEZWxldGUnLFxuICAgICAgICAnc3RhcnRUeXBpbmcnLFxuICAgICAgICAnc3RvcFR5cGluZycsXG4gICAgICAgICd0eXBpbmcnLFxuICAgICAgICAndHlwaW5nQ291bnQnLFxuICAgICAgICAnY3JlYXRlTWVzc2FnZUNvbGxlY3RvcicsXG4gICAgICAgICdhd2FpdE1lc3NhZ2VzJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgaWYgKGlnbm9yZS5pbmNsdWRlcyhwcm9wKSkgY29udGludWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHN0cnVjdHVyZS5wcm90b3R5cGUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVGV4dEJhc2VkQ2hhbm5lbC5wcm90b3R5cGUsIHByb3ApLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0QmFzZWRDaGFubmVsO1xuXG4vLyBGaXhlcyBDaXJjdWxhclxuY29uc3QgTWVzc2FnZU1hbmFnZXIgPSByZXF1aXJlKCcuLi8uLi9tYW5hZ2Vycy9NZXNzYWdlTWFuYWdlcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCaXRGaWVsZCA9IHJlcXVpcmUoJy4vQml0RmllbGQnKTtcblxuLyoqXG4gKiBEYXRhIHN0cnVjdHVyZSB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gaW50ZXJhY3Qgd2l0aCBhbiB7QGxpbmsgQWN0aXZpdHkjZmxhZ3N9IGJpdGZpZWxkLlxuICogQGV4dGVuZHMge0JpdEZpZWxkfVxuICovXG5jbGFzcyBBY3Rpdml0eUZsYWdzIGV4dGVuZHMgQml0RmllbGQge31cblxuLyoqXG4gKiBAbmFtZSBBY3Rpdml0eUZsYWdzXG4gKiBAa2luZCBjb25zdHJ1Y3RvclxuICogQG1lbWJlcm9mIEFjdGl2aXR5RmxhZ3NcbiAqIEBwYXJhbSB7Qml0RmllbGRSZXNvbHZhYmxlfSBbYml0cz0wXSBCaXQocykgdG8gcmVhZCBmcm9tXG4gKi9cblxuLyoqXG4gKiBOdW1lcmljIGFjdGl2aXR5IGZsYWdzLiBBbGwgYXZhaWxhYmxlIHByb3BlcnRpZXM6XG4gKiAqIGBJTlNUQU5DRWBcbiAqICogYEpPSU5gXG4gKiAqIGBTUEVDVEFURWBcbiAqICogYEpPSU5fUkVRVUVTVGBcbiAqICogYFNZTkNgXG4gKiAqIGBQTEFZYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGlzY29yZC5jb20vZGV2ZWxvcGVycy9kb2NzL3RvcGljcy9nYXRld2F5I2FjdGl2aXR5LW9iamVjdC1hY3Rpdml0eS1mbGFnc31cbiAqL1xuQWN0aXZpdHlGbGFncy5GTEFHUyA9IHtcbiAgSU5TVEFOQ0U6IDEgPDwgMCxcbiAgSk9JTjogMSA8PCAxLFxuICBTUEVDVEFURTogMSA8PCAyLFxuICBKT0lOX1JFUVVFU1Q6IDEgPDwgMyxcbiAgU1lOQzogMSA8PCA0LFxuICBQTEFZOiAxIDw8IDUsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdGl2aXR5RmxhZ3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgUmFuZ2VFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbi8qKlxuICogRGF0YSBzdHJ1Y3R1cmUgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIGludGVyYWN0IHdpdGggYSBiaXRmaWVsZC5cbiAqL1xuY2xhc3MgQml0RmllbGQge1xuICAvKipcbiAgICogQHBhcmFtIHtCaXRGaWVsZFJlc29sdmFibGV9IFtiaXRzPTBdIEJpdChzKSB0byByZWFkIGZyb21cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJpdHMpIHtcbiAgICAvKipcbiAgICAgKiBCaXRmaWVsZCBvZiB0aGUgcGFja2VkIGJpdHNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYml0ZmllbGQgPSB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmUoYml0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJpdGZpZWxkIGhhcyBhIGJpdCwgb3IgYW55IG9mIG11bHRpcGxlIGJpdHMuXG4gICAqIEBwYXJhbSB7Qml0RmllbGRSZXNvbHZhYmxlfSBiaXQgQml0KHMpIHRvIGNoZWNrIGZvclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGFueShiaXQpIHtcbiAgICByZXR1cm4gKHRoaXMuYml0ZmllbGQgJiB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmUoYml0KSkgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgYml0ZmllbGQgZXF1YWxzIGFub3RoZXJcbiAgICogQHBhcmFtIHtCaXRGaWVsZFJlc29sdmFibGV9IGJpdCBCaXQocykgdG8gY2hlY2sgZm9yXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKGJpdCkge1xuICAgIHJldHVybiB0aGlzLmJpdGZpZWxkID09PSB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmUoYml0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgYml0ZmllbGQgaGFzIGEgYml0LCBvciBtdWx0aXBsZSBiaXRzLlxuICAgKiBAcGFyYW0ge0JpdEZpZWxkUmVzb2x2YWJsZX0gYml0IEJpdChzKSB0byBjaGVjayBmb3JcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXMoYml0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYml0KSkgcmV0dXJuIGJpdC5ldmVyeShwID0+IHRoaXMuaGFzKHApKTtcbiAgICBiaXQgPSB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmUoYml0KTtcbiAgICByZXR1cm4gKHRoaXMuYml0ZmllbGQgJiBiaXQpID09PSBiaXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgZ2l2ZW4gYml0cyB0aGF0IGFyZSBtaXNzaW5nIGZyb20gdGhlIGJpdGZpZWxkLlxuICAgKiBAcGFyYW0ge0JpdEZpZWxkUmVzb2x2YWJsZX0gYml0cyBCaXQocykgdG8gY2hlY2sgZm9yXG4gICAqIEBwYXJhbSB7Li4uKn0gaGFzUGFyYW1zIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGhhcyBtZXRob2QsIGlmIGFueVxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBtaXNzaW5nKGJpdHMsIC4uLmhhc1BhcmFtcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShiaXRzKSkgYml0cyA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGJpdHMpLnRvQXJyYXkoZmFsc2UpO1xuICAgIHJldHVybiBiaXRzLmZpbHRlcihwID0+ICF0aGlzLmhhcyhwLCAuLi5oYXNQYXJhbXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmVlemVzIHRoZXNlIGJpdHMsIG1ha2luZyB0aGVtIGltbXV0YWJsZS5cbiAgICogQHJldHVybnMge1JlYWRvbmx5PEJpdEZpZWxkPn0gVGhlc2UgYml0c1xuICAgKi9cbiAgZnJlZXplKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYml0cyB0byB0aGVzZSBvbmVzLlxuICAgKiBAcGFyYW0gey4uLkJpdEZpZWxkUmVzb2x2YWJsZX0gW2JpdHNdIEJpdHMgdG8gYWRkXG4gICAqIEByZXR1cm5zIHtCaXRGaWVsZH0gVGhlc2UgYml0cyBvciBuZXcgQml0RmllbGQgaWYgdGhlIGluc3RhbmNlIGlzIGZyb3plbi5cbiAgICovXG4gIGFkZCguLi5iaXRzKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IGJpdCBvZiBiaXRzKSB7XG4gICAgICB0b3RhbCB8PSB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmUoYml0KTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5pc0Zyb3plbih0aGlzKSkgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYml0ZmllbGQgfCB0b3RhbCk7XG4gICAgdGhpcy5iaXRmaWVsZCB8PSB0b3RhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGJpdHMgZnJvbSB0aGVzZS5cbiAgICogQHBhcmFtIHsuLi5CaXRGaWVsZFJlc29sdmFibGV9IFtiaXRzXSBCaXRzIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7Qml0RmllbGR9IFRoZXNlIGJpdHMgb3IgbmV3IEJpdEZpZWxkIGlmIHRoZSBpbnN0YW5jZSBpcyBmcm96ZW4uXG4gICAqL1xuICByZW1vdmUoLi4uYml0cykge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChjb25zdCBiaXQgb2YgYml0cykge1xuICAgICAgdG90YWwgfD0gdGhpcy5jb25zdHJ1Y3Rvci5yZXNvbHZlKGJpdCk7XG4gICAgfVxuICAgIGlmIChPYmplY3QuaXNGcm96ZW4odGhpcykpIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmJpdGZpZWxkICYgfnRvdGFsKTtcbiAgICB0aGlzLmJpdGZpZWxkICY9IH50b3RhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBtYXBwaW5nIGZpZWxkIG5hbWVzIHRvIGEge0BsaW5rIGJvb2xlYW59IGluZGljYXRpbmcgd2hldGhlciB0aGVcbiAgICogYml0IGlzIGF2YWlsYWJsZS5cbiAgICogQHBhcmFtIHsuLi4qfSBoYXNQYXJhbXMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgaGFzIG1ldGhvZCwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBzZXJpYWxpemUoLi4uaGFzUGFyYW1zKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2ZsYWcsIGJpdF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb25zdHJ1Y3Rvci5GTEFHUykpIHNlcmlhbGl6ZWRbZmxhZ10gPSB0aGlzLmhhcyhiaXQsIC4uLmhhc1BhcmFtcyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiB7QGxpbmsgQXJyYXl9IG9mIGJpdGZpZWxkIG5hbWVzIGJhc2VkIG9uIHRoZSBiaXRzIGF2YWlsYWJsZS5cbiAgICogQHBhcmFtIHsuLi4qfSBoYXNQYXJhbXMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgaGFzIG1ldGhvZCwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIHRvQXJyYXkoLi4uaGFzUGFyYW1zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IuRkxBR1MpLmZpbHRlcihiaXQgPT4gdGhpcy5oYXMoYml0LCAuLi5oYXNQYXJhbXMpKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5iaXRmaWVsZDtcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuYml0ZmllbGQ7XG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQqIHRoaXMudG9BcnJheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgdG8gZ2l2ZSBhIGJpdGZpZWxkLiBUaGlzIGNhbiBiZTpcbiAgICogKiBBIHN0cmluZyAoc2VlIHtAbGluayBCaXRGaWVsZC5GTEFHU30pXG4gICAqICogQSBiaXQgbnVtYmVyXG4gICAqICogQW4gaW5zdGFuY2Ugb2YgQml0RmllbGRcbiAgICogKiBBbiBBcnJheSBvZiBCaXRGaWVsZFJlc29sdmFibGVcbiAgICogQHR5cGVkZWYge3N0cmluZ3xudW1iZXJ8Qml0RmllbGR8Qml0RmllbGRSZXNvbHZhYmxlW119IEJpdEZpZWxkUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYml0ZmllbGRzIHRvIHRoZWlyIG51bWVyaWMgZm9ybS5cbiAgICogQHBhcmFtIHtCaXRGaWVsZFJlc29sdmFibGV9IFtiaXQ9MF0gLSBiaXQocykgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIHJlc29sdmUoYml0ID0gMCkge1xuICAgIGlmICh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCkgcmV0dXJuIGJpdDtcbiAgICBpZiAoYml0IGluc3RhbmNlb2YgQml0RmllbGQpIHJldHVybiBiaXQuYml0ZmllbGQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYml0KSkgcmV0dXJuIGJpdC5tYXAocCA9PiB0aGlzLnJlc29sdmUocCkpLnJlZHVjZSgocHJldiwgcCkgPT4gcHJldiB8IHAsIDApO1xuICAgIGlmICh0eXBlb2YgYml0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdGhpcy5GTEFHU1tiaXRdICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXMuRkxBR1NbYml0XTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBSYW5nZUVycm9yKCdCSVRGSUVMRF9JTlZBTElEJyk7XG4gICAgZXJyb3IuYml0ID0gYml0O1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogTnVtZXJpYyBiaXRmaWVsZCBmbGFncy5cbiAqIDxpbmZvPkRlZmluZWQgaW4gZXh0ZW5zaW9uIGNsYXNzZXM8L2luZm8+XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGFic3RyYWN0XG4gKi9cbkJpdEZpZWxkLkZMQUdTID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQml0RmllbGQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnQGRpc2NvcmRqcy9jb2xsZWN0aW9uJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi9VdGlsJyk7XG5cbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBCYXNlQ29sbGVjdGlvbiB7XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZSA9PiAodHlwZW9mIGUudG9KU09OID09PSAnZnVuY3Rpb24nID8gZS50b0pTT04oKSA6IFV0aWwuZmxhdHRlbihlKSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjtcblxuLyoqXG4gKiBAZXh0ZXJuYWwgQ29sbGVjdGlvblxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kaXNjb3JkLmpzLm9yZy8jL2RvY3MvY29sbGVjdGlvbi9tYXN0ZXIvY2xhc3MvQ29sbGVjdGlvbn1cbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBQYWNrYWdlID0gKGV4cG9ydHMuUGFja2FnZSA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpKTtcbmNvbnN0IHsgRXJyb3IsIFJhbmdlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgYnJvd3NlciA9IChleHBvcnRzLmJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyk7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBjbGllbnQuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDbGllbnRPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcnxudW1iZXJbXXxzdHJpbmd9IFtzaGFyZHNdIElEIG9mIHRoZSBzaGFyZCB0byBydW4sIG9yIGFuIGFycmF5IG9mIHNoYXJkIElEcy4gSWYgbm90IHNwZWNpZmllZCxcbiAqIHRoZSBjbGllbnQgd2lsbCBzcGF3biB7QGxpbmsgQ2xpZW50T3B0aW9ucyNzaGFyZENvdW50fSBzaGFyZHMuIElmIHNldCB0byBgYXV0b2AsIGl0IHdpbGwgZmV0Y2ggdGhlXG4gKiByZWNvbW1lbmRlZCBhbW91bnQgb2Ygc2hhcmRzIGZyb20gRGlzY29yZCBhbmQgc3Bhd24gdGhhdCBhbW91bnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2hhcmRDb3VudD0xXSBUaGUgdG90YWwgYW1vdW50IG9mIHNoYXJkcyB1c2VkIGJ5IGFsbCBwcm9jZXNzZXMgb2YgdGhpcyBib3RcbiAqIChlLmcuIHJlY29tbWVuZGVkIHNoYXJkIGNvdW50LCBzaGFyZCBjb3VudCBvZiB0aGUgU2hhcmRpbmdNYW5hZ2VyKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttZXNzYWdlQ2FjaGVNYXhTaXplPTIwMF0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gY2FjaGUgcGVyIGNoYW5uZWxcbiAqICgtMSBvciBJbmZpbml0eSBmb3IgdW5saW1pdGVkIC0gZG9uJ3QgZG8gdGhpcyB3aXRob3V0IG1lc3NhZ2Ugc3dlZXBpbmcsIG90aGVyd2lzZSBtZW1vcnkgdXNhZ2Ugd2lsbCBjbGltYlxuICogaW5kZWZpbml0ZWx5KVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttZXNzYWdlQ2FjaGVMaWZldGltZT0wXSBIb3cgbG9uZyBhIG1lc3NhZ2Ugc2hvdWxkIHN0YXkgaW4gdGhlIGNhY2hlIHVudGlsIGl0IGlzIGNvbnNpZGVyZWRcbiAqIHN3ZWVwYWJsZSAoaW4gc2Vjb25kcywgMCBmb3IgZm9yZXZlcilcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWVzc2FnZVN3ZWVwSW50ZXJ2YWw9MF0gSG93IGZyZXF1ZW50bHkgdG8gcmVtb3ZlIG1lc3NhZ2VzIGZyb20gdGhlIGNhY2hlIHRoYXQgYXJlIG9sZGVyIHRoYW5cbiAqIHRoZSBtZXNzYWdlIGNhY2hlIGxpZmV0aW1lIChpbiBzZWNvbmRzLCAwIGZvciBuZXZlcilcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWVzc2FnZUVkaXRIaXN0b3J5TWF4U2l6ZT0tMV0gTWF4aW11bSBudW1iZXIgb2YgcHJldmlvdXMgdmVyc2lvbnMgdG8gaG9sZCBmb3IgYW4gZWRpdGVkIG1lc3NhZ2VcbiAqICgtMSBvciBJbmZpbml0eSBmb3IgdW5saW1pdGVkIC0gZG9uJ3QgZG8gdGhpcyB3aXRob3V0IHN3ZWVwaW5nLCBvdGhlcndpc2UgbWVtb3J5IHVzYWdlIG1heSBjbGltYiBpbmRlZmluaXRlbHkuKVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZmV0Y2hBbGxNZW1iZXJzPWZhbHNlXSBXaGV0aGVyIHRvIGNhY2hlIGFsbCBndWlsZCBtZW1iZXJzIGFuZCB1c2VycyB1cG9uIHN0YXJ0dXAsIGFzIHdlbGwgYXNcbiAqIHVwb24gam9pbmluZyBhIGd1aWxkIChzaG91bGQgYmUgYXZvaWRlZCB3aGVuZXZlciBwb3NzaWJsZSlcbiAqIEBwcm9wZXJ0eSB7RGlzYWJsZU1lbnRpb25UeXBlfSBbZGlzYWJsZU1lbnRpb25zPSdub25lJ10gRGVmYXVsdCB2YWx1ZSBmb3Ige0BsaW5rIE1lc3NhZ2VPcHRpb25zI2Rpc2FibGVNZW50aW9uc31cbiAqIEBwcm9wZXJ0eSB7TWVzc2FnZU1lbnRpb25PcHRpb25zfSBbYWxsb3dlZE1lbnRpb25zXSBEZWZhdWx0IHZhbHVlIGZvciB7QGxpbmsgTWVzc2FnZU9wdGlvbnMjYWxsb3dlZE1lbnRpb25zfVxuICogQHByb3BlcnR5IHtQYXJ0aWFsVHlwZVtdfSBbcGFydGlhbHNdIFN0cnVjdHVyZXMgYWxsb3dlZCB0byBiZSBwYXJ0aWFsLiBUaGlzIG1lYW5zIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBldmVuIHdoZW5cbiAqIHRoZXkncmUgbWlzc2luZyBhbGwgdGhlIGRhdGEgZm9yIGEgcGFydGljdWxhciBzdHJ1Y3R1cmUuIFNlZSB0aGUgXCJQYXJ0aWFsc1wiIHRvcGljIGxpc3RlZCBpbiB0aGUgc2lkZWJhciBmb3Igc29tZVxuICogaW1wb3J0YW50IHVzYWdlIGluZm9ybWF0aW9uLCBhcyBwYXJ0aWFscyByZXF1aXJlIHlvdSB0byBwdXQgY2hlY2tzIGluIHBsYWNlIHdoZW4gaGFuZGxpbmcgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzdFdzQnJpZGdlVGltZW91dD01MDAwXSBNYXhpbXVtIHRpbWUgcGVybWl0dGVkIGJldHdlZW4gUkVTVCByZXNwb25zZXMgYW5kIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIHdlYnNvY2tldCBldmVudHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzdFRpbWVPZmZzZXQ9NTAwXSBFeHRyYSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBjb250aW51aW5nIHRvIG1ha2UgUkVTVFxuICogcmVxdWVzdHMgKGhpZ2hlciB2YWx1ZXMgd2lsbCByZWR1Y2UgcmF0ZS1saW1pdGluZyBlcnJvcnMgb24gYmFkIGNvbm5lY3Rpb25zKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXN0UmVxdWVzdFRpbWVvdXQ9MTUwMDBdIFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FuY2VsbGluZyBhIFJFU1QgcmVxdWVzdCwgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc3RTd2VlcEludGVydmFsPTYwXSBIb3cgZnJlcXVlbnRseSB0byBkZWxldGUgaW5hY3RpdmUgcmVxdWVzdCBidWNrZXRzLCBpbiBzZWNvbmRzXG4gKiAob3IgMCBmb3IgbmV2ZXIpXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JldHJ5TGltaXQ9MV0gSG93IG1hbnkgdGltZXMgdG8gcmV0cnkgb24gNVhYIGVycm9ycyAoSW5maW5pdHkgZm9yIGluZGVmaW5pdGUgYW1vdW50IG9mIHJldHJpZXMpXG4gKiBAcHJvcGVydHkge1ByZXNlbmNlRGF0YX0gW3ByZXNlbmNlXSBQcmVzZW5jZSBkYXRhIHRvIHVzZSB1cG9uIGxvZ2luXG4gKiBAcHJvcGVydHkge1dlYnNvY2tldE9wdGlvbnN9IFt3c10gT3B0aW9ucyBmb3IgdGhlIFdlYlNvY2tldFxuICogQHByb3BlcnR5IHtIVFRQT3B0aW9uc30gW2h0dHBdIEhUVFAgb3B0aW9uc1xuICovXG5leHBvcnRzLkRlZmF1bHRPcHRpb25zID0ge1xuICBzaGFyZENvdW50OiAxLFxuICBtZXNzYWdlQ2FjaGVNYXhTaXplOiAyMDAsXG4gIG1lc3NhZ2VDYWNoZUxpZmV0aW1lOiAwLFxuICBtZXNzYWdlU3dlZXBJbnRlcnZhbDogMCxcbiAgbWVzc2FnZUVkaXRIaXN0b3J5TWF4U2l6ZTogLTEsXG4gIGZldGNoQWxsTWVtYmVyczogZmFsc2UsXG4gIGRpc2FibGVNZW50aW9uczogJ25vbmUnLFxuICBwYXJ0aWFsczogW10sXG4gIHJlc3RXc0JyaWRnZVRpbWVvdXQ6IDUwMDAsXG4gIHJlc3RSZXF1ZXN0VGltZW91dDogMTUwMDAsXG4gIHJldHJ5TGltaXQ6IDEsXG4gIHJlc3RUaW1lT2Zmc2V0OiA1MDAsXG4gIHJlc3RTd2VlcEludGVydmFsOiA2MCxcbiAgcHJlc2VuY2U6IHt9LFxuXG4gIC8qKlxuICAgKiBXZWJTb2NrZXQgb3B0aW9ucyAodGhlc2UgYXJlIGxlZnQgYXMgc25ha2VfY2FzZSB0byBtYXRjaCB0aGUgQVBJKVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBXZWJzb2NrZXRPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGFyZ2VfdGhyZXNob2xkPTUwXSBOdW1iZXIgb2YgbWVtYmVycyBpbiBhIGd1aWxkIGFmdGVyIHdoaWNoIG9mZmxpbmUgdXNlcnMgd2lsbCBubyBsb25nZXIgYmVcbiAgICogc2VudCBpbiB0aGUgaW5pdGlhbCBndWlsZCBtZW1iZXIgbGlzdCwgbXVzdCBiZSBiZXR3ZWVuIDUwIGFuZCAyNTBcbiAgICogQHByb3BlcnR5IHtJbnRlbnRzUmVzb2x2YWJsZX0gW2ludGVudHNdIEludGVudHMgdG8gZW5hYmxlIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICovXG4gIHdzOiB7XG4gICAgbGFyZ2VfdGhyZXNob2xkOiA1MCxcbiAgICBjb21wcmVzczogZmFsc2UsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgJG9zOiBicm93c2VyID8gJ2Jyb3dzZXInIDogcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgICAgICRicm93c2VyOiAnZGlzY29yZC5qcycsXG4gICAgICAkZGV2aWNlOiAnZGlzY29yZC5qcycsXG4gICAgfSxcbiAgICB2ZXJzaW9uOiA2LFxuICB9LFxuXG4gIC8qKlxuICAgKiBIVFRQIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge09iamVjdH0gSFRUUE9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2ZXJzaW9uPTddIEFQSSB2ZXJzaW9uIHRvIHVzZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FwaT0naHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGknXSBCYXNlIHVybCBvZiB0aGUgQVBJXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2RuPSdodHRwczovL2Nkbi5kaXNjb3JkYXBwLmNvbSddIEJhc2UgdXJsIG9mIHRoZSBDRE5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpbnZpdGU9J2h0dHBzOi8vZGlzY29yZC5nZyddIEJhc2UgdXJsIG9mIGludml0ZXNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZW1wbGF0ZT0naHR0cHM6Ly9kaXNjb3JkLm5ldyddIEJhc2UgdXJsIG9mIHRlbXBsYXRlc1xuICAgKi9cbiAgaHR0cDoge1xuICAgIHZlcnNpb246IDcsXG4gICAgYXBpOiAnaHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGknLFxuICAgIGNkbjogJ2h0dHBzOi8vY2RuLmRpc2NvcmRhcHAuY29tJyxcbiAgICBpbnZpdGU6ICdodHRwczovL2Rpc2NvcmQuZ2cnLFxuICAgIHRlbXBsYXRlOiAnaHR0cHM6Ly9kaXNjb3JkLm5ldycsXG4gIH0sXG59O1xuXG5leHBvcnRzLlVzZXJBZ2VudCA9IGJyb3dzZXJcbiAgPyBudWxsXG4gIDogYERpc2NvcmRCb3QgKCR7UGFja2FnZS5ob21lcGFnZS5zcGxpdCgnIycpWzBdfSwgJHtQYWNrYWdlLnZlcnNpb259KSBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9ufWA7XG5cbmV4cG9ydHMuV1NDb2RlcyA9IHtcbiAgMTAwMDogJ1dTX0NMT1NFX1JFUVVFU1RFRCcsXG4gIDQwMDQ6ICdUT0tFTl9JTlZBTElEJyxcbiAgNDAxMDogJ1NIQVJESU5HX0lOVkFMSUQnLFxuICA0MDExOiAnU0hBUkRJTkdfUkVRVUlSRUQnLFxuICA0MDEzOiAnSU5WQUxJRF9JTlRFTlRTJyxcbiAgNDAxNDogJ0RJU0FMTE9XRURfSU5URU5UUycsXG59O1xuXG5jb25zdCBBbGxvd2VkSW1hZ2VGb3JtYXRzID0gWyd3ZWJwJywgJ3BuZycsICdqcGcnLCAnanBlZycsICdnaWYnXTtcblxuY29uc3QgQWxsb3dlZEltYWdlU2l6ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA5IH0sIChlLCBpKSA9PiAyICoqIChpICsgNCkpO1xuXG5mdW5jdGlvbiBtYWtlSW1hZ2VVcmwocm9vdCwgeyBmb3JtYXQgPSAnd2VicCcsIHNpemUgfSA9IHt9KSB7XG4gIGlmIChmb3JtYXQgJiYgIUFsbG93ZWRJbWFnZUZvcm1hdHMuaW5jbHVkZXMoZm9ybWF0KSkgdGhyb3cgbmV3IEVycm9yKCdJTUFHRV9GT1JNQVQnLCBmb3JtYXQpO1xuICBpZiAoc2l6ZSAmJiAhQWxsb3dlZEltYWdlU2l6ZXMuaW5jbHVkZXMoc2l6ZSkpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJTUFHRV9TSVpFJywgc2l6ZSk7XG4gIHJldHVybiBgJHtyb290fS4ke2Zvcm1hdH0ke3NpemUgPyBgP3NpemU9JHtzaXplfWAgOiAnJ31gO1xufVxuLyoqXG4gKiBPcHRpb25zIGZvciBJbWFnZSBVUkxzLlxuICogQHR5cGVkZWYge09iamVjdH0gSW1hZ2VVUkxPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Zvcm1hdF0gT25lIG9mIGB3ZWJwYCwgYHBuZ2AsIGBqcGdgLCBganBlZ2AsIGBnaWZgLiBJZiBubyBmb3JtYXQgaXMgcHJvdmlkZWQsXG4gKiBkZWZhdWx0cyB0byBgd2VicGAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkeW5hbWljXSBJZiB0cnVlLCB0aGUgZm9ybWF0IHdpbGwgZHluYW1pY2FsbHkgY2hhbmdlIHRvIGBnaWZgIGZvclxuICogYW5pbWF0ZWQgYXZhdGFyczsgdGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdIE9uZSBvZiBgMTZgLCBgMzJgLCBgNjRgLCBgMTI4YCwgYDI1NmAsIGA1MTJgLCBgMTAyNGAsIGAyMDQ4YCwgYDQwOTZgXG4gKi9cblxuZXhwb3J0cy5FbmRwb2ludHMgPSB7XG4gIENETihyb290KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVtb2ppOiAoZW1vamlJRCwgZm9ybWF0ID0gJ3BuZycpID0+IGAke3Jvb3R9L2Vtb2ppcy8ke2Vtb2ppSUR9LiR7Zm9ybWF0fWAsXG4gICAgICBBc3NldDogbmFtZSA9PiBgJHtyb290fS9hc3NldHMvJHtuYW1lfWAsXG4gICAgICBEZWZhdWx0QXZhdGFyOiBkaXNjcmltaW5hdG9yID0+IGAke3Jvb3R9L2VtYmVkL2F2YXRhcnMvJHtkaXNjcmltaW5hdG9yfS5wbmdgLFxuICAgICAgQXZhdGFyOiAodXNlcklELCBoYXNoLCBmb3JtYXQgPSAnd2VicCcsIHNpemUsIGR5bmFtaWMgPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAoZHluYW1pYykgZm9ybWF0ID0gaGFzaC5zdGFydHNXaXRoKCdhXycpID8gJ2dpZicgOiBmb3JtYXQ7XG4gICAgICAgIHJldHVybiBtYWtlSW1hZ2VVcmwoYCR7cm9vdH0vYXZhdGFycy8ke3VzZXJJRH0vJHtoYXNofWAsIHsgZm9ybWF0LCBzaXplIH0pO1xuICAgICAgfSxcbiAgICAgIEJhbm5lcjogKGd1aWxkSUQsIGhhc2gsIGZvcm1hdCA9ICd3ZWJwJywgc2l6ZSkgPT5cbiAgICAgICAgbWFrZUltYWdlVXJsKGAke3Jvb3R9L2Jhbm5lcnMvJHtndWlsZElEfS8ke2hhc2h9YCwgeyBmb3JtYXQsIHNpemUgfSksXG4gICAgICBJY29uOiAoZ3VpbGRJRCwgaGFzaCwgZm9ybWF0ID0gJ3dlYnAnLCBzaXplLCBkeW5hbWljID0gZmFsc2UpID0+IHtcbiAgICAgICAgaWYgKGR5bmFtaWMpIGZvcm1hdCA9IGhhc2guc3RhcnRzV2l0aCgnYV8nKSA/ICdnaWYnIDogZm9ybWF0O1xuICAgICAgICByZXR1cm4gbWFrZUltYWdlVXJsKGAke3Jvb3R9L2ljb25zLyR7Z3VpbGRJRH0vJHtoYXNofWAsIHsgZm9ybWF0LCBzaXplIH0pO1xuICAgICAgfSxcbiAgICAgIEFwcEljb246IChjbGllbnRJRCwgaGFzaCwgeyBmb3JtYXQgPSAnd2VicCcsIHNpemUgfSA9IHt9KSA9PlxuICAgICAgICBtYWtlSW1hZ2VVcmwoYCR7cm9vdH0vYXBwLWljb25zLyR7Y2xpZW50SUR9LyR7aGFzaH1gLCB7IHNpemUsIGZvcm1hdCB9KSxcbiAgICAgIEFwcEFzc2V0OiAoY2xpZW50SUQsIGhhc2gsIHsgZm9ybWF0ID0gJ3dlYnAnLCBzaXplIH0gPSB7fSkgPT5cbiAgICAgICAgbWFrZUltYWdlVXJsKGAke3Jvb3R9L2FwcC1hc3NldHMvJHtjbGllbnRJRH0vJHtoYXNofWAsIHsgc2l6ZSwgZm9ybWF0IH0pLFxuICAgICAgR0RNSWNvbjogKGNoYW5uZWxJRCwgaGFzaCwgZm9ybWF0ID0gJ3dlYnAnLCBzaXplKSA9PlxuICAgICAgICBtYWtlSW1hZ2VVcmwoYCR7cm9vdH0vY2hhbm5lbC1pY29ucy8ke2NoYW5uZWxJRH0vJHtoYXNofWAsIHsgc2l6ZSwgZm9ybWF0IH0pLFxuICAgICAgU3BsYXNoOiAoZ3VpbGRJRCwgaGFzaCwgZm9ybWF0ID0gJ3dlYnAnLCBzaXplKSA9PlxuICAgICAgICBtYWtlSW1hZ2VVcmwoYCR7cm9vdH0vc3BsYXNoZXMvJHtndWlsZElEfS8ke2hhc2h9YCwgeyBzaXplLCBmb3JtYXQgfSksXG4gICAgICBEaXNjb3ZlcnlTcGxhc2g6IChndWlsZElELCBoYXNoLCBmb3JtYXQgPSAnd2VicCcsIHNpemUpID0+XG4gICAgICAgIG1ha2VJbWFnZVVybChgJHtyb290fS9kaXNjb3Zlcnktc3BsYXNoZXMvJHtndWlsZElEfS8ke2hhc2h9YCwgeyBzaXplLCBmb3JtYXQgfSksXG4gICAgICBUZWFtSWNvbjogKHRlYW1JRCwgaGFzaCwgeyBmb3JtYXQgPSAnd2VicCcsIHNpemUgfSA9IHt9KSA9PlxuICAgICAgICBtYWtlSW1hZ2VVcmwoYCR7cm9vdH0vdGVhbS1pY29ucy8ke3RlYW1JRH0vJHtoYXNofWAsIHsgc2l6ZSwgZm9ybWF0IH0pLFxuICAgIH07XG4gIH0sXG4gIGludml0ZTogKHJvb3QsIGNvZGUpID0+IGAke3Jvb3R9LyR7Y29kZX1gLFxuICBib3RHYXRld2F5OiAnL2dhdGV3YXkvYm90Jyxcbn07XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBjbGllbnQuIEhlcmUgYXJlIHRoZSBhdmFpbGFibGUgc3RhdHVzZXM6XG4gKiAqIFJFQURZOiAwXG4gKiAqIENPTk5FQ1RJTkc6IDFcbiAqICogUkVDT05ORUNUSU5HOiAyXG4gKiAqIElETEU6IDNcbiAqICogTkVBUkxZOiA0XG4gKiAqIERJU0NPTk5FQ1RFRDogNVxuICogKiBXQUlUSU5HX0ZPUl9HVUlMRFM6IDZcbiAqICogSURFTlRJRllJTkc6IDdcbiAqICogUkVTVU1JTkc6IDhcbiAqIEB0eXBlZGVmIHtudW1iZXJ9IFN0YXR1c1xuICovXG5leHBvcnRzLlN0YXR1cyA9IHtcbiAgUkVBRFk6IDAsXG4gIENPTk5FQ1RJTkc6IDEsXG4gIFJFQ09OTkVDVElORzogMixcbiAgSURMRTogMyxcbiAgTkVBUkxZOiA0LFxuICBESVNDT05ORUNURUQ6IDUsXG4gIFdBSVRJTkdfRk9SX0dVSUxEUzogNixcbiAgSURFTlRJRllJTkc6IDcsXG4gIFJFU1VNSU5HOiA4LFxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgYSB2b2ljZSBjb25uZWN0aW9uLiBIZXJlIGFyZSB0aGUgYXZhaWxhYmxlIHN0YXR1c2VzOlxuICogKiBDT05ORUNURUQ6IDBcbiAqICogQ09OTkVDVElORzogMVxuICogKiBBVVRIRU5USUNBVElORzogMlxuICogKiBSRUNPTk5FQ1RJTkc6IDNcbiAqICogRElTQ09OTkVDVEVEOiA0XG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBWb2ljZVN0YXR1c1xuICovXG5leHBvcnRzLlZvaWNlU3RhdHVzID0ge1xuICBDT05ORUNURUQ6IDAsXG4gIENPTk5FQ1RJTkc6IDEsXG4gIEFVVEhFTlRJQ0FUSU5HOiAyLFxuICBSRUNPTk5FQ1RJTkc6IDMsXG4gIERJU0NPTk5FQ1RFRDogNCxcbn07XG5cbmV4cG9ydHMuT1BDb2RlcyA9IHtcbiAgRElTUEFUQ0g6IDAsXG4gIEhFQVJUQkVBVDogMSxcbiAgSURFTlRJRlk6IDIsXG4gIFNUQVRVU19VUERBVEU6IDMsXG4gIFZPSUNFX1NUQVRFX1VQREFURTogNCxcbiAgVk9JQ0VfR1VJTERfUElORzogNSxcbiAgUkVTVU1FOiA2LFxuICBSRUNPTk5FQ1Q6IDcsXG4gIFJFUVVFU1RfR1VJTERfTUVNQkVSUzogOCxcbiAgSU5WQUxJRF9TRVNTSU9OOiA5LFxuICBIRUxMTzogMTAsXG4gIEhFQVJUQkVBVF9BQ0s6IDExLFxufTtcblxuZXhwb3J0cy5Wb2ljZU9QQ29kZXMgPSB7XG4gIElERU5USUZZOiAwLFxuICBTRUxFQ1RfUFJPVE9DT0w6IDEsXG4gIFJFQURZOiAyLFxuICBIRUFSVEJFQVQ6IDMsXG4gIFNFU1NJT05fREVTQ1JJUFRJT046IDQsXG4gIFNQRUFLSU5HOiA1LFxuICBIRUxMTzogOCxcbiAgQ0xJRU5UX0NPTk5FQ1Q6IDEyLFxuICBDTElFTlRfRElTQ09OTkVDVDogMTMsXG59O1xuXG5leHBvcnRzLkV2ZW50cyA9IHtcbiAgUkFURV9MSU1JVDogJ3JhdGVMaW1pdCcsXG4gIENMSUVOVF9SRUFEWTogJ3JlYWR5JyxcbiAgR1VJTERfQ1JFQVRFOiAnZ3VpbGRDcmVhdGUnLFxuICBHVUlMRF9ERUxFVEU6ICdndWlsZERlbGV0ZScsXG4gIEdVSUxEX1VQREFURTogJ2d1aWxkVXBkYXRlJyxcbiAgR1VJTERfVU5BVkFJTEFCTEU6ICdndWlsZFVuYXZhaWxhYmxlJyxcbiAgR1VJTERfQVZBSUxBQkxFOiAnZ3VpbGRBdmFpbGFibGUnLFxuICBHVUlMRF9NRU1CRVJfQUREOiAnZ3VpbGRNZW1iZXJBZGQnLFxuICBHVUlMRF9NRU1CRVJfUkVNT1ZFOiAnZ3VpbGRNZW1iZXJSZW1vdmUnLFxuICBHVUlMRF9NRU1CRVJfVVBEQVRFOiAnZ3VpbGRNZW1iZXJVcGRhdGUnLFxuICBHVUlMRF9NRU1CRVJfQVZBSUxBQkxFOiAnZ3VpbGRNZW1iZXJBdmFpbGFibGUnLFxuICBHVUlMRF9NRU1CRVJfU1BFQUtJTkc6ICdndWlsZE1lbWJlclNwZWFraW5nJyxcbiAgR1VJTERfTUVNQkVSU19DSFVOSzogJ2d1aWxkTWVtYmVyc0NodW5rJyxcbiAgR1VJTERfSU5URUdSQVRJT05TX1VQREFURTogJ2d1aWxkSW50ZWdyYXRpb25zVXBkYXRlJyxcbiAgR1VJTERfUk9MRV9DUkVBVEU6ICdyb2xlQ3JlYXRlJyxcbiAgR1VJTERfUk9MRV9ERUxFVEU6ICdyb2xlRGVsZXRlJyxcbiAgSU5WSVRFX0NSRUFURTogJ2ludml0ZUNyZWF0ZScsXG4gIElOVklURV9ERUxFVEU6ICdpbnZpdGVEZWxldGUnLFxuICBHVUlMRF9ST0xFX1VQREFURTogJ3JvbGVVcGRhdGUnLFxuICBHVUlMRF9FTU9KSV9DUkVBVEU6ICdlbW9qaUNyZWF0ZScsXG4gIEdVSUxEX0VNT0pJX0RFTEVURTogJ2Vtb2ppRGVsZXRlJyxcbiAgR1VJTERfRU1PSklfVVBEQVRFOiAnZW1vamlVcGRhdGUnLFxuICBHVUlMRF9CQU5fQUREOiAnZ3VpbGRCYW5BZGQnLFxuICBHVUlMRF9CQU5fUkVNT1ZFOiAnZ3VpbGRCYW5SZW1vdmUnLFxuICBDSEFOTkVMX0NSRUFURTogJ2NoYW5uZWxDcmVhdGUnLFxuICBDSEFOTkVMX0RFTEVURTogJ2NoYW5uZWxEZWxldGUnLFxuICBDSEFOTkVMX1VQREFURTogJ2NoYW5uZWxVcGRhdGUnLFxuICBDSEFOTkVMX1BJTlNfVVBEQVRFOiAnY2hhbm5lbFBpbnNVcGRhdGUnLFxuICBNRVNTQUdFX0NSRUFURTogJ21lc3NhZ2UnLFxuICBNRVNTQUdFX0RFTEVURTogJ21lc3NhZ2VEZWxldGUnLFxuICBNRVNTQUdFX1VQREFURTogJ21lc3NhZ2VVcGRhdGUnLFxuICBNRVNTQUdFX0JVTEtfREVMRVRFOiAnbWVzc2FnZURlbGV0ZUJ1bGsnLFxuICBNRVNTQUdFX1JFQUNUSU9OX0FERDogJ21lc3NhZ2VSZWFjdGlvbkFkZCcsXG4gIE1FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFOiAnbWVzc2FnZVJlYWN0aW9uUmVtb3ZlJyxcbiAgTUVTU0FHRV9SRUFDVElPTl9SRU1PVkVfQUxMOiAnbWVzc2FnZVJlYWN0aW9uUmVtb3ZlQWxsJyxcbiAgTUVTU0FHRV9SRUFDVElPTl9SRU1PVkVfRU1PSkk6ICdtZXNzYWdlUmVhY3Rpb25SZW1vdmVFbW9qaScsXG4gIFVTRVJfVVBEQVRFOiAndXNlclVwZGF0ZScsXG4gIFBSRVNFTkNFX1VQREFURTogJ3ByZXNlbmNlVXBkYXRlJyxcbiAgVk9JQ0VfU0VSVkVSX1VQREFURTogJ3ZvaWNlU2VydmVyVXBkYXRlJyxcbiAgVk9JQ0VfU1RBVEVfVVBEQVRFOiAndm9pY2VTdGF0ZVVwZGF0ZScsXG4gIFZPSUNFX0JST0FEQ0FTVF9TVUJTQ1JJQkU6ICdzdWJzY3JpYmUnLFxuICBWT0lDRV9CUk9BRENBU1RfVU5TVUJTQ1JJQkU6ICd1bnN1YnNjcmliZScsXG4gIFRZUElOR19TVEFSVDogJ3R5cGluZ1N0YXJ0JyxcbiAgVFlQSU5HX1NUT1A6ICd0eXBpbmdTdG9wJyxcbiAgV0VCSE9PS1NfVVBEQVRFOiAnd2ViaG9va1VwZGF0ZScsXG4gIEVSUk9SOiAnZXJyb3InLFxuICBXQVJOOiAnd2FybicsXG4gIERFQlVHOiAnZGVidWcnLFxuICBTSEFSRF9ESVNDT05ORUNUOiAnc2hhcmREaXNjb25uZWN0JyxcbiAgU0hBUkRfRVJST1I6ICdzaGFyZEVycm9yJyxcbiAgU0hBUkRfUkVDT05ORUNUSU5HOiAnc2hhcmRSZWNvbm5lY3RpbmcnLFxuICBTSEFSRF9SRUFEWTogJ3NoYXJkUmVhZHknLFxuICBTSEFSRF9SRVNVTUU6ICdzaGFyZFJlc3VtZScsXG4gIElOVkFMSURBVEVEOiAnaW52YWxpZGF0ZWQnLFxuICBSQVc6ICdyYXcnLFxufTtcblxuZXhwb3J0cy5TaGFyZEV2ZW50cyA9IHtcbiAgQ0xPU0U6ICdjbG9zZScsXG4gIERFU1RST1lFRDogJ2Rlc3Ryb3llZCcsXG4gIElOVkFMSURfU0VTU0lPTjogJ2ludmFsaWRTZXNzaW9uJyxcbiAgUkVBRFk6ICdyZWFkeScsXG4gIFJFU1VNRUQ6ICdyZXN1bWVkJyxcbiAgQUxMX1JFQURZOiAnYWxsUmVhZHknLFxufTtcblxuLyoqXG4gKiBUaGUgdHlwZSBvZiBTdHJ1Y3R1cmUgYWxsb3dlZCB0byBiZSBhIHBhcnRpYWw6XG4gKiAqIFVTRVJcbiAqICogQ0hBTk5FTCAob25seSBhZmZlY3RzIERNQ2hhbm5lbHMpXG4gKiAqIEdVSUxEX01FTUJFUlxuICogKiBNRVNTQUdFXG4gKiAqIFJFQUNUSU9OXG4gKiA8d2Fybj5QYXJ0aWFscyByZXF1aXJlIHlvdSB0byBwdXQgY2hlY2tzIGluIHBsYWNlIHdoZW4gaGFuZGxpbmcgZGF0YSwgcmVhZCB0aGUgUGFydGlhbHMgdG9waWMgbGlzdGVkIGluIHRoZVxuICogc2lkZWJhciBmb3IgbW9yZSBpbmZvcm1hdGlvbi48L3dhcm4+XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBQYXJ0aWFsVHlwZVxuICovXG5leHBvcnRzLlBhcnRpYWxUeXBlcyA9IGtleU1pcnJvcihbJ1VTRVInLCAnQ0hBTk5FTCcsICdHVUlMRF9NRU1CRVInLCAnTUVTU0FHRScsICdSRUFDVElPTiddKTtcblxuLyoqXG4gKiBUaGUgdHlwZSBvZiBhIHdlYnNvY2tldCBtZXNzYWdlIGV2ZW50LCBlLmcuIGBNRVNTQUdFX0NSRUFURWAuIEhlcmUgYXJlIHRoZSBhdmFpbGFibGUgZXZlbnRzOlxuICogKiBSRUFEWVxuICogKiBSRVNVTUVEXG4gKiAqIEdVSUxEX0NSRUFURVxuICogKiBHVUlMRF9ERUxFVEVcbiAqICogR1VJTERfVVBEQVRFXG4gKiAqIElOVklURV9DUkVBVEVcbiAqICogSU5WSVRFX0RFTEVURVxuICogKiBHVUlMRF9NRU1CRVJfQUREXG4gKiAqIEdVSUxEX01FTUJFUl9SRU1PVkVcbiAqICogR1VJTERfTUVNQkVSX1VQREFURVxuICogKiBHVUlMRF9NRU1CRVJTX0NIVU5LXG4gKiAqIEdVSUxEX0lOVEVHUkFUSU9OU19VUERBVEVcbiAqICogR1VJTERfUk9MRV9DUkVBVEVcbiAqICogR1VJTERfUk9MRV9ERUxFVEVcbiAqICogR1VJTERfUk9MRV9VUERBVEVcbiAqICogR1VJTERfQkFOX0FERFxuICogKiBHVUlMRF9CQU5fUkVNT1ZFXG4gKiAqIEdVSUxEX0VNT0pJU19VUERBVEVcbiAqICogQ0hBTk5FTF9DUkVBVEVcbiAqICogQ0hBTk5FTF9ERUxFVEVcbiAqICogQ0hBTk5FTF9VUERBVEVcbiAqICogQ0hBTk5FTF9QSU5TX1VQREFURVxuICogKiBNRVNTQUdFX0NSRUFURVxuICogKiBNRVNTQUdFX0RFTEVURVxuICogKiBNRVNTQUdFX1VQREFURVxuICogKiBNRVNTQUdFX0RFTEVURV9CVUxLXG4gKiAqIE1FU1NBR0VfUkVBQ1RJT05fQUREXG4gKiAqIE1FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFXG4gKiAqIE1FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFX0FMTFxuICogKiBNRVNTQUdFX1JFQUNUSU9OX1JFTU9WRV9FTU9KSVxuICogKiBVU0VSX1VQREFURVxuICogKiBQUkVTRU5DRV9VUERBVEVcbiAqICogVFlQSU5HX1NUQVJUXG4gKiAqIFZPSUNFX1NUQVRFX1VQREFURVxuICogKiBWT0lDRV9TRVJWRVJfVVBEQVRFXG4gKiAqIFdFQkhPT0tTX1VQREFURVxuICogQHR5cGVkZWYge3N0cmluZ30gV1NFdmVudFR5cGVcbiAqL1xuZXhwb3J0cy5XU0V2ZW50cyA9IGtleU1pcnJvcihbXG4gICdSRUFEWScsXG4gICdSRVNVTUVEJyxcbiAgJ0dVSUxEX0NSRUFURScsXG4gICdHVUlMRF9ERUxFVEUnLFxuICAnR1VJTERfVVBEQVRFJyxcbiAgJ0lOVklURV9DUkVBVEUnLFxuICAnSU5WSVRFX0RFTEVURScsXG4gICdHVUlMRF9NRU1CRVJfQUREJyxcbiAgJ0dVSUxEX01FTUJFUl9SRU1PVkUnLFxuICAnR1VJTERfTUVNQkVSX1VQREFURScsXG4gICdHVUlMRF9NRU1CRVJTX0NIVU5LJyxcbiAgJ0dVSUxEX0lOVEVHUkFUSU9OU19VUERBVEUnLFxuICAnR1VJTERfUk9MRV9DUkVBVEUnLFxuICAnR1VJTERfUk9MRV9ERUxFVEUnLFxuICAnR1VJTERfUk9MRV9VUERBVEUnLFxuICAnR1VJTERfQkFOX0FERCcsXG4gICdHVUlMRF9CQU5fUkVNT1ZFJyxcbiAgJ0dVSUxEX0VNT0pJU19VUERBVEUnLFxuICAnQ0hBTk5FTF9DUkVBVEUnLFxuICAnQ0hBTk5FTF9ERUxFVEUnLFxuICAnQ0hBTk5FTF9VUERBVEUnLFxuICAnQ0hBTk5FTF9QSU5TX1VQREFURScsXG4gICdNRVNTQUdFX0NSRUFURScsXG4gICdNRVNTQUdFX0RFTEVURScsXG4gICdNRVNTQUdFX1VQREFURScsXG4gICdNRVNTQUdFX0RFTEVURV9CVUxLJyxcbiAgJ01FU1NBR0VfUkVBQ1RJT05fQUREJyxcbiAgJ01FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFJyxcbiAgJ01FU1NBR0VfUkVBQ1RJT05fUkVNT1ZFX0FMTCcsXG4gICdNRVNTQUdFX1JFQUNUSU9OX1JFTU9WRV9FTU9KSScsXG4gICdVU0VSX1VQREFURScsXG4gICdQUkVTRU5DRV9VUERBVEUnLFxuICAnVFlQSU5HX1NUQVJUJyxcbiAgJ1ZPSUNFX1NUQVRFX1VQREFURScsXG4gICdWT0lDRV9TRVJWRVJfVVBEQVRFJyxcbiAgJ1dFQkhPT0tTX1VQREFURScsXG5dKTtcblxuLyoqXG4gKiBUaGUgdHlwZSBvZiBhIG1lc3NhZ2UsIGUuZy4gYERFRkFVTFRgLiBIZXJlIGFyZSB0aGUgYXZhaWxhYmxlIHR5cGVzOlxuICogKiBERUZBVUxUXG4gKiAqIFJFQ0lQSUVOVF9BRERcbiAqICogUkVDSVBJRU5UX1JFTU9WRVxuICogKiBDQUxMXG4gKiAqIENIQU5ORUxfTkFNRV9DSEFOR0VcbiAqICogQ0hBTk5FTF9JQ09OX0NIQU5HRVxuICogKiBQSU5TX0FERFxuICogKiBHVUlMRF9NRU1CRVJfSk9JTlxuICogKiBVU0VSX1BSRU1JVU1fR1VJTERfU1VCU0NSSVBUSU9OXG4gKiAqIFVTRVJfUFJFTUlVTV9HVUlMRF9TVUJTQ1JJUFRJT05fVElFUl8xXG4gKiAqIFVTRVJfUFJFTUlVTV9HVUlMRF9TVUJTQ1JJUFRJT05fVElFUl8yXG4gKiAqIFVTRVJfUFJFTUlVTV9HVUlMRF9TVUJTQ1JJUFRJT05fVElFUl8zXG4gKiAqIENIQU5ORUxfRk9MTE9XX0FERFxuICogKiBHVUlMRF9ESVNDT1ZFUllfRElTUVVBTElGSUVEXG4gKiAqIEdVSUxEX0RJU0NPVkVSWV9SRVFVQUxJRklFRFxuICogQHR5cGVkZWYge3N0cmluZ30gTWVzc2FnZVR5cGVcbiAqL1xuZXhwb3J0cy5NZXNzYWdlVHlwZXMgPSBbXG4gICdERUZBVUxUJyxcbiAgJ1JFQ0lQSUVOVF9BREQnLFxuICAnUkVDSVBJRU5UX1JFTU9WRScsXG4gICdDQUxMJyxcbiAgJ0NIQU5ORUxfTkFNRV9DSEFOR0UnLFxuICAnQ0hBTk5FTF9JQ09OX0NIQU5HRScsXG4gICdQSU5TX0FERCcsXG4gICdHVUlMRF9NRU1CRVJfSk9JTicsXG4gICdVU0VSX1BSRU1JVU1fR1VJTERfU1VCU0NSSVBUSU9OJyxcbiAgJ1VTRVJfUFJFTUlVTV9HVUlMRF9TVUJTQ1JJUFRJT05fVElFUl8xJyxcbiAgJ1VTRVJfUFJFTUlVTV9HVUlMRF9TVUJTQ1JJUFRJT05fVElFUl8yJyxcbiAgJ1VTRVJfUFJFTUlVTV9HVUlMRF9TVUJTQ1JJUFRJT05fVElFUl8zJyxcbiAgJ0NIQU5ORUxfRk9MTE9XX0FERCcsXG4gIG51bGwsXG4gICdHVUlMRF9ESVNDT1ZFUllfRElTUVVBTElGSUVEJyxcbiAgJ0dVSUxEX0RJU0NPVkVSWV9SRVFVQUxJRklFRCcsXG5dO1xuXG4vKipcbiAqIDxpbmZvPkJvdHMgY2Fubm90IHNldCBhIGBDVVNUT01fU1RBVFVTYCwgaXQgaXMgb25seSBmb3IgY3VzdG9tIHN0YXR1c2VzIHJlY2VpdmVkIGZyb20gdXNlcnM8L2luZm8+XG4gKiBUaGUgdHlwZSBvZiBhbiBhY3Rpdml0eSBvZiBhIHVzZXJzIHByZXNlbmNlLCBlLmcuIGBQTEFZSU5HYC4gSGVyZSBhcmUgdGhlIGF2YWlsYWJsZSB0eXBlczpcbiAqICogUExBWUlOR1xuICogKiBTVFJFQU1JTkdcbiAqICogTElTVEVOSU5HXG4gKiAqIFdBVENISU5HXG4gKiAqIENVU1RPTV9TVEFUVVNcbiAqICogQ09NUEVUSU5HXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBBY3Rpdml0eVR5cGVcbiAqL1xuZXhwb3J0cy5BY3Rpdml0eVR5cGVzID0gWydQTEFZSU5HJywgJ1NUUkVBTUlORycsICdMSVNURU5JTkcnLCAnV0FUQ0hJTkcnLCAnQ1VTVE9NX1NUQVRVUycsICdDT01QRVRJTkcnXTtcblxuZXhwb3J0cy5DaGFubmVsVHlwZXMgPSB7XG4gIFRFWFQ6IDAsXG4gIERNOiAxLFxuICBWT0lDRTogMixcbiAgR1JPVVA6IDMsXG4gIENBVEVHT1JZOiA0LFxuICBORVdTOiA1LFxuICBTVE9SRTogNixcbn07XG5cbmV4cG9ydHMuQ2xpZW50QXBwbGljYXRpb25Bc3NldFR5cGVzID0ge1xuICBTTUFMTDogMSxcbiAgQklHOiAyLFxufTtcblxuZXhwb3J0cy5Db2xvcnMgPSB7XG4gIERFRkFVTFQ6IDB4MDAwMDAwLFxuICBXSElURTogMHhmZmZmZmYsXG4gIEFRVUE6IDB4MWFiYzljLFxuICBHUkVFTjogMHgyZWNjNzEsXG4gIEJMVUU6IDB4MzQ5OGRiLFxuICBZRUxMT1c6IDB4ZmZmZjAwLFxuICBQVVJQTEU6IDB4OWI1OWI2LFxuICBMVU1JTk9VU19WSVZJRF9QSU5LOiAweGU5MWU2MyxcbiAgR09MRDogMHhmMWM0MGYsXG4gIE9SQU5HRTogMHhlNjdlMjIsXG4gIFJFRDogMHhlNzRjM2MsXG4gIEdSRVk6IDB4OTVhNWE2LFxuICBOQVZZOiAweDM0NDk1ZSxcbiAgREFSS19BUVVBOiAweDExODA2YSxcbiAgREFSS19HUkVFTjogMHgxZjhiNGMsXG4gIERBUktfQkxVRTogMHgyMDY2OTQsXG4gIERBUktfUFVSUExFOiAweDcxMzY4YSxcbiAgREFSS19WSVZJRF9QSU5LOiAweGFkMTQ1NyxcbiAgREFSS19HT0xEOiAweGMyN2MwZSxcbiAgREFSS19PUkFOR0U6IDB4YTg0MzAwLFxuICBEQVJLX1JFRDogMHg5OTJkMjIsXG4gIERBUktfR1JFWTogMHg5NzljOWYsXG4gIERBUktFUl9HUkVZOiAweDdmOGM4ZCxcbiAgTElHSFRfR1JFWTogMHhiY2MwYzAsXG4gIERBUktfTkFWWTogMHgyYzNlNTAsXG4gIEJMVVJQTEU6IDB4NzI4OWRhLFxuICBHUkVZUExFOiAweDk5YWFiNSxcbiAgREFSS19CVVRfTk9UX0JMQUNLOiAweDJjMmYzMyxcbiAgTk9UX1FVSVRFX0JMQUNLOiAweDIzMjcyYSxcbn07XG5cbi8qKlxuICogVGhlIHZhbHVlIHNldCBmb3IgdGhlIGV4cGxpY2l0IGNvbnRlbnQgZmlsdGVyIGxldmVscyBmb3IgYSBndWlsZDpcbiAqICogRElTQUJMRURcbiAqICogTUVNQkVSU19XSVRIT1VUX1JPTEVTXG4gKiAqIEFMTF9NRU1CRVJTXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBFeHBsaWNpdENvbnRlbnRGaWx0ZXJMZXZlbFxuICovXG5leHBvcnRzLkV4cGxpY2l0Q29udGVudEZpbHRlckxldmVscyA9IFsnRElTQUJMRUQnLCAnTUVNQkVSU19XSVRIT1VUX1JPTEVTJywgJ0FMTF9NRU1CRVJTJ107XG5cbi8qKlxuICogVGhlIHZhbHVlIHNldCBmb3IgdGhlIHZlcmlmaWNhdGlvbiBsZXZlbHMgZm9yIGEgZ3VpbGQ6XG4gKiAqIE5PTkVcbiAqICogTE9XXG4gKiAqIE1FRElVTVxuICogKiBISUdIXG4gKiAqIFZFUllfSElHSFxuICogQHR5cGVkZWYge3N0cmluZ30gVmVyaWZpY2F0aW9uTGV2ZWxcbiAqL1xuZXhwb3J0cy5WZXJpZmljYXRpb25MZXZlbHMgPSBbJ05PTkUnLCAnTE9XJywgJ01FRElVTScsICdISUdIJywgJ1ZFUllfSElHSCddO1xuXG4vKipcbiAqIEFuIGVycm9yIGVuY291bnRlcmVkIHdoaWxlIHBlcmZvcm1pbmcgYW4gQVBJIHJlcXVlc3QuIEhlcmUgYXJlIHRoZSBwb3RlbnRpYWwgZXJyb3JzOlxuICogKiBVTktOT1dOX0FDQ09VTlRcbiAqICogVU5LTk9XTl9BUFBMSUNBVElPTlxuICogKiBVTktOT1dOX0NIQU5ORUxcbiAqICogVU5LTk9XTl9HVUlMRFxuICogKiBVTktOT1dOX0lOVEVHUkFUSU9OXG4gKiAqIFVOS05PV05fSU5WSVRFXG4gKiAqIFVOS05PV05fTUVNQkVSXG4gKiAqIFVOS05PV05fTUVTU0FHRVxuICogKiBVTktOT1dOX09WRVJXUklURVxuICogKiBVTktOT1dOX1BST1ZJREVSXG4gKiAqIFVOS05PV05fUk9MRVxuICogKiBVTktOT1dOX1RPS0VOXG4gKiAqIFVOS05PV05fVVNFUlxuICogKiBVTktOT1dOX0VNT0pJXG4gKiAqIFVOS05PV05fV0VCSE9PS1xuICogKiBVTktOT1dOX0JBTlxuICogKiBVTktOT1dOX0dVSUxEX1RFTVBMQVRFXG4gKiAqIEJPVF9QUk9ISUJJVEVEX0VORFBPSU5UXG4gKiAqIEJPVF9PTkxZX0VORFBPSU5UXG4gKiAqIENIQU5ORUxfSElUX1dSSVRFX1JBVEVMSU1JVFxuICogKiBNQVhJTVVNX0dVSUxEU1xuICogKiBNQVhJTVVNX0ZSSUVORFNcbiAqICogTUFYSU1VTV9QSU5TXG4gKiAqIE1BWElNVU1fUk9MRVNcbiAqICogTUFYSU1VTV9XRUJIT09LU1xuICogKiBNQVhJTVVNX1JFQUNUSU9OU1xuICogKiBNQVhJTVVNX0NIQU5ORUxTXG4gKiAqIE1BWElNVU1fQVRUQUNITUVOVFNcbiAqICogTUFYSU1VTV9JTlZJVEVTXG4gKiAqIEdVSUxEX0FMUkVBRFlfSEFTX1RFTVBMQVRFXG4gKiAqIFVOQVVUSE9SSVpFRFxuICogKiBBQ0NPVU5UX1ZFUklGSUNBVElPTl9SRVFVSVJFRFxuICogKiBSRVFVRVNUX0VOVElUWV9UT09fTEFSR0VcbiAqICogRkVBVFVSRV9URU1QT1JBUklMWV9ESVNBQkxFRFxuICogKiBVU0VSX0JBTk5FRFxuICogKiBBTFJFQURZX0NST1NTUE9TVEVEXG4gKiAqIE1JU1NJTkdfQUNDRVNTXG4gKiAqIElOVkFMSURfQUNDT1VOVF9UWVBFXG4gKiAqIENBTk5PVF9FWEVDVVRFX09OX0RNXG4gKiAqIEVNQkVEX0RJU0FCTEVEXG4gKiAqIENBTk5PVF9FRElUX01FU1NBR0VfQllfT1RIRVJcbiAqICogQ0FOTk9UX1NFTkRfRU1QVFlfTUVTU0FHRVxuICogKiBDQU5OT1RfTUVTU0FHRV9VU0VSXG4gKiAqIENBTk5PVF9TRU5EX01FU1NBR0VTX0lOX1ZPSUNFX0NIQU5ORUxcbiAqICogQ0hBTk5FTF9WRVJJRklDQVRJT05fTEVWRUxfVE9PX0hJR0hcbiAqICogT0FVVEgyX0FQUExJQ0FUSU9OX0JPVF9BQlNFTlRcbiAqICogTUFYSU1VTV9PQVVUSDJfQVBQTElDQVRJT05TXG4gKiAqIElOVkFMSURfT0FVVEhfU1RBVEVcbiAqICogTUlTU0lOR19QRVJNSVNTSU9OU1xuICogKiBJTlZBTElEX0FVVEhFTlRJQ0FUSU9OX1RPS0VOXG4gKiAqIE5PVEVfVE9PX0xPTkdcbiAqICogSU5WQUxJRF9CVUxLX0RFTEVURV9RVUFOVElUWVxuICogKiBDQU5OT1RfUElOX01FU1NBR0VfSU5fT1RIRVJfQ0hBTk5FTFxuICogKiBJTlZBTElEX09SX1RBS0VOX0lOVklURV9DT0RFXG4gKiAqIENBTk5PVF9FWEVDVVRFX09OX1NZU1RFTV9NRVNTQUdFXG4gKiAqIElOVkFMSURfT0FVVEhfVE9LRU5cbiAqICogQlVMS19ERUxFVEVfTUVTU0FHRV9UT09fT0xEXG4gKiAqIElOVkFMSURfRk9STV9CT0RZXG4gKiAqIElOVklURV9BQ0NFUFRFRF9UT19HVUlMRF9OT1RfQ09OVEFJTklOR19CT1RcbiAqICogSU5WQUxJRF9BUElfVkVSU0lPTlxuICogKiBDQU5OT1RfREVMRVRFX0NPTU1VTklUWV9SRVFVSVJFRF9DSEFOTkVMXG4gKiAqIFJFQUNUSU9OX0JMT0NLRURcbiAqICogUkVTT1VSQ0VfT1ZFUkxPQURFRFxuICogQHR5cGVkZWYge3N0cmluZ30gQVBJRXJyb3JcbiAqL1xuZXhwb3J0cy5BUElFcnJvcnMgPSB7XG4gIFVOS05PV05fQUNDT1VOVDogMTAwMDEsXG4gIFVOS05PV05fQVBQTElDQVRJT046IDEwMDAyLFxuICBVTktOT1dOX0NIQU5ORUw6IDEwMDAzLFxuICBVTktOT1dOX0dVSUxEOiAxMDAwNCxcbiAgVU5LTk9XTl9JTlRFR1JBVElPTjogMTAwMDUsXG4gIFVOS05PV05fSU5WSVRFOiAxMDAwNixcbiAgVU5LTk9XTl9NRU1CRVI6IDEwMDA3LFxuICBVTktOT1dOX01FU1NBR0U6IDEwMDA4LFxuICBVTktOT1dOX09WRVJXUklURTogMTAwMDksXG4gIFVOS05PV05fUFJPVklERVI6IDEwMDEwLFxuICBVTktOT1dOX1JPTEU6IDEwMDExLFxuICBVTktOT1dOX1RPS0VOOiAxMDAxMixcbiAgVU5LTk9XTl9VU0VSOiAxMDAxMyxcbiAgVU5LTk9XTl9FTU9KSTogMTAwMTQsXG4gIFVOS05PV05fV0VCSE9PSzogMTAwMTUsXG4gIFVOS05PV05fQkFOOiAxMDAyNixcbiAgVU5LTk9XTl9HVUlMRF9URU1QTEFURTogMTAwNTcsXG4gIEJPVF9QUk9ISUJJVEVEX0VORFBPSU5UOiAyMDAwMSxcbiAgQk9UX09OTFlfRU5EUE9JTlQ6IDIwMDAyLFxuICBDSEFOTkVMX0hJVF9XUklURV9SQVRFTElNSVQ6IDIwMDI4LFxuICBNQVhJTVVNX0dVSUxEUzogMzAwMDEsXG4gIE1BWElNVU1fRlJJRU5EUzogMzAwMDIsXG4gIE1BWElNVU1fUElOUzogMzAwMDMsXG4gIE1BWElNVU1fUk9MRVM6IDMwMDA1LFxuICBNQVhJTVVNX1dFQkhPT0tTOiAzMDAwNyxcbiAgTUFYSU1VTV9SRUFDVElPTlM6IDMwMDEwLFxuICBNQVhJTVVNX0NIQU5ORUxTOiAzMDAxMyxcbiAgTUFYSU1VTV9BVFRBQ0hNRU5UUzogMzAwMTUsXG4gIE1BWElNVU1fSU5WSVRFUzogMzAwMTYsXG4gIEdVSUxEX0FMUkVBRFlfSEFTX1RFTVBMQVRFOiAzMDAzMSxcbiAgVU5BVVRIT1JJWkVEOiA0MDAwMSxcbiAgQUNDT1VOVF9WRVJJRklDQVRJT05fUkVRVUlSRUQ6IDQwMDAyLFxuICBSRVFVRVNUX0VOVElUWV9UT09fTEFSR0U6IDQwMDA1LFxuICBGRUFUVVJFX1RFTVBPUkFSSUxZX0RJU0FCTEVEOiA0MDAwNixcbiAgVVNFUl9CQU5ORUQ6IDQwMDA3LFxuICBBTFJFQURZX0NST1NTUE9TVEVEOiA0MDAzMyxcbiAgTUlTU0lOR19BQ0NFU1M6IDUwMDAxLFxuICBJTlZBTElEX0FDQ09VTlRfVFlQRTogNTAwMDIsXG4gIENBTk5PVF9FWEVDVVRFX09OX0RNOiA1MDAwMyxcbiAgRU1CRURfRElTQUJMRUQ6IDUwMDA0LFxuICBDQU5OT1RfRURJVF9NRVNTQUdFX0JZX09USEVSOiA1MDAwNSxcbiAgQ0FOTk9UX1NFTkRfRU1QVFlfTUVTU0FHRTogNTAwMDYsXG4gIENBTk5PVF9NRVNTQUdFX1VTRVI6IDUwMDA3LFxuICBDQU5OT1RfU0VORF9NRVNTQUdFU19JTl9WT0lDRV9DSEFOTkVMOiA1MDAwOCxcbiAgQ0hBTk5FTF9WRVJJRklDQVRJT05fTEVWRUxfVE9PX0hJR0g6IDUwMDA5LFxuICBPQVVUSDJfQVBQTElDQVRJT05fQk9UX0FCU0VOVDogNTAwMTAsXG4gIE1BWElNVU1fT0FVVEgyX0FQUExJQ0FUSU9OUzogNTAwMTEsXG4gIElOVkFMSURfT0FVVEhfU1RBVEU6IDUwMDEyLFxuICBNSVNTSU5HX1BFUk1JU1NJT05TOiA1MDAxMyxcbiAgSU5WQUxJRF9BVVRIRU5USUNBVElPTl9UT0tFTjogNTAwMTQsXG4gIE5PVEVfVE9PX0xPTkc6IDUwMDE1LFxuICBJTlZBTElEX0JVTEtfREVMRVRFX1FVQU5USVRZOiA1MDAxNixcbiAgQ0FOTk9UX1BJTl9NRVNTQUdFX0lOX09USEVSX0NIQU5ORUw6IDUwMDE5LFxuICBJTlZBTElEX09SX1RBS0VOX0lOVklURV9DT0RFOiA1MDAyMCxcbiAgQ0FOTk9UX0VYRUNVVEVfT05fU1lTVEVNX01FU1NBR0U6IDUwMDIxLFxuICBJTlZBTElEX09BVVRIX1RPS0VOOiA1MDAyNSxcbiAgQlVMS19ERUxFVEVfTUVTU0FHRV9UT09fT0xEOiA1MDAzNCxcbiAgSU5WQUxJRF9GT1JNX0JPRFk6IDUwMDM1LFxuICBJTlZJVEVfQUNDRVBURURfVE9fR1VJTERfTk9UX0NPTlRBSU5JTkdfQk9UOiA1MDAzNixcbiAgSU5WQUxJRF9BUElfVkVSU0lPTjogNTAwNDEsXG4gIENBTk5PVF9ERUxFVEVfQ09NTVVOSVRZX1JFUVVJUkVEX0NIQU5ORUw6IDUwMDc0LFxuICBSRUFDVElPTl9CTE9DS0VEOiA5MDAwMSxcbiAgUkVTT1VSQ0VfT1ZFUkxPQURFRDogMTMwMDAwLFxufTtcblxuLyoqXG4gKiBUaGUgdmFsdWUgc2V0IGZvciBhIGd1aWxkJ3MgZGVmYXVsdCBtZXNzYWdlIG5vdGlmaWNhdGlvbnMsIGUuZy4gYEFMTGAuIEhlcmUgYXJlIHRoZSBhdmFpbGFibGUgdHlwZXM6XG4gKiAqIEFMTFxuICogKiBNRU5USU9OU1xuICogQHR5cGVkZWYge3N0cmluZ30gRGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zXG4gKi9cbmV4cG9ydHMuRGVmYXVsdE1lc3NhZ2VOb3RpZmljYXRpb25zID0gWydBTEwnLCAnTUVOVElPTlMnXTtcblxuLyoqXG4gKiBUaGUgdmFsdWUgc2V0IGZvciBhIHRlYW0gbWVtYmVycydzIG1lbWJlcnNoaXAgc3RhdGU6XG4gKiAqIElOVklURURcbiAqICogQUNDRVBURURcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IE1lbWJlcnNoaXBTdGF0ZXNcbiAqL1xuZXhwb3J0cy5NZW1iZXJzaGlwU3RhdGVzID0gW1xuICAvLyBUaGV5IHN0YXJ0IGF0IDFcbiAgbnVsbCxcbiAgJ0lOVklURUQnLFxuICAnQUNDRVBURUQnLFxuXTtcblxuLyoqXG4gKiBUaGUgdmFsdWUgc2V0IGZvciBhIHdlYmhvb2sncyB0eXBlOlxuICogKiBJbmNvbWluZ1xuICogKiBDaGFubmVsIEZvbGxvd2VyXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBXZWJob29rVHlwZXNcbiAqL1xuZXhwb3J0cy5XZWJob29rVHlwZXMgPSBbXG4gIC8vIFRoZXkgc3RhcnQgYXQgMVxuICBudWxsLFxuICAnSW5jb21pbmcnLFxuICAnQ2hhbm5lbCBGb2xsb3dlcicsXG5dO1xuXG5mdW5jdGlvbiBrZXlNaXJyb3IoYXJyKSB7XG4gIGxldCB0bXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycikgdG1wW3ZhbHVlXSA9IHZhbHVlO1xuICByZXR1cm4gdG1wO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCBmZXRjaCA9IHJlcXVpcmUoJ25vZGUtZmV0Y2gnKTtcbmNvbnN0IHsgRXJyb3I6IERpc2NvcmRFcnJvciwgVHlwZUVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IHsgYnJvd3NlciB9ID0gcmVxdWlyZSgnLi4vdXRpbC9Db25zdGFudHMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBUaGUgRGF0YVJlc29sdmVyIGlkZW50aWZpZXMgZGlmZmVyZW50IG9iamVjdHMgYW5kIHRyaWVzIHRvIHJlc29sdmUgYSBzcGVjaWZpYyBwaWVjZSBvZiBpbmZvcm1hdGlvbiBmcm9tIHRoZW0uXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEYXRhUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2xhc3MgbWF5IG5vdCBiZSBpbnN0YW50aWF0ZWQuYCk7XG4gIH1cblxuICAvKipcbiAgICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBnaXZlIGFuIGludml0ZSBjb2RlLiBUaGlzIGNhbiBiZTpcbiAgICogKiBBbiBpbnZpdGUgY29kZVxuICAgKiAqIEFuIGludml0ZSBVUkxcbiAgICogQHR5cGVkZWYge3N0cmluZ30gSW52aXRlUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBnaXZlIGFuIHRlbXBsYXRlIGNvZGUuIFRoaXMgY2FuIGJlOlxuICAgKiAqIEEgdGVtcGxhdGUgY29kZVxuICAgKiAqIEEgdGVtcGxhdGUgVVJMXG4gICAqIEB0eXBlZGVmIHtzdHJpbmd9IEd1aWxkVGVtcGxhdGVSZXNvbHZhYmxlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgc3RyaW5nIHRvIGEgY29kZSBiYXNlZCBvbiB0aGUgcGFzc2VkIHJlZ2V4LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBUaGUgc3RyaW5nIHRvIHJlc29sdmVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFRoZSBSZWdFeHAgdXNlZCB0byBleHRyYWN0IHRoZSBjb2RlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcmVzb2x2ZUNvZGUoZGF0YSwgcmVnZXgpIHtcbiAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMoZGF0YSk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gfHwgZGF0YSA6IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgSW52aXRlUmVzb2x2YWJsZSB0byBhbiBpbnZpdGUgY29kZS5cbiAgICogQHBhcmFtIHtJbnZpdGVSZXNvbHZhYmxlfSBkYXRhIFRoZSBpbnZpdGUgcmVzb2x2YWJsZSB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcmVzb2x2ZUludml0ZUNvZGUoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVDb2RlKGRhdGEsIC9kaXNjb3JkKD86KD86YXBwKT9cXC5jb21cXC9pbnZpdGV8XFwuZ2coPzpcXC9pbnZpdGUpPylcXC8oW1xcdy1dezIsMjU1fSkvaSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgR3VpbGRUZW1wbGF0ZVJlc29sdmFibGUgdG8gYSB0ZW1wbGF0ZSBjb2RlLlxuICAgKiBAcGFyYW0ge0d1aWxkVGVtcGxhdGVSZXNvbHZhYmxlfSBkYXRhIFRoZSB0ZW1wbGF0ZSByZXNvbHZhYmxlIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyByZXNvbHZlR3VpbGRUZW1wbGF0ZUNvZGUoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVDb2RlKGRhdGEsIC9kaXNjb3JkKD86YXBwKT9cXC4oPzpjb21cXC90ZW1wbGF0ZXxuZXcpXFwvKFtcXHctXXsyLDI1NX0pL2kpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgQmFzZTY0UmVzb2x2YWJsZSwgYSBzdHJpbmcsIG9yIGEgQnVmZmVyUmVzb2x2YWJsZSB0byBhIEJhc2UgNjQgaW1hZ2UuXG4gICAqIEBwYXJhbSB7QnVmZmVyUmVzb2x2YWJsZXxCYXNlNjRSZXNvbHZhYmxlfSBpbWFnZSBUaGUgaW1hZ2UgdG8gYmUgcmVzb2x2ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8P3N0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgcmVzb2x2ZUltYWdlKGltYWdlKSB7XG4gICAgaWYgKCFpbWFnZSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycgJiYgaW1hZ2Uuc3RhcnRzV2l0aCgnZGF0YTonKSkge1xuICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5yZXNvbHZlRmlsZUFzQnVmZmVyKGltYWdlKTtcbiAgICByZXR1cm4gRGF0YVJlc29sdmVyLnJlc29sdmVCYXNlNjQoZmlsZSk7XG4gIH1cblxuICAvKipcbiAgICogRGF0YSB0aGF0IHJlc29sdmVzIHRvIGdpdmUgYSBCYXNlNjQgc3RyaW5nLCB0eXBpY2FsbHkgZm9yIGltYWdlIHVwbG9hZGluZy4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBCdWZmZXJcbiAgICogKiBBIGJhc2U2NCBzdHJpbmdcbiAgICogQHR5cGVkZWYge0J1ZmZlcnxzdHJpbmd9IEJhc2U2NFJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgQmFzZTY0UmVzb2x2YWJsZSB0byBhIEJhc2UgNjQgaW1hZ2UuXG4gICAqIEBwYXJhbSB7QmFzZTY0UmVzb2x2YWJsZX0gZGF0YSBUaGUgYmFzZSA2NCByZXNvbHZhYmxlIHlvdSB3YW50IHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgez9zdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcmVzb2x2ZUJhc2U2NChkYXRhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGBkYXRhOmltYWdlL2pwZztiYXNlNjQsJHtkYXRhLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgdG8gZ2l2ZSBhIEJ1ZmZlci4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBCdWZmZXJcbiAgICogKiBUaGUgcGF0aCB0byBhIGxvY2FsIGZpbGVcbiAgICogKiBBIFVSTFxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfEJ1ZmZlcn0gQnVmZmVyUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogQGV4dGVybmFsIFN0cmVhbVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sfVxuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBCdWZmZXJSZXNvbHZhYmxlIHRvIGEgQnVmZmVyIG9yIGEgU3RyZWFtLlxuICAgKiBAcGFyYW0ge0J1ZmZlclJlc29sdmFibGV8U3RyZWFtfSByZXNvdXJjZSBUaGUgYnVmZmVyIG9yIHN0cmVhbSByZXNvbHZhYmxlIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyfFN0cmVhbT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgcmVzb2x2ZUZpbGUocmVzb3VyY2UpIHtcbiAgICBpZiAoIWJyb3dzZXIgJiYgQnVmZmVyLmlzQnVmZmVyKHJlc291cmNlKSkgcmV0dXJuIHJlc291cmNlO1xuICAgIGlmIChicm93c2VyICYmIHJlc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHJldHVybiBVdGlsLmNvbnZlcnRUb0J1ZmZlcihyZXNvdXJjZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgaWYgKGJyb3dzZXIgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBCbG9iKSByZXR1cm4gcmVzb3VyY2U7XG4gICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlKSByZXR1cm4gcmVzb3VyY2U7XG5cbiAgICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy8udGVzdChyZXNvdXJjZSkpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gocmVzb3VyY2UpO1xuICAgICAgICByZXR1cm4gYnJvd3NlciA/IHJlcy5ibG9iKCkgOiByZXMuYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoIWJyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gcGF0aC5yZXNvbHZlKHJlc291cmNlKTtcbiAgICAgICAgICBmcy5zdGF0KGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICBpZiAoIXN0YXRzLmlzRmlsZSgpKSByZXR1cm4gcmVqZWN0KG5ldyBEaXNjb3JkRXJyb3IoJ0ZJTEVfTk9UX0ZPVU5EJywgZmlsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JFUV9SRVNPVVJDRV9UWVBFJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBCdWZmZXJSZXNvbHZhYmxlIHRvIGEgQnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlclJlc29sdmFibGV8U3RyZWFtfSByZXNvdXJjZSBUaGUgYnVmZmVyIG9yIHN0cmVhbSByZXNvbHZhYmxlIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyByZXNvbHZlRmlsZUFzQnVmZmVyKHJlc291cmNlKSB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMucmVzb2x2ZUZpbGUocmVzb3VyY2UpO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZmlsZSkpIHJldHVybiBmaWxlO1xuXG4gICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBmaWxlKSBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhUmVzb2x2ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBCaXRGaWVsZCA9IHJlcXVpcmUoJy4vQml0RmllbGQnKTtcblxuLyoqXG4gKiBEYXRhIHN0cnVjdHVyZSB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gY2FsY3VsYXRlIGludGVudHMuXG4gKiBAZXh0ZW5kcyB7Qml0RmllbGR9XG4gKi9cbmNsYXNzIEludGVudHMgZXh0ZW5kcyBCaXRGaWVsZCB7fVxuXG4vKipcbiAqIEBuYW1lIEludGVudHNcbiAqIEBraW5kIGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyb2YgSW50ZW50c1xuICogQHBhcmFtIHtJbnRlbnRzUmVzb2x2YWJsZX0gW2JpdHM9MF0gQml0KHMpIHRvIHJlYWQgZnJvbVxuICovXG5cbi8qKlxuICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBnaXZlIGEgcGVybWlzc2lvbiBudW1iZXIuIFRoaXMgY2FuIGJlOlxuICogKiBBIHN0cmluZyAoc2VlIHtAbGluayBJbnRlbnRzLkZMQUdTfSlcbiAqICogQW4gaW50ZW50cyBmbGFnXG4gKiAqIEFuIGluc3RhbmNlIG9mIEludGVudHNcbiAqICogQW4gYXJyYXkgb2YgSW50ZW50c1Jlc29sdmFibGVcbiAqIEB0eXBlZGVmIHtzdHJpbmd8bnVtYmVyfEludGVudHN8SW50ZW50c1Jlc29sdmFibGVbXX0gSW50ZW50c1Jlc29sdmFibGVcbiAqL1xuXG4vKipcbiAqIE51bWVyaWMgd2Vic29ja2V0IGludGVudHMuIEFsbCBhdmFpbGFibGUgcHJvcGVydGllczpcbiAqICogYEdVSUxEU2BcbiAqICogYEdVSUxEX01FTUJFUlNgXG4gKiAqIGBHVUlMRF9CQU5TYFxuICogKiBgR1VJTERfRU1PSklTYFxuICogKiBgR1VJTERfSU5URUdSQVRJT05TYFxuICogKiBgR1VJTERfV0VCSE9PS1NgXG4gKiAqIGBHVUlMRF9JTlZJVEVTYFxuICogKiBgR1VJTERfVk9JQ0VfU1RBVEVTYFxuICogKiBgR1VJTERfUFJFU0VOQ0VTYFxuICogKiBgR1VJTERfTUVTU0FHRVNgXG4gKiAqIGBHVUlMRF9NRVNTQUdFX1JFQUNUSU9OU2BcbiAqICogYEdVSUxEX01FU1NBR0VfVFlQSU5HYFxuICogKiBgRElSRUNUX01FU1NBR0VTYFxuICogKiBgRElSRUNUX01FU1NBR0VfUkVBQ1RJT05TYFxuICogKiBgRElSRUNUX01FU1NBR0VfVFlQSU5HYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGlzY29yZC5jb20vZGV2ZWxvcGVycy9kb2NzL3RvcGljcy9nYXRld2F5I2xpc3Qtb2YtaW50ZW50c31cbiAqL1xuSW50ZW50cy5GTEFHUyA9IHtcbiAgR1VJTERTOiAxIDw8IDAsXG4gIEdVSUxEX01FTUJFUlM6IDEgPDwgMSxcbiAgR1VJTERfQkFOUzogMSA8PCAyLFxuICBHVUlMRF9FTU9KSVM6IDEgPDwgMyxcbiAgR1VJTERfSU5URUdSQVRJT05TOiAxIDw8IDQsXG4gIEdVSUxEX1dFQkhPT0tTOiAxIDw8IDUsXG4gIEdVSUxEX0lOVklURVM6IDEgPDwgNixcbiAgR1VJTERfVk9JQ0VfU1RBVEVTOiAxIDw8IDcsXG4gIEdVSUxEX1BSRVNFTkNFUzogMSA8PCA4LFxuICBHVUlMRF9NRVNTQUdFUzogMSA8PCA5LFxuICBHVUlMRF9NRVNTQUdFX1JFQUNUSU9OUzogMSA8PCAxMCxcbiAgR1VJTERfTUVTU0FHRV9UWVBJTkc6IDEgPDwgMTEsXG4gIERJUkVDVF9NRVNTQUdFUzogMSA8PCAxMixcbiAgRElSRUNUX01FU1NBR0VfUkVBQ1RJT05TOiAxIDw8IDEzLFxuICBESVJFQ1RfTUVTU0FHRV9UWVBJTkc6IDEgPDwgMTQsXG59O1xuXG4vKipcbiAqIEJpdGZpZWxkIHJlcHJlc2VudGluZyBhbGwgcHJpdmlsZWdlZCBpbnRlbnRzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kaXNjb3JkLmNvbS9kZXZlbG9wZXJzL2RvY3MvdG9waWNzL2dhdGV3YXkjcHJpdmlsZWdlZC1pbnRlbnRzfVxuICovXG5JbnRlbnRzLlBSSVZJTEVHRUQgPSBJbnRlbnRzLkZMQUdTLkdVSUxEX01FTUJFUlMgfCBJbnRlbnRzLkZMQUdTLkdVSUxEX1BSRVNFTkNFUztcblxuLyoqXG4gKiBCaXRmaWVsZCByZXByZXNlbnRpbmcgYWxsIGludGVudHMgY29tYmluZWRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbkludGVudHMuQUxMID0gT2JqZWN0LnZhbHVlcyhJbnRlbnRzLkZMQUdTKS5yZWR1Y2UoKGFjYywgcCkgPT4gYWNjIHwgcCwgMCk7XG5cbi8qKlxuICogQml0ZmllbGQgcmVwcmVzZW50aW5nIGFsbCBub24tcHJpdmlsZWdlZCBpbnRlbnRzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5JbnRlbnRzLk5PTl9QUklWSUxFR0VEID0gSW50ZW50cy5BTEwgJiB+SW50ZW50cy5QUklWSUxFR0VEO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL0NvbGxlY3Rpb24uanMnKTtcblxuLyoqXG4gKiBBIENvbGxlY3Rpb24gd2hpY2ggaG9sZHMgYSBtYXggYW1vdW50IG9mIGVudHJpZXMuIFRoZSBmaXJzdCBrZXkgaXMgZGVsZXRlZCBpZiB0aGUgQ29sbGVjdGlvbiBoYXNcbiAqIHJlYWNoZWQgbWF4IHNpemUuXG4gKiBAZXh0ZW5kcyB7Q29sbGVjdGlvbn1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4U2l6ZT0wXSBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBbaXRlcmFibGU9bnVsbF0gT3B0aW9uYWwgZW50cmllcyBwYXNzZWQgdG8gdGhlIE1hcCBjb25zdHJ1Y3Rvci5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIExpbWl0ZWRDb2xsZWN0aW9uIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAwLCBpdGVyYWJsZSA9IG51bGwpIHtcbiAgICBzdXBlcihpdGVyYWJsZSk7XG4gICAgLyoqXG4gICAgICogVGhlIG1heCBzaXplIG9mIHRoZSBDb2xsZWN0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMubWF4U2l6ZSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMuc2l6ZSA+PSB0aGlzLm1heFNpemUgJiYgIXRoaXMuaGFzKGtleSkpIHRoaXMuZGVsZXRlKHRoaXMuZmlyc3RLZXkoKSk7XG4gICAgcmV0dXJuIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcbiAgICByZXR1cm4gQ29sbGVjdGlvbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZWRDb2xsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCaXRGaWVsZCA9IHJlcXVpcmUoJy4vQml0RmllbGQnKTtcblxuLyoqXG4gKiBEYXRhIHN0cnVjdHVyZSB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gaW50ZXJhY3Qgd2l0aCBhbiB7QGxpbmsgTWVzc2FnZSNmbGFnc30gYml0ZmllbGQuXG4gKiBAZXh0ZW5kcyB7Qml0RmllbGR9XG4gKi9cbmNsYXNzIE1lc3NhZ2VGbGFncyBleHRlbmRzIEJpdEZpZWxkIHt9XG5cbi8qKlxuICogQG5hbWUgTWVzc2FnZUZsYWdzXG4gKiBAa2luZCBjb25zdHJ1Y3RvclxuICogQG1lbWJlcm9mIE1lc3NhZ2VGbGFnc1xuICogQHBhcmFtIHtCaXRGaWVsZFJlc29sdmFibGV9IFtiaXRzPTBdIEJpdChzKSB0byByZWFkIGZyb21cbiAqL1xuXG4vKipcbiAqIE51bWVyaWMgbWVzc2FnZSBmbGFncy4gQWxsIGF2YWlsYWJsZSBwcm9wZXJ0aWVzOlxuICogKiBgQ1JPU1NQT1NURURgXG4gKiAqIGBJU19DUk9TU1BPU1RgXG4gKiAqIGBTVVBQUkVTU19FTUJFRFNgXG4gKiAqIGBTT1VSQ0VfTUVTU0FHRV9ERUxFVEVEYFxuICogKiBgVVJHRU5UYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGlzY29yZC5jb20vZGV2ZWxvcGVycy9kb2NzL3Jlc291cmNlcy9jaGFubmVsI21lc3NhZ2Utb2JqZWN0LW1lc3NhZ2UtZmxhZ3N9XG4gKi9cbk1lc3NhZ2VGbGFncy5GTEFHUyA9IHtcbiAgQ1JPU1NQT1NURUQ6IDEgPDwgMCxcbiAgSVNfQ1JPU1NQT1NUOiAxIDw8IDEsXG4gIFNVUFBSRVNTX0VNQkVEUzogMSA8PCAyLFxuICBTT1VSQ0VfTUVTU0FHRV9ERUxFVEVEOiAxIDw8IDMsXG4gIFVSR0VOVDogMSA8PCA0LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlRmxhZ3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJpdEZpZWxkID0gcmVxdWlyZSgnLi9CaXRGaWVsZCcpO1xuXG4vKipcbiAqIERhdGEgc3RydWN0dXJlIHRoYXQgbWFrZXMgaXQgZWFzeSB0byBpbnRlcmFjdCB3aXRoIGEgcGVybWlzc2lvbiBiaXRmaWVsZC4gQWxsIHtAbGluayBHdWlsZE1lbWJlcn1zIGhhdmUgYSBzZXQgb2ZcbiAqIHBlcm1pc3Npb25zIGluIHRoZWlyIGd1aWxkLCBhbmQgZWFjaCBjaGFubmVsIGluIHRoZSBndWlsZCBtYXkgYWxzbyBoYXZlIHtAbGluayBQZXJtaXNzaW9uT3ZlcndyaXRlc30gZm9yIHRoZSBtZW1iZXJcbiAqIHRoYXQgb3ZlcnJpZGUgdGhlaXIgZGVmYXVsdCBwZXJtaXNzaW9ucy5cbiAqIEBleHRlbmRzIHtCaXRGaWVsZH1cbiAqL1xuY2xhc3MgUGVybWlzc2lvbnMgZXh0ZW5kcyBCaXRGaWVsZCB7XG4gIC8qKlxuICAgKiBAbmFtZSBQZXJtaXNzaW9uc1xuICAgKiBAa2luZCBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgUGVybWlzc2lvbnNcbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uUmVzb2x2YWJsZX0gW2JpdHM9MF0gQml0KHMpIHRvIHJlYWQgZnJvbVxuICAgKi9cblxuICAvKipcbiAgICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBnaXZlIGEgcGVybWlzc2lvbiBudW1iZXIuIFRoaXMgY2FuIGJlOlxuICAgKiAqIEEgc3RyaW5nIChzZWUge0BsaW5rIFBlcm1pc3Npb25zLkZMQUdTfSlcbiAgICogKiBBIHBlcm1pc3Npb24gbnVtYmVyXG4gICAqICogQW4gaW5zdGFuY2Ugb2YgUGVybWlzc2lvbnNcbiAgICogKiBBbiBBcnJheSBvZiBQZXJtaXNzaW9uUmVzb2x2YWJsZVxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfG51bWJlcnxQZXJtaXNzaW9uc3xQZXJtaXNzaW9uUmVzb2x2YWJsZVtdfSBQZXJtaXNzaW9uUmVzb2x2YWJsZVxuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJpdGZpZWxkIGhhcyBhIHBlcm1pc3Npb24sIG9yIGFueSBvZiBtdWx0aXBsZSBwZXJtaXNzaW9ucy5cbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uUmVzb2x2YWJsZX0gcGVybWlzc2lvbiBQZXJtaXNzaW9uKHMpIHRvIGNoZWNrIGZvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja0FkbWluPXRydWVdIFdoZXRoZXIgdG8gYWxsb3cgdGhlIGFkbWluaXN0cmF0b3IgcGVybWlzc2lvbiB0byBvdmVycmlkZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGFueShwZXJtaXNzaW9uLCBjaGVja0FkbWluID0gdHJ1ZSkge1xuICAgIHJldHVybiAoY2hlY2tBZG1pbiAmJiBzdXBlci5oYXModGhpcy5jb25zdHJ1Y3Rvci5GTEFHUy5BRE1JTklTVFJBVE9SKSkgfHwgc3VwZXIuYW55KHBlcm1pc3Npb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBiaXRmaWVsZCBoYXMgYSBwZXJtaXNzaW9uLCBvciBtdWx0aXBsZSBwZXJtaXNzaW9ucy5cbiAgICogQHBhcmFtIHtQZXJtaXNzaW9uUmVzb2x2YWJsZX0gcGVybWlzc2lvbiBQZXJtaXNzaW9uKHMpIHRvIGNoZWNrIGZvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja0FkbWluPXRydWVdIFdoZXRoZXIgdG8gYWxsb3cgdGhlIGFkbWluaXN0cmF0b3IgcGVybWlzc2lvbiB0byBvdmVycmlkZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhcyhwZXJtaXNzaW9uLCBjaGVja0FkbWluID0gdHJ1ZSkge1xuICAgIHJldHVybiAoY2hlY2tBZG1pbiAmJiBzdXBlci5oYXModGhpcy5jb25zdHJ1Y3Rvci5GTEFHUy5BRE1JTklTVFJBVE9SKSkgfHwgc3VwZXIuaGFzKHBlcm1pc3Npb24pO1xuICB9XG59XG5cbi8qKlxuICogTnVtZXJpYyBwZXJtaXNzaW9uIGZsYWdzLiBBbGwgYXZhaWxhYmxlIHByb3BlcnRpZXM6XG4gKiAqIGBBRE1JTklTVFJBVE9SYCAoaW1wbGljaXRseSBoYXMgKmFsbCogcGVybWlzc2lvbnMsIGFuZCBieXBhc3NlcyBhbGwgY2hhbm5lbCBvdmVyd3JpdGVzKVxuICogKiBgQ1JFQVRFX0lOU1RBTlRfSU5WSVRFYCAoY3JlYXRlIGludml0YXRpb25zIHRvIHRoZSBndWlsZClcbiAqICogYEtJQ0tfTUVNQkVSU2BcbiAqICogYEJBTl9NRU1CRVJTYFxuICogKiBgTUFOQUdFX0NIQU5ORUxTYCAoZWRpdCBhbmQgcmVvcmRlciBjaGFubmVscylcbiAqICogYE1BTkFHRV9HVUlMRGAgKGVkaXQgdGhlIGd1aWxkIGluZm9ybWF0aW9uLCByZWdpb24sIGV0Yy4pXG4gKiAqIGBBRERfUkVBQ1RJT05TYCAoYWRkIG5ldyByZWFjdGlvbnMgdG8gbWVzc2FnZXMpXG4gKiAqIGBWSUVXX0FVRElUX0xPR2BcbiAqICogYFBSSU9SSVRZX1NQRUFLRVJgXG4gKiAqIGBTVFJFQU1gXG4gKiAqIGBWSUVXX0NIQU5ORUxgXG4gKiAqIGBTRU5EX01FU1NBR0VTYFxuICogKiBgU0VORF9UVFNfTUVTU0FHRVNgXG4gKiAqIGBNQU5BR0VfTUVTU0FHRVNgIChkZWxldGUgbWVzc2FnZXMgYW5kIHJlYWN0aW9ucylcbiAqICogYEVNQkVEX0xJTktTYCAobGlua3MgcG9zdGVkIHdpbGwgaGF2ZSBhIHByZXZpZXcgZW1iZWRkZWQpXG4gKiAqIGBBVFRBQ0hfRklMRVNgXG4gKiAqIGBSRUFEX01FU1NBR0VfSElTVE9SWWAgKHZpZXcgbWVzc2FnZXMgdGhhdCB3ZXJlIHBvc3RlZCBwcmlvciB0byBvcGVuaW5nIERpc2NvcmQpXG4gKiAqIGBNRU5USU9OX0VWRVJZT05FYFxuICogKiBgVVNFX0VYVEVSTkFMX0VNT0pJU2AgKHVzZSBlbW9qaXMgZnJvbSBkaWZmZXJlbnQgZ3VpbGRzKVxuICogKiBgVklFV19HVUlMRF9JTlNJR0hUU2BcbiAqICogYENPTk5FQ1RgIChjb25uZWN0IHRvIGEgdm9pY2UgY2hhbm5lbClcbiAqICogYFNQRUFLYCAoc3BlYWsgaW4gYSB2b2ljZSBjaGFubmVsKVxuICogKiBgTVVURV9NRU1CRVJTYCAobXV0ZSBtZW1iZXJzIGFjcm9zcyBhbGwgdm9pY2UgY2hhbm5lbHMpXG4gKiAqIGBERUFGRU5fTUVNQkVSU2AgKGRlYWZlbiBtZW1iZXJzIGFjcm9zcyBhbGwgdm9pY2UgY2hhbm5lbHMpXG4gKiAqIGBNT1ZFX01FTUJFUlNgIChtb3ZlIG1lbWJlcnMgYmV0d2VlbiB2b2ljZSBjaGFubmVscylcbiAqICogYFVTRV9WQURgICh1c2Ugdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uKVxuICogKiBgQ0hBTkdFX05JQ0tOQU1FYFxuICogKiBgTUFOQUdFX05JQ0tOQU1FU2AgKGNoYW5nZSBvdGhlciBtZW1iZXJzJyBuaWNrbmFtZXMpXG4gKiAqIGBNQU5BR0VfUk9MRVNgXG4gKiAqIGBNQU5BR0VfV0VCSE9PS1NgXG4gKiAqIGBNQU5BR0VfRU1PSklTYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGlzY29yZC5jb20vZGV2ZWxvcGVycy9kb2NzL3RvcGljcy9wZXJtaXNzaW9uc31cbiAqL1xuUGVybWlzc2lvbnMuRkxBR1MgPSB7XG4gIENSRUFURV9JTlNUQU5UX0lOVklURTogMSA8PCAwLFxuICBLSUNLX01FTUJFUlM6IDEgPDwgMSxcbiAgQkFOX01FTUJFUlM6IDEgPDwgMixcbiAgQURNSU5JU1RSQVRPUjogMSA8PCAzLFxuICBNQU5BR0VfQ0hBTk5FTFM6IDEgPDwgNCxcbiAgTUFOQUdFX0dVSUxEOiAxIDw8IDUsXG4gIEFERF9SRUFDVElPTlM6IDEgPDwgNixcbiAgVklFV19BVURJVF9MT0c6IDEgPDwgNyxcbiAgUFJJT1JJVFlfU1BFQUtFUjogMSA8PCA4LFxuICBTVFJFQU06IDEgPDwgOSxcbiAgVklFV19DSEFOTkVMOiAxIDw8IDEwLFxuICBTRU5EX01FU1NBR0VTOiAxIDw8IDExLFxuICBTRU5EX1RUU19NRVNTQUdFUzogMSA8PCAxMixcbiAgTUFOQUdFX01FU1NBR0VTOiAxIDw8IDEzLFxuICBFTUJFRF9MSU5LUzogMSA8PCAxNCxcbiAgQVRUQUNIX0ZJTEVTOiAxIDw8IDE1LFxuICBSRUFEX01FU1NBR0VfSElTVE9SWTogMSA8PCAxNixcbiAgTUVOVElPTl9FVkVSWU9ORTogMSA8PCAxNyxcbiAgVVNFX0VYVEVSTkFMX0VNT0pJUzogMSA8PCAxOCxcbiAgVklFV19HVUlMRF9JTlNJR0hUUzogMSA8PCAxOSxcbiAgQ09OTkVDVDogMSA8PCAyMCxcbiAgU1BFQUs6IDEgPDwgMjEsXG4gIE1VVEVfTUVNQkVSUzogMSA8PCAyMixcbiAgREVBRkVOX01FTUJFUlM6IDEgPDwgMjMsXG4gIE1PVkVfTUVNQkVSUzogMSA8PCAyNCxcbiAgVVNFX1ZBRDogMSA8PCAyNSxcbiAgQ0hBTkdFX05JQ0tOQU1FOiAxIDw8IDI2LFxuICBNQU5BR0VfTklDS05BTUVTOiAxIDw8IDI3LFxuICBNQU5BR0VfUk9MRVM6IDEgPDwgMjgsXG4gIE1BTkFHRV9XRUJIT09LUzogMSA8PCAyOSxcbiAgTUFOQUdFX0VNT0pJUzogMSA8PCAzMCxcbn07XG5cbi8qKlxuICogQml0ZmllbGQgcmVwcmVzZW50aW5nIGV2ZXJ5IHBlcm1pc3Npb24gY29tYmluZWRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cblBlcm1pc3Npb25zLkFMTCA9IE9iamVjdC52YWx1ZXMoUGVybWlzc2lvbnMuRkxBR1MpLnJlZHVjZSgoYWxsLCBwKSA9PiBhbGwgfCBwLCAwKTtcblxuLyoqXG4gKiBCaXRmaWVsZCByZXByZXNlbnRpbmcgdGhlIGRlZmF1bHQgcGVybWlzc2lvbnMgZm9yIHVzZXJzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5QZXJtaXNzaW9ucy5ERUZBVUxUID0gMTA0MzI0NjczO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcm1pc3Npb25zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbi8vIERpc2NvcmQgZXBvY2ggKDIwMTUtMDEtMDFUMDA6MDA6MDAuMDAwWilcbmNvbnN0IEVQT0NIID0gMTQyMDA3MDQwMDAwMDtcbmxldCBJTkNSRU1FTlQgPSAwO1xuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciB1c2VmdWwgc25vd2ZsYWtlLXJlbGF0ZWQgbWV0aG9kcy5cbiAqL1xuY2xhc3MgU25vd2ZsYWtlVXRpbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBjbGFzcyBtYXkgbm90IGJlIGluc3RhbnRpYXRlZC5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIFR3aXR0ZXIgc25vd2ZsYWtlLCBleGNlcHQgdGhlIGVwb2NoIGlzIDIwMTUtMDEtMDFUMDA6MDA6MDAuMDAwWlxuICAgKiBgYGBcbiAgICogSWYgd2UgaGF2ZSBhIHNub3dmbGFrZSAnMjY2MjQxOTQ4ODI0NzY0NDE2JyB3ZSBjYW4gcmVwcmVzZW50IGl0IGFzIGJpbmFyeTpcbiAgICpcbiAgICogNjQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMiAgICAgMTcgICAgIDEyICAgICAgICAgIDBcbiAgICogIDAwMDAwMDExMTAxMTAwMDExMTEwMDAwMTEwMTAwMTAwMDEwMTAwMDAwMCAgMDAwMDEgIDAwMDAwICAwMDAwMDAwMDAwMDBcbiAgICogICAgICAgbnVtYmVyIG9mIG1zIHNpbmNlIERpc2NvcmQgZXBvY2ggICAgICAgd29ya2VyICBwaWQgICAgaW5jcmVtZW50XG4gICAqIGBgYFxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBTbm93Zmxha2VcbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIERpc2NvcmQgc25vd2ZsYWtlLlxuICAgKiA8aW5mbz5UaGlzIGhhcmRjb2RlcyB0aGUgd29ya2VyIElEIGFzIDEgYW5kIHRoZSBwcm9jZXNzIElEIGFzIDAuPC9pbmZvPlxuICAgKiBAcGFyYW0ge251bWJlcnxEYXRlfSBbdGltZXN0YW1wPURhdGUubm93KCldIFRpbWVzdGFtcCBvciBkYXRlIG9mIHRoZSBzbm93Zmxha2UgdG8gZ2VuZXJhdGVcbiAgICogQHJldHVybnMge1Nub3dmbGFrZX0gVGhlIGdlbmVyYXRlZCBzbm93Zmxha2VcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZSh0aW1lc3RhbXAgPSBEYXRlLm5vdygpKSB7XG4gICAgaWYgKHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUpIHRpbWVzdGFtcCA9IHRpbWVzdGFtcC5nZXRUaW1lKCk7XG4gICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgIT09ICdudW1iZXInIHx8IGlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBcInRpbWVzdGFtcFwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgKHJlY2VpdmVkICR7aXNOYU4odGltZXN0YW1wKSA/ICdOYU4nIDogdHlwZW9mIHRpbWVzdGFtcH0pYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChJTkNSRU1FTlQgPj0gNDA5NSkgSU5DUkVNRU5UID0gMDtcbiAgICBjb25zdCBCSU5BUlkgPSBgJHsodGltZXN0YW1wIC0gRVBPQ0gpLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDQyLCAnMCcpfTAwMDAxMDAwMDAkeyhJTkNSRU1FTlQrKylcbiAgICAgIC50b1N0cmluZygyKVxuICAgICAgLnBhZFN0YXJ0KDEyLCAnMCcpfWA7XG4gICAgcmV0dXJuIFV0aWwuYmluYXJ5VG9JRChCSU5BUlkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZGVjb25zdHJ1Y3RlZCBzbm93Zmxha2UuXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IERlY29uc3RydWN0ZWRTbm93Zmxha2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCBUaW1lc3RhbXAgdGhlIHNub3dmbGFrZSB3YXMgY3JlYXRlZFxuICAgKiBAcHJvcGVydHkge0RhdGV9IGRhdGUgRGF0ZSB0aGUgc25vd2ZsYWtlIHdhcyBjcmVhdGVkXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3b3JrZXJJRCBXb3JrZXIgSUQgaW4gdGhlIHNub3dmbGFrZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJvY2Vzc0lEIFByb2Nlc3MgSUQgaW4gdGhlIHNub3dmbGFrZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaW5jcmVtZW50IEluY3JlbWVudCBpbiB0aGUgc25vd2ZsYWtlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiaW5hcnkgQmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzbm93Zmxha2VcbiAgICovXG5cbiAgLyoqXG4gICAqIERlY29uc3RydWN0cyBhIERpc2NvcmQgc25vd2ZsYWtlLlxuICAgKiBAcGFyYW0ge1Nub3dmbGFrZX0gc25vd2ZsYWtlIFNub3dmbGFrZSB0byBkZWNvbnN0cnVjdFxuICAgKiBAcmV0dXJucyB7RGVjb25zdHJ1Y3RlZFNub3dmbGFrZX0gRGVjb25zdHJ1Y3RlZCBzbm93Zmxha2VcbiAgICovXG4gIHN0YXRpYyBkZWNvbnN0cnVjdChzbm93Zmxha2UpIHtcbiAgICBjb25zdCBCSU5BUlkgPSBVdGlsLmlkVG9CaW5hcnkoc25vd2ZsYWtlKS50b1N0cmluZygyKS5wYWRTdGFydCg2NCwgJzAnKTtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICB0aW1lc3RhbXA6IHBhcnNlSW50KEJJTkFSWS5zdWJzdHJpbmcoMCwgNDIpLCAyKSArIEVQT0NILFxuICAgICAgd29ya2VySUQ6IHBhcnNlSW50KEJJTkFSWS5zdWJzdHJpbmcoNDIsIDQ3KSwgMiksXG4gICAgICBwcm9jZXNzSUQ6IHBhcnNlSW50KEJJTkFSWS5zdWJzdHJpbmcoNDcsIDUyKSwgMiksXG4gICAgICBpbmNyZW1lbnQ6IHBhcnNlSW50KEJJTkFSWS5zdWJzdHJpbmcoNTIsIDY0KSwgMiksXG4gICAgICBiaW5hcnk6IEJJTkFSWSxcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXMsICdkYXRlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcCk7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2NvcmQncyBlcG9jaCB2YWx1ZSAoMjAxNS0wMS0wMVQwMDowMDowMC4wMDBaKS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IEVQT0NIKCkge1xuICAgIHJldHVybiBFUE9DSDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNub3dmbGFrZVV0aWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJpdEZpZWxkID0gcmVxdWlyZSgnLi9CaXRGaWVsZCcpO1xuXG4vKipcbiAqIERhdGEgc3RydWN0dXJlIHRoYXQgbWFrZXMgaXQgZWFzeSB0byBpbnRlcmFjdCB3aXRoIGEge0BsaW5rIFZvaWNlQ29ubmVjdGlvbiNzcGVha2luZ31cbiAqIGFuZCB7QGxpbmsgZ3VpbGRNZW1iZXJTcGVha2luZ30gZXZlbnQgYml0ZmllbGRzLlxuICogQGV4dGVuZHMge0JpdEZpZWxkfVxuICovXG5jbGFzcyBTcGVha2luZyBleHRlbmRzIEJpdEZpZWxkIHt9XG5cbi8qKlxuICogQG5hbWUgU3BlYWtpbmdcbiAqIEBraW5kIGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyb2YgU3BlYWtpbmdcbiAqIEBwYXJhbSB7Qml0RmllbGRSZXNvbHZhYmxlfSBbYml0cz0wXSBCaXQocykgdG8gcmVhZCBmcm9tXG4gKi9cblxuLyoqXG4gKiBOdW1lcmljIHNwZWFraW5nIGZsYWdzLiBBbGwgYXZhaWxhYmxlIHByb3BlcnRpZXM6XG4gKiAqIGBTUEVBS0lOR2BcbiAqICogYFNPVU5EU0hBUkVgXG4gKiAqIGBQUklPUklUWV9TUEVBS0lOR2BcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2Rpc2NvcmQuY29tL2RldmVsb3BlcnMvZG9jcy90b3BpY3Mvdm9pY2UtY29ubmVjdGlvbnMjc3BlYWtpbmd9XG4gKi9cblNwZWFraW5nLkZMQUdTID0ge1xuICBTUEVBS0lORzogMSA8PCAwLFxuICBTT1VORFNIQVJFOiAxIDw8IDEsXG4gIFBSSU9SSVRZX1NQRUFLSU5HOiAxIDw8IDIsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwZWFraW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGV4dGVuZGFibGUgc3RydWN0dXJlOlxuICogKiAqKmBHdWlsZEVtb2ppYCoqXG4gKiAqICoqYERNQ2hhbm5lbGAqKlxuICogKiAqKmBUZXh0Q2hhbm5lbGAqKlxuICogKiAqKmBWb2ljZUNoYW5uZWxgKipcbiAqICogKipgQ2F0ZWdvcnlDaGFubmVsYCoqXG4gKiAqICoqYE5ld3NDaGFubmVsYCoqXG4gKiAqICoqYFN0b3JlQ2hhbm5lbGAqKlxuICogKiAqKmBHdWlsZE1lbWJlcmAqKlxuICogKiAqKmBHdWlsZGAqKlxuICogKiAqKmBNZXNzYWdlYCoqXG4gKiAqICoqYE1lc3NhZ2VSZWFjdGlvbmAqKlxuICogKiAqKmBQcmVzZW5jZWAqKlxuICogKiAqKmBDbGllbnRQcmVzZW5jZWAqKlxuICogKiAqKmBWb2ljZVN0YXRlYCoqXG4gKiAqICoqYFJvbGVgKipcbiAqICogKipgVXNlcmAqKlxuICogQHR5cGVkZWYge3N0cmluZ30gRXh0ZW5kYWJsZVN0cnVjdHVyZVxuICovXG5cbi8qKlxuICogQWxsb3dzIGZvciB0aGUgZXh0ZW5zaW9uIG9mIGJ1aWx0LWluIERpc2NvcmQuanMgc3RydWN0dXJlcyB0aGF0IGFyZSBpbnN0YW50aWF0ZWQgYnkge0BsaW5rIEJhc2VNYW5hZ2VyIE1hbmFnZXJzfS5cbiAqL1xuY2xhc3MgU3RydWN0dXJlcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBjbGFzcyBtYXkgbm90IGJlIGluc3RhbnRpYXRlZC5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBzdHJ1Y3R1cmUgY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJ1Y3R1cmUgTmFtZSBvZiB0aGUgc3RydWN0dXJlIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQoc3RydWN0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmUgPT09ICdzdHJpbmcnKSByZXR1cm4gc3RydWN0dXJlc1tzdHJ1Y3R1cmVdO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwic3RydWN0dXJlXCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyAocmVjZWl2ZWQgJHt0eXBlb2Ygc3RydWN0dXJlfSlgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmRzIGEgc3RydWN0dXJlLlxuICAgKiA8d2Fybj4gTWFrZSBzdXJlIHRvIGV4dGVuZCBhbGwgc3RydWN0dXJlcyBiZWZvcmUgaW5zdGFudGlhdGluZyB5b3VyIGNsaWVudC5cbiAgICogRXh0ZW5kaW5nIGFmdGVyIGRvaW5nIHNvIG1heSBub3Qgd29yayBhcyBleHBlY3RlZC4gPC93YXJuPlxuICAgKiBAcGFyYW0ge0V4dGVuZGFibGVTdHJ1Y3R1cmV9IHN0cnVjdHVyZSBOYW1lIG9mIHRoZSBzdHJ1Y3R1cmUgY2xhc3MgdG8gZXh0ZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV4dGVuZGVyIEZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGJhc2UgY2xhc3MgdG8gZXh0ZW5kIGFzIGl0cyBvbmx5IHBhcmFtZXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogZXh0ZW5kZWQgY2xhc3MvcHJvdG90eXBlXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gRXh0ZW5kZWQgY2xhc3MvcHJvdG90eXBlIHJldHVybmVkIGZyb20gdGhlIGV4dGVuZGVyXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHsgU3RydWN0dXJlcyB9ID0gcmVxdWlyZSgnZGlzY29yZC5qcycpO1xuICAgKlxuICAgKiBTdHJ1Y3R1cmVzLmV4dGVuZCgnR3VpbGQnLCBHdWlsZCA9PiB7XG4gICAqICAgY2xhc3MgQ29vbEd1aWxkIGV4dGVuZHMgR3VpbGQge1xuICAgKiAgICAgY29uc3RydWN0b3IoY2xpZW50LCBkYXRhKSB7XG4gICAqICAgICAgIHN1cGVyKGNsaWVudCwgZGF0YSk7XG4gICAqICAgICAgIHRoaXMuY29vbCA9IHRydWU7XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiAgIHJldHVybiBDb29sR3VpbGQ7XG4gICAqIH0pO1xuICAgKi9cbiAgc3RhdGljIGV4dGVuZChzdHJ1Y3R1cmUsIGV4dGVuZGVyKSB7XG4gICAgaWYgKCFzdHJ1Y3R1cmVzW3N0cnVjdHVyZV0pIHRocm93IG5ldyBSYW5nZUVycm9yKGBcIiR7c3RydWN0dXJlfVwiIGlzIG5vdCBhIHZhbGlkIGV4dGVuc2libGUgc3RydWN0dXJlLmApO1xuICAgIGlmICh0eXBlb2YgZXh0ZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVkID0gYChyZWNlaXZlZCAke3R5cGVvZiBleHRlbmRlcn0pYDtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBcImV4dGVuZGVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZXh0ZW5kZWQgc3RydWN0dXJlIGNsYXNzL3Byb3RvdHlwZSAke3JlY2VpdmVkfS5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbmRlZCA9IGV4dGVuZGVyKHN0cnVjdHVyZXNbc3RydWN0dXJlXSk7XG4gICAgaWYgKHR5cGVvZiBleHRlbmRlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgcmVjZWl2ZWQgPSBgKHJlY2VpdmVkICR7dHlwZW9mIGV4dGVuZGVkfSlgO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIGV4dGVuZGVyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIHRoZSBleHRlbmRlZCBzdHJ1Y3R1cmUgY2xhc3MvcHJvdG90eXBlICR7cmVjZWl2ZWR9LmApO1xuICAgIH1cblxuICAgIGlmICghKGV4dGVuZGVkLnByb3RvdHlwZSBpbnN0YW5jZW9mIHN0cnVjdHVyZXNbc3RydWN0dXJlXSkpIHtcbiAgICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihleHRlbmRlZCk7XG4gICAgICBjb25zdCByZWNlaXZlZCA9IGAke2V4dGVuZGVkLm5hbWUgfHwgJ3VubmFtZWQnfSR7cHJvdG90eXBlLm5hbWUgPyBgIGV4dGVuZHMgJHtwcm90b3R5cGUubmFtZX1gIDogJyd9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSBjbGFzcy9wcm90b3R5cGUgcmV0dXJuZWQgZnJvbSB0aGUgZXh0ZW5kZXIgZnVuY3Rpb24gbXVzdCBleHRlbmQgdGhlIGV4aXN0aW5nIHN0cnVjdHVyZSBjbGFzcy9wcm90b3R5cGUnICtcbiAgICAgICAgICBgIChyZWNlaXZlZCBmdW5jdGlvbiAke3JlY2VpdmVkfTsgZXhwZWN0ZWQgZXh0ZW5zaW9uIG9mICR7c3RydWN0dXJlc1tzdHJ1Y3R1cmVdLm5hbWV9KS5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzdHJ1Y3R1cmVzW3N0cnVjdHVyZV0gPSBleHRlbmRlZDtcbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gIH1cbn1cblxuY29uc3Qgc3RydWN0dXJlcyA9IHtcbiAgR3VpbGRFbW9qaTogcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9HdWlsZEVtb2ppJyksXG4gIERNQ2hhbm5lbDogcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9ETUNoYW5uZWwnKSxcbiAgVGV4dENoYW5uZWw6IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvVGV4dENoYW5uZWwnKSxcbiAgVm9pY2VDaGFubmVsOiByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL1ZvaWNlQ2hhbm5lbCcpLFxuICBDYXRlZ29yeUNoYW5uZWw6IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvQ2F0ZWdvcnlDaGFubmVsJyksXG4gIE5ld3NDaGFubmVsOiByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL05ld3NDaGFubmVsJyksXG4gIFN0b3JlQ2hhbm5lbDogcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9TdG9yZUNoYW5uZWwnKSxcbiAgR3VpbGRNZW1iZXI6IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvR3VpbGRNZW1iZXInKSxcbiAgR3VpbGQ6IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvR3VpbGQnKSxcbiAgTWVzc2FnZTogcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9NZXNzYWdlJyksXG4gIE1lc3NhZ2VSZWFjdGlvbjogcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9NZXNzYWdlUmVhY3Rpb24nKSxcbiAgUHJlc2VuY2U6IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvUHJlc2VuY2UnKS5QcmVzZW5jZSxcbiAgQ2xpZW50UHJlc2VuY2U6IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvQ2xpZW50UHJlc2VuY2UnKSxcbiAgVm9pY2VTdGF0ZTogcmVxdWlyZSgnLi4vc3RydWN0dXJlcy9Wb2ljZVN0YXRlJyksXG4gIFJvbGU6IHJlcXVpcmUoJy4uL3N0cnVjdHVyZXMvUm9sZScpLFxuICBVc2VyOiByZXF1aXJlKCcuLi9zdHJ1Y3R1cmVzL1VzZXInKSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RydWN0dXJlcztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQml0RmllbGQgPSByZXF1aXJlKCcuL0JpdEZpZWxkJyk7XG5cbi8qKlxuICogRGF0YSBzdHJ1Y3R1cmUgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIGludGVyYWN0IHdpdGggYSB7QGxpbmsgR3VpbGQjc3lzdGVtQ2hhbm5lbEZsYWdzfSBiaXRmaWVsZC5cbiAqIDxpbmZvPk5vdGUgdGhhdCBhbGwgZXZlbnQgbWVzc2FnZSB0eXBlcyBhcmUgZW5hYmxlZCBieSBkZWZhdWx0LFxuICogYW5kIGJ5IHNldHRpbmcgdGhlaXIgY29ycmVzcG9uZGluZyBmbGFncyB5b3UgYXJlIGRpc2FibGluZyB0aGVtPC9pbmZvPlxuICogQGV4dGVuZHMge0JpdEZpZWxkfVxuICovXG5jbGFzcyBTeXN0ZW1DaGFubmVsRmxhZ3MgZXh0ZW5kcyBCaXRGaWVsZCB7fVxuXG4vKipcbiAqIEBuYW1lIFN5c3RlbUNoYW5uZWxGbGFnc1xuICogQGtpbmQgY29uc3RydWN0b3JcbiAqIEBtZW1iZXJvZiBTeXN0ZW1DaGFubmVsRmxhZ3NcbiAqIEBwYXJhbSB7U3lzdGVtQ2hhbm5lbEZsYWdzUmVzb2x2YWJsZX0gW2JpdHM9MF0gQml0KHMpIHRvIHJlYWQgZnJvbVxuICovXG5cbi8qKlxuICogRGF0YSB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBnaXZlIGEgc3l0ZW0gY2hhbm5lbCBmbGFnIGJpdGZpZWxkLiBUaGlzIGNhbiBiZTpcbiAqICogQSBzdHJpbmcgKHNlZSB7QGxpbmsgU3lzdGVtQ2hhbm5lbEZsYWdzLkZMQUdTfSlcbiAqICogQSBzeXRlbSBjaGFubmVsIGZsYWdcbiAqICogQW4gaW5zdGFuY2Ugb2YgU3lzdGVtQ2hhbm5lbEZsYWdzXG4gKiAqIEFuIEFycmF5IG9mIFN5c3RlbUNoYW5uZWxGbGFnc1Jlc29sdmFibGVcbiAqIEB0eXBlZGVmIHtzdHJpbmd8bnVtYmVyfFN5c3RlbUNoYW5uZWxGbGFnc3xTeXN0ZW1DaGFubmVsRmxhZ3NSZXNvbHZhYmxlW119IFN5c3RlbUNoYW5uZWxGbGFnc1Jlc29sdmFibGVcbiAqL1xuXG4vKipcbiAqIE51bWVyaWMgc3lzdGVtIGNoYW5uZWwgZmxhZ3MuIEFsbCBhdmFpbGFibGUgcHJvcGVydGllczpcbiAqICogYFdFTENPTUVfTUVTU0FHRV9ESVNBQkxFRGBcbiAqICogYEJPT1NUX01FU1NBR0VfRElTQUJMRURgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5TeXN0ZW1DaGFubmVsRmxhZ3MuRkxBR1MgPSB7XG4gIFdFTENPTUVfTUVTU0FHRV9ESVNBQkxFRDogMSA8PCAwLFxuICBCT09TVF9NRVNTQUdFX0RJU0FCTEVEOiAxIDw8IDEsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbUNoYW5uZWxGbGFncztcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IEJpdEZpZWxkID0gcmVxdWlyZSgnLi9CaXRGaWVsZCcpO1xuXG4vKipcbiAqIERhdGEgc3RydWN0dXJlIHRoYXQgbWFrZXMgaXQgZWFzeSB0byBpbnRlcmFjdCB3aXRoIGEge0BsaW5rIFVzZXIjZmxhZ3N9IGJpdGZpZWxkLlxuICogQGV4dGVuZHMge0JpdEZpZWxkfVxuICovXG5jbGFzcyBVc2VyRmxhZ3MgZXh0ZW5kcyBCaXRGaWVsZCB7fVxuXG4vKipcbiAqIEBuYW1lIFVzZXJGbGFnc1xuICogQGtpbmQgY29uc3RydWN0b3JcbiAqIEBtZW1iZXJvZiBVc2VyRmxhZ3NcbiAqIEBwYXJhbSB7Qml0RmllbGRSZXNvbHZhYmxlfSBbYml0cz0wXSBCaXQocykgdG8gcmVhZCBmcm9tXG4gKi9cblxuLyoqXG4gKiBOdW1lcmljIHVzZXIgZmxhZ3MuIEFsbCBhdmFpbGFibGUgcHJvcGVydGllczpcbiAqICogYERJU0NPUkRfRU1QTE9ZRUVgXG4gKiAqIGBQQVJUTkVSRURfU0VSVkVSX09XTkVSYFxuICogKiBgRElTQ09SRF9QQVJUTkVSYCAqKihkZXByZWNhdGVkKSoqXG4gKiAqIGBIWVBFU1FVQURfRVZFTlRTYFxuICogKiBgQlVHSFVOVEVSX0xFVkVMXzFgXG4gKiAqIGBIT1VTRV9CUkFWRVJZYFxuICogKiBgSE9VU0VfQlJJTExJQU5DRWBcbiAqICogYEhPVVNFX0JBTEFOQ0VgXG4gKiAqIGBFQVJMWV9TVVBQT1JURVJgXG4gKiAqIGBURUFNX1VTRVJgXG4gKiAqIGBTWVNURU1gXG4gKiAqIGBCVUdIVU5URVJfTEVWRUxfMmBcbiAqICogYFZFUklGSUVEX0JPVGBcbiAqICogYEVBUkxZX1ZFUklGSUVEX0JPVF9ERVZFTE9QRVJgXG4gKiAqIGBWRVJJRklFRF9ERVZFTE9QRVJgICoqKGRlcHJlY2F0ZWQpKipcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2Rpc2NvcmQuY29tL2RldmVsb3BlcnMvZG9jcy9yZXNvdXJjZXMvdXNlciN1c2VyLW9iamVjdC11c2VyLWZsYWdzfVxuICovXG5Vc2VyRmxhZ3MuRkxBR1MgPSB7XG4gIERJU0NPUkRfRU1QTE9ZRUU6IDEgPDwgMCxcbiAgUEFSVE5FUkVEX1NFUlZFUl9PV05FUjogMSA8PCAxLFxuICBESVNDT1JEX1BBUlRORVI6IDEgPDwgMSxcbiAgSFlQRVNRVUFEX0VWRU5UUzogMSA8PCAyLFxuICBCVUdIVU5URVJfTEVWRUxfMTogMSA8PCAzLFxuICBIT1VTRV9CUkFWRVJZOiAxIDw8IDYsXG4gIEhPVVNFX0JSSUxMSUFOQ0U6IDEgPDwgNyxcbiAgSE9VU0VfQkFMQU5DRTogMSA8PCA4LFxuICBFQVJMWV9TVVBQT1JURVI6IDEgPDwgOSxcbiAgVEVBTV9VU0VSOiAxIDw8IDEwLFxuICBTWVNURU06IDEgPDwgMTIsXG4gIEJVR0hVTlRFUl9MRVZFTF8yOiAxIDw8IDE0LFxuICBWRVJJRklFRF9CT1Q6IDEgPDwgMTYsXG4gIEVBUkxZX1ZFUklGSUVEX0RFVkVMT1BFUjogMSA8PCAxNyxcbiAgVkVSSUZJRURfREVWRUxPUEVSOiAxIDw8IDE3LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyRmxhZ3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgcGFyc2UgfSA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZldGNoID0gcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xuY29uc3QgeyBDb2xvcnMsIERlZmF1bHRPcHRpb25zLCBFbmRwb2ludHMgfSA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5jb25zdCB7IEVycm9yOiBEaXNjb3JkRXJyb3IsIFJhbmdlRXJyb3IsIFR5cGVFcnJvciB9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBoYXMgPSAobywgaykgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspO1xuY29uc3QgaXNPYmplY3QgPSBkID0+IHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBkICE9PSBudWxsO1xuXG4vKipcbiAqIENvbnRhaW5zIHZhcmlvdXMgZ2VuZXJhbC1wdXJwb3NlIHV0aWxpdHkgbWV0aG9kcy4gVGhlc2UgZnVuY3Rpb25zIGFyZSBhbHNvIGF2YWlsYWJsZSBvbiB0aGUgYmFzZSBgRGlzY29yZGAgb2JqZWN0LlxuICovXG5jbGFzcyBVdGlsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNsYXNzIG1heSBub3QgYmUgaW5zdGFudGlhdGVkLmApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYXR0ZW4gYW4gb2JqZWN0LiBBbnkgcHJvcGVydGllcyB0aGF0IGFyZSBjb2xsZWN0aW9ucyB3aWxsIGdldCBjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgb2Yga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0PHN0cmluZywgYm9vbGVhbnxzdHJpbmc+fSBbcHJvcHNdIFNwZWNpZmljIHByb3BlcnRpZXMgdG8gaW5jbHVkZS9leGNsdWRlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZsYXR0ZW4ob2JqLCAuLi5wcm9wcykge1xuICAgIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcblxuICAgIGNvbnN0IG9ialByb3BzID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSlcbiAgICAgIC5tYXAoayA9PiAoeyBba106IHRydWUgfSkpO1xuXG4gICAgcHJvcHMgPSBvYmpQcm9wcy5sZW5ndGggPyBPYmplY3QuYXNzaWduKC4uLm9ialByb3BzLCAuLi5wcm9wcykgOiBPYmplY3QuYXNzaWduKHt9LCAuLi5wcm9wcyk7XG5cbiAgICBjb25zdCBvdXQgPSB7fTtcblxuICAgIGZvciAobGV0IFtwcm9wLCBuZXdQcm9wXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcbiAgICAgIGlmICghbmV3UHJvcCkgY29udGludWU7XG4gICAgICBuZXdQcm9wID0gbmV3UHJvcCA9PT0gdHJ1ZSA/IHByb3AgOiBuZXdQcm9wO1xuXG4gICAgICBjb25zdCBlbGVtZW50ID0gb2JqW3Byb3BdO1xuICAgICAgY29uc3QgZWxlbUlzT2JqID0gaXNPYmplY3QoZWxlbWVudCk7XG4gICAgICBjb25zdCB2YWx1ZU9mID0gZWxlbUlzT2JqICYmIHR5cGVvZiBlbGVtZW50LnZhbHVlT2YgPT09ICdmdW5jdGlvbicgPyBlbGVtZW50LnZhbHVlT2YoKSA6IG51bGw7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBDb2xsZWN0aW9uLCBtYWtlIHRoZSBhcnJheSBvZiBrZXlzXG4gICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vQ29sbGVjdGlvbicpKSBvdXRbbmV3UHJvcF0gPSBBcnJheS5mcm9tKGVsZW1lbnQua2V5cygpKTtcbiAgICAgIC8vIElmIHRoZSB2YWx1ZU9mIGlzIGEgQ29sbGVjdGlvbiwgdXNlIGl0cyBhcnJheSBvZiBrZXlzXG4gICAgICBlbHNlIGlmICh2YWx1ZU9mIGluc3RhbmNlb2YgcmVxdWlyZSgnLi9Db2xsZWN0aW9uJykpIG91dFtuZXdQcm9wXSA9IEFycmF5LmZyb20odmFsdWVPZi5rZXlzKCkpO1xuICAgICAgLy8gSWYgaXQncyBhbiBhcnJheSwgZmxhdHRlbiBlYWNoIGVsZW1lbnRcbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIG91dFtuZXdQcm9wXSA9IGVsZW1lbnQubWFwKGUgPT4gVXRpbC5mbGF0dGVuKGUpKTtcbiAgICAgIC8vIElmIGl0J3MgYW4gb2JqZWN0IHdpdGggYSBwcmltaXRpdmUgYHZhbHVlT2ZgLCB1c2UgdGhhdCB2YWx1ZVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlT2YgIT09ICdvYmplY3QnKSBvdXRbbmV3UHJvcF0gPSB2YWx1ZU9mO1xuICAgICAgLy8gSWYgaXQncyBhIHByaW1pdGl2ZVxuICAgICAgZWxzZSBpZiAoIWVsZW1Jc09iaikgb3V0W25ld1Byb3BdID0gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIG11bHRpcGxlIGNodW5rcyBhdCBhIGRlc2lnbmF0ZWQgY2hhcmFjdGVyIHRoYXQgZG8gbm90IGV4Y2VlZCBhIHNwZWNpZmljIGxlbmd0aC5cbiAgICogQHBhcmFtIHtTdHJpbmdSZXNvbHZhYmxlfSB0ZXh0IENvbnRlbnQgdG8gc3BsaXRcbiAgICogQHBhcmFtIHtTcGxpdE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGNvbnRyb2xsaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgc3BsaXRcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIHNwbGl0TWVzc2FnZSh0ZXh0LCB7IG1heExlbmd0aCA9IDIwMDAsIGNoYXIgPSAnXFxuJywgcHJlcGVuZCA9ICcnLCBhcHBlbmQgPSAnJyB9ID0ge30pIHtcbiAgICB0ZXh0ID0gVXRpbC5yZXNvbHZlU3RyaW5nKHRleHQpO1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGgpIHJldHVybiBbdGV4dF07XG4gICAgY29uc3Qgc3BsaXRUZXh0ID0gdGV4dC5zcGxpdChjaGFyKTtcbiAgICBpZiAoc3BsaXRUZXh0LnNvbWUoY2h1bmsgPT4gY2h1bmsubGVuZ3RoID4gbWF4TGVuZ3RoKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NQTElUX01BWF9MRU4nKTtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGxldCBtc2cgPSAnJztcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHNwbGl0VGV4dCkge1xuICAgICAgaWYgKG1zZyAmJiAobXNnICsgY2hhciArIGNodW5rICsgYXBwZW5kKS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgbWVzc2FnZXMucHVzaChtc2cgKyBhcHBlbmQpO1xuICAgICAgICBtc2cgPSBwcmVwZW5kO1xuICAgICAgfVxuICAgICAgbXNnICs9IChtc2cgJiYgbXNnICE9PSBwcmVwZW5kID8gY2hhciA6ICcnKSArIGNodW5rO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXMuY29uY2F0KG1zZykuZmlsdGVyKG0gPT4gbSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyBhbnkgRGlzY29yZC1mbGF2b3VyIG1hcmtkb3duIGluIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBDb250ZW50IHRvIGVzY2FwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFdoYXQgdHlwZXMgb2YgbWFya2Rvd24gdG8gZXNjYXBlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29kZUJsb2NrPXRydWVdIFdoZXRoZXIgdG8gZXNjYXBlIGNvZGUgYmxvY2tzIG9yIG5vdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlubGluZUNvZGU9dHJ1ZV0gV2hldGhlciB0byBlc2NhcGUgaW5saW5lIGNvZGUgb3Igbm90XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYm9sZD10cnVlXSBXaGV0aGVyIHRvIGVzY2FwZSBib2xkcyBvciBub3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pdGFsaWM9dHJ1ZV0gV2hldGhlciB0byBlc2NhcGUgaXRhbGljcyBvciBub3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bmRlcmxpbmU9dHJ1ZV0gV2hldGhlciB0byBlc2NhcGUgdW5kZXJsaW5lcyBvciBub3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zdHJpa2V0aHJvdWdoPXRydWVdIFdoZXRoZXIgdG8gZXNjYXBlIHN0cmlrZXRocm91Z2hzIG9yIG5vdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNwb2lsZXI9dHJ1ZV0gV2hldGhlciB0byBlc2NhcGUgc3BvaWxlcnMgb3Igbm90XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29kZUJsb2NrQ29udGVudD10cnVlXSBXaGV0aGVyIHRvIGVzY2FwZSB0ZXh0IGluc2lkZSBjb2RlIGJsb2NrcyBvciBub3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbmxpbmVDb2RlQ29udGVudD10cnVlXSBXaGV0aGVyIHRvIGVzY2FwZSB0ZXh0IGluc2lkZSBpbmxpbmUgY29kZSBvciBub3RcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBlc2NhcGVNYXJrZG93bihcbiAgICB0ZXh0LFxuICAgIHtcbiAgICAgIGNvZGVCbG9jayA9IHRydWUsXG4gICAgICBpbmxpbmVDb2RlID0gdHJ1ZSxcbiAgICAgIGJvbGQgPSB0cnVlLFxuICAgICAgaXRhbGljID0gdHJ1ZSxcbiAgICAgIHVuZGVybGluZSA9IHRydWUsXG4gICAgICBzdHJpa2V0aHJvdWdoID0gdHJ1ZSxcbiAgICAgIHNwb2lsZXIgPSB0cnVlLFxuICAgICAgY29kZUJsb2NrQ29udGVudCA9IHRydWUsXG4gICAgICBpbmxpbmVDb2RlQ29udGVudCA9IHRydWUsXG4gICAgfSA9IHt9LFxuICApIHtcbiAgICBpZiAoIWNvZGVCbG9ja0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgIC5zcGxpdCgnYGBgJylcbiAgICAgICAgLm1hcCgoc3ViU3RyaW5nLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgICAgICBpZiAoaW5kZXggJSAyICYmIGluZGV4ICE9PSBhcnJheS5sZW5ndGggLSAxKSByZXR1cm4gc3ViU3RyaW5nO1xuICAgICAgICAgIHJldHVybiBVdGlsLmVzY2FwZU1hcmtkb3duKHN1YlN0cmluZywge1xuICAgICAgICAgICAgaW5saW5lQ29kZSxcbiAgICAgICAgICAgIGJvbGQsXG4gICAgICAgICAgICBpdGFsaWMsXG4gICAgICAgICAgICB1bmRlcmxpbmUsXG4gICAgICAgICAgICBzdHJpa2V0aHJvdWdoLFxuICAgICAgICAgICAgc3BvaWxlcixcbiAgICAgICAgICAgIGlubGluZUNvZGVDb250ZW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihjb2RlQmxvY2sgPyAnXFxcXGBcXFxcYFxcXFxgJyA6ICdgYGAnKTtcbiAgICB9XG4gICAgaWYgKCFpbmxpbmVDb2RlQ29udGVudCkge1xuICAgICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnNwbGl0KC8oPzw9XnxbXmBdKWAoPz1bXmBdfCQpL2cpXG4gICAgICAgIC5tYXAoKHN1YlN0cmluZywgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgICAgICAgaWYgKGluZGV4ICUgMiAmJiBpbmRleCAhPT0gYXJyYXkubGVuZ3RoIC0gMSkgcmV0dXJuIHN1YlN0cmluZztcbiAgICAgICAgICByZXR1cm4gVXRpbC5lc2NhcGVNYXJrZG93bihzdWJTdHJpbmcsIHtcbiAgICAgICAgICAgIGNvZGVCbG9jayxcbiAgICAgICAgICAgIGJvbGQsXG4gICAgICAgICAgICBpdGFsaWMsXG4gICAgICAgICAgICB1bmRlcmxpbmUsXG4gICAgICAgICAgICBzdHJpa2V0aHJvdWdoLFxuICAgICAgICAgICAgc3BvaWxlcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oaW5saW5lQ29kZSA/ICdcXFxcYCcgOiAnYCcpO1xuICAgIH1cbiAgICBpZiAoaW5saW5lQ29kZSkgdGV4dCA9IFV0aWwuZXNjYXBlSW5saW5lQ29kZSh0ZXh0KTtcbiAgICBpZiAoY29kZUJsb2NrKSB0ZXh0ID0gVXRpbC5lc2NhcGVDb2RlQmxvY2sodGV4dCk7XG4gICAgaWYgKGl0YWxpYykgdGV4dCA9IFV0aWwuZXNjYXBlSXRhbGljKHRleHQpO1xuICAgIGlmIChib2xkKSB0ZXh0ID0gVXRpbC5lc2NhcGVCb2xkKHRleHQpO1xuICAgIGlmICh1bmRlcmxpbmUpIHRleHQgPSBVdGlsLmVzY2FwZVVuZGVybGluZSh0ZXh0KTtcbiAgICBpZiAoc3RyaWtldGhyb3VnaCkgdGV4dCA9IFV0aWwuZXNjYXBlU3RyaWtldGhyb3VnaCh0ZXh0KTtcbiAgICBpZiAoc3BvaWxlcikgdGV4dCA9IFV0aWwuZXNjYXBlU3BvaWxlcih0ZXh0KTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIGNvZGUgYmxvY2sgbWFya2Rvd24gaW4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IENvbnRlbnQgdG8gZXNjYXBlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXNjYXBlQ29kZUJsb2NrKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9gYGAvZywgJ1xcXFxgXFxcXGBcXFxcYCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgaW5saW5lIGNvZGUgbWFya2Rvd24gaW4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IENvbnRlbnQgdG8gZXNjYXBlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXNjYXBlSW5saW5lQ29kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvKD88PV58W15gXSlgKD89W15gXXwkKS9nLCAnXFxcXGAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIGl0YWxpYyBtYXJrZG93biBpbiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQ29udGVudCB0byBlc2NhcGVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBlc2NhcGVJdGFsaWModGV4dCkge1xuICAgIGxldCBpID0gMDtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oPzw9XnxbXipdKVxcKihbXipdfFxcKlxcKnwkKS9nLCAoXywgbWF0Y2gpID0+IHtcbiAgICAgIGlmIChtYXRjaCA9PT0gJyoqJykgcmV0dXJuICsraSAlIDIgPyBgXFxcXCoke21hdGNofWAgOiBgJHttYXRjaH1cXFxcKmA7XG4gICAgICByZXR1cm4gYFxcXFwqJHttYXRjaH1gO1xuICAgIH0pO1xuICAgIGkgPSAwO1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyg/PD1efFteX10pXyhbXl9dfF9ffCQpL2csIChfLCBtYXRjaCkgPT4ge1xuICAgICAgaWYgKG1hdGNoID09PSAnX18nKSByZXR1cm4gKytpICUgMiA/IGBcXFxcXyR7bWF0Y2h9YCA6IGAke21hdGNofVxcXFxfYDtcbiAgICAgIHJldHVybiBgXFxcXF8ke21hdGNofWA7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyBib2xkIG1hcmtkb3duIGluIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBDb250ZW50IHRvIGVzY2FwZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGVzY2FwZUJvbGQodGV4dCkge1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXCpcXCooXFwqKT8vZywgKF8sIG1hdGNoKSA9PiB7XG4gICAgICBpZiAobWF0Y2gpIHJldHVybiArK2kgJSAyID8gYCR7bWF0Y2h9XFxcXCpcXFxcKmAgOiBgXFxcXCpcXFxcKiR7bWF0Y2h9YDtcbiAgICAgIHJldHVybiAnXFxcXCpcXFxcKic7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyB1bmRlcmxpbmUgbWFya2Rvd24gaW4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IENvbnRlbnQgdG8gZXNjYXBlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXNjYXBlVW5kZXJsaW5lKHRleHQpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvX18oXyk/L2csIChfLCBtYXRjaCkgPT4ge1xuICAgICAgaWYgKG1hdGNoKSByZXR1cm4gKytpICUgMiA/IGAke21hdGNofVxcXFxfXFxcXF9gIDogYFxcXFxfXFxcXF8ke21hdGNofWA7XG4gICAgICByZXR1cm4gJ1xcXFxfXFxcXF8nO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgc3RyaWtldGhyb3VnaCBtYXJrZG93biBpbiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQ29udGVudCB0byBlc2NhcGVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBlc2NhcGVTdHJpa2V0aHJvdWdoKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9+fi9nLCAnXFxcXH5cXFxcficpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgc3BvaWxlciBtYXJrZG93biBpbiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQ29udGVudCB0byBlc2NhcGVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBlc2NhcGVTcG9pbGVyKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHxcXHwvZywgJ1xcXFx8XFxcXHwnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWNvbW1lbmRlZCBzaGFyZCBjb3VudCBmcm9tIERpc2NvcmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBEaXNjb3JkIGF1dGggdG9rZW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtndWlsZHNQZXJTaGFyZD0xMDAwXSBOdW1iZXIgb2YgZ3VpbGRzIHBlciBzaGFyZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBUaGUgcmVjb21tZW5kZWQgbnVtYmVyIG9mIHNoYXJkc1xuICAgKi9cbiAgc3RhdGljIGZldGNoUmVjb21tZW5kZWRTaGFyZHModG9rZW4sIGd1aWxkc1BlclNoYXJkID0gMTAwMCkge1xuICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBEaXNjb3JkRXJyb3IoJ1RPS0VOX01JU1NJTkcnKTtcbiAgICByZXR1cm4gZmV0Y2goYCR7RGVmYXVsdE9wdGlvbnMuaHR0cC5hcGl9L3Yke0RlZmF1bHRPcHRpb25zLmh0dHAudmVyc2lvbn0ke0VuZHBvaW50cy5ib3RHYXRld2F5fWAsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCb3QgJHt0b2tlbi5yZXBsYWNlKC9eQm90XFxzKi9pLCAnJyl9YCB9LFxuICAgIH0pXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICBpZiAocmVzLm9rKSByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkgdGhyb3cgbmV3IERpc2NvcmRFcnJvcignVE9LRU5fSU5WQUxJRCcpO1xuICAgICAgICB0aHJvdyByZXM7XG4gICAgICB9KVxuICAgICAgLnRoZW4oZGF0YSA9PiBkYXRhLnNoYXJkcyAqICgxMDAwIC8gZ3VpbGRzUGVyU2hhcmQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgZW1vamkgaW5mbyBvdXQgb2YgYSBzdHJpbmcuIFRoZSBzdHJpbmcgbXVzdCBiZSBvbmUgb2Y6XG4gICAqICogQSBVVEYtOCBlbW9qaSAobm8gSUQpXG4gICAqICogQSBVUkwtZW5jb2RlZCBVVEYtOCBlbW9qaSAobm8gSUQpXG4gICAqICogQSBEaXNjb3JkIGN1c3RvbSBlbW9qaSAoYDw6bmFtZTppZD5gIG9yIGA8YTpuYW1lOmlkPmApXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEVtb2ppIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3Qgd2l0aCBgYW5pbWF0ZWRgLCBgbmFtZWAsIGFuZCBgaWRgIHByb3BlcnRpZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBwYXJzZUVtb2ppKHRleHQpIHtcbiAgICBpZiAodGV4dC5pbmNsdWRlcygnJScpKSB0ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQpO1xuICAgIGlmICghdGV4dC5pbmNsdWRlcygnOicpKSByZXR1cm4geyBhbmltYXRlZDogZmFsc2UsIG5hbWU6IHRleHQsIGlkOiBudWxsIH07XG4gICAgY29uc3QgbSA9IHRleHQubWF0Y2goLzw/KD86KGEpOik/KFxcd3syLDMyfSk6KFxcZHsxNywxOX0pPz4/Lyk7XG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4geyBhbmltYXRlZDogQm9vbGVhbihtWzFdKSwgbmFtZTogbVsyXSwgaWQ6IG1bM10gfHwgbnVsbCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYWxsb3ctY29waWVzIGFuIG9iamVjdCB3aXRoIGl0cyBjbGFzcy9wcm90b3R5cGUgaW50YWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byBjbG9uZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGNsb25lT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUob2JqKSwgb2JqKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGRlZmF1bHQgcHJvcGVydGllcyBvbiBhbiBvYmplY3QgdGhhdCBhcmVuJ3QgYWxyZWFkeSBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWYgRGVmYXVsdCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnaXZlbiBPYmplY3QgdG8gYXNzaWduIGRlZmF1bHRzIHRvXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbWVyZ2VEZWZhdWx0KGRlZiwgZ2l2ZW4pIHtcbiAgICBpZiAoIWdpdmVuKSByZXR1cm4gZGVmO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZikge1xuICAgICAgaWYgKCFoYXMoZ2l2ZW4sIGtleSkgfHwgZ2l2ZW5ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdpdmVuW2tleV0gPSBkZWZba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZ2l2ZW5ba2V5XSA9PT0gT2JqZWN0KGdpdmVuW2tleV0pKSB7XG4gICAgICAgIGdpdmVuW2tleV0gPSBVdGlsLm1lcmdlRGVmYXVsdChkZWZba2V5XSwgZ2l2ZW5ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdpdmVuO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFycmF5QnVmZmVyIG9yIHN0cmluZyB0byBhIEJ1ZmZlci5cbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxzdHJpbmd9IGFiIEFycmF5QnVmZmVyIHRvIGNvbnZlcnRcbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBjb252ZXJ0VG9CdWZmZXIoYWIpIHtcbiAgICBpZiAodHlwZW9mIGFiID09PSAnc3RyaW5nJykgYWIgPSBVdGlsLnN0cjJhYihhYik7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgc3RyMmFiKHN0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzdHIubGVuZ3RoICogMik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBzdHJMZW4gPSBzdHIubGVuZ3RoOyBpIDwgc3RyTGVuOyBpKyspIHZpZXdbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGFuIEVycm9yIGZyb20gYSBwbGFpbiBpbmZvIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBFcnJvciBpbmZvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmoubmFtZSBFcnJvciB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmoubWVzc2FnZSBNZXNzYWdlIGZvciB0aGUgZXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iai5zdGFjayBTdGFjayBmb3IgdGhlIGVycm9yXG4gICAqIEByZXR1cm5zIHtFcnJvcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBtYWtlRXJyb3Iob2JqKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG9iai5tZXNzYWdlKTtcbiAgICBlcnIubmFtZSA9IG9iai5uYW1lO1xuICAgIGVyci5zdGFjayA9IG9iai5zdGFjaztcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgcGxhaW4gZXJyb3IgaW5mbyBvYmplY3QgZnJvbSBhbiBFcnJvci5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIEVycm9yIHRvIGdldCBpbmZvIGZyb21cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBtYWtlUGxhaW5FcnJvcihlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogZXJyLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnIuc3RhY2ssXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBlbGVtZW50IGluIGFuIGFycmF5ICppbiBwbGFjZSouXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5IEFycmF5IHRvIG1vZGlmeVxuICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgRWxlbWVudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleCBJbmRleCBvciBvZmZzZXQgdG8gbW92ZSB0aGUgZWxlbWVudCB0b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvZmZzZXQ9ZmFsc2VdIE1vdmUgdGhlIGVsZW1lbnQgYnkgYW4gb2Zmc2V0IGFtb3VudCByYXRoZXIgdGhhbiB0byBhIHNldCBpbmRleFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG1vdmVFbGVtZW50SW5BcnJheShhcnJheSwgZWxlbWVudCwgbmV3SW5kZXgsIG9mZnNldCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIG5ld0luZGV4ID0gKG9mZnNldCA/IGluZGV4IDogMCkgKyBuZXdJbmRleDtcbiAgICBpZiAobmV3SW5kZXggPiAtMSAmJiBuZXdJbmRleCA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgcmVtb3ZlZEVsZW1lbnQgPSBhcnJheS5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgYXJyYXkuc3BsaWNlKG5ld0luZGV4LCAwLCByZW1vdmVkRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgdG8gZ2l2ZSBhIHN0cmluZy4gVGhpcyBjYW4gYmU6XG4gICAqICogQSBzdHJpbmdcbiAgICogKiBBbiBhcnJheSAoam9pbmVkIHdpdGggYSBuZXcgbGluZSBkZWxpbWl0ZXIgdG8gZ2l2ZSBhIHN0cmluZylcbiAgICogKiBBbnkgdmFsdWVcbiAgICogQHR5cGVkZWYge3N0cmluZ3xBcnJheXwqfSBTdHJpbmdSZXNvbHZhYmxlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIFN0cmluZ1Jlc29sdmFibGUgdG8gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nUmVzb2x2YWJsZX0gZGF0YSBUaGUgc3RyaW5nIHJlc29sdmFibGUgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHJlc29sdmVTdHJpbmcoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHJldHVybiBkYXRhO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSByZXR1cm4gZGF0YS5qb2luKCdcXG4nKTtcbiAgICByZXR1cm4gU3RyaW5nKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbiBiZSBhIG51bWJlciwgaGV4IHN0cmluZywgYW4gUkdCIGFycmF5IGxpa2U6XG4gICAqIGBgYGpzXG4gICAqIFsyNTUsIDAsIDI1NV0gLy8gcHVycGxlXG4gICAqIGBgYFxuICAgKiBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdHJpbmdzOlxuICAgKiAtIGBERUZBVUxUYFxuICAgKiAtIGBXSElURWBcbiAgICogLSBgQVFVQWBcbiAgICogLSBgR1JFRU5gXG4gICAqIC0gYEJMVUVgXG4gICAqIC0gYFlFTExPV2BcbiAgICogLSBgUFVSUExFYFxuICAgKiAtIGBMVU1JTk9VU19WSVZJRF9QSU5LYFxuICAgKiAtIGBHT0xEYFxuICAgKiAtIGBPUkFOR0VgXG4gICAqIC0gYFJFRGBcbiAgICogLSBgR1JFWWBcbiAgICogLSBgREFSS0VSX0dSRVlgXG4gICAqIC0gYE5BVllgXG4gICAqIC0gYERBUktfQVFVQWBcbiAgICogLSBgREFSS19HUkVFTmBcbiAgICogLSBgREFSS19CTFVFYFxuICAgKiAtIGBEQVJLX1BVUlBMRWBcbiAgICogLSBgREFSS19WSVZJRF9QSU5LYFxuICAgKiAtIGBEQVJLX0dPTERgXG4gICAqIC0gYERBUktfT1JBTkdFYFxuICAgKiAtIGBEQVJLX1JFRGBcbiAgICogLSBgREFSS19HUkVZYFxuICAgKiAtIGBMSUdIVF9HUkVZYFxuICAgKiAtIGBEQVJLX05BVllgXG4gICAqIC0gYEJMVVJQTEVgXG4gICAqIC0gYEdSRVlQTEVgXG4gICAqIC0gYERBUktfQlVUX05PVF9CTEFDS2BcbiAgICogLSBgTk9UX1FVSVRFX0JMQUNLYFxuICAgKiAtIGBSQU5ET01gXG4gICAqIEB0eXBlZGVmIHtzdHJpbmd8bnVtYmVyfG51bWJlcltdfSBDb2xvclJlc29sdmFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgQ29sb3JSZXNvbHZhYmxlIGludG8gYSBjb2xvciBudW1iZXIuXG4gICAqIEBwYXJhbSB7Q29sb3JSZXNvbHZhYmxlfSBjb2xvciBDb2xvciB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEEgY29sb3JcbiAgICovXG4gIHN0YXRpYyByZXNvbHZlQ29sb3IoY29sb3IpIHtcbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGNvbG9yID09PSAnUkFORE9NJykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgweGZmZmZmZiArIDEpKTtcbiAgICAgIGlmIChjb2xvciA9PT0gJ0RFRkFVTFQnKSByZXR1cm4gMDtcbiAgICAgIGNvbG9yID0gQ29sb3JzW2NvbG9yXSB8fCBwYXJzZUludChjb2xvci5yZXBsYWNlKCcjJywgJycpLCAxNik7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgICAgY29sb3IgPSAoY29sb3JbMF0gPDwgMTYpICsgKGNvbG9yWzFdIDw8IDgpICsgY29sb3JbMl07XG4gICAgfVxuXG4gICAgaWYgKGNvbG9yIDwgMCB8fCBjb2xvciA+IDB4ZmZmZmZmKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ09MT1JfUkFOR0UnKTtcbiAgICBlbHNlIGlmIChjb2xvciAmJiBpc05hTihjb2xvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NPTE9SX0NPTlZFUlQnKTtcblxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBieSBEaXNjb3JkJ3MgcG9zaXRpb24gYW5kIElELlxuICAgKiBAcGFyYW0gIHtDb2xsZWN0aW9ufSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gb2Ygb2JqZWN0cyB0byBzb3J0XG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGRpc2NvcmRTb3J0KGNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5zb3J0ZWQoXG4gICAgICAoYSwgYikgPT5cbiAgICAgICAgYS5yYXdQb3NpdGlvbiAtIGIucmF3UG9zaXRpb24gfHxcbiAgICAgICAgcGFyc2VJbnQoYi5pZC5zbGljZSgwLCAtMTApKSAtIHBhcnNlSW50KGEuaWQuc2xpY2UoMCwgLTEwKSkgfHxcbiAgICAgICAgcGFyc2VJbnQoYi5pZC5zbGljZSgxMCkpIC0gcGFyc2VJbnQoYS5pZC5zbGljZSgxMCkpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBDaGFubmVsIG9yIFJvbGUuXG4gICAqIEBwYXJhbSB7Q2hhbm5lbHxSb2xlfSBpdGVtIE9iamVjdCB0byBzZXQgdGhlIHBvc2l0aW9uIG9mXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBOZXcgcG9zaXRpb24gZm9yIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSByZWxhdGl2ZSBXaGV0aGVyIGBwb3NpdGlvbmAgaXMgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcG9zaXRpb25cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uPHN0cmluZywgQ2hhbm5lbHxSb2xlPn0gc29ydGVkIEEgY29sbGVjdGlvbiBvZiB0aGUgb2JqZWN0cyBzb3J0ZWQgcHJvcGVybHlcbiAgICogQHBhcmFtIHtBUElSb3V0ZXJ9IHJvdXRlIFJvdXRlIHRvIGNhbGwgUEFUQ0ggb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIFJlYXNvbiBmb3IgdGhlIGNoYW5nZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXT59IFVwZGF0ZWQgaXRlbSBsaXN0LCB3aXRoIGBpZGAgYW5kIGBwb3NpdGlvbmAgcHJvcGVydGllc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIHNldFBvc2l0aW9uKGl0ZW0sIHBvc2l0aW9uLCByZWxhdGl2ZSwgc29ydGVkLCByb3V0ZSwgcmVhc29uKSB7XG4gICAgbGV0IHVwZGF0ZWRJdGVtcyA9IHNvcnRlZC5hcnJheSgpO1xuICAgIFV0aWwubW92ZUVsZW1lbnRJbkFycmF5KHVwZGF0ZWRJdGVtcywgaXRlbSwgcG9zaXRpb24sIHJlbGF0aXZlKTtcbiAgICB1cGRhdGVkSXRlbXMgPSB1cGRhdGVkSXRlbXMubWFwKChyLCBpKSA9PiAoeyBpZDogci5pZCwgcG9zaXRpb246IGkgfSkpO1xuICAgIHJldHVybiByb3V0ZS5wYXRjaCh7IGRhdGE6IHVwZGF0ZWRJdGVtcywgcmVhc29uIH0pLnRoZW4oKCkgPT4gdXBkYXRlZEl0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHRlcm5hdGl2ZSB0byBOb2RlJ3MgYHBhdGguYmFzZW5hbWVgLCByZW1vdmluZyBxdWVyeSBzdHJpbmcgYWZ0ZXIgdGhlIGV4dGVuc2lvbiBpZiBpdCBleGlzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gZ2V0IHRoZSBiYXNlbmFtZSBvZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4dF0gRmlsZSBleHRlbnNpb24gdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2VuYW1lIG9mIHRoZSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgYmFzZW5hbWUocGF0aCwgZXh0KSB7XG4gICAgbGV0IHJlcyA9IHBhcnNlKHBhdGgpO1xuICAgIHJldHVybiBleHQgJiYgcmVzLmV4dC5zdGFydHNXaXRoKGV4dCkgPyByZXMubmFtZSA6IHJlcy5iYXNlLnNwbGl0KCc/JylbMF07XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIHNub3dmbGFrZSBmcm9tIGEgZGVjaW1hbCBzdHJpbmcgdG8gYSBiaXQgc3RyaW5nLlxuICAgKiBAcGFyYW0gIHtTbm93Zmxha2V9IG51bSBTbm93Zmxha2UgdG8gYmUgdHJhbnNmb3JtZWRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBpZFRvQmluYXJ5KG51bSkge1xuICAgIGxldCBiaW4gPSAnJztcbiAgICBsZXQgaGlnaCA9IHBhcnNlSW50KG51bS5zbGljZSgwLCAtMTApKSB8fCAwO1xuICAgIGxldCBsb3cgPSBwYXJzZUludChudW0uc2xpY2UoLTEwKSk7XG4gICAgd2hpbGUgKGxvdyA+IDAgfHwgaGlnaCA+IDApIHtcbiAgICAgIGJpbiA9IFN0cmluZyhsb3cgJiAxKSArIGJpbjtcbiAgICAgIGxvdyA9IE1hdGguZmxvb3IobG93IC8gMik7XG4gICAgICBpZiAoaGlnaCA+IDApIHtcbiAgICAgICAgbG93ICs9IDUwMDAwMDAwMDAgKiAoaGlnaCAlIDIpO1xuICAgICAgICBoaWdoID0gTWF0aC5mbG9vcihoaWdoIC8gMik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW47XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIHNub3dmbGFrZSBmcm9tIGEgYml0IHN0cmluZyB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG51bSBCaXQgc3RyaW5nIHRvIGJlIHRyYW5zZm9ybWVkXG4gICAqIEByZXR1cm5zIHtTbm93Zmxha2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgYmluYXJ5VG9JRChudW0pIHtcbiAgICBsZXQgZGVjID0gJyc7XG5cbiAgICB3aGlsZSAobnVtLmxlbmd0aCA+IDUwKSB7XG4gICAgICBjb25zdCBoaWdoID0gcGFyc2VJbnQobnVtLnNsaWNlKDAsIC0zMiksIDIpO1xuICAgICAgY29uc3QgbG93ID0gcGFyc2VJbnQoKGhpZ2ggJSAxMCkudG9TdHJpbmcoMikgKyBudW0uc2xpY2UoLTMyKSwgMik7XG5cbiAgICAgIGRlYyA9IChsb3cgJSAxMCkudG9TdHJpbmcoKSArIGRlYztcbiAgICAgIG51bSA9XG4gICAgICAgIE1hdGguZmxvb3IoaGlnaCAvIDEwKS50b1N0cmluZygyKSArXG4gICAgICAgIE1hdGguZmxvb3IobG93IC8gMTApXG4gICAgICAgICAgLnRvU3RyaW5nKDIpXG4gICAgICAgICAgLnBhZFN0YXJ0KDMyLCAnMCcpO1xuICAgIH1cblxuICAgIG51bSA9IHBhcnNlSW50KG51bSwgMik7XG4gICAgd2hpbGUgKG51bSA+IDApIHtcbiAgICAgIGRlYyA9IChudW0gJSAxMCkudG9TdHJpbmcoKSArIGRlYztcbiAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMTApO1xuICAgIH1cblxuICAgIHJldHVybiBkZWM7XG4gIH1cblxuICAvKipcbiAgICogQnJlYWtzIHVzZXIsIHJvbGUgYW5kIGV2ZXJ5b25lL2hlcmUgbWVudGlvbnMgYnkgYWRkaW5nIGEgemVybyB3aWR0aCBzcGFjZSBhZnRlciBldmVyeSBAIGNoYXJhY3RlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2FuaXRpemVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyByZW1vdmVNZW50aW9ucyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL0AvZywgJ0BcXHUyMDBiJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgdG8gaGF2ZSBhbGwgbWVudGlvbnMgcmVwbGFjZWQgYnkgdGhlIGVxdWl2YWxlbnQgdGV4dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2Ugb2JqZWN0IHRvIHJlZmVyZW5jZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGNsZWFuQ29udGVudChzdHIsIG1lc3NhZ2UpIHtcbiAgICBzdHIgPSBzdHJcbiAgICAgIC5yZXBsYWNlKC88QCE/WzAtOV0rPi9nLCBpbnB1dCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gaW5wdXQucmVwbGFjZSgvPHwhfD58QC9nLCAnJyk7XG4gICAgICAgIGlmIChtZXNzYWdlLmNoYW5uZWwudHlwZSA9PT0gJ2RtJykge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLmNsaWVudC51c2Vycy5jYWNoZS5nZXQoaWQpO1xuICAgICAgICAgIHJldHVybiB1c2VyID8gVXRpbC5yZW1vdmVNZW50aW9ucyhgQCR7dXNlci51c2VybmFtZX1gKSA6IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVtYmVyID0gbWVzc2FnZS5jaGFubmVsLmd1aWxkLm1lbWJlcnMuY2FjaGUuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgIHJldHVybiBVdGlsLnJlbW92ZU1lbnRpb25zKGBAJHttZW1iZXIuZGlzcGxheU5hbWV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UuY2xpZW50LnVzZXJzLmNhY2hlLmdldChpZCk7XG4gICAgICAgICAgcmV0dXJuIHVzZXIgPyBVdGlsLnJlbW92ZU1lbnRpb25zKGBAJHt1c2VyLnVzZXJuYW1lfWApIDogaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAucmVwbGFjZSgvPCNbMC05XSs+L2csIGlucHV0ID0+IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG1lc3NhZ2UuY2xpZW50LmNoYW5uZWxzLmNhY2hlLmdldChpbnB1dC5yZXBsYWNlKC88fCN8Pi9nLCAnJykpO1xuICAgICAgICByZXR1cm4gY2hhbm5lbCA/IGAjJHtjaGFubmVsLm5hbWV9YCA6IGlucHV0O1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKC88QCZbMC05XSs+L2csIGlucHV0ID0+IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY2hhbm5lbC50eXBlID09PSAnZG0nKSByZXR1cm4gaW5wdXQ7XG4gICAgICAgIGNvbnN0IHJvbGUgPSBtZXNzYWdlLmd1aWxkLnJvbGVzLmNhY2hlLmdldChpbnB1dC5yZXBsYWNlKC88fEB8PnwmL2csICcnKSk7XG4gICAgICAgIHJldHVybiByb2xlID8gYEAke3JvbGUubmFtZX1gIDogaW5wdXQ7XG4gICAgICB9KTtcbiAgICBpZiAobWVzc2FnZS5jbGllbnQub3B0aW9ucy5kaXNhYmxlTWVudGlvbnMgPT09ICdldmVyeW9uZScpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9AKFtePD5AIF0qKS9nbXN1LCAobWF0Y2gsIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoKC9eWyYhXT9cXGQrJC8pKSB7XG4gICAgICAgICAgcmV0dXJuIGBAJHt0YXJnZXR9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYEBcXHUyMDBiJHt0YXJnZXR9YDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmNsaWVudC5vcHRpb25zLmRpc2FibGVNZW50aW9ucyA9PT0gJ2FsbCcpIHtcbiAgICAgIHJldHVybiBVdGlsLnJlbW92ZU1lbnRpb25zKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IHRvIHB1dCBpbiBhIGNvZGVibG9jayB3aXRoIGFsbCBjb2RlYmxvY2sgZmVuY2VzIHJlcGxhY2VkIGJ5IHRoZSBlcXVpdmFsZW50IGJhY2t0aWNrcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBjbGVhbkNvZGVCbG9ja0NvbnRlbnQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL2BgYC9nLCAnYFxcdTIwMGJgYCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgYSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtcyBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSByZXNvbHZpbmcgKGluIG1pbGxpc2Vjb25kcylcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVsYXlGb3IobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG4iLCIvKiBAZmxvdyAqL1xuLyo6OlxuXG50eXBlIERvdGVudlBhcnNlT3B0aW9ucyA9IHtcbiAgZGVidWc/OiBib29sZWFuXG59XG5cbi8vIGtleXMgYW5kIHZhbHVlcyBmcm9tIHNyY1xudHlwZSBEb3RlbnZQYXJzZU91dHB1dCA9IHsgW3N0cmluZ106IHN0cmluZyB9XG5cbnR5cGUgRG90ZW52Q29uZmlnT3B0aW9ucyA9IHtcbiAgcGF0aD86IHN0cmluZywgLy8gcGF0aCB0byAuZW52IGZpbGVcbiAgZW5jb2Rpbmc/OiBzdHJpbmcsIC8vIGVuY29kaW5nIG9mIC5lbnYgZmlsZVxuICBkZWJ1Zz86IHN0cmluZyAvLyB0dXJuIG9uIGxvZ2dpbmcgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xufVxuXG50eXBlIERvdGVudkNvbmZpZ091dHB1dCA9IHtcbiAgcGFyc2VkPzogRG90ZW52UGFyc2VPdXRwdXQsXG4gIGVycm9yPzogRXJyb3Jcbn1cblxuKi9cblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmZ1bmN0aW9uIGxvZyAobWVzc2FnZSAvKjogc3RyaW5nICovKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52XVtERUJVR10gJHttZXNzYWdlfWApXG59XG5cbmNvbnN0IE5FV0xJTkUgPSAnXFxuJ1xuY29uc3QgUkVfSU5JX0tFWV9WQUwgPSAvXlxccyooW1xcdy4tXSspXFxzKj1cXHMqKC4qKT9cXHMqJC9cbmNvbnN0IFJFX05FV0xJTkVTID0gL1xcXFxuL2dcbmNvbnN0IE5FV0xJTkVTX01BVENIID0gL1xcbnxcXHJ8XFxyXFxuL1xuXG4vLyBQYXJzZXMgc3JjIGludG8gYW4gT2JqZWN0XG5mdW5jdGlvbiBwYXJzZSAoc3JjIC8qOiBzdHJpbmcgfCBCdWZmZXIgKi8sIG9wdGlvbnMgLyo6ID9Eb3RlbnZQYXJzZU9wdGlvbnMgKi8pIC8qOiBEb3RlbnZQYXJzZU91dHB1dCAqLyB7XG4gIGNvbnN0IGRlYnVnID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpXG4gIGNvbnN0IG9iaiA9IHt9XG5cbiAgLy8gY29udmVydCBCdWZmZXJzIGJlZm9yZSBzcGxpdHRpbmcgaW50byBsaW5lcyBhbmQgcHJvY2Vzc2luZ1xuICBzcmMudG9TdHJpbmcoKS5zcGxpdChORVdMSU5FU19NQVRDSCkuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgaWR4KSB7XG4gICAgLy8gbWF0Y2hpbmcgXCJLRVknIGFuZCAnVkFMJyBpbiAnS0VZPVZBTCdcbiAgICBjb25zdCBrZXlWYWx1ZUFyciA9IGxpbmUubWF0Y2goUkVfSU5JX0tFWV9WQUwpXG4gICAgLy8gbWF0Y2hlZD9cbiAgICBpZiAoa2V5VmFsdWVBcnIgIT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5VmFsdWVBcnJbMV1cbiAgICAgIC8vIGRlZmF1bHQgdW5kZWZpbmVkIG9yIG1pc3NpbmcgdmFsdWVzIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgbGV0IHZhbCA9IChrZXlWYWx1ZUFyclsyXSB8fCAnJylcbiAgICAgIGNvbnN0IGVuZCA9IHZhbC5sZW5ndGggLSAxXG4gICAgICBjb25zdCBpc0RvdWJsZVF1b3RlZCA9IHZhbFswXSA9PT0gJ1wiJyAmJiB2YWxbZW5kXSA9PT0gJ1wiJ1xuICAgICAgY29uc3QgaXNTaW5nbGVRdW90ZWQgPSB2YWxbMF0gPT09IFwiJ1wiICYmIHZhbFtlbmRdID09PSBcIidcIlxuXG4gICAgICAvLyBpZiBzaW5nbGUgb3IgZG91YmxlIHF1b3RlZCwgcmVtb3ZlIHF1b3Rlc1xuICAgICAgaWYgKGlzU2luZ2xlUXVvdGVkIHx8IGlzRG91YmxlUXVvdGVkKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSwgZW5kKVxuXG4gICAgICAgIC8vIGlmIGRvdWJsZSBxdW90ZWQsIGV4cGFuZCBuZXdsaW5lc1xuICAgICAgICBpZiAoaXNEb3VibGVRdW90ZWQpIHtcbiAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShSRV9ORVdMSU5FUywgTkVXTElORSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgdmFsID0gdmFsLnRyaW0oKVxuICAgICAgfVxuXG4gICAgICBvYmpba2V5XSA9IHZhbFxuICAgIH0gZWxzZSBpZiAoZGVidWcpIHtcbiAgICAgIGxvZyhgZGlkIG5vdCBtYXRjaCBrZXkgYW5kIHZhbHVlIHdoZW4gcGFyc2luZyBsaW5lICR7aWR4ICsgMX06ICR7bGluZX1gKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gb2JqXG59XG5cbi8vIFBvcHVsYXRlcyBwcm9jZXNzLmVudiBmcm9tIC5lbnYgZmlsZVxuZnVuY3Rpb24gY29uZmlnIChvcHRpb25zIC8qOiA/RG90ZW52Q29uZmlnT3B0aW9ucyAqLykgLyo6IERvdGVudkNvbmZpZ091dHB1dCAqLyB7XG4gIGxldCBkb3RlbnZQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICcuZW52JylcbiAgbGV0IGVuY29kaW5nIC8qOiBzdHJpbmcgKi8gPSAndXRmOCdcbiAgbGV0IGRlYnVnID0gZmFsc2VcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhdGggIT0gbnVsbCkge1xuICAgICAgZG90ZW52UGF0aCA9IG9wdGlvbnMucGF0aFxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgZGVidWcgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzcGVjaWZ5aW5nIGFuIGVuY29kaW5nIHJldHVybnMgYSBzdHJpbmcgaW5zdGVhZCBvZiBhIGJ1ZmZlclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKGZzLnJlYWRGaWxlU3luYyhkb3RlbnZQYXRoLCB7IGVuY29kaW5nIH0pLCB7IGRlYnVnIH0pXG5cbiAgICBPYmplY3Qua2V5cyhwYXJzZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzcy5lbnYsIGtleSkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnZba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgICB9IGVsc2UgaWYgKGRlYnVnKSB7XG4gICAgICAgIGxvZyhgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gXFxgcHJvY2Vzcy5lbnZcXGAgYW5kIHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuYClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHsgcGFyc2VkIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGVycm9yOiBlIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25maWcgPSBjb25maWdcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2VcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICBpZiAoZXJyb3JMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICB2YXIgZXJyb3JMaXN0ZW5lcjtcblxuICAgIC8vIEFkZGluZyBhbiBlcnJvciBsaXN0ZW5lciBpcyBub3Qgb3B0aW9uYWwgYmVjYXVzZVxuICAgIC8vIGlmIGFuIGVycm9yIGlzIHRocm93biBvbiBhbiBldmVudCBlbWl0dGVyIHdlIGNhbm5vdFxuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBhY3R1YWwgZXZlbnQgd2UgYXJlIHdhaXRpbmcgd2lsbFxuICAgIC8vIGJlIGZpcmVkLiBUaGUgcmVzdWx0IGNvdWxkIGJlIGEgc2lsZW50IHdheSB0byBjcmVhdGVcbiAgICAvLyBtZW1vcnkgb3IgZmlsZSBkZXNjcmlwdG9yIGxlYWtzLCB3aGljaCBpcyBzb21ldGhpbmdcbiAgICAvLyB3ZSBzaG91bGQgYXZvaWQuXG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG5cbiAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBlbWl0dGVyLm9uY2UobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuXHQvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcblx0Ly8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG5cdC8vIEhvd2V2ZXIsIHRoaXMgY2F1c2VzIENTUCB2aW9sYXRpb25zIGluIENocm9tZSBhcHBzLlxuXHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG5cdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG5cdHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZ2xvYmFsLmZldGNoO1xuXG4vLyBOZWVkZWQgZm9yIFR5cGVTY3JpcHQgYW5kIFdlYnBhY2suXG5pZiAoZ2xvYmFsLmZldGNoKSB7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGdsb2JhbC5mZXRjaC5iaW5kKGdsb2JhbCk7XG59XG5cbmV4cG9ydHMuSGVhZGVycyA9IGdsb2JhbC5IZWFkZXJzO1xuZXhwb3J0cy5SZXF1ZXN0ID0gZ2xvYmFsLlJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gZ2xvYmFsLlJlc3BvbnNlOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgZG90ZW52ID0gcmVxdWlyZShcImRvdGVudlwiKTtcclxudmFyIF84YmFsbF8xID0gcmVxdWlyZShcIjhiYWxsXCIpO1xyXG52YXIgRGlzY29yZCA9IHJlcXVpcmUoXCJkaXNjb3JkLmpzXCIpO1xyXG52YXIgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XHJcbmRvdGVudi5jb25maWcoKTtcclxudmFyIGJvdCA9IG5ldyBEaXNjb3JkLkNsaWVudCgpO1xyXG52YXIgVE9LRU4gPSBwcm9jZXNzLmVudi5UT0tFTjtcclxuYm90LmxvZ2luKFRPS0VOKTtcclxuYm90Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1zZykge1xyXG4gICAgaWYgKG1zZy5hdXRob3IuYm90KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChtc2cubWVudGlvbnMuaGFzKGJvdC51c2VyLmlkKSAmJiBtc2cuY29udGVudC5lbmRzV2l0aChcIj9cIikpIHtcclxuICAgICAgICBtc2cucmVwbHkoXzhiYWxsXzFbXCJkZWZhdWx0XCJdKCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1zZy5tZW50aW9ucy5oYXMoYm90LnVzZXIuaWQpICYmIG1zZy5jb250ZW50LmluY2x1ZGVzKFwiY2hlY2sgbGlicmFyeVwiKSkge1xyXG4gICAgICAgIG1zZy5yZXBseShsaWJfMS5lY2hvKCkpO1xyXG4gICAgfVxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMuZWNobyA9IHZvaWQgMDtcclxuZnVuY3Rpb24gZWNobygpIHtcclxuICAgIHJldHVybiBcImhlbGxvIGZyb20gdGhlIGxpYnJhcnlcIjtcclxufVxyXG5leHBvcnRzLmVjaG8gPSBlY2hvO1xyXG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4vLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdleHBvcnRzJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4iXSwic291cmNlUm9vdCI6IiJ9